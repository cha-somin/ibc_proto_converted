// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: babylon/checkpointing/v1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryRawCheckpointListRequest is the request type for the
/// Query/RawCheckpoints RPC method.
struct Babylon_Checkpointing_V1_QueryRawCheckpointListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// status defines the status of the raw checkpoints of the query
  var status: Babylon_Checkpointing_V1_CheckpointStatus = .ckptStatusAccumulating

  /// pagination defines an optional pagination for the request.
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryRawCheckpointListResponse is the response type for the
/// Query/RawCheckpoints RPC method.
struct Babylon_Checkpointing_V1_QueryRawCheckpointListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the order is going from the newest to oldest based on the epoch number
  var rawCheckpoints: [Babylon_Checkpointing_V1_RawCheckpointWithMetaResponse] = []

  /// pagination defines the pagination in the response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryRawCheckpointRequest is the request type for the Query/RawCheckpoint
/// RPC method.
struct Babylon_Checkpointing_V1_QueryRawCheckpointRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// epoch_num defines the epoch for the queried checkpoint
  var epochNum: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryRawCheckpointResponse is the response type for the Query/RawCheckpoint
/// RPC method.
struct Babylon_Checkpointing_V1_QueryRawCheckpointResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rawCheckpoint: Babylon_Checkpointing_V1_RawCheckpointWithMetaResponse {
    get {return _rawCheckpoint ?? Babylon_Checkpointing_V1_RawCheckpointWithMetaResponse()}
    set {_rawCheckpoint = newValue}
  }
  /// Returns true if `rawCheckpoint` has been explicitly set.
  var hasRawCheckpoint: Bool {return self._rawCheckpoint != nil}
  /// Clears the value of `rawCheckpoint`. Subsequent reads from it will return its default value.
  mutating func clearRawCheckpoint() {self._rawCheckpoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rawCheckpoint: Babylon_Checkpointing_V1_RawCheckpointWithMetaResponse? = nil
}

/// QueryRawCheckpointsRequest is the request type for the Query/RawCheckpoints
/// RPC method.
struct Babylon_Checkpointing_V1_QueryRawCheckpointsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pagination defines whether to have the pagination in the request
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryRawCheckpointsResponse is the response type for the Query/RawCheckpoints
/// RPC method.
struct Babylon_Checkpointing_V1_QueryRawCheckpointsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the order is going from the newest to oldest based on the epoch number
  var rawCheckpoints: [Babylon_Checkpointing_V1_RawCheckpointWithMetaResponse] = []

  /// pagination defines the pagination in the response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryBlsPublicKeyListRequest is the request type for the Query/BlsPublicKeys
/// RPC method.
struct Babylon_Checkpointing_V1_QueryBlsPublicKeyListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// epoch_num defines the epoch for the queried bls public keys
  var epochNum: UInt64 = 0

  /// pagination defines an optional pagination for the request.
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// BlsPublicKeyListResponse couples validator address, voting power, and its bls
/// public key
struct Babylon_Checkpointing_V1_BlsPublicKeyListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// validator_address is the address of the validator
  var validatorAddress: String = String()

  /// bls_pub_key is the BLS public key of the validator
  var blsPubKeyHex: String = String()

  /// voting_power is the voting power of the validator at the given epoch
  var votingPower: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBlsPublicKeyListResponse is the response type for the
/// Query/BlsPublicKeys RPC method.
struct Babylon_Checkpointing_V1_QueryBlsPublicKeyListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var validatorWithBlsKeys: [Babylon_Checkpointing_V1_BlsPublicKeyListResponse] = []

  /// pagination defines the pagination in the response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryEpochStatusRequest is the request type for the Query/EpochStatus
/// RPC method.
struct Babylon_Checkpointing_V1_QueryEpochStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epochNum: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryEpochStatusResponse is the response type for the Query/EpochStatus
/// RPC method.
struct Babylon_Checkpointing_V1_QueryEpochStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Babylon_Checkpointing_V1_CheckpointStatus = .ckptStatusAccumulating

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryRecentEpochStatusCountRequest is the request type for the
/// Query/EpochStatusCount RPC method.
struct Babylon_Checkpointing_V1_QueryRecentEpochStatusCountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// epoch_count is the number of the most recent epochs to include in the
  /// aggregation
  var epochCount: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryRecentEpochStatusCountResponse is the response type for the
/// Query/EpochStatusCount RPC method.
struct Babylon_Checkpointing_V1_QueryRecentEpochStatusCountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tipEpoch: UInt64 = 0

  var epochCount: UInt64 = 0

  var statusCount: Dictionary<String,UInt64> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryLastCheckpointWithStatusRequest is the request type for the
/// Query/LastCheckpointWithStatus RPC method.
struct Babylon_Checkpointing_V1_QueryLastCheckpointWithStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Babylon_Checkpointing_V1_CheckpointStatus = .ckptStatusAccumulating

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryLastCheckpointWithStatusResponse is the response type for the
/// Query/LastCheckpointWithStatus RPC method.
struct Babylon_Checkpointing_V1_QueryLastCheckpointWithStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rawCheckpoint: Babylon_Checkpointing_V1_RawCheckpointResponse {
    get {return _rawCheckpoint ?? Babylon_Checkpointing_V1_RawCheckpointResponse()}
    set {_rawCheckpoint = newValue}
  }
  /// Returns true if `rawCheckpoint` has been explicitly set.
  var hasRawCheckpoint: Bool {return self._rawCheckpoint != nil}
  /// Clears the value of `rawCheckpoint`. Subsequent reads from it will return its default value.
  mutating func clearRawCheckpoint() {self._rawCheckpoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rawCheckpoint: Babylon_Checkpointing_V1_RawCheckpointResponse? = nil
}

/// RawCheckpointResponse wraps the BLS multi sig with metadata
struct Babylon_Checkpointing_V1_RawCheckpointResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// epoch_num defines the epoch number the raw checkpoint is for
  var epochNum: UInt64 = 0

  /// block_hash_hex defines the 'BlockID.Hash', which is the hash of
  /// the block that individual BLS sigs are signed on as hex string
  var blockHashHex: String = String()

  /// bitmap defines the bitmap that indicates the signers of the BLS multi sig
  var bitmap: Data = Data()

  /// bls_multi_sig defines the multi sig that is aggregated from individual BLS
  /// sigs
  var blsMultiSig: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CheckpointStateUpdateResponse defines a state transition on the checkpoint.
struct Babylon_Checkpointing_V1_CheckpointStateUpdateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// state defines the event of a state transition towards this state
  var state: Babylon_Checkpointing_V1_CheckpointStatus = .ckptStatusAccumulating

  /// status_desc represents the description of status enum.
  var statusDesc: String = String()

  /// block_height is the height of the Babylon block that triggers the state
  /// update
  var blockHeight: UInt64 = 0

  /// block_time is the timestamp in the Babylon block that triggers the state
  /// update
  var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  var hasBlockTime: Bool {return self._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  mutating func clearBlockTime() {self._blockTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// RawCheckpointWithMetaResponse wraps the raw checkpoint with metadata.
struct Babylon_Checkpointing_V1_RawCheckpointWithMetaResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ckpt: Babylon_Checkpointing_V1_RawCheckpointResponse {
    get {return _ckpt ?? Babylon_Checkpointing_V1_RawCheckpointResponse()}
    set {_ckpt = newValue}
  }
  /// Returns true if `ckpt` has been explicitly set.
  var hasCkpt: Bool {return self._ckpt != nil}
  /// Clears the value of `ckpt`. Subsequent reads from it will return its default value.
  mutating func clearCkpt() {self._ckpt = nil}

  /// status defines the status of the checkpoint
  var status: Babylon_Checkpointing_V1_CheckpointStatus = .ckptStatusAccumulating

  /// status_desc represents the description of status enum.
  var statusDesc: String = String()

  /// bls_aggr_pk defines the aggregated BLS public key
  var blsAggrPk: Data = Data()

  /// power_sum defines the accumulated voting power for the checkpoint
  var powerSum: UInt64 = 0

  /// lifecycle defines the lifecycle of this checkpoint, i.e., each state
  /// transition and the time (in both timestamp and block height) of this
  /// transition.
  var lifecycle: [Babylon_Checkpointing_V1_CheckpointStateUpdateResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ckpt: Babylon_Checkpointing_V1_RawCheckpointResponse? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Babylon_Checkpointing_V1_QueryRawCheckpointListRequest: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_QueryRawCheckpointListResponse: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_QueryRawCheckpointRequest: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_QueryRawCheckpointResponse: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_QueryRawCheckpointsRequest: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_QueryRawCheckpointsResponse: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_QueryBlsPublicKeyListRequest: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_BlsPublicKeyListResponse: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_QueryBlsPublicKeyListResponse: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_QueryEpochStatusRequest: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_QueryEpochStatusResponse: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_QueryRecentEpochStatusCountRequest: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_QueryRecentEpochStatusCountResponse: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_QueryLastCheckpointWithStatusRequest: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_QueryLastCheckpointWithStatusResponse: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_RawCheckpointResponse: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_CheckpointStateUpdateResponse: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_RawCheckpointWithMetaResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "babylon.checkpointing.v1"

extension Babylon_Checkpointing_V1_QueryRawCheckpointListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRawCheckpointListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .ckptStatusAccumulating {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryRawCheckpointListRequest, rhs: Babylon_Checkpointing_V1_QueryRawCheckpointListRequest) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_QueryRawCheckpointListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRawCheckpointListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_checkpoints"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rawCheckpoints) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rawCheckpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rawCheckpoints, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryRawCheckpointListResponse, rhs: Babylon_Checkpointing_V1_QueryRawCheckpointListResponse) -> Bool {
    if lhs.rawCheckpoints != rhs.rawCheckpoints {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_QueryRawCheckpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRawCheckpointRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_num"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochNum != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryRawCheckpointRequest, rhs: Babylon_Checkpointing_V1_QueryRawCheckpointRequest) -> Bool {
    if lhs.epochNum != rhs.epochNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_QueryRawCheckpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRawCheckpointResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_checkpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rawCheckpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rawCheckpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryRawCheckpointResponse, rhs: Babylon_Checkpointing_V1_QueryRawCheckpointResponse) -> Bool {
    if lhs._rawCheckpoint != rhs._rawCheckpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_QueryRawCheckpointsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRawCheckpointsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryRawCheckpointsRequest, rhs: Babylon_Checkpointing_V1_QueryRawCheckpointsRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_QueryRawCheckpointsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRawCheckpointsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_checkpoints"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rawCheckpoints) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rawCheckpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rawCheckpoints, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryRawCheckpointsResponse, rhs: Babylon_Checkpointing_V1_QueryRawCheckpointsResponse) -> Bool {
    if lhs.rawCheckpoints != rhs.rawCheckpoints {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_QueryBlsPublicKeyListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBlsPublicKeyListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_num"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNum) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.epochNum != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNum, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryBlsPublicKeyListRequest, rhs: Babylon_Checkpointing_V1_QueryBlsPublicKeyListRequest) -> Bool {
    if lhs.epochNum != rhs.epochNum {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_BlsPublicKeyListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlsPublicKeyListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_address"),
    2: .standard(proto: "bls_pub_key_hex"),
    3: .standard(proto: "voting_power"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blsPubKeyHex) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.votingPower) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 1)
    }
    if !self.blsPubKeyHex.isEmpty {
      try visitor.visitSingularStringField(value: self.blsPubKeyHex, fieldNumber: 2)
    }
    if self.votingPower != 0 {
      try visitor.visitSingularUInt64Field(value: self.votingPower, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_BlsPublicKeyListResponse, rhs: Babylon_Checkpointing_V1_BlsPublicKeyListResponse) -> Bool {
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs.blsPubKeyHex != rhs.blsPubKeyHex {return false}
    if lhs.votingPower != rhs.votingPower {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_QueryBlsPublicKeyListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBlsPublicKeyListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_with_bls_keys"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.validatorWithBlsKeys) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.validatorWithBlsKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validatorWithBlsKeys, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryBlsPublicKeyListResponse, rhs: Babylon_Checkpointing_V1_QueryBlsPublicKeyListResponse) -> Bool {
    if lhs.validatorWithBlsKeys != rhs.validatorWithBlsKeys {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_QueryEpochStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEpochStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_num"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochNum != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryEpochStatusRequest, rhs: Babylon_Checkpointing_V1_QueryEpochStatusRequest) -> Bool {
    if lhs.epochNum != rhs.epochNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_QueryEpochStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEpochStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .ckptStatusAccumulating {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryEpochStatusResponse, rhs: Babylon_Checkpointing_V1_QueryEpochStatusResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_QueryRecentEpochStatusCountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRecentEpochStatusCountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryRecentEpochStatusCountRequest, rhs: Babylon_Checkpointing_V1_QueryRecentEpochStatusCountRequest) -> Bool {
    if lhs.epochCount != rhs.epochCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_QueryRecentEpochStatusCountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRecentEpochStatusCountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tip_epoch"),
    2: .standard(proto: "epoch_count"),
    3: .standard(proto: "status_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.tipEpoch) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.epochCount) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: &self.statusCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tipEpoch != 0 {
      try visitor.visitSingularUInt64Field(value: self.tipEpoch, fieldNumber: 1)
    }
    if self.epochCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochCount, fieldNumber: 2)
    }
    if !self.statusCount.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: self.statusCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryRecentEpochStatusCountResponse, rhs: Babylon_Checkpointing_V1_QueryRecentEpochStatusCountResponse) -> Bool {
    if lhs.tipEpoch != rhs.tipEpoch {return false}
    if lhs.epochCount != rhs.epochCount {return false}
    if lhs.statusCount != rhs.statusCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_QueryLastCheckpointWithStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryLastCheckpointWithStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .ckptStatusAccumulating {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryLastCheckpointWithStatusRequest, rhs: Babylon_Checkpointing_V1_QueryLastCheckpointWithStatusRequest) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_QueryLastCheckpointWithStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryLastCheckpointWithStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_checkpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rawCheckpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rawCheckpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_QueryLastCheckpointWithStatusResponse, rhs: Babylon_Checkpointing_V1_QueryLastCheckpointWithStatusResponse) -> Bool {
    if lhs._rawCheckpoint != rhs._rawCheckpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_RawCheckpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RawCheckpointResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_num"),
    2: .standard(proto: "block_hash_hex"),
    3: .same(proto: "bitmap"),
    4: .standard(proto: "bls_multi_sig"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNum) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockHashHex) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.bitmap) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.blsMultiSig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochNum != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNum, fieldNumber: 1)
    }
    if !self.blockHashHex.isEmpty {
      try visitor.visitSingularStringField(value: self.blockHashHex, fieldNumber: 2)
    }
    if !self.bitmap.isEmpty {
      try visitor.visitSingularBytesField(value: self.bitmap, fieldNumber: 3)
    }
    if !self.blsMultiSig.isEmpty {
      try visitor.visitSingularBytesField(value: self.blsMultiSig, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_RawCheckpointResponse, rhs: Babylon_Checkpointing_V1_RawCheckpointResponse) -> Bool {
    if lhs.epochNum != rhs.epochNum {return false}
    if lhs.blockHashHex != rhs.blockHashHex {return false}
    if lhs.bitmap != rhs.bitmap {return false}
    if lhs.blsMultiSig != rhs.blsMultiSig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_CheckpointStateUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckpointStateUpdateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "status_desc"),
    3: .standard(proto: "block_height"),
    4: .standard(proto: "block_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.statusDesc) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.blockHeight) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._blockTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.state != .ckptStatusAccumulating {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if !self.statusDesc.isEmpty {
      try visitor.visitSingularStringField(value: self.statusDesc, fieldNumber: 2)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 3)
    }
    try { if let v = self._blockTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_CheckpointStateUpdateResponse, rhs: Babylon_Checkpointing_V1_CheckpointStateUpdateResponse) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.statusDesc != rhs.statusDesc {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs._blockTime != rhs._blockTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_RawCheckpointWithMetaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RawCheckpointWithMetaResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ckpt"),
    2: .same(proto: "status"),
    3: .standard(proto: "status_desc"),
    4: .standard(proto: "bls_aggr_pk"),
    5: .standard(proto: "power_sum"),
    6: .same(proto: "lifecycle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ckpt) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.statusDesc) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.blsAggrPk) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.powerSum) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.lifecycle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ckpt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.status != .ckptStatusAccumulating {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.statusDesc.isEmpty {
      try visitor.visitSingularStringField(value: self.statusDesc, fieldNumber: 3)
    }
    if !self.blsAggrPk.isEmpty {
      try visitor.visitSingularBytesField(value: self.blsAggrPk, fieldNumber: 4)
    }
    if self.powerSum != 0 {
      try visitor.visitSingularUInt64Field(value: self.powerSum, fieldNumber: 5)
    }
    if !self.lifecycle.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lifecycle, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_RawCheckpointWithMetaResponse, rhs: Babylon_Checkpointing_V1_RawCheckpointWithMetaResponse) -> Bool {
    if lhs._ckpt != rhs._ckpt {return false}
    if lhs.status != rhs.status {return false}
    if lhs.statusDesc != rhs.statusDesc {return false}
    if lhs.blsAggrPk != rhs.blsAggrPk {return false}
    if lhs.powerSum != rhs.powerSum {return false}
    if lhs.lifecycle != rhs.lifecycle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
