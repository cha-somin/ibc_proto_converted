// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: babylon/btcstaking/v1/btcstaking.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// BTCDelegationStatus is the status of a delegation.
/// There are two possible valid state transition paths for a BTC delegation:
/// - PENDING -> VERIFIED -> ACTIVE -> UNBONDED -> EXPIRED
/// - PENDING -> VERIFIED -> ACTIVE -> UNBONDED/EXPIRED
/// and one invalid state transition path:
/// - PENDING -> VERIFIED -> UNBONDED i.e the staker unbonded before
/// activating delegation on Babylon chain.
/// In valid transition paths, the delegation becomes UNBONDED when:
/// - either the staking transaction timelock expires
/// - or the staker requests early undelegation through MsgBTCUndelegate message.
enum Babylon_Btcstaking_V1_BTCDelegationStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// PENDING defines a delegation that is waiting for covenant signatures.
  case pending // = 0

  /// VERIFIED defines a delegation that has covenant signatures but is not yet
  /// included in the BTC chain.
  case verified // = 1

  /// ACTIVE defines a delegation that has voting power
  case active // = 2

  /// UNBONDED defines a delegation no longer has voting power
  /// by receiving unbonding tx with signatures from staker and covenant committee
  case unbonded // = 3

  /// EXPIRED defines a delegation no longer has voting power
  /// for reaching the end of staking transaction timelock
  case expired // = 4

  /// ANY is any of the above status
  case any // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .pending
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pending
    case 1: self = .verified
    case 2: self = .active
    case 3: self = .unbonded
    case 4: self = .expired
    case 5: self = .any
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .pending: return 0
    case .verified: return 1
    case .active: return 2
    case .unbonded: return 3
    case .expired: return 4
    case .any: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Babylon_Btcstaking_V1_BTCDelegationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Babylon_Btcstaking_V1_BTCDelegationStatus] = [
    .pending,
    .verified,
    .active,
    .unbonded,
    .expired,
    .any,
  ]
}

#endif  // swift(>=4.2)

/// FinalityProvider defines a finality provider
struct Babylon_Btcstaking_V1_FinalityProvider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// addr is the bech32 address identifier of the finality provider.
  var addr: String = String()

  /// description defines the description terms for the finality provider.
  var description_p: Cosmos_Staking_V1beta1_Description {
    get {return _description_p ?? Cosmos_Staking_V1beta1_Description()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  /// commission defines the commission rate of the finality provider.
  var commission: String = String()

  /// btc_pk is the Bitcoin secp256k1 PK of this finality provider
  /// the PK follows encoding in BIP-340 spec
  var btcPk: Data = Data()

  /// pop is the proof of possession of the btc_pk, where the BTC
  /// private key signs the bech32 bbn addr of the finality provider.
  var pop: Babylon_Btcstaking_V1_ProofOfPossessionBTC {
    get {return _pop ?? Babylon_Btcstaking_V1_ProofOfPossessionBTC()}
    set {_pop = newValue}
  }
  /// Returns true if `pop` has been explicitly set.
  var hasPop: Bool {return self._pop != nil}
  /// Clears the value of `pop`. Subsequent reads from it will return its default value.
  mutating func clearPop() {self._pop = nil}

  /// slashed_babylon_height indicates the Babylon height when
  /// the finality provider is slashed.
  /// if it's 0 then the finality provider is not slashed
  var slashedBabylonHeight: UInt64 = 0

  /// slashed_btc_height indicates the BTC height when
  /// the finality provider is slashed.
  /// if it's 0 then the finality provider is not slashed
  var slashedBtcHeight: UInt32 = 0

  /// jailed defines whether the finality provider is jailed
  var jailed: Bool = false

  /// highest_voted_height is the highest height for which the
  /// finality provider has voted
  var highestVotedHeight: UInt32 = 0

  /// consumer_id is the ID of the consumer the finality provider is operating on.
  /// If it's missing / empty, it's assumed the finality provider is operating in the Babylon chain.
  var consumerID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _description_p: Cosmos_Staking_V1beta1_Description? = nil
  fileprivate var _pop: Babylon_Btcstaking_V1_ProofOfPossessionBTC? = nil
}

/// FinalityProviderWithMeta wraps the FinalityProvider with metadata.
struct Babylon_Btcstaking_V1_FinalityProviderWithMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// btc_pk is the Bitcoin secp256k1 PK of thisfinality provider
  /// the PK follows encoding in BIP-340 spec
  var btcPk: Data = Data()

  /// height is the queried Babylon height
  var height: UInt64 = 0

  /// voting_power is the voting power of this finality provider at the given height
  var votingPower: UInt64 = 0

  /// slashed_babylon_height indicates the Babylon height when
  /// the finality provider is slashed.
  /// if it's 0 then the finality provider is not slashed
  var slashedBabylonHeight: UInt64 = 0

  /// slashed_btc_height indicates the BTC height when
  /// the finality provider is slashed.
  /// if it's 0 then the finality provider is not slashed
  var slashedBtcHeight: UInt32 = 0

  /// jailed defines whether the finality provider is detected jailed
  var jailed: Bool = false

  /// highest_voted_height is the highest height for which the
  /// finality provider has voted
  var highestVotedHeight: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BTCDelegation defines a BTC delegation
struct Babylon_Btcstaking_V1_BTCDelegation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// staker_addr is the address to receive rewards from BTC delegation.
  var stakerAddr: String {
    get {return _storage._stakerAddr}
    set {_uniqueStorage()._stakerAddr = newValue}
  }

  /// btc_pk is the Bitcoin secp256k1 PK of this BTC delegation
  /// the PK follows encoding in BIP-340 spec
  var btcPk: Data {
    get {return _storage._btcPk}
    set {_uniqueStorage()._btcPk = newValue}
  }

  /// pop is the proof of possession of babylon_pk and btc_pk
  var pop: Babylon_Btcstaking_V1_ProofOfPossessionBTC {
    get {return _storage._pop ?? Babylon_Btcstaking_V1_ProofOfPossessionBTC()}
    set {_uniqueStorage()._pop = newValue}
  }
  /// Returns true if `pop` has been explicitly set.
  var hasPop: Bool {return _storage._pop != nil}
  /// Clears the value of `pop`. Subsequent reads from it will return its default value.
  mutating func clearPop() {_uniqueStorage()._pop = nil}

  /// fp_btc_pk_list is the list of BIP-340 PKs of the finality providers that
  /// this BTC delegation delegates to
  /// If there is more than 1 PKs, then this means the delegation is restaked
  /// to multiple finality providers
  var fpBtcPkList: [Data] {
    get {return _storage._fpBtcPkList}
    set {_uniqueStorage()._fpBtcPkList = newValue}
  }

  /// staking_time is the number of blocks for which the delegation is locked on BTC chain
  var stakingTime: UInt32 {
    get {return _storage._stakingTime}
    set {_uniqueStorage()._stakingTime = newValue}
  }

  /// start_height is the start BTC height of the BTC delegation
  /// it is the start BTC height of the timelock
  var startHeight: UInt32 {
    get {return _storage._startHeight}
    set {_uniqueStorage()._startHeight = newValue}
  }

  /// end_height is the end height of the BTC delegation
  /// it is calculated by end_height = start_height + staking_time
  var endHeight: UInt32 {
    get {return _storage._endHeight}
    set {_uniqueStorage()._endHeight = newValue}
  }

  /// total_sat is the total amount of BTC stakes in this delegation
  /// quantified in satoshi
  var totalSat: UInt64 {
    get {return _storage._totalSat}
    set {_uniqueStorage()._totalSat = newValue}
  }

  /// staking_tx is the staking tx
  var stakingTx: Data {
    get {return _storage._stakingTx}
    set {_uniqueStorage()._stakingTx = newValue}
  }

  /// staking_output_idx is the index of the staking output in the staking tx
  var stakingOutputIdx: UInt32 {
    get {return _storage._stakingOutputIdx}
    set {_uniqueStorage()._stakingOutputIdx = newValue}
  }

  /// slashing_tx is the slashing tx
  /// It is partially signed by SK corresponding to btc_pk, but not signed by
  /// finality provider or covenant yet.
  var slashingTx: Data {
    get {return _storage._slashingTx}
    set {_uniqueStorage()._slashingTx = newValue}
  }

  /// delegator_sig is the signature on the slashing tx
  /// by the delegator (i.e., SK corresponding to btc_pk).
  /// It will be a part of the witness for the staking tx output.
  var delegatorSig: Data {
    get {return _storage._delegatorSig}
    set {_uniqueStorage()._delegatorSig = newValue}
  }

  /// covenant_sigs is a list of adaptor signatures on the slashing tx
  /// by each covenant member
  /// It will be a part of the witness for the staking tx output.
  var covenantSigs: [Babylon_Btcstaking_V1_CovenantAdaptorSignatures] {
    get {return _storage._covenantSigs}
    set {_uniqueStorage()._covenantSigs = newValue}
  }

  /// unbonding_time describes how long the funds will be locked either in unbonding output
  /// or slashing change output
  var unbondingTime: UInt32 {
    get {return _storage._unbondingTime}
    set {_uniqueStorage()._unbondingTime = newValue}
  }

  /// btc_undelegation is the information about the early unbonding path of the BTC delegation
  var btcUndelegation: Babylon_Btcstaking_V1_BTCUndelegation {
    get {return _storage._btcUndelegation ?? Babylon_Btcstaking_V1_BTCUndelegation()}
    set {_uniqueStorage()._btcUndelegation = newValue}
  }
  /// Returns true if `btcUndelegation` has been explicitly set.
  var hasBtcUndelegation: Bool {return _storage._btcUndelegation != nil}
  /// Clears the value of `btcUndelegation`. Subsequent reads from it will return its default value.
  mutating func clearBtcUndelegation() {_uniqueStorage()._btcUndelegation = nil}

  /// version of the params used to validate the delegation
  var paramsVersion: UInt32 {
    get {return _storage._paramsVersion}
    set {_uniqueStorage()._paramsVersion = newValue}
  }

  /// btc_tip_height is the height of the BTC light client tip at the time of
  /// the delegation creation
  var btcTipHeight: UInt32 {
    get {return _storage._btcTipHeight}
    set {_uniqueStorage()._btcTipHeight = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DelegatorUnbondingInfo contains the information about transaction which spent
/// the staking output. It contains:
/// - spend_stake_tx: the transaction which spent the staking output
struct Babylon_Btcstaking_V1_DelegatorUnbondingInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// spend_stake_tx is the transaction which spent the staking output. It is
  /// filled only if spend_stake_tx is different than unbonding_tx registered
  /// on the Babylon chain.
  var spendStakeTx: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BTCUndelegation contains the information about the early unbonding path of the BTC delegation
struct Babylon_Btcstaking_V1_BTCUndelegation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unbonding_tx is the transaction which will transfer the funds from staking
  /// output to unbonding output. Unbonding output will usually have lower timelock
  /// than staking output.
  var unbondingTx: Data = Data()

  /// slashing_tx is the slashing tx for unbonding transactions
  /// It is partially signed by SK corresponding to btc_pk, but not signed by
  /// finality provider or covenant yet.
  var slashingTx: Data = Data()

  /// delegator_slashing_sig is the signature on the slashing tx
  /// by the delegator (i.e., SK corresponding to btc_pk).
  /// It will be a part of the witness for the unbonding tx output.
  var delegatorSlashingSig: Data = Data()

  /// covenant_slashing_sigs is a list of adaptor signatures on the slashing tx
  /// by each covenant member
  /// It will be a part of the witness for the staking tx output.
  var covenantSlashingSigs: [Babylon_Btcstaking_V1_CovenantAdaptorSignatures] = []

  /// covenant_unbonding_sig_list is the list of signatures on the unbonding tx
  /// by covenant members
  /// It must be provided after processing undelegate message by Babylon
  var covenantUnbondingSigList: [Babylon_Btcstaking_V1_SignatureInfo] = []

  /// delegator_unbonding_info is the information about transaction which spent
  /// the staking output
  var delegatorUnbondingInfo: Babylon_Btcstaking_V1_DelegatorUnbondingInfo {
    get {return _delegatorUnbondingInfo ?? Babylon_Btcstaking_V1_DelegatorUnbondingInfo()}
    set {_delegatorUnbondingInfo = newValue}
  }
  /// Returns true if `delegatorUnbondingInfo` has been explicitly set.
  var hasDelegatorUnbondingInfo: Bool {return self._delegatorUnbondingInfo != nil}
  /// Clears the value of `delegatorUnbondingInfo`. Subsequent reads from it will return its default value.
  mutating func clearDelegatorUnbondingInfo() {self._delegatorUnbondingInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _delegatorUnbondingInfo: Babylon_Btcstaking_V1_DelegatorUnbondingInfo? = nil
}

/// BTCDelegatorDelegations is a collection of BTC delegations from the same delegator.
struct Babylon_Btcstaking_V1_BTCDelegatorDelegations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dels: [Babylon_Btcstaking_V1_BTCDelegation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BTCDelegatorDelegationIndex is a list of staking tx hashes of BTC delegations from the same delegator.
struct Babylon_Btcstaking_V1_BTCDelegatorDelegationIndex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stakingTxHashList: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SignatureInfo is a BIP-340 signature together with its signer's BIP-340 PK
struct Babylon_Btcstaking_V1_SignatureInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pk: Data = Data()

  var sig: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CovenantAdaptorSignatures is a list adaptor signatures signed by the
/// covenant with different finality provider's public keys as encryption keys
struct Babylon_Btcstaking_V1_CovenantAdaptorSignatures {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// cov_pk is the public key of the covenant emulator, used as the public key of the adaptor signature
  var covPk: Data = Data()

  /// adaptor_sigs is a list of adaptor signatures, each encrypted by a restaked BTC finality provider's public key
  var adaptorSigs: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SelectiveSlashingEvidence is the evidence that the finality provider
/// selectively slashed a BTC delegation
/// NOTE: it's possible that a slashed finality provider exploits the
/// SelectiveSlashingEvidence endpoint while it is actually slashed due to
/// equivocation. But such behaviour does not affect the system's security
/// or gives any benefit for the adversary
struct Babylon_Btcstaking_V1_SelectiveSlashingEvidence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// staking_tx_hash is the hash of the staking tx.
  /// It uniquely identifies a BTC delegation
  var stakingTxHash: String = String()

  /// fp_btc_pk is the BTC PK of the finality provider who
  /// launches the selective slashing offence
  var fpBtcPk: Data = Data()

  /// recovered_fp_btc_sk is the finality provider's BTC SK recovered from
  /// the covenant adaptor/Schnorr signature pair. It is the consequence
  /// of selective slashing.
  var recoveredFpBtcSk: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InclusionProof proves the existence of tx on BTC blockchain
/// including
/// - the position of the tx on BTC blockchain
/// - the Merkle proof that this tx is on the above position
struct Babylon_Btcstaking_V1_InclusionProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// key is the position (txIdx, blockHash) of this tx on BTC blockchain
  var key: Babylon_Btccheckpoint_V1_TransactionKey {
    get {return _key ?? Babylon_Btccheckpoint_V1_TransactionKey()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// proof is the Merkle proof that this tx is included in the position in `key`
  var proof: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: Babylon_Btccheckpoint_V1_TransactionKey? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Babylon_Btcstaking_V1_BTCDelegationStatus: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_FinalityProvider: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_FinalityProviderWithMeta: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_BTCDelegation: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_DelegatorUnbondingInfo: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_BTCUndelegation: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_BTCDelegatorDelegations: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_BTCDelegatorDelegationIndex: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_SignatureInfo: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_CovenantAdaptorSignatures: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_SelectiveSlashingEvidence: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_InclusionProof: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "babylon.btcstaking.v1"

extension Babylon_Btcstaking_V1_BTCDelegationStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "VERIFIED"),
    2: .same(proto: "ACTIVE"),
    3: .same(proto: "UNBONDED"),
    4: .same(proto: "EXPIRED"),
    5: .same(proto: "ANY"),
  ]
}

extension Babylon_Btcstaking_V1_FinalityProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalityProvider"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
    2: .same(proto: "description"),
    3: .same(proto: "commission"),
    4: .standard(proto: "btc_pk"),
    5: .same(proto: "pop"),
    6: .standard(proto: "slashed_babylon_height"),
    7: .standard(proto: "slashed_btc_height"),
    8: .same(proto: "jailed"),
    9: .standard(proto: "highest_voted_height"),
    10: .standard(proto: "consumer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.commission) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.btcPk) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._pop) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.slashedBabylonHeight) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.slashedBtcHeight) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.jailed) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.highestVotedHeight) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.consumerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    try { if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.commission.isEmpty {
      try visitor.visitSingularStringField(value: self.commission, fieldNumber: 3)
    }
    if !self.btcPk.isEmpty {
      try visitor.visitSingularBytesField(value: self.btcPk, fieldNumber: 4)
    }
    try { if let v = self._pop {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.slashedBabylonHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.slashedBabylonHeight, fieldNumber: 6)
    }
    if self.slashedBtcHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.slashedBtcHeight, fieldNumber: 7)
    }
    if self.jailed != false {
      try visitor.visitSingularBoolField(value: self.jailed, fieldNumber: 8)
    }
    if self.highestVotedHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.highestVotedHeight, fieldNumber: 9)
    }
    if !self.consumerID.isEmpty {
      try visitor.visitSingularStringField(value: self.consumerID, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_FinalityProvider, rhs: Babylon_Btcstaking_V1_FinalityProvider) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.commission != rhs.commission {return false}
    if lhs.btcPk != rhs.btcPk {return false}
    if lhs._pop != rhs._pop {return false}
    if lhs.slashedBabylonHeight != rhs.slashedBabylonHeight {return false}
    if lhs.slashedBtcHeight != rhs.slashedBtcHeight {return false}
    if lhs.jailed != rhs.jailed {return false}
    if lhs.highestVotedHeight != rhs.highestVotedHeight {return false}
    if lhs.consumerID != rhs.consumerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_FinalityProviderWithMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalityProviderWithMeta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "btc_pk"),
    2: .same(proto: "height"),
    3: .standard(proto: "voting_power"),
    4: .standard(proto: "slashed_babylon_height"),
    5: .standard(proto: "slashed_btc_height"),
    6: .same(proto: "jailed"),
    7: .standard(proto: "highest_voted_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.btcPk) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.votingPower) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.slashedBabylonHeight) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.slashedBtcHeight) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.jailed) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.highestVotedHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.btcPk.isEmpty {
      try visitor.visitSingularBytesField(value: self.btcPk, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if self.votingPower != 0 {
      try visitor.visitSingularUInt64Field(value: self.votingPower, fieldNumber: 3)
    }
    if self.slashedBabylonHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.slashedBabylonHeight, fieldNumber: 4)
    }
    if self.slashedBtcHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.slashedBtcHeight, fieldNumber: 5)
    }
    if self.jailed != false {
      try visitor.visitSingularBoolField(value: self.jailed, fieldNumber: 6)
    }
    if self.highestVotedHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.highestVotedHeight, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_FinalityProviderWithMeta, rhs: Babylon_Btcstaking_V1_FinalityProviderWithMeta) -> Bool {
    if lhs.btcPk != rhs.btcPk {return false}
    if lhs.height != rhs.height {return false}
    if lhs.votingPower != rhs.votingPower {return false}
    if lhs.slashedBabylonHeight != rhs.slashedBabylonHeight {return false}
    if lhs.slashedBtcHeight != rhs.slashedBtcHeight {return false}
    if lhs.jailed != rhs.jailed {return false}
    if lhs.highestVotedHeight != rhs.highestVotedHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_BTCDelegation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BTCDelegation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staker_addr"),
    2: .standard(proto: "btc_pk"),
    3: .same(proto: "pop"),
    4: .standard(proto: "fp_btc_pk_list"),
    5: .standard(proto: "staking_time"),
    6: .standard(proto: "start_height"),
    7: .standard(proto: "end_height"),
    8: .standard(proto: "total_sat"),
    9: .standard(proto: "staking_tx"),
    10: .standard(proto: "staking_output_idx"),
    11: .standard(proto: "slashing_tx"),
    12: .standard(proto: "delegator_sig"),
    13: .standard(proto: "covenant_sigs"),
    14: .standard(proto: "unbonding_time"),
    15: .standard(proto: "btc_undelegation"),
    16: .standard(proto: "params_version"),
    17: .standard(proto: "btc_tip_height"),
  ]

  fileprivate class _StorageClass {
    var _stakerAddr: String = String()
    var _btcPk: Data = Data()
    var _pop: Babylon_Btcstaking_V1_ProofOfPossessionBTC? = nil
    var _fpBtcPkList: [Data] = []
    var _stakingTime: UInt32 = 0
    var _startHeight: UInt32 = 0
    var _endHeight: UInt32 = 0
    var _totalSat: UInt64 = 0
    var _stakingTx: Data = Data()
    var _stakingOutputIdx: UInt32 = 0
    var _slashingTx: Data = Data()
    var _delegatorSig: Data = Data()
    var _covenantSigs: [Babylon_Btcstaking_V1_CovenantAdaptorSignatures] = []
    var _unbondingTime: UInt32 = 0
    var _btcUndelegation: Babylon_Btcstaking_V1_BTCUndelegation? = nil
    var _paramsVersion: UInt32 = 0
    var _btcTipHeight: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _stakerAddr = source._stakerAddr
      _btcPk = source._btcPk
      _pop = source._pop
      _fpBtcPkList = source._fpBtcPkList
      _stakingTime = source._stakingTime
      _startHeight = source._startHeight
      _endHeight = source._endHeight
      _totalSat = source._totalSat
      _stakingTx = source._stakingTx
      _stakingOutputIdx = source._stakingOutputIdx
      _slashingTx = source._slashingTx
      _delegatorSig = source._delegatorSig
      _covenantSigs = source._covenantSigs
      _unbondingTime = source._unbondingTime
      _btcUndelegation = source._btcUndelegation
      _paramsVersion = source._paramsVersion
      _btcTipHeight = source._btcTipHeight
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._stakerAddr) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._btcPk) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._pop) }()
        case 4: try { try decoder.decodeRepeatedBytesField(value: &_storage._fpBtcPkList) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._stakingTime) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._startHeight) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._endHeight) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalSat) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._stakingTx) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._stakingOutputIdx) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._slashingTx) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._delegatorSig) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._covenantSigs) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._unbondingTime) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._btcUndelegation) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._paramsVersion) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._btcTipHeight) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._stakerAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stakerAddr, fieldNumber: 1)
      }
      if !_storage._btcPk.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._btcPk, fieldNumber: 2)
      }
      try { if let v = _storage._pop {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._fpBtcPkList.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._fpBtcPkList, fieldNumber: 4)
      }
      if _storage._stakingTime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._stakingTime, fieldNumber: 5)
      }
      if _storage._startHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._startHeight, fieldNumber: 6)
      }
      if _storage._endHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._endHeight, fieldNumber: 7)
      }
      if _storage._totalSat != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalSat, fieldNumber: 8)
      }
      if !_storage._stakingTx.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._stakingTx, fieldNumber: 9)
      }
      if _storage._stakingOutputIdx != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._stakingOutputIdx, fieldNumber: 10)
      }
      if !_storage._slashingTx.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._slashingTx, fieldNumber: 11)
      }
      if !_storage._delegatorSig.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._delegatorSig, fieldNumber: 12)
      }
      if !_storage._covenantSigs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._covenantSigs, fieldNumber: 13)
      }
      if _storage._unbondingTime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._unbondingTime, fieldNumber: 14)
      }
      try { if let v = _storage._btcUndelegation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._paramsVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._paramsVersion, fieldNumber: 16)
      }
      if _storage._btcTipHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._btcTipHeight, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_BTCDelegation, rhs: Babylon_Btcstaking_V1_BTCDelegation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._stakerAddr != rhs_storage._stakerAddr {return false}
        if _storage._btcPk != rhs_storage._btcPk {return false}
        if _storage._pop != rhs_storage._pop {return false}
        if _storage._fpBtcPkList != rhs_storage._fpBtcPkList {return false}
        if _storage._stakingTime != rhs_storage._stakingTime {return false}
        if _storage._startHeight != rhs_storage._startHeight {return false}
        if _storage._endHeight != rhs_storage._endHeight {return false}
        if _storage._totalSat != rhs_storage._totalSat {return false}
        if _storage._stakingTx != rhs_storage._stakingTx {return false}
        if _storage._stakingOutputIdx != rhs_storage._stakingOutputIdx {return false}
        if _storage._slashingTx != rhs_storage._slashingTx {return false}
        if _storage._delegatorSig != rhs_storage._delegatorSig {return false}
        if _storage._covenantSigs != rhs_storage._covenantSigs {return false}
        if _storage._unbondingTime != rhs_storage._unbondingTime {return false}
        if _storage._btcUndelegation != rhs_storage._btcUndelegation {return false}
        if _storage._paramsVersion != rhs_storage._paramsVersion {return false}
        if _storage._btcTipHeight != rhs_storage._btcTipHeight {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_DelegatorUnbondingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelegatorUnbondingInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "spend_stake_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.spendStakeTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spendStakeTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.spendStakeTx, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_DelegatorUnbondingInfo, rhs: Babylon_Btcstaking_V1_DelegatorUnbondingInfo) -> Bool {
    if lhs.spendStakeTx != rhs.spendStakeTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_BTCUndelegation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BTCUndelegation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unbonding_tx"),
    2: .standard(proto: "slashing_tx"),
    3: .standard(proto: "delegator_slashing_sig"),
    4: .standard(proto: "covenant_slashing_sigs"),
    5: .standard(proto: "covenant_unbonding_sig_list"),
    6: .standard(proto: "delegator_unbonding_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.unbondingTx) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.slashingTx) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.delegatorSlashingSig) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.covenantSlashingSigs) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.covenantUnbondingSigList) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._delegatorUnbondingInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.unbondingTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.unbondingTx, fieldNumber: 1)
    }
    if !self.slashingTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.slashingTx, fieldNumber: 2)
    }
    if !self.delegatorSlashingSig.isEmpty {
      try visitor.visitSingularBytesField(value: self.delegatorSlashingSig, fieldNumber: 3)
    }
    if !self.covenantSlashingSigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.covenantSlashingSigs, fieldNumber: 4)
    }
    if !self.covenantUnbondingSigList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.covenantUnbondingSigList, fieldNumber: 5)
    }
    try { if let v = self._delegatorUnbondingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_BTCUndelegation, rhs: Babylon_Btcstaking_V1_BTCUndelegation) -> Bool {
    if lhs.unbondingTx != rhs.unbondingTx {return false}
    if lhs.slashingTx != rhs.slashingTx {return false}
    if lhs.delegatorSlashingSig != rhs.delegatorSlashingSig {return false}
    if lhs.covenantSlashingSigs != rhs.covenantSlashingSigs {return false}
    if lhs.covenantUnbondingSigList != rhs.covenantUnbondingSigList {return false}
    if lhs._delegatorUnbondingInfo != rhs._delegatorUnbondingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_BTCDelegatorDelegations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BTCDelegatorDelegations"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_BTCDelegatorDelegations, rhs: Babylon_Btcstaking_V1_BTCDelegatorDelegations) -> Bool {
    if lhs.dels != rhs.dels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_BTCDelegatorDelegationIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BTCDelegatorDelegationIndex"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staking_tx_hash_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.stakingTxHashList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stakingTxHashList.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.stakingTxHashList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_BTCDelegatorDelegationIndex, rhs: Babylon_Btcstaking_V1_BTCDelegatorDelegationIndex) -> Bool {
    if lhs.stakingTxHashList != rhs.stakingTxHashList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_SignatureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignatureInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pk"),
    2: .same(proto: "sig"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pk) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.sig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pk.isEmpty {
      try visitor.visitSingularBytesField(value: self.pk, fieldNumber: 1)
    }
    if !self.sig.isEmpty {
      try visitor.visitSingularBytesField(value: self.sig, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_SignatureInfo, rhs: Babylon_Btcstaking_V1_SignatureInfo) -> Bool {
    if lhs.pk != rhs.pk {return false}
    if lhs.sig != rhs.sig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_CovenantAdaptorSignatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CovenantAdaptorSignatures"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cov_pk"),
    2: .standard(proto: "adaptor_sigs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.covPk) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.adaptorSigs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.covPk.isEmpty {
      try visitor.visitSingularBytesField(value: self.covPk, fieldNumber: 1)
    }
    if !self.adaptorSigs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.adaptorSigs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_CovenantAdaptorSignatures, rhs: Babylon_Btcstaking_V1_CovenantAdaptorSignatures) -> Bool {
    if lhs.covPk != rhs.covPk {return false}
    if lhs.adaptorSigs != rhs.adaptorSigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_SelectiveSlashingEvidence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelectiveSlashingEvidence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staking_tx_hash"),
    2: .standard(proto: "fp_btc_pk"),
    3: .standard(proto: "recovered_fp_btc_sk"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stakingTxHash) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.fpBtcPk) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.recoveredFpBtcSk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stakingTxHash.isEmpty {
      try visitor.visitSingularStringField(value: self.stakingTxHash, fieldNumber: 1)
    }
    if !self.fpBtcPk.isEmpty {
      try visitor.visitSingularBytesField(value: self.fpBtcPk, fieldNumber: 2)
    }
    if !self.recoveredFpBtcSk.isEmpty {
      try visitor.visitSingularBytesField(value: self.recoveredFpBtcSk, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_SelectiveSlashingEvidence, rhs: Babylon_Btcstaking_V1_SelectiveSlashingEvidence) -> Bool {
    if lhs.stakingTxHash != rhs.stakingTxHash {return false}
    if lhs.fpBtcPk != rhs.fpBtcPk {return false}
    if lhs.recoveredFpBtcSk != rhs.recoveredFpBtcSk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_InclusionProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InclusionProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.proof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.proof.isEmpty {
      try visitor.visitSingularBytesField(value: self.proof, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_InclusionProof, rhs: Babylon_Btcstaking_V1_InclusionProof) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
