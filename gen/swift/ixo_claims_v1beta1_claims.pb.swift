// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ixo/claims/v1beta1/claims.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Ixo_Claims_V1beta1_CollectionState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case `open` // = 0
  case paused // = 1
  case closed // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .open
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .open
    case 1: self = .paused
    case 2: self = .closed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .open: return 0
    case .paused: return 1
    case .closed: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ixo_Claims_V1beta1_CollectionState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ixo_Claims_V1beta1_CollectionState] = [
    .open,
    .paused,
    .closed,
  ]
}

#endif  // swift(>=4.2)

enum Ixo_Claims_V1beta1_EvaluationStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case pending // = 0
  case approved // = 1
  case rejected // = 2
  case disputed // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .pending
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pending
    case 1: self = .approved
    case 2: self = .rejected
    case 3: self = .disputed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .pending: return 0
    case .approved: return 1
    case .rejected: return 2
    case .disputed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ixo_Claims_V1beta1_EvaluationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ixo_Claims_V1beta1_EvaluationStatus] = [
    .pending,
    .approved,
    .rejected,
    .disputed,
  ]
}

#endif  // swift(>=4.2)

enum Ixo_Claims_V1beta1_PaymentType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case submission // = 0
  case approval // = 1
  case evaluation // = 2
  case rejection // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .submission
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .submission
    case 1: self = .approval
    case 2: self = .evaluation
    case 3: self = .rejection
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .submission: return 0
    case .approval: return 1
    case .evaluation: return 2
    case .rejection: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ixo_Claims_V1beta1_PaymentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ixo_Claims_V1beta1_PaymentType] = [
    .submission,
    .approval,
    .evaluation,
    .rejection,
  ]
}

#endif  // swift(>=4.2)

enum Ixo_Claims_V1beta1_PaymentStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case noPayment // = 0

  /// agent is contracted to receive payment
  case promised // = 1

  /// authz set up, no guarantee
  case authorized // = 2

  /// escrow set up with funds blocked
  case gauranteed // = 3
  case paid // = 4
  case failed // = 5
  case disputed // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .noPayment
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noPayment
    case 1: self = .promised
    case 2: self = .authorized
    case 3: self = .gauranteed
    case 4: self = .paid
    case 5: self = .failed
    case 6: self = .disputed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noPayment: return 0
    case .promised: return 1
    case .authorized: return 2
    case .gauranteed: return 3
    case .paid: return 4
    case .failed: return 5
    case .disputed: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ixo_Claims_V1beta1_PaymentStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ixo_Claims_V1beta1_PaymentStatus] = [
    .noPayment,
    .promised,
    .authorized,
    .gauranteed,
    .paid,
    .failed,
    .disputed,
  ]
}

#endif  // swift(>=4.2)

struct Ixo_Claims_V1beta1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var collectionSequence: UInt64 = 0

  var ixoAccount: String = String()

  var networkFeePercentage: String = String()

  var nodeFeePercentage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Claims_V1beta1_Collection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// collection id is the incremented internal id for the collection of claims
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// entity is the DID of the entity for which the claims are being created
  var entity: String {
    get {return _storage._entity}
    set {_uniqueStorage()._entity = newValue}
  }

  /// admin is the account address that will authorize or revoke agents and
  /// payments (the grantor)
  var admin: String {
    get {return _storage._admin}
    set {_uniqueStorage()._admin = newValue}
  }

  /// protocol is the DID of the claim protocol
  var `protocol`: String {
    get {return _storage._protocol}
    set {_uniqueStorage()._protocol = newValue}
  }

  /// startDate is the date after which claims may be submitted
  var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  var hasStartDate: Bool {return _storage._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  mutating func clearStartDate() {_uniqueStorage()._startDate = nil}

  /// endDate is the date after which no more claims may be submitted (no endDate
  /// is allowed)
  var endDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endDate = newValue}
  }
  /// Returns true if `endDate` has been explicitly set.
  var hasEndDate: Bool {return _storage._endDate != nil}
  /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
  mutating func clearEndDate() {_uniqueStorage()._endDate = nil}

  /// quota is the maximum number of claims that may be submitted, 0 is unlimited
  var quota: UInt64 {
    get {return _storage._quota}
    set {_uniqueStorage()._quota = newValue}
  }

  /// count is the number of claims already submitted (internally calculated)
  var count: UInt64 {
    get {return _storage._count}
    set {_uniqueStorage()._count = newValue}
  }

  /// evaluated is the number of claims that have been evaluated (internally
  /// calculated)
  var evaluated: UInt64 {
    get {return _storage._evaluated}
    set {_uniqueStorage()._evaluated = newValue}
  }

  /// approved is the number of claims that have been evaluated and approved
  /// (internally calculated)
  var approved: UInt64 {
    get {return _storage._approved}
    set {_uniqueStorage()._approved = newValue}
  }

  /// rejected is the number of claims that have been evaluated and rejected
  /// (internally calculated)
  var rejected: UInt64 {
    get {return _storage._rejected}
    set {_uniqueStorage()._rejected = newValue}
  }

  /// disputed is the number of claims that have disputed status (internally
  /// calculated)
  var disputed: UInt64 {
    get {return _storage._disputed}
    set {_uniqueStorage()._disputed = newValue}
  }

  /// state is the current state of this Collection (open, paused, closed)
  var state: Ixo_Claims_V1beta1_CollectionState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// payments is the amount paid for claim submission, evaluation, approval, or
  /// rejection
  var payments: Ixo_Claims_V1beta1_Payments {
    get {return _storage._payments ?? Ixo_Claims_V1beta1_Payments()}
    set {_uniqueStorage()._payments = newValue}
  }
  /// Returns true if `payments` has been explicitly set.
  var hasPayments: Bool {return _storage._payments != nil}
  /// Clears the value of `payments`. Subsequent reads from it will return its default value.
  mutating func clearPayments() {_uniqueStorage()._payments = nil}

  /// signer address
  var signer: String {
    get {return _storage._signer}
    set {_uniqueStorage()._signer = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ixo_Claims_V1beta1_Payments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var submission: Ixo_Claims_V1beta1_Payment {
    get {return _storage._submission ?? Ixo_Claims_V1beta1_Payment()}
    set {_uniqueStorage()._submission = newValue}
  }
  /// Returns true if `submission` has been explicitly set.
  var hasSubmission: Bool {return _storage._submission != nil}
  /// Clears the value of `submission`. Subsequent reads from it will return its default value.
  mutating func clearSubmission() {_uniqueStorage()._submission = nil}

  var evaluation: Ixo_Claims_V1beta1_Payment {
    get {return _storage._evaluation ?? Ixo_Claims_V1beta1_Payment()}
    set {_uniqueStorage()._evaluation = newValue}
  }
  /// Returns true if `evaluation` has been explicitly set.
  var hasEvaluation: Bool {return _storage._evaluation != nil}
  /// Clears the value of `evaluation`. Subsequent reads from it will return its default value.
  mutating func clearEvaluation() {_uniqueStorage()._evaluation = nil}

  var approval: Ixo_Claims_V1beta1_Payment {
    get {return _storage._approval ?? Ixo_Claims_V1beta1_Payment()}
    set {_uniqueStorage()._approval = newValue}
  }
  /// Returns true if `approval` has been explicitly set.
  var hasApproval: Bool {return _storage._approval != nil}
  /// Clears the value of `approval`. Subsequent reads from it will return its default value.
  mutating func clearApproval() {_uniqueStorage()._approval = nil}

  /// Payment penalty = 5;
  var rejection: Ixo_Claims_V1beta1_Payment {
    get {return _storage._rejection ?? Ixo_Claims_V1beta1_Payment()}
    set {_uniqueStorage()._rejection = newValue}
  }
  /// Returns true if `rejection` has been explicitly set.
  var hasRejection: Bool {return _storage._rejection != nil}
  /// Clears the value of `rejection`. Subsequent reads from it will return its default value.
  mutating func clearRejection() {_uniqueStorage()._rejection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ixo_Claims_V1beta1_Payment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// account is the entity account address from which the payment will be made
  var account: String = String()

  var amount: [Cosmos_Base_V1beta1_Coin] = []

  /// if empty(nil) then no contract payment, not allowed for Evaluation Payment
  var contract1155Payment: Ixo_Claims_V1beta1_Contract1155Payment {
    get {return _contract1155Payment ?? Ixo_Claims_V1beta1_Contract1155Payment()}
    set {_contract1155Payment = newValue}
  }
  /// Returns true if `contract1155Payment` has been explicitly set.
  var hasContract1155Payment: Bool {return self._contract1155Payment != nil}
  /// Clears the value of `contract1155Payment`. Subsequent reads from it will return its default value.
  mutating func clearContract1155Payment() {self._contract1155Payment = nil}

  /// timeout after claim/evaluation to create authZ for payment, if 0 then
  /// immidiate direct payment
  var timeoutNs: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeoutNs ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeoutNs = newValue}
  }
  /// Returns true if `timeoutNs` has been explicitly set.
  var hasTimeoutNs: Bool {return self._timeoutNs != nil}
  /// Clears the value of `timeoutNs`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutNs() {self._timeoutNs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contract1155Payment: Ixo_Claims_V1beta1_Contract1155Payment? = nil
  fileprivate var _timeoutNs: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

struct Ixo_Claims_V1beta1_Contract1155Payment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var tokenID: String = String()

  var amount: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Claims_V1beta1_Claim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// collection_id indicates to which Collection this claim belongs
  var collectionID: String {
    get {return _storage._collectionID}
    set {_uniqueStorage()._collectionID = newValue}
  }

  /// agent is the DID of the agent submitting the claim
  var agentDid: String {
    get {return _storage._agentDid}
    set {_uniqueStorage()._agentDid = newValue}
  }

  var agentAddress: String {
    get {return _storage._agentAddress}
    set {_uniqueStorage()._agentAddress = newValue}
  }

  /// submissionDate is the date and time that the claim was submitted on-chain
  var submissionDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._submissionDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._submissionDate = newValue}
  }
  /// Returns true if `submissionDate` has been explicitly set.
  var hasSubmissionDate: Bool {return _storage._submissionDate != nil}
  /// Clears the value of `submissionDate`. Subsequent reads from it will return its default value.
  mutating func clearSubmissionDate() {_uniqueStorage()._submissionDate = nil}

  /// claimID is the unique identifier of the claim in the cid hash format
  var claimID: String {
    get {return _storage._claimID}
    set {_uniqueStorage()._claimID = newValue}
  }

  /// evaluation is the result of one or more claim evaluations
  var evaluation: Ixo_Claims_V1beta1_Evaluation {
    get {return _storage._evaluation ?? Ixo_Claims_V1beta1_Evaluation()}
    set {_uniqueStorage()._evaluation = newValue}
  }
  /// Returns true if `evaluation` has been explicitly set.
  var hasEvaluation: Bool {return _storage._evaluation != nil}
  /// Clears the value of `evaluation`. Subsequent reads from it will return its default value.
  mutating func clearEvaluation() {_uniqueStorage()._evaluation = nil}

  var paymentsStatus: Ixo_Claims_V1beta1_ClaimPayments {
    get {return _storage._paymentsStatus ?? Ixo_Claims_V1beta1_ClaimPayments()}
    set {_uniqueStorage()._paymentsStatus = newValue}
  }
  /// Returns true if `paymentsStatus` has been explicitly set.
  var hasPaymentsStatus: Bool {return _storage._paymentsStatus != nil}
  /// Clears the value of `paymentsStatus`. Subsequent reads from it will return its default value.
  mutating func clearPaymentsStatus() {_uniqueStorage()._paymentsStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ixo_Claims_V1beta1_ClaimPayments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var submission: Ixo_Claims_V1beta1_PaymentStatus = .noPayment

  var evaluation: Ixo_Claims_V1beta1_PaymentStatus = .noPayment

  var approval: Ixo_Claims_V1beta1_PaymentStatus = .noPayment

  /// PaymentStatus penalty = 5;
  var rejection: Ixo_Claims_V1beta1_PaymentStatus = .noPayment

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Claims_V1beta1_Evaluation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// claim_id indicates which Claim this evaluation is for
  var claimID: String = String()

  /// collection_id indicates to which Collection the claim being evaluated
  /// belongs to
  var collectionID: String = String()

  /// oracle is the DID of the Oracle entity that evaluates the claim
  var oracle: String = String()

  /// agent is the DID of the agent that submits the evaluation
  var agentDid: String = String()

  var agentAddress: String = String()

  /// status is the evaluation status expressed as an integer (2=approved,
  /// 3=rejected, ...)
  var status: Ixo_Claims_V1beta1_EvaluationStatus = .pending

  /// reason is the code expressed as an integer, for why the evaluation result
  /// was given (codes defined by evaluator)
  var reason: UInt32 = 0

  /// verificationProof is the cid of the evaluation Verfiable Credential
  var verificationProof: String = String()

  /// evaluationDate is the date and time that the claim evaluation was submitted
  /// on-chain
  var evaluationDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _evaluationDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_evaluationDate = newValue}
  }
  /// Returns true if `evaluationDate` has been explicitly set.
  var hasEvaluationDate: Bool {return self._evaluationDate != nil}
  /// Clears the value of `evaluationDate`. Subsequent reads from it will return its default value.
  mutating func clearEvaluationDate() {self._evaluationDate = nil}

  /// custom amount specified by evaluator for claim approval, if empty list then
  /// use default by Collection
  var amount: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _evaluationDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Ixo_Claims_V1beta1_Dispute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subjectID: String = String()

  /// type is expressed as an integer, interpreted by the client
  var type: Int32 = 0

  var data: Ixo_Claims_V1beta1_DisputeData {
    get {return _data ?? Ixo_Claims_V1beta1_DisputeData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _data: Ixo_Claims_V1beta1_DisputeData? = nil
}

struct Ixo_Claims_V1beta1_DisputeData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// dispute link ***.ipfs
  var uri: String = String()

  var type: String = String()

  var proof: String = String()

  var encrypted: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Ixo_Claims_V1beta1_CollectionState: @unchecked Sendable {}
extension Ixo_Claims_V1beta1_EvaluationStatus: @unchecked Sendable {}
extension Ixo_Claims_V1beta1_PaymentType: @unchecked Sendable {}
extension Ixo_Claims_V1beta1_PaymentStatus: @unchecked Sendable {}
extension Ixo_Claims_V1beta1_Params: @unchecked Sendable {}
extension Ixo_Claims_V1beta1_Collection: @unchecked Sendable {}
extension Ixo_Claims_V1beta1_Payments: @unchecked Sendable {}
extension Ixo_Claims_V1beta1_Payment: @unchecked Sendable {}
extension Ixo_Claims_V1beta1_Contract1155Payment: @unchecked Sendable {}
extension Ixo_Claims_V1beta1_Claim: @unchecked Sendable {}
extension Ixo_Claims_V1beta1_ClaimPayments: @unchecked Sendable {}
extension Ixo_Claims_V1beta1_Evaluation: @unchecked Sendable {}
extension Ixo_Claims_V1beta1_Dispute: @unchecked Sendable {}
extension Ixo_Claims_V1beta1_DisputeData: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ixo.claims.v1beta1"

extension Ixo_Claims_V1beta1_CollectionState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPEN"),
    1: .same(proto: "PAUSED"),
    2: .same(proto: "CLOSED"),
  ]
}

extension Ixo_Claims_V1beta1_EvaluationStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "APPROVED"),
    2: .same(proto: "REJECTED"),
    3: .same(proto: "EvaluationStatus_DISPUTED"),
  ]
}

extension Ixo_Claims_V1beta1_PaymentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBMISSION"),
    1: .same(proto: "APPROVAL"),
    2: .same(proto: "EVALUATION"),
    3: .same(proto: "REJECTION"),
  ]
}

extension Ixo_Claims_V1beta1_PaymentStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_PAYMENT"),
    1: .same(proto: "PROMISED"),
    2: .same(proto: "AUTHORIZED"),
    3: .same(proto: "GAURANTEED"),
    4: .same(proto: "PAID"),
    5: .same(proto: "FAILED"),
    6: .same(proto: "PaymentStatus_DISPUTED"),
  ]
}

extension Ixo_Claims_V1beta1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collection_sequence"),
    2: .standard(proto: "ixo_account"),
    3: .standard(proto: "network_fee_percentage"),
    4: .standard(proto: "node_fee_percentage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.collectionSequence) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ixoAccount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.networkFeePercentage) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodeFeePercentage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.collectionSequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.collectionSequence, fieldNumber: 1)
    }
    if !self.ixoAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.ixoAccount, fieldNumber: 2)
    }
    if !self.networkFeePercentage.isEmpty {
      try visitor.visitSingularStringField(value: self.networkFeePercentage, fieldNumber: 3)
    }
    if !self.nodeFeePercentage.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeFeePercentage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Claims_V1beta1_Params, rhs: Ixo_Claims_V1beta1_Params) -> Bool {
    if lhs.collectionSequence != rhs.collectionSequence {return false}
    if lhs.ixoAccount != rhs.ixoAccount {return false}
    if lhs.networkFeePercentage != rhs.networkFeePercentage {return false}
    if lhs.nodeFeePercentage != rhs.nodeFeePercentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Claims_V1beta1_Collection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Collection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "entity"),
    3: .same(proto: "admin"),
    4: .same(proto: "protocol"),
    5: .standard(proto: "start_date"),
    6: .standard(proto: "end_date"),
    7: .same(proto: "quota"),
    8: .same(proto: "count"),
    9: .same(proto: "evaluated"),
    10: .same(proto: "approved"),
    11: .same(proto: "rejected"),
    12: .same(proto: "disputed"),
    13: .same(proto: "state"),
    14: .same(proto: "payments"),
    15: .same(proto: "signer"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _entity: String = String()
    var _admin: String = String()
    var _protocol: String = String()
    var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _quota: UInt64 = 0
    var _count: UInt64 = 0
    var _evaluated: UInt64 = 0
    var _approved: UInt64 = 0
    var _rejected: UInt64 = 0
    var _disputed: UInt64 = 0
    var _state: Ixo_Claims_V1beta1_CollectionState = .open
    var _payments: Ixo_Claims_V1beta1_Payments? = nil
    var _signer: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _entity = source._entity
      _admin = source._admin
      _protocol = source._protocol
      _startDate = source._startDate
      _endDate = source._endDate
      _quota = source._quota
      _count = source._count
      _evaluated = source._evaluated
      _approved = source._approved
      _rejected = source._rejected
      _disputed = source._disputed
      _state = source._state
      _payments = source._payments
      _signer = source._signer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._entity) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._admin) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._protocol) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._startDate) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._endDate) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._quota) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._count) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._evaluated) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._approved) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._rejected) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._disputed) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._payments) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._signer) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._entity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._entity, fieldNumber: 2)
      }
      if !_storage._admin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._admin, fieldNumber: 3)
      }
      if !_storage._protocol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._protocol, fieldNumber: 4)
      }
      try { if let v = _storage._startDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._endDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._quota != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._quota, fieldNumber: 7)
      }
      if _storage._count != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._count, fieldNumber: 8)
      }
      if _storage._evaluated != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._evaluated, fieldNumber: 9)
      }
      if _storage._approved != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._approved, fieldNumber: 10)
      }
      if _storage._rejected != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._rejected, fieldNumber: 11)
      }
      if _storage._disputed != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._disputed, fieldNumber: 12)
      }
      if _storage._state != .open {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 13)
      }
      try { if let v = _storage._payments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._signer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._signer, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Claims_V1beta1_Collection, rhs: Ixo_Claims_V1beta1_Collection) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._entity != rhs_storage._entity {return false}
        if _storage._admin != rhs_storage._admin {return false}
        if _storage._protocol != rhs_storage._protocol {return false}
        if _storage._startDate != rhs_storage._startDate {return false}
        if _storage._endDate != rhs_storage._endDate {return false}
        if _storage._quota != rhs_storage._quota {return false}
        if _storage._count != rhs_storage._count {return false}
        if _storage._evaluated != rhs_storage._evaluated {return false}
        if _storage._approved != rhs_storage._approved {return false}
        if _storage._rejected != rhs_storage._rejected {return false}
        if _storage._disputed != rhs_storage._disputed {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._payments != rhs_storage._payments {return false}
        if _storage._signer != rhs_storage._signer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Claims_V1beta1_Payments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "submission"),
    2: .same(proto: "evaluation"),
    3: .same(proto: "approval"),
    4: .same(proto: "rejection"),
  ]

  fileprivate class _StorageClass {
    var _submission: Ixo_Claims_V1beta1_Payment? = nil
    var _evaluation: Ixo_Claims_V1beta1_Payment? = nil
    var _approval: Ixo_Claims_V1beta1_Payment? = nil
    var _rejection: Ixo_Claims_V1beta1_Payment? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _submission = source._submission
      _evaluation = source._evaluation
      _approval = source._approval
      _rejection = source._rejection
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._submission) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._evaluation) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._approval) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._rejection) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._submission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._evaluation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._approval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._rejection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Claims_V1beta1_Payments, rhs: Ixo_Claims_V1beta1_Payments) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._submission != rhs_storage._submission {return false}
        if _storage._evaluation != rhs_storage._evaluation {return false}
        if _storage._approval != rhs_storage._approval {return false}
        if _storage._rejection != rhs_storage._rejection {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Claims_V1beta1_Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "amount"),
    3: .standard(proto: "contract_1155_payment"),
    4: .standard(proto: "timeout_ns"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._contract1155Payment) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timeoutNs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 2)
    }
    try { if let v = self._contract1155Payment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._timeoutNs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Claims_V1beta1_Payment, rhs: Ixo_Claims_V1beta1_Payment) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._contract1155Payment != rhs._contract1155Payment {return false}
    if lhs._timeoutNs != rhs._timeoutNs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Claims_V1beta1_Contract1155Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Contract1155Payment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "token_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt32Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Claims_V1beta1_Contract1155Payment, rhs: Ixo_Claims_V1beta1_Contract1155Payment) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Claims_V1beta1_Claim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Claim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collection_id"),
    2: .standard(proto: "agent_did"),
    3: .standard(proto: "agent_address"),
    4: .standard(proto: "submission_date"),
    5: .standard(proto: "claim_id"),
    6: .same(proto: "evaluation"),
    7: .standard(proto: "payments_status"),
  ]

  fileprivate class _StorageClass {
    var _collectionID: String = String()
    var _agentDid: String = String()
    var _agentAddress: String = String()
    var _submissionDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _claimID: String = String()
    var _evaluation: Ixo_Claims_V1beta1_Evaluation? = nil
    var _paymentsStatus: Ixo_Claims_V1beta1_ClaimPayments? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collectionID = source._collectionID
      _agentDid = source._agentDid
      _agentAddress = source._agentAddress
      _submissionDate = source._submissionDate
      _claimID = source._claimID
      _evaluation = source._evaluation
      _paymentsStatus = source._paymentsStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._collectionID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._agentDid) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._agentAddress) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._submissionDate) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._claimID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._evaluation) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._paymentsStatus) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._collectionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collectionID, fieldNumber: 1)
      }
      if !_storage._agentDid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._agentDid, fieldNumber: 2)
      }
      if !_storage._agentAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._agentAddress, fieldNumber: 3)
      }
      try { if let v = _storage._submissionDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._claimID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._claimID, fieldNumber: 5)
      }
      try { if let v = _storage._evaluation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._paymentsStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Claims_V1beta1_Claim, rhs: Ixo_Claims_V1beta1_Claim) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collectionID != rhs_storage._collectionID {return false}
        if _storage._agentDid != rhs_storage._agentDid {return false}
        if _storage._agentAddress != rhs_storage._agentAddress {return false}
        if _storage._submissionDate != rhs_storage._submissionDate {return false}
        if _storage._claimID != rhs_storage._claimID {return false}
        if _storage._evaluation != rhs_storage._evaluation {return false}
        if _storage._paymentsStatus != rhs_storage._paymentsStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Claims_V1beta1_ClaimPayments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClaimPayments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "submission"),
    2: .same(proto: "evaluation"),
    3: .same(proto: "approval"),
    4: .same(proto: "rejection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.submission) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.evaluation) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.approval) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.rejection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.submission != .noPayment {
      try visitor.visitSingularEnumField(value: self.submission, fieldNumber: 1)
    }
    if self.evaluation != .noPayment {
      try visitor.visitSingularEnumField(value: self.evaluation, fieldNumber: 2)
    }
    if self.approval != .noPayment {
      try visitor.visitSingularEnumField(value: self.approval, fieldNumber: 3)
    }
    if self.rejection != .noPayment {
      try visitor.visitSingularEnumField(value: self.rejection, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Claims_V1beta1_ClaimPayments, rhs: Ixo_Claims_V1beta1_ClaimPayments) -> Bool {
    if lhs.submission != rhs.submission {return false}
    if lhs.evaluation != rhs.evaluation {return false}
    if lhs.approval != rhs.approval {return false}
    if lhs.rejection != rhs.rejection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Claims_V1beta1_Evaluation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Evaluation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "claim_id"),
    2: .standard(proto: "collection_id"),
    3: .same(proto: "oracle"),
    4: .standard(proto: "agent_did"),
    5: .standard(proto: "agent_address"),
    6: .same(proto: "status"),
    7: .same(proto: "reason"),
    8: .standard(proto: "verification_proof"),
    9: .standard(proto: "evaluation_date"),
    10: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.claimID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.collectionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.oracle) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.agentDid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.agentAddress) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.reason) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.verificationProof) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._evaluationDate) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.claimID.isEmpty {
      try visitor.visitSingularStringField(value: self.claimID, fieldNumber: 1)
    }
    if !self.collectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionID, fieldNumber: 2)
    }
    if !self.oracle.isEmpty {
      try visitor.visitSingularStringField(value: self.oracle, fieldNumber: 3)
    }
    if !self.agentDid.isEmpty {
      try visitor.visitSingularStringField(value: self.agentDid, fieldNumber: 4)
    }
    if !self.agentAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.agentAddress, fieldNumber: 5)
    }
    if self.status != .pending {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 6)
    }
    if self.reason != 0 {
      try visitor.visitSingularUInt32Field(value: self.reason, fieldNumber: 7)
    }
    if !self.verificationProof.isEmpty {
      try visitor.visitSingularStringField(value: self.verificationProof, fieldNumber: 8)
    }
    try { if let v = self._evaluationDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Claims_V1beta1_Evaluation, rhs: Ixo_Claims_V1beta1_Evaluation) -> Bool {
    if lhs.claimID != rhs.claimID {return false}
    if lhs.collectionID != rhs.collectionID {return false}
    if lhs.oracle != rhs.oracle {return false}
    if lhs.agentDid != rhs.agentDid {return false}
    if lhs.agentAddress != rhs.agentAddress {return false}
    if lhs.status != rhs.status {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.verificationProof != rhs.verificationProof {return false}
    if lhs._evaluationDate != rhs._evaluationDate {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Claims_V1beta1_Dispute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Dispute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subject_id"),
    2: .same(proto: "type"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subjectID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.subjectID, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Claims_V1beta1_Dispute, rhs: Ixo_Claims_V1beta1_Dispute) -> Bool {
    if lhs.subjectID != rhs.subjectID {return false}
    if lhs.type != rhs.type {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Claims_V1beta1_DisputeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisputeData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "type"),
    3: .same(proto: "proof"),
    4: .same(proto: "encrypted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.proof) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.encrypted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.proof.isEmpty {
      try visitor.visitSingularStringField(value: self.proof, fieldNumber: 3)
    }
    if self.encrypted != false {
      try visitor.visitSingularBoolField(value: self.encrypted, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Claims_V1beta1_DisputeData, rhs: Ixo_Claims_V1beta1_DisputeData) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.type != rhs.type {return false}
    if lhs.proof != rhs.proof {return false}
    if lhs.encrypted != rhs.encrypted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
