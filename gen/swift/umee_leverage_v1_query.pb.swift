// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: umee/leverage/v1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryParams defines the request structure for the Params gRPC service
/// handler.
struct Umee_Leverage_V1_QueryParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryParamsResponse defines the response structure for the Params gRPC
/// service handler.
struct Umee_Leverage_V1_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Umee_Leverage_V1_Params {
    get {return _params ?? Umee_Leverage_V1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Umee_Leverage_V1_Params? = nil
}

/// QueryRegisteredTokens defines the request structure for the RegisteredTokens
/// gRPC service handler.
struct Umee_Leverage_V1_QueryRegisteredTokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseDenom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryRegisteredTokensResponse defines the response structure for the
/// RegisteredTokens gRPC service handler.
struct Umee_Leverage_V1_QueryRegisteredTokensResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var registry: [Umee_Leverage_V1_Token] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryMarketSummary defines the request structure for the MarketSummary gRPC service handler.
struct Umee_Leverage_V1_QueryMarketSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryMarketSummaryResponse defines the response structure for the MarketSummary gRPC service handler.
struct Umee_Leverage_V1_QueryMarketSummaryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Symbol Denom is the human-readable representation of a token denom, for example "UMEE" or "ATOM".
  var symbolDenom: String {
    get {return _storage._symbolDenom}
    set {_uniqueStorage()._symbolDenom = newValue}
  }

  /// Exponent is the power of ten required to get from base denom to symbol denom. For example, an exponent of 6 means 10^6 uumee = 1 UMEE.
  var exponent: UInt32 {
    get {return _storage._exponent}
    set {_uniqueStorage()._exponent = newValue}
  }

  /// Oracle Price is the current USD value of a token. Oracle price is nil when the oracle is down.
  var oraclePrice: String {
    get {return _storage._oraclePrice}
    set {_uniqueStorage()._oraclePrice = newValue}
  }

  /// uToken Exchange Rate is the amount of base tokens received when withdrawing 1 uToken. For example, a uToken exchange rate of 1.5 means a supplier receives 3 uumee for every 2 u/uumee they wish to withdraw. The same applies in reverse: supplying 3 uumee would award 2 u/uumee at that time.
  var uTokenExchangeRate: String {
    get {return _storage._uTokenExchangeRate}
    set {_uniqueStorage()._uTokenExchangeRate = newValue}
  }

  /// Supply APY is the current interest rate suppliers are receiving for their deposits. For example, 0.11 would mean 11% APY. Supply APY is always less than borrow APY.
  var supplyApy: String {
    get {return _storage._supplyApy}
    set {_uniqueStorage()._supplyApy = newValue}
  }

  /// Borrow APY is the current interest rate borrowers are being charged on their loans. For example, 0.2 would mean 20% APY.
  var borrowApy: String {
    get {return _storage._borrowApy}
    set {_uniqueStorage()._borrowApy = newValue}
  }

  /// Supplied is the total amount of tokens supplied to the the system by all suppliers, including any interest earned. This includes that tokens which have been borrowed out or enabled as collateral, but excludes reserves. Supplied is denominated in base tokens, so exponent must be applied to convert to symbol denom.
  var supplied: String {
    get {return _storage._supplied}
    set {_uniqueStorage()._supplied = newValue}
  }

  /// Reserved is the total amount of tokens held in reserve by the module for emergencies. Reserves are always excluded from total supply, borrow, collateral, and liqduidity queries. Reserves are denominated in base tokens, so exponent must be applied to convert to symbol denom.
  var reserved: String {
    get {return _storage._reserved}
    set {_uniqueStorage()._reserved = newValue}
  }

  /// Collateral is the total amount of uTokens collateralized by all borrowers. Collateral is denominated in uTokenso, so both uToken exchange rate and exponent must also be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee and uToken exchange rate is 1.2, then 5 UMEE have been collateralized.
  var collateral: String {
    get {return _storage._collateral}
    set {_uniqueStorage()._collateral = newValue}
  }

  /// Borrowed is the total amount of debt in this token held across all borrowers. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
  var borrowed: String {
    get {return _storage._borrowed}
    set {_uniqueStorage()._borrowed = newValue}
  }

  /// Liquidity is the amount of a token that has been supplied but not yet borrowed or reserved. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
  var liquidity: String {
    get {return _storage._liquidity}
    set {_uniqueStorage()._liquidity = newValue}
  }

  /// Maximum Borrow is the amount of a token that is available for borrowing, including that which has already been borrowed out. This amount is less than total supply due to safety limits. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if borrowed is 3000000 uumee and maximum borrow is 4000000 uumee, then 1 UMEE is currently available for borrowing.
  var maximumBorrow: String {
    get {return _storage._maximumBorrow}
    set {_uniqueStorage()._maximumBorrow = newValue}
  }

  /// Maximum Collateral is the amount of a token that can be collateralized, including that which is already collateral. This amount is less than total supply due to safety limits. It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee, uToken exchange rate is 1.2, and maximum borrow is 7000000 uumee, then a maximum of 2 additional UMEE is permitted to be collateralized.
  var maximumCollateral: String {
    get {return _storage._maximumCollateral}
    set {_uniqueStorage()._maximumCollateral = newValue}
  }

  /// Minimum Liquidity is the minimum amount of liquidity in the module required by safety limits, based on the current collateral. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if liquidity is 9000000 uumee and minimum liquidity is 8000000 uumee, then a maximum of 1 additional UMEE is currently available for borrowing or withdrawal.
  var minimumLiquidity: String {
    get {return _storage._minimumLiquidity}
    set {_uniqueStorage()._minimumLiquidity = newValue}
  }

  /// uToken Supply is the total amount of a base token's associated uToken in circulation.
  var uTokenSupply: String {
    get {return _storage._uTokenSupply}
    set {_uniqueStorage()._uTokenSupply = newValue}
  }

  /// Available Borrow is the maximum additional amount of base tokens than can be borrowed based on current liquidity and system safety limits. It can also be calculated by MIN(maximum_borrow - borrowed, liquidity - minimum_liquidity). It is denominated in base tokens, so exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and borrowing is temporarily unavailable.
  var availableBorrow: String {
    get {return _storage._availableBorrow}
    set {_uniqueStorage()._availableBorrow = newValue}
  }

  /// Available Withdraw is the maximum amount of uTokens than can currently be withdrawn based on liquidity and system safety limits. It can also be calculated by (liquidity - minimum_liquidity). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and withdrawal is temporarily unavailable.
  var availableWithdraw: String {
    get {return _storage._availableWithdraw}
    set {_uniqueStorage()._availableWithdraw = newValue}
  }

  /// Available Collateralize is the maximum additional amount of uTokens than can be collateralized based on current liquidity and system safety limits. It can also be calculated by (maximum_collateral, - collateral). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and additional collateral cannot be created until more liquidity is present.
  var availableCollateralize: String {
    get {return _storage._availableCollateralize}
    set {_uniqueStorage()._availableCollateralize = newValue}
  }

  /// Oracle Historic Price is the historic USD value of a token. Historic price is defined as the median of the last N historic median prices from the oracle module, with N being this token's HistoricMedians in the leverage registry. Current price is used if required medians is zero. Price is nil when the oracle is down or insufficient historic medians are available.
  var oracleHistoricPrice: String {
    get {return _storage._oracleHistoricPrice}
    set {_uniqueStorage()._oracleHistoricPrice = newValue}
  }

  var errors: String {
    get {return _storage._errors}
    set {_uniqueStorage()._errors = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// QueryAccountBalances defines the request structure for the AccountBalances gRPC service handler.
struct Umee_Leverage_V1_QueryAccountBalances {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountBalancesResponse defines the response structure for the AccountBalances gRPC service handler.
struct Umee_Leverage_V1_QueryAccountBalancesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Supplied contains all tokens the account has supplied, including interest earned. It is denominated in base tokens, so exponent from each coin's registered_tokens entry must be applied to convert to symbol denom.
  var supplied: [Cosmos_Base_V1beta1_Coin] = []

  /// Collateral contains all uTokens the account has collateralized. It is denominated in uTokens, so both exponent and uToken exchange rate from each coin's market_summary must be applied to convert to base token symbol denom.
  var collateral: [Cosmos_Base_V1beta1_Coin] = []

  /// Borrowed contains all tokens the account has borrowed, including interest owed. It is denominated in base tokens, so exponent from each coin's registered_tokens entry must be applied to convert to symbol denom.
  var borrowed: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountSummary defines the request structure for the AccountSummary gRPC service handler.
struct Umee_Leverage_V1_QueryAccountSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountSummaryResponse defines the response structure for the AccountSummary gRPC service handler.
struct Umee_Leverage_V1_QueryAccountSummaryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Supplied Value is the sum of the USD value of all tokens the account has supplied, including interest earned.
  /// Computation skips assets which are missing oracle prices, potentially resulting in a lower supplied
  /// value than if prices were all available.
  var suppliedValue: String = String()

  /// Collateral Value is the sum of the USD value of all uTokens the account has collateralized.
  /// Computation skips collateral which is missing an oracle price, potentially resulting in a lower collateral
  /// value than if prices were all available.
  var collateralValue: String = String()

  /// Borrowed Value is the sum of the USD value of all tokens the account has borrowed, including interest owed.
  /// It always uses spot prices.
  /// Computation skips borrows which are missing oracle prices, potentially resulting in a lower borrowed
  /// value than if prices were all available.
  var borrowedValue: String = String()

  /// Borrow Limit is the maximum Borrowed Value the account is allowed to reach through direct borrowing.
  /// The lower of spot or historic price for each collateral token is used when calculating borrow limits.
  /// Computation skips collateral which is missing an oracle price, potentially resulting in a lower borrow
  /// limit than if prices were all available.
  var borrowLimit: String = String()

  /// Liquidation Threshold is the Borrowed Value at which the account becomes eligible for liquidation.
  /// Will be null if an oracle price required for computation is missing.
  var liquidationThreshold: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryLiquidationTargets defines the request structure for the LiquidationTargets gRPC service handler.
struct Umee_Leverage_V1_QueryLiquidationTargets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryLiquidationTargetsResponse defines the response structure for the LiquidationTargets gRPC service handler.
struct Umee_Leverage_V1_QueryLiquidationTargetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Targets are the addresses of borrowers eligible for liquidation.
  var targets: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBadDebts defines the request structure for the
/// BedDebts gRPC service handler.
struct Umee_Leverage_V1_QueryBadDebts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBadDebtsResponse defines the response structure for the BedDebts gRPC service handler.
struct Umee_Leverage_V1_QueryBadDebtsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Targets are borrow positions currently marked for bad debt repayment. Each contains an Address and a Denom.
  var targets: [Umee_Leverage_V1_BadDebt] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryMaxWithdraw defines the request structure for the MaxWithdraw gRPC service handler.
struct Umee_Leverage_V1_QueryMaxWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  /// denom is the base token denom associated with the uToken to withdraw.
  /// empty denom will query all registered tokens.
  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryMaxWithdrawResponse defines the response structure for the MaxWithdraw gRPC service handler.
struct Umee_Leverage_V1_QueryMaxWithdrawResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uTokens is the maximum amount of uTokens that can be withdrawn
  var uTokens: [Cosmos_Base_V1beta1_Coin] = []

  /// Tokens is the equivalent of max uTokens converted to base tokens
  var tokens: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryMaxBorrow defines the request structure for the MaxBorrow gRPC service handler.
struct Umee_Leverage_V1_QueryMaxBorrow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  /// denom is the base token denom to borrow.
  /// empty denom will query all registered tokens.
  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryMaxBorrowResponse defines the response structure for the MaxBorrow gRPC service handler.
struct Umee_Leverage_V1_QueryMaxBorrowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tokens is the maximum amount of tokens that can be borrowed
  var tokens: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Umee_Leverage_V1_QueryParams: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryParamsResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryRegisteredTokens: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryRegisteredTokensResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryMarketSummary: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryMarketSummaryResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryAccountBalances: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryAccountBalancesResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryAccountSummary: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryAccountSummaryResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryLiquidationTargets: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryLiquidationTargetsResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryBadDebts: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryBadDebtsResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryMaxWithdraw: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryMaxWithdrawResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryMaxBorrow: @unchecked Sendable {}
extension Umee_Leverage_V1_QueryMaxBorrowResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "umee.leverage.v1"

extension Umee_Leverage_V1_QueryParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParams"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryParams, rhs: Umee_Leverage_V1_QueryParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryParamsResponse, rhs: Umee_Leverage_V1_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryRegisteredTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRegisteredTokens"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.baseDenom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.baseDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.baseDenom, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryRegisteredTokens, rhs: Umee_Leverage_V1_QueryRegisteredTokens) -> Bool {
    if lhs.baseDenom != rhs.baseDenom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryRegisteredTokensResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRegisteredTokensResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "registry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.registry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.registry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.registry, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryRegisteredTokensResponse, rhs: Umee_Leverage_V1_QueryRegisteredTokensResponse) -> Bool {
    if lhs.registry != rhs.registry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryMarketSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMarketSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryMarketSummary, rhs: Umee_Leverage_V1_QueryMarketSummary) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryMarketSummaryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMarketSummaryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "symbol_denom"),
    2: .same(proto: "exponent"),
    3: .standard(proto: "oracle_price"),
    4: .standard(proto: "uToken_exchange_rate"),
    5: .standard(proto: "supply_APY"),
    6: .standard(proto: "borrow_APY"),
    7: .same(proto: "supplied"),
    8: .same(proto: "reserved"),
    9: .same(proto: "collateral"),
    10: .same(proto: "borrowed"),
    11: .same(proto: "liquidity"),
    12: .standard(proto: "maximum_borrow"),
    13: .standard(proto: "maximum_collateral"),
    14: .standard(proto: "minimum_liquidity"),
    15: .standard(proto: "uToken_supply"),
    16: .standard(proto: "available_borrow"),
    17: .standard(proto: "available_withdraw"),
    18: .standard(proto: "available_collateralize"),
    19: .standard(proto: "oracle_historic_price"),
    20: .same(proto: "errors"),
  ]

  fileprivate class _StorageClass {
    var _symbolDenom: String = String()
    var _exponent: UInt32 = 0
    var _oraclePrice: String = String()
    var _uTokenExchangeRate: String = String()
    var _supplyApy: String = String()
    var _borrowApy: String = String()
    var _supplied: String = String()
    var _reserved: String = String()
    var _collateral: String = String()
    var _borrowed: String = String()
    var _liquidity: String = String()
    var _maximumBorrow: String = String()
    var _maximumCollateral: String = String()
    var _minimumLiquidity: String = String()
    var _uTokenSupply: String = String()
    var _availableBorrow: String = String()
    var _availableWithdraw: String = String()
    var _availableCollateralize: String = String()
    var _oracleHistoricPrice: String = String()
    var _errors: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _symbolDenom = source._symbolDenom
      _exponent = source._exponent
      _oraclePrice = source._oraclePrice
      _uTokenExchangeRate = source._uTokenExchangeRate
      _supplyApy = source._supplyApy
      _borrowApy = source._borrowApy
      _supplied = source._supplied
      _reserved = source._reserved
      _collateral = source._collateral
      _borrowed = source._borrowed
      _liquidity = source._liquidity
      _maximumBorrow = source._maximumBorrow
      _maximumCollateral = source._maximumCollateral
      _minimumLiquidity = source._minimumLiquidity
      _uTokenSupply = source._uTokenSupply
      _availableBorrow = source._availableBorrow
      _availableWithdraw = source._availableWithdraw
      _availableCollateralize = source._availableCollateralize
      _oracleHistoricPrice = source._oracleHistoricPrice
      _errors = source._errors
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._symbolDenom) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._exponent) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._oraclePrice) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._uTokenExchangeRate) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._supplyApy) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._borrowApy) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._supplied) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._reserved) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._collateral) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._borrowed) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._liquidity) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._maximumBorrow) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._maximumCollateral) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._minimumLiquidity) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._uTokenSupply) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._availableBorrow) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._availableWithdraw) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._availableCollateralize) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._oracleHistoricPrice) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._errors) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._symbolDenom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._symbolDenom, fieldNumber: 1)
      }
      if _storage._exponent != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._exponent, fieldNumber: 2)
      }
      if !_storage._oraclePrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._oraclePrice, fieldNumber: 3)
      }
      if !_storage._uTokenExchangeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uTokenExchangeRate, fieldNumber: 4)
      }
      if !_storage._supplyApy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._supplyApy, fieldNumber: 5)
      }
      if !_storage._borrowApy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._borrowApy, fieldNumber: 6)
      }
      if !_storage._supplied.isEmpty {
        try visitor.visitSingularStringField(value: _storage._supplied, fieldNumber: 7)
      }
      if !_storage._reserved.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reserved, fieldNumber: 8)
      }
      if !_storage._collateral.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collateral, fieldNumber: 9)
      }
      if !_storage._borrowed.isEmpty {
        try visitor.visitSingularStringField(value: _storage._borrowed, fieldNumber: 10)
      }
      if !_storage._liquidity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._liquidity, fieldNumber: 11)
      }
      if !_storage._maximumBorrow.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maximumBorrow, fieldNumber: 12)
      }
      if !_storage._maximumCollateral.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maximumCollateral, fieldNumber: 13)
      }
      if !_storage._minimumLiquidity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minimumLiquidity, fieldNumber: 14)
      }
      if !_storage._uTokenSupply.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uTokenSupply, fieldNumber: 15)
      }
      if !_storage._availableBorrow.isEmpty {
        try visitor.visitSingularStringField(value: _storage._availableBorrow, fieldNumber: 16)
      }
      if !_storage._availableWithdraw.isEmpty {
        try visitor.visitSingularStringField(value: _storage._availableWithdraw, fieldNumber: 17)
      }
      if !_storage._availableCollateralize.isEmpty {
        try visitor.visitSingularStringField(value: _storage._availableCollateralize, fieldNumber: 18)
      }
      if !_storage._oracleHistoricPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._oracleHistoricPrice, fieldNumber: 19)
      }
      if !_storage._errors.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errors, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryMarketSummaryResponse, rhs: Umee_Leverage_V1_QueryMarketSummaryResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._symbolDenom != rhs_storage._symbolDenom {return false}
        if _storage._exponent != rhs_storage._exponent {return false}
        if _storage._oraclePrice != rhs_storage._oraclePrice {return false}
        if _storage._uTokenExchangeRate != rhs_storage._uTokenExchangeRate {return false}
        if _storage._supplyApy != rhs_storage._supplyApy {return false}
        if _storage._borrowApy != rhs_storage._borrowApy {return false}
        if _storage._supplied != rhs_storage._supplied {return false}
        if _storage._reserved != rhs_storage._reserved {return false}
        if _storage._collateral != rhs_storage._collateral {return false}
        if _storage._borrowed != rhs_storage._borrowed {return false}
        if _storage._liquidity != rhs_storage._liquidity {return false}
        if _storage._maximumBorrow != rhs_storage._maximumBorrow {return false}
        if _storage._maximumCollateral != rhs_storage._maximumCollateral {return false}
        if _storage._minimumLiquidity != rhs_storage._minimumLiquidity {return false}
        if _storage._uTokenSupply != rhs_storage._uTokenSupply {return false}
        if _storage._availableBorrow != rhs_storage._availableBorrow {return false}
        if _storage._availableWithdraw != rhs_storage._availableWithdraw {return false}
        if _storage._availableCollateralize != rhs_storage._availableCollateralize {return false}
        if _storage._oracleHistoricPrice != rhs_storage._oracleHistoricPrice {return false}
        if _storage._errors != rhs_storage._errors {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryAccountBalances: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountBalances"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryAccountBalances, rhs: Umee_Leverage_V1_QueryAccountBalances) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryAccountBalancesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountBalancesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "supplied"),
    2: .same(proto: "collateral"),
    3: .same(proto: "borrowed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.supplied) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.collateral) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.borrowed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.supplied.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.supplied, fieldNumber: 1)
    }
    if !self.collateral.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collateral, fieldNumber: 2)
    }
    if !self.borrowed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.borrowed, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryAccountBalancesResponse, rhs: Umee_Leverage_V1_QueryAccountBalancesResponse) -> Bool {
    if lhs.supplied != rhs.supplied {return false}
    if lhs.collateral != rhs.collateral {return false}
    if lhs.borrowed != rhs.borrowed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryAccountSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryAccountSummary, rhs: Umee_Leverage_V1_QueryAccountSummary) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryAccountSummaryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountSummaryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supplied_value"),
    2: .standard(proto: "collateral_value"),
    3: .standard(proto: "borrowed_value"),
    4: .standard(proto: "borrow_limit"),
    5: .standard(proto: "liquidation_threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.suppliedValue) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.collateralValue) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.borrowedValue) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.borrowLimit) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.liquidationThreshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.suppliedValue.isEmpty {
      try visitor.visitSingularStringField(value: self.suppliedValue, fieldNumber: 1)
    }
    if !self.collateralValue.isEmpty {
      try visitor.visitSingularStringField(value: self.collateralValue, fieldNumber: 2)
    }
    if !self.borrowedValue.isEmpty {
      try visitor.visitSingularStringField(value: self.borrowedValue, fieldNumber: 3)
    }
    if !self.borrowLimit.isEmpty {
      try visitor.visitSingularStringField(value: self.borrowLimit, fieldNumber: 4)
    }
    if !self.liquidationThreshold.isEmpty {
      try visitor.visitSingularStringField(value: self.liquidationThreshold, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryAccountSummaryResponse, rhs: Umee_Leverage_V1_QueryAccountSummaryResponse) -> Bool {
    if lhs.suppliedValue != rhs.suppliedValue {return false}
    if lhs.collateralValue != rhs.collateralValue {return false}
    if lhs.borrowedValue != rhs.borrowedValue {return false}
    if lhs.borrowLimit != rhs.borrowLimit {return false}
    if lhs.liquidationThreshold != rhs.liquidationThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryLiquidationTargets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryLiquidationTargets"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryLiquidationTargets, rhs: Umee_Leverage_V1_QueryLiquidationTargets) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryLiquidationTargetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryLiquidationTargetsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.targets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryLiquidationTargetsResponse, rhs: Umee_Leverage_V1_QueryLiquidationTargetsResponse) -> Bool {
    if lhs.targets != rhs.targets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryBadDebts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBadDebts"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryBadDebts, rhs: Umee_Leverage_V1_QueryBadDebts) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryBadDebtsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBadDebtsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.targets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.targets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryBadDebtsResponse, rhs: Umee_Leverage_V1_QueryBadDebtsResponse) -> Bool {
    if lhs.targets != rhs.targets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryMaxWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMaxWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryMaxWithdraw, rhs: Umee_Leverage_V1_QueryMaxWithdraw) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryMaxWithdrawResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMaxWithdrawResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uTokens"),
    2: .same(proto: "tokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.uTokens) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uTokens, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryMaxWithdrawResponse, rhs: Umee_Leverage_V1_QueryMaxWithdrawResponse) -> Bool {
    if lhs.uTokens != rhs.uTokens {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryMaxBorrow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMaxBorrow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryMaxBorrow, rhs: Umee_Leverage_V1_QueryMaxBorrow) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_QueryMaxBorrowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMaxBorrowResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_QueryMaxBorrowResponse, rhs: Umee_Leverage_V1_QueryMaxBorrowResponse) -> Bool {
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
