// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: injective/oracle/v1beta1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Injective_Oracle_V1beta1_QueryPythPriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var priceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_QueryPythPriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var priceState: Injective_Oracle_V1beta1_PythPriceState {
    get {return _priceState ?? Injective_Oracle_V1beta1_PythPriceState()}
    set {_priceState = newValue}
  }
  /// Returns true if `priceState` has been explicitly set.
  var hasPriceState: Bool {return self._priceState != nil}
  /// Clears the value of `priceState`. Subsequent reads from it will return its default value.
  mutating func clearPriceState() {self._priceState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _priceState: Injective_Oracle_V1beta1_PythPriceState? = nil
}

/// QueryOracleParamsRequest is the request type for the Query/OracleParams RPC
/// method.
struct Injective_Oracle_V1beta1_QueryParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryOracleParamsResponse is the response type for the Query/OracleParams RPC
/// method.
struct Injective_Oracle_V1beta1_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Injective_Oracle_V1beta1_Params {
    get {return _params ?? Injective_Oracle_V1beta1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Injective_Oracle_V1beta1_Params? = nil
}

/// QueryBandRelayersRequest is the request type for the Query/BandRelayers RPC
/// method.
struct Injective_Oracle_V1beta1_QueryBandRelayersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBandRelayersResponse is the response type for the Query/BandRelayers RPC
/// method.
struct Injective_Oracle_V1beta1_QueryBandRelayersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var relayers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBandPriceStatesRequest is the request type for the Query/BandPriceStates
/// RPC method.
struct Injective_Oracle_V1beta1_QueryBandPriceStatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBandPriceStatesResponse is the response type for the
/// Query/BandPriceStates RPC method.
struct Injective_Oracle_V1beta1_QueryBandPriceStatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var priceStates: [Injective_Oracle_V1beta1_BandPriceState] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBandIBCPriceStatesRequest is the request type for the
/// Query/BandIBCPriceStates RPC method.
struct Injective_Oracle_V1beta1_QueryBandIBCPriceStatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBandIBCPriceStatesResponse is the response type for the
/// Query/BandIBCPriceStates RPC method.
struct Injective_Oracle_V1beta1_QueryBandIBCPriceStatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var priceStates: [Injective_Oracle_V1beta1_BandPriceState] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryPriceFeedPriceStatesRequest is the request type for the
/// Query/PriceFeedPriceStates RPC method.
struct Injective_Oracle_V1beta1_QueryPriceFeedPriceStatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryPriceFeedPriceStatesResponse is the response type for the
/// Query/PriceFeedPriceStates RPC method.
struct Injective_Oracle_V1beta1_QueryPriceFeedPriceStatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var priceStates: [Injective_Oracle_V1beta1_PriceFeedState] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCoinbasePriceStatesRequest is the request type for the
/// Query/CoinbasePriceStates RPC method.
struct Injective_Oracle_V1beta1_QueryCoinbasePriceStatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCoinbasePriceStatesResponse is the response type for the
/// Query/CoinbasePriceStates RPC method.
struct Injective_Oracle_V1beta1_QueryCoinbasePriceStatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var priceStates: [Injective_Oracle_V1beta1_CoinbasePriceState] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryPythPriceStatesRequest is the request type for the
/// Query/CoinbasePriceStates RPC method.
struct Injective_Oracle_V1beta1_QueryPythPriceStatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryPythPriceStatesResponse is the response type for the
/// Query/CoinbasePriceStates RPC method.
struct Injective_Oracle_V1beta1_QueryPythPriceStatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var priceStates: [Injective_Oracle_V1beta1_PythPriceState] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryProviderPriceStateRequest is the request type for the
/// Query/ProviderPriceState RPC method.
struct Injective_Oracle_V1beta1_QueryProviderPriceStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var provider: String = String()

  var symbol: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryProviderPriceStatesResponse is the response type for the
/// Query/ProviderPriceStates RPC method.
struct Injective_Oracle_V1beta1_QueryProviderPriceStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var priceState: Injective_Oracle_V1beta1_PriceState {
    get {return _priceState ?? Injective_Oracle_V1beta1_PriceState()}
    set {_priceState = newValue}
  }
  /// Returns true if `priceState` has been explicitly set.
  var hasPriceState: Bool {return self._priceState != nil}
  /// Clears the value of `priceState`. Subsequent reads from it will return its default value.
  mutating func clearPriceState() {self._priceState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _priceState: Injective_Oracle_V1beta1_PriceState? = nil
}

/// QueryModuleStateRequest is the request type for the Query/OracleModuleState
/// RPC method.
struct Injective_Oracle_V1beta1_QueryModuleStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryModuleStateResponse is the response type for the Query/OracleModuleState
/// RPC method.
struct Injective_Oracle_V1beta1_QueryModuleStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Injective_Oracle_V1beta1_GenesisState {
    get {return _state ?? Injective_Oracle_V1beta1_GenesisState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _state: Injective_Oracle_V1beta1_GenesisState? = nil
}

struct Injective_Oracle_V1beta1_QueryHistoricalPriceRecordsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oracle: Injective_Oracle_V1beta1_OracleType = .unspecified

  var symbolID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_QueryHistoricalPriceRecordsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var priceRecords: [Injective_Oracle_V1beta1_PriceRecords] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_OracleHistoryOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// MaxAge restricts the oracle price records oldest age in seconds from the
  /// current block time to consider. A value of 0 means use all the records
  /// present on the chain.
  var maxAge: UInt64 = 0

  /// If IncludeRawHistory is true, the raw underlying data used for the
  /// computation is included in the response
  var includeRawHistory: Bool = false

  /// If IncludeMetadata is true, metadata on the computation is included in the
  /// response
  var includeMetadata: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryOracleVolatilityRequest is the request type for Query/OracleVolatility
/// RPC method.
struct Injective_Oracle_V1beta1_QueryOracleVolatilityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseInfo: Injective_Oracle_V1beta1_OracleInfo {
    get {return _baseInfo ?? Injective_Oracle_V1beta1_OracleInfo()}
    set {_baseInfo = newValue}
  }
  /// Returns true if `baseInfo` has been explicitly set.
  var hasBaseInfo: Bool {return self._baseInfo != nil}
  /// Clears the value of `baseInfo`. Subsequent reads from it will return its default value.
  mutating func clearBaseInfo() {self._baseInfo = nil}

  var quoteInfo: Injective_Oracle_V1beta1_OracleInfo {
    get {return _quoteInfo ?? Injective_Oracle_V1beta1_OracleInfo()}
    set {_quoteInfo = newValue}
  }
  /// Returns true if `quoteInfo` has been explicitly set.
  var hasQuoteInfo: Bool {return self._quoteInfo != nil}
  /// Clears the value of `quoteInfo`. Subsequent reads from it will return its default value.
  mutating func clearQuoteInfo() {self._quoteInfo = nil}

  var oracleHistoryOptions: Injective_Oracle_V1beta1_OracleHistoryOptions {
    get {return _oracleHistoryOptions ?? Injective_Oracle_V1beta1_OracleHistoryOptions()}
    set {_oracleHistoryOptions = newValue}
  }
  /// Returns true if `oracleHistoryOptions` has been explicitly set.
  var hasOracleHistoryOptions: Bool {return self._oracleHistoryOptions != nil}
  /// Clears the value of `oracleHistoryOptions`. Subsequent reads from it will return its default value.
  mutating func clearOracleHistoryOptions() {self._oracleHistoryOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseInfo: Injective_Oracle_V1beta1_OracleInfo? = nil
  fileprivate var _quoteInfo: Injective_Oracle_V1beta1_OracleInfo? = nil
  fileprivate var _oracleHistoryOptions: Injective_Oracle_V1beta1_OracleHistoryOptions? = nil
}

/// QueryOracleVolatilityResponse is the response type for Query/OracleVolatility
/// RPC method.
struct Injective_Oracle_V1beta1_QueryOracleVolatilityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var volatility: String = String()

  var historyMetadata: Injective_Oracle_V1beta1_MetadataStatistics {
    get {return _historyMetadata ?? Injective_Oracle_V1beta1_MetadataStatistics()}
    set {_historyMetadata = newValue}
  }
  /// Returns true if `historyMetadata` has been explicitly set.
  var hasHistoryMetadata: Bool {return self._historyMetadata != nil}
  /// Clears the value of `historyMetadata`. Subsequent reads from it will return its default value.
  mutating func clearHistoryMetadata() {self._historyMetadata = nil}

  var rawHistory: [Injective_Oracle_V1beta1_PriceRecord] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _historyMetadata: Injective_Oracle_V1beta1_MetadataStatistics? = nil
}

struct Injective_Oracle_V1beta1_QueryOracleProvidersInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_QueryOracleProvidersInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var providers: [Injective_Oracle_V1beta1_ProviderInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_QueryOracleProviderPricesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var provider: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_QueryOracleProviderPricesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var providerState: [Injective_Oracle_V1beta1_ProviderState] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryOraclePriceRequest is the request type for the Query/OraclePrice RPC
/// method.
struct Injective_Oracle_V1beta1_QueryOraclePriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  var base: String = String()

  var quote: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_PricePairState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairPrice: String = String()

  var basePrice: String = String()

  var quotePrice: String = String()

  var baseCumulativePrice: String = String()

  var quoteCumulativePrice: String = String()

  var baseTimestamp: Int64 = 0

  var quoteTimestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryOraclePriceResponse is the response type for the Query/OraclePrice RPC
/// method.
struct Injective_Oracle_V1beta1_QueryOraclePriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pricePairState: Injective_Oracle_V1beta1_PricePairState {
    get {return _pricePairState ?? Injective_Oracle_V1beta1_PricePairState()}
    set {_pricePairState = newValue}
  }
  /// Returns true if `pricePairState` has been explicitly set.
  var hasPricePairState: Bool {return self._pricePairState != nil}
  /// Clears the value of `pricePairState`. Subsequent reads from it will return its default value.
  mutating func clearPricePairState() {self._pricePairState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pricePairState: Injective_Oracle_V1beta1_PricePairState? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Injective_Oracle_V1beta1_QueryPythPriceRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryPythPriceResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryParamsRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryParamsResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryBandRelayersRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryBandRelayersResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryBandPriceStatesRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryBandPriceStatesResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryBandIBCPriceStatesRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryBandIBCPriceStatesResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryPriceFeedPriceStatesRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryPriceFeedPriceStatesResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryCoinbasePriceStatesRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryCoinbasePriceStatesResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryPythPriceStatesRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryPythPriceStatesResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryProviderPriceStateRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryProviderPriceStateResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryModuleStateRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryModuleStateResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryHistoricalPriceRecordsRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryHistoricalPriceRecordsResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_OracleHistoryOptions: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryOracleVolatilityRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryOracleVolatilityResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryOracleProvidersInfoRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryOracleProvidersInfoResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryOracleProviderPricesRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryOracleProviderPricesResponse: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryOraclePriceRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_PricePairState: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_QueryOraclePriceResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "injective.oracle.v1beta1"

extension Injective_Oracle_V1beta1_QueryPythPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPythPriceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "price_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.priceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.priceID.isEmpty {
      try visitor.visitSingularStringField(value: self.priceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryPythPriceRequest, rhs: Injective_Oracle_V1beta1_QueryPythPriceRequest) -> Bool {
    if lhs.priceID != rhs.priceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryPythPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPythPriceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "price_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._priceState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._priceState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryPythPriceResponse, rhs: Injective_Oracle_V1beta1_QueryPythPriceResponse) -> Bool {
    if lhs._priceState != rhs._priceState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryParamsRequest, rhs: Injective_Oracle_V1beta1_QueryParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryParamsResponse, rhs: Injective_Oracle_V1beta1_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryBandRelayersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBandRelayersRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryBandRelayersRequest, rhs: Injective_Oracle_V1beta1_QueryBandRelayersRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryBandRelayersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBandRelayersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "relayers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.relayers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.relayers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relayers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryBandRelayersResponse, rhs: Injective_Oracle_V1beta1_QueryBandRelayersResponse) -> Bool {
    if lhs.relayers != rhs.relayers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryBandPriceStatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBandPriceStatesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryBandPriceStatesRequest, rhs: Injective_Oracle_V1beta1_QueryBandPriceStatesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryBandPriceStatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBandPriceStatesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "price_states"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.priceStates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.priceStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.priceStates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryBandPriceStatesResponse, rhs: Injective_Oracle_V1beta1_QueryBandPriceStatesResponse) -> Bool {
    if lhs.priceStates != rhs.priceStates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryBandIBCPriceStatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBandIBCPriceStatesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryBandIBCPriceStatesRequest, rhs: Injective_Oracle_V1beta1_QueryBandIBCPriceStatesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryBandIBCPriceStatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBandIBCPriceStatesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "price_states"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.priceStates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.priceStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.priceStates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryBandIBCPriceStatesResponse, rhs: Injective_Oracle_V1beta1_QueryBandIBCPriceStatesResponse) -> Bool {
    if lhs.priceStates != rhs.priceStates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryPriceFeedPriceStatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPriceFeedPriceStatesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryPriceFeedPriceStatesRequest, rhs: Injective_Oracle_V1beta1_QueryPriceFeedPriceStatesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryPriceFeedPriceStatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPriceFeedPriceStatesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "price_states"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.priceStates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.priceStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.priceStates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryPriceFeedPriceStatesResponse, rhs: Injective_Oracle_V1beta1_QueryPriceFeedPriceStatesResponse) -> Bool {
    if lhs.priceStates != rhs.priceStates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryCoinbasePriceStatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCoinbasePriceStatesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryCoinbasePriceStatesRequest, rhs: Injective_Oracle_V1beta1_QueryCoinbasePriceStatesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryCoinbasePriceStatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCoinbasePriceStatesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "price_states"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.priceStates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.priceStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.priceStates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryCoinbasePriceStatesResponse, rhs: Injective_Oracle_V1beta1_QueryCoinbasePriceStatesResponse) -> Bool {
    if lhs.priceStates != rhs.priceStates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryPythPriceStatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPythPriceStatesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryPythPriceStatesRequest, rhs: Injective_Oracle_V1beta1_QueryPythPriceStatesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryPythPriceStatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPythPriceStatesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "price_states"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.priceStates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.priceStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.priceStates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryPythPriceStatesResponse, rhs: Injective_Oracle_V1beta1_QueryPythPriceStatesResponse) -> Bool {
    if lhs.priceStates != rhs.priceStates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryProviderPriceStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryProviderPriceStateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
    2: .same(proto: "symbol"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryProviderPriceStateRequest, rhs: Injective_Oracle_V1beta1_QueryProviderPriceStateRequest) -> Bool {
    if lhs.provider != rhs.provider {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryProviderPriceStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryProviderPriceStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "price_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._priceState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._priceState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryProviderPriceStateResponse, rhs: Injective_Oracle_V1beta1_QueryProviderPriceStateResponse) -> Bool {
    if lhs._priceState != rhs._priceState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryModuleStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryModuleStateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryModuleStateRequest, rhs: Injective_Oracle_V1beta1_QueryModuleStateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryModuleStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryModuleStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryModuleStateResponse, rhs: Injective_Oracle_V1beta1_QueryModuleStateResponse) -> Bool {
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryHistoricalPriceRecordsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryHistoricalPriceRecordsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oracle"),
    2: .standard(proto: "symbol_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.oracle) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbolID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.oracle != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracle, fieldNumber: 1)
    }
    if !self.symbolID.isEmpty {
      try visitor.visitSingularStringField(value: self.symbolID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryHistoricalPriceRecordsRequest, rhs: Injective_Oracle_V1beta1_QueryHistoricalPriceRecordsRequest) -> Bool {
    if lhs.oracle != rhs.oracle {return false}
    if lhs.symbolID != rhs.symbolID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryHistoricalPriceRecordsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryHistoricalPriceRecordsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "price_records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.priceRecords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.priceRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.priceRecords, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryHistoricalPriceRecordsResponse, rhs: Injective_Oracle_V1beta1_QueryHistoricalPriceRecordsResponse) -> Bool {
    if lhs.priceRecords != rhs.priceRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_OracleHistoryOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OracleHistoryOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_age"),
    2: .standard(proto: "include_raw_history"),
    3: .standard(proto: "include_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.maxAge) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeRawHistory) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxAge != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxAge, fieldNumber: 1)
    }
    if self.includeRawHistory != false {
      try visitor.visitSingularBoolField(value: self.includeRawHistory, fieldNumber: 2)
    }
    if self.includeMetadata != false {
      try visitor.visitSingularBoolField(value: self.includeMetadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_OracleHistoryOptions, rhs: Injective_Oracle_V1beta1_OracleHistoryOptions) -> Bool {
    if lhs.maxAge != rhs.maxAge {return false}
    if lhs.includeRawHistory != rhs.includeRawHistory {return false}
    if lhs.includeMetadata != rhs.includeMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryOracleVolatilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOracleVolatilityRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_info"),
    2: .standard(proto: "quote_info"),
    3: .standard(proto: "oracle_history_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseInfo) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._quoteInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._oracleHistoryOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._quoteInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oracleHistoryOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryOracleVolatilityRequest, rhs: Injective_Oracle_V1beta1_QueryOracleVolatilityRequest) -> Bool {
    if lhs._baseInfo != rhs._baseInfo {return false}
    if lhs._quoteInfo != rhs._quoteInfo {return false}
    if lhs._oracleHistoryOptions != rhs._oracleHistoryOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryOracleVolatilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOracleVolatilityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volatility"),
    2: .standard(proto: "history_metadata"),
    3: .standard(proto: "raw_history"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.volatility) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._historyMetadata) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rawHistory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.volatility.isEmpty {
      try visitor.visitSingularStringField(value: self.volatility, fieldNumber: 1)
    }
    try { if let v = self._historyMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.rawHistory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rawHistory, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryOracleVolatilityResponse, rhs: Injective_Oracle_V1beta1_QueryOracleVolatilityResponse) -> Bool {
    if lhs.volatility != rhs.volatility {return false}
    if lhs._historyMetadata != rhs._historyMetadata {return false}
    if lhs.rawHistory != rhs.rawHistory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryOracleProvidersInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOracleProvidersInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryOracleProvidersInfoRequest, rhs: Injective_Oracle_V1beta1_QueryOracleProvidersInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryOracleProvidersInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOracleProvidersInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "providers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.providers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.providers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.providers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryOracleProvidersInfoResponse, rhs: Injective_Oracle_V1beta1_QueryOracleProvidersInfoResponse) -> Bool {
    if lhs.providers != rhs.providers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryOracleProviderPricesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOracleProviderPricesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryOracleProviderPricesRequest, rhs: Injective_Oracle_V1beta1_QueryOracleProviderPricesRequest) -> Bool {
    if lhs.provider != rhs.provider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryOracleProviderPricesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOracleProviderPricesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "providerState"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.providerState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.providerState.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.providerState, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryOracleProviderPricesResponse, rhs: Injective_Oracle_V1beta1_QueryOracleProviderPricesResponse) -> Bool {
    if lhs.providerState != rhs.providerState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryOraclePriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOraclePriceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "oracle_type"),
    2: .same(proto: "base"),
    3: .same(proto: "quote"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.base) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quote) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 1)
    }
    if !self.base.isEmpty {
      try visitor.visitSingularStringField(value: self.base, fieldNumber: 2)
    }
    if !self.quote.isEmpty {
      try visitor.visitSingularStringField(value: self.quote, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryOraclePriceRequest, rhs: Injective_Oracle_V1beta1_QueryOraclePriceRequest) -> Bool {
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.base != rhs.base {return false}
    if lhs.quote != rhs.quote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_PricePairState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PricePairState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_price"),
    2: .standard(proto: "base_price"),
    3: .standard(proto: "quote_price"),
    4: .standard(proto: "base_cumulative_price"),
    5: .standard(proto: "quote_cumulative_price"),
    6: .standard(proto: "base_timestamp"),
    7: .standard(proto: "quote_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pairPrice) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.basePrice) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quotePrice) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.baseCumulativePrice) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.quoteCumulativePrice) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.baseTimestamp) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.quoteTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pairPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.pairPrice, fieldNumber: 1)
    }
    if !self.basePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.basePrice, fieldNumber: 2)
    }
    if !self.quotePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.quotePrice, fieldNumber: 3)
    }
    if !self.baseCumulativePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.baseCumulativePrice, fieldNumber: 4)
    }
    if !self.quoteCumulativePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteCumulativePrice, fieldNumber: 5)
    }
    if self.baseTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.baseTimestamp, fieldNumber: 6)
    }
    if self.quoteTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.quoteTimestamp, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_PricePairState, rhs: Injective_Oracle_V1beta1_PricePairState) -> Bool {
    if lhs.pairPrice != rhs.pairPrice {return false}
    if lhs.basePrice != rhs.basePrice {return false}
    if lhs.quotePrice != rhs.quotePrice {return false}
    if lhs.baseCumulativePrice != rhs.baseCumulativePrice {return false}
    if lhs.quoteCumulativePrice != rhs.quoteCumulativePrice {return false}
    if lhs.baseTimestamp != rhs.baseTimestamp {return false}
    if lhs.quoteTimestamp != rhs.quoteTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_QueryOraclePriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOraclePriceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "price_pair_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pricePairState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pricePairState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_QueryOraclePriceResponse, rhs: Injective_Oracle_V1beta1_QueryOraclePriceResponse) -> Bool {
    if lhs._pricePairState != rhs._pricePairState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
