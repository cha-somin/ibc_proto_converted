// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: thorchain/v1/x/thorchain/types/type_events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Types_PendingLiquidityType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case add // = 0
  case withdraw // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .add
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .add
    case 1: self = .withdraw
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .add: return 0
    case .withdraw: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_PendingLiquidityType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Types_PendingLiquidityType] = [
    .add,
    .withdraw,
  ]
}

#endif  // swift(>=4.2)

enum Types_BondType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case bondPaid // = 0
  case bondReturned // = 1
  case bondReward // = 2
  case bondCost // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .bondPaid
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bondPaid
    case 1: self = .bondReturned
    case 2: self = .bondReward
    case 3: self = .bondCost
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .bondPaid: return 0
    case .bondReturned: return 1
    case .bondReward: return 2
    case .bondCost: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_BondType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Types_BondType] = [
    .bondPaid,
    .bondReturned,
    .bondReward,
    .bondCost,
  ]
}

#endif  // swift(>=4.2)

enum Types_MintBurnSupplyType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case mint // = 0
  case burn // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .mint
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mint
    case 1: self = .burn
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .mint: return 0
    case .burn: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_MintBurnSupplyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Types_MintBurnSupplyType] = [
    .mint,
    .burn,
  ]
}

#endif  // swift(>=4.2)

struct Types_PoolMod {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var asset: Common_Asset {
    get {return _asset ?? Common_Asset()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var runeAmt: String = String()

  var runeAdd: Bool = false

  var assetAmt: String = String()

  var assetAdd: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Common_Asset? = nil
}

struct Types_EventLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: Common_Coin {
    get {return _source ?? Common_Coin()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var target: Common_Coin {
    get {return _target ?? Common_Coin()}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  mutating func clearTarget() {self._target = nil}

  var txID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _source: Common_Coin? = nil
  fileprivate var _target: Common_Coin? = nil
}

struct Types_EventStreamingSwap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: String {
    get {return _storage._txID}
    set {_uniqueStorage()._txID = newValue}
  }

  var interval: UInt64 {
    get {return _storage._interval}
    set {_uniqueStorage()._interval = newValue}
  }

  var quantity: UInt64 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  var count: UInt64 {
    get {return _storage._count}
    set {_uniqueStorage()._count = newValue}
  }

  var lastHeight: Int64 {
    get {return _storage._lastHeight}
    set {_uniqueStorage()._lastHeight = newValue}
  }

  var tradeTarget: String {
    get {return _storage._tradeTarget}
    set {_uniqueStorage()._tradeTarget = newValue}
  }

  var deposit: Common_Coin {
    get {return _storage._deposit ?? Common_Coin()}
    set {_uniqueStorage()._deposit = newValue}
  }
  /// Returns true if `deposit` has been explicitly set.
  var hasDeposit: Bool {return _storage._deposit != nil}
  /// Clears the value of `deposit`. Subsequent reads from it will return its default value.
  mutating func clearDeposit() {_uniqueStorage()._deposit = nil}

  var `in`: Common_Coin {
    get {return _storage._in ?? Common_Coin()}
    set {_uniqueStorage()._in = newValue}
  }
  /// Returns true if ``in`` has been explicitly set.
  var hasIn: Bool {return _storage._in != nil}
  /// Clears the value of ``in``. Subsequent reads from it will return its default value.
  mutating func clearIn() {_uniqueStorage()._in = nil}

  var out: Common_Coin {
    get {return _storage._out ?? Common_Coin()}
    set {_uniqueStorage()._out = newValue}
  }
  /// Returns true if `out` has been explicitly set.
  var hasOut: Bool {return _storage._out != nil}
  /// Clears the value of `out`. Subsequent reads from it will return its default value.
  mutating func clearOut() {_uniqueStorage()._out = nil}

  var failedSwaps: [UInt64] {
    get {return _storage._failedSwaps}
    set {_uniqueStorage()._failedSwaps = newValue}
  }

  var failedSwapReasons: [String] {
    get {return _storage._failedSwapReasons}
    set {_uniqueStorage()._failedSwapReasons = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_EventSwap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pool: Common_Asset {
    get {return _storage._pool ?? Common_Asset()}
    set {_uniqueStorage()._pool = newValue}
  }
  /// Returns true if `pool` has been explicitly set.
  var hasPool: Bool {return _storage._pool != nil}
  /// Clears the value of `pool`. Subsequent reads from it will return its default value.
  mutating func clearPool() {_uniqueStorage()._pool = nil}

  var swapTarget: String {
    get {return _storage._swapTarget}
    set {_uniqueStorage()._swapTarget = newValue}
  }

  var swapSlip: String {
    get {return _storage._swapSlip}
    set {_uniqueStorage()._swapSlip = newValue}
  }

  var liquidityFee: String {
    get {return _storage._liquidityFee}
    set {_uniqueStorage()._liquidityFee = newValue}
  }

  var liquidityFeeInRune: String {
    get {return _storage._liquidityFeeInRune}
    set {_uniqueStorage()._liquidityFeeInRune = newValue}
  }

  var inTx: Common_Tx {
    get {return _storage._inTx ?? Common_Tx()}
    set {_uniqueStorage()._inTx = newValue}
  }
  /// Returns true if `inTx` has been explicitly set.
  var hasInTx: Bool {return _storage._inTx != nil}
  /// Clears the value of `inTx`. Subsequent reads from it will return its default value.
  mutating func clearInTx() {_uniqueStorage()._inTx = nil}

  var outTxs: Common_Tx {
    get {return _storage._outTxs ?? Common_Tx()}
    set {_uniqueStorage()._outTxs = newValue}
  }
  /// Returns true if `outTxs` has been explicitly set.
  var hasOutTxs: Bool {return _storage._outTxs != nil}
  /// Clears the value of `outTxs`. Subsequent reads from it will return its default value.
  mutating func clearOutTxs() {_uniqueStorage()._outTxs = nil}

  var emitAsset: Common_Coin {
    get {return _storage._emitAsset ?? Common_Coin()}
    set {_uniqueStorage()._emitAsset = newValue}
  }
  /// Returns true if `emitAsset` has been explicitly set.
  var hasEmitAsset: Bool {return _storage._emitAsset != nil}
  /// Clears the value of `emitAsset`. Subsequent reads from it will return its default value.
  mutating func clearEmitAsset() {_uniqueStorage()._emitAsset = nil}

  var synthUnits: String {
    get {return _storage._synthUnits}
    set {_uniqueStorage()._synthUnits = newValue}
  }

  var streamingSwapQuantity: UInt64 {
    get {return _storage._streamingSwapQuantity}
    set {_uniqueStorage()._streamingSwapQuantity = newValue}
  }

  var streamingSwapCount: UInt64 {
    get {return _storage._streamingSwapCount}
    set {_uniqueStorage()._streamingSwapCount = newValue}
  }

  var poolSlip: String {
    get {return _storage._poolSlip}
    set {_uniqueStorage()._poolSlip = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_EventAddLiquidity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pool: Common_Asset {
    get {return _pool ?? Common_Asset()}
    set {_pool = newValue}
  }
  /// Returns true if `pool` has been explicitly set.
  var hasPool: Bool {return self._pool != nil}
  /// Clears the value of `pool`. Subsequent reads from it will return its default value.
  mutating func clearPool() {self._pool = nil}

  var providerUnits: String = String()

  var runeAddress: String = String()

  var runeAmount: String = String()

  var assetAmount: String = String()

  var runeTxID: String = String()

  var assetTxID: String = String()

  var assetAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pool: Common_Asset? = nil
}

struct Types_EventWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pool: Common_Asset {
    get {return _storage._pool ?? Common_Asset()}
    set {_uniqueStorage()._pool = newValue}
  }
  /// Returns true if `pool` has been explicitly set.
  var hasPool: Bool {return _storage._pool != nil}
  /// Clears the value of `pool`. Subsequent reads from it will return its default value.
  mutating func clearPool() {_uniqueStorage()._pool = nil}

  var providerUnits: String {
    get {return _storage._providerUnits}
    set {_uniqueStorage()._providerUnits = newValue}
  }

  var basisPoints: Int64 {
    get {return _storage._basisPoints}
    set {_uniqueStorage()._basisPoints = newValue}
  }

  var asymmetry: Data {
    get {return _storage._asymmetry}
    set {_uniqueStorage()._asymmetry = newValue}
  }

  var inTx: Common_Tx {
    get {return _storage._inTx ?? Common_Tx()}
    set {_uniqueStorage()._inTx = newValue}
  }
  /// Returns true if `inTx` has been explicitly set.
  var hasInTx: Bool {return _storage._inTx != nil}
  /// Clears the value of `inTx`. Subsequent reads from it will return its default value.
  mutating func clearInTx() {_uniqueStorage()._inTx = nil}

  var emitAsset: String {
    get {return _storage._emitAsset}
    set {_uniqueStorage()._emitAsset = newValue}
  }

  var emitRune: String {
    get {return _storage._emitRune}
    set {_uniqueStorage()._emitRune = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_EventPendingLiquidity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pool: Common_Asset {
    get {return _pool ?? Common_Asset()}
    set {_pool = newValue}
  }
  /// Returns true if `pool` has been explicitly set.
  var hasPool: Bool {return self._pool != nil}
  /// Clears the value of `pool`. Subsequent reads from it will return its default value.
  mutating func clearPool() {self._pool = nil}

  var pendingType: Types_PendingLiquidityType = .add

  var runeAddress: String = String()

  var runeAmount: String = String()

  var assetAddress: String = String()

  var assetAmount: String = String()

  var runeTxID: String = String()

  var assetTxID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pool: Common_Asset? = nil
}

struct Types_EventDonate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pool: Common_Asset {
    get {return _pool ?? Common_Asset()}
    set {_pool = newValue}
  }
  /// Returns true if `pool` has been explicitly set.
  var hasPool: Bool {return self._pool != nil}
  /// Clears the value of `pool`. Subsequent reads from it will return its default value.
  mutating func clearPool() {self._pool = nil}

  var inTx: Common_Tx {
    get {return _inTx ?? Common_Tx()}
    set {_inTx = newValue}
  }
  /// Returns true if `inTx` has been explicitly set.
  var hasInTx: Bool {return self._inTx != nil}
  /// Clears the value of `inTx`. Subsequent reads from it will return its default value.
  mutating func clearInTx() {self._inTx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pool: Common_Asset? = nil
  fileprivate var _inTx: Common_Tx? = nil
}

struct Types_EventPool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pool: Common_Asset {
    get {return _pool ?? Common_Asset()}
    set {_pool = newValue}
  }
  /// Returns true if `pool` has been explicitly set.
  var hasPool: Bool {return self._pool != nil}
  /// Clears the value of `pool`. Subsequent reads from it will return its default value.
  mutating func clearPool() {self._pool = nil}

  var status: Types_PoolStatus = .unknownPoolStatus

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pool: Common_Asset? = nil
}

struct Types_PoolAmt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var asset: Common_Asset {
    get {return _asset ?? Common_Asset()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var amount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Common_Asset? = nil
}

struct Types_EventRewards {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondReward: String = String()

  var poolRewards: [Types_PoolAmt] = []

  var devFundReward: String = String()

  var incomeBurn: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventRefund {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt32 = 0

  var reason: String = String()

  var inTx: Common_Tx {
    get {return _inTx ?? Common_Tx()}
    set {_inTx = newValue}
  }
  /// Returns true if `inTx` has been explicitly set.
  var hasInTx: Bool {return self._inTx != nil}
  /// Clears the value of `inTx`. Subsequent reads from it will return its default value.
  mutating func clearInTx() {self._inTx = nil}

  var fee: Common_Fee {
    get {return _fee ?? Common_Fee()}
    set {_fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  var hasFee: Bool {return self._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  mutating func clearFee() {self._fee = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _inTx: Common_Tx? = nil
  fileprivate var _fee: Common_Fee? = nil
}

struct Types_EventBond {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: String = String()

  var bondType: Types_BondType = .bondPaid

  var txIn: Common_Tx {
    get {return _txIn ?? Common_Tx()}
    set {_txIn = newValue}
  }
  /// Returns true if `txIn` has been explicitly set.
  var hasTxIn: Bool {return self._txIn != nil}
  /// Clears the value of `txIn`. Subsequent reads from it will return its default value.
  mutating func clearTxIn() {self._txIn = nil}

  var nodeAddress: Data = Data()

  var bondAddress: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _txIn: Common_Tx? = nil
}

struct Types_GasPool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var asset: Common_Asset {
    get {return _asset ?? Common_Asset()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var runeAmt: String = String()

  var assetAmt: String = String()

  var count: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Common_Asset? = nil
}

struct Types_EventGas {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pools: [Types_GasPool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventReserve {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reserveContributor: Types_ReserveContributor {
    get {return _reserveContributor ?? Types_ReserveContributor()}
    set {_reserveContributor = newValue}
  }
  /// Returns true if `reserveContributor` has been explicitly set.
  var hasReserveContributor: Bool {return self._reserveContributor != nil}
  /// Clears the value of `reserveContributor`. Subsequent reads from it will return its default value.
  mutating func clearReserveContributor() {self._reserveContributor = nil}

  var inTx: Common_Tx {
    get {return _inTx ?? Common_Tx()}
    set {_inTx = newValue}
  }
  /// Returns true if `inTx` has been explicitly set.
  var hasInTx: Bool {return self._inTx != nil}
  /// Clears the value of `inTx`. Subsequent reads from it will return its default value.
  mutating func clearInTx() {self._inTx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _reserveContributor: Types_ReserveContributor? = nil
  fileprivate var _inTx: Common_Tx? = nil
}

struct Types_EventScheduledOutbound {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var outTx: Types_TxOutItem {
    get {return _outTx ?? Types_TxOutItem()}
    set {_outTx = newValue}
  }
  /// Returns true if `outTx` has been explicitly set.
  var hasOutTx: Bool {return self._outTx != nil}
  /// Clears the value of `outTx`. Subsequent reads from it will return its default value.
  mutating func clearOutTx() {self._outTx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outTx: Types_TxOutItem? = nil
}

struct Types_EventSecurity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: String = String()

  var tx: Common_Tx {
    get {return _tx ?? Common_Tx()}
    set {_tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  var hasTx: Bool {return self._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  mutating func clearTx() {self._tx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tx: Common_Tx? = nil
}

struct Types_EventSlash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pool: Common_Asset {
    get {return _pool ?? Common_Asset()}
    set {_pool = newValue}
  }
  /// Returns true if `pool` has been explicitly set.
  var hasPool: Bool {return self._pool != nil}
  /// Clears the value of `pool`. Subsequent reads from it will return its default value.
  mutating func clearPool() {self._pool = nil}

  var slashAmount: [Types_PoolAmt] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pool: Common_Asset? = nil
}

struct Types_EventErrata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: String = String()

  var pools: [Types_PoolMod] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventFee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: String = String()

  var fee: Common_Fee {
    get {return _fee ?? Common_Fee()}
    set {_fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  var hasFee: Bool {return self._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  mutating func clearFee() {self._fee = nil}

  var synthUnits: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fee: Common_Fee? = nil
}

struct Types_EventOutbound {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inTxID: String = String()

  var tx: Common_Tx {
    get {return _tx ?? Common_Tx()}
    set {_tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  var hasTx: Bool {return self._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  mutating func clearTx() {self._tx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tx: Common_Tx? = nil
}

struct Types_EventTssKeygenSuccess {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pubKey: String = String()

  var members: [String] = []

  var height: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventTssKeygenFailure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var failReason: String = String()

  var isUnicast: Bool = false

  var blameNodes: [String] = []

  var round: String = String()

  var height: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventTssKeygenMetric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pubKey: String = String()

  var medianDurationMs: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventTssKeysignMetric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: String = String()

  var medianDurationMs: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventSlashPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeAddress: Data = Data()

  var slashPoints: Int64 = 0

  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventPoolBalanceChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolChange: Types_PoolMod {
    get {return _poolChange ?? Types_PoolMod()}
    set {_poolChange = newValue}
  }
  /// Returns true if `poolChange` has been explicitly set.
  var hasPoolChange: Bool {return self._poolChange != nil}
  /// Clears the value of `poolChange`. Subsequent reads from it will return its default value.
  mutating func clearPoolChange() {self._poolChange = nil}

  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _poolChange: Types_PoolMod? = nil
}

struct Types_EventMintBurn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var supply: Types_MintBurnSupplyType = .mint

  var denom: String = String()

  var amount: String = String()

  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventTradeAccountDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: String = String()

  var asset: Common_Asset {
    get {return _asset ?? Common_Asset()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var assetAddress: String = String()

  var runeAddress: String = String()

  var txID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Common_Asset? = nil
}

struct Types_EventTradeAccountWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: String = String()

  var asset: Common_Asset {
    get {return _asset ?? Common_Asset()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var assetAddress: String = String()

  var runeAddress: String = String()

  var txID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Common_Asset? = nil
}

struct Types_EventRUNEPoolDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var runeAddress: Data = Data()

  var runeAmount: String = String()

  var units: String = String()

  var txID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventRUNEPoolWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var runeAddress: Data = Data()

  var basisPoints: Int64 = 0

  var runeAmount: String = String()

  var units: String = String()

  var txID: String = String()

  var affiliateBasisPts: Int64 = 0

  var affiliateAmount: String = String()

  var affiliateAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventLoanOpen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var collateralDeposited: String = String()

  var collateralAsset: Common_Asset {
    get {return _collateralAsset ?? Common_Asset()}
    set {_collateralAsset = newValue}
  }
  /// Returns true if `collateralAsset` has been explicitly set.
  var hasCollateralAsset: Bool {return self._collateralAsset != nil}
  /// Clears the value of `collateralAsset`. Subsequent reads from it will return its default value.
  mutating func clearCollateralAsset() {self._collateralAsset = nil}

  var collateralizationRatio: String = String()

  var debtIssued: String = String()

  var owner: String = String()

  var targetAsset: Common_Asset {
    get {return _targetAsset ?? Common_Asset()}
    set {_targetAsset = newValue}
  }
  /// Returns true if `targetAsset` has been explicitly set.
  var hasTargetAsset: Bool {return self._targetAsset != nil}
  /// Clears the value of `targetAsset`. Subsequent reads from it will return its default value.
  mutating func clearTargetAsset() {self._targetAsset = nil}

  var txID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _collateralAsset: Common_Asset? = nil
  fileprivate var _targetAsset: Common_Asset? = nil
}

struct Types_EventLoanRepayment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var collateralWithdrawn: String = String()

  var collateralAsset: Common_Asset {
    get {return _collateralAsset ?? Common_Asset()}
    set {_collateralAsset = newValue}
  }
  /// Returns true if `collateralAsset` has been explicitly set.
  var hasCollateralAsset: Bool {return self._collateralAsset != nil}
  /// Clears the value of `collateralAsset`. Subsequent reads from it will return its default value.
  mutating func clearCollateralAsset() {self._collateralAsset = nil}

  var debtRepaid: String = String()

  var owner: String = String()

  var txID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _collateralAsset: Common_Asset? = nil
}

struct Types_EventTHORName {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var chain: String = String()

  var address: String = String()

  var registrationFee: String = String()

  var fundAmt: String = String()

  var expire: Int64 = 0

  var owner: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventSetMimir {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventSetNodeMimir {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: String = String()

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_EventVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Types_PendingLiquidityType: @unchecked Sendable {}
extension Types_BondType: @unchecked Sendable {}
extension Types_MintBurnSupplyType: @unchecked Sendable {}
extension Types_PoolMod: @unchecked Sendable {}
extension Types_EventLimitOrder: @unchecked Sendable {}
extension Types_EventStreamingSwap: @unchecked Sendable {}
extension Types_EventSwap: @unchecked Sendable {}
extension Types_EventAddLiquidity: @unchecked Sendable {}
extension Types_EventWithdraw: @unchecked Sendable {}
extension Types_EventPendingLiquidity: @unchecked Sendable {}
extension Types_EventDonate: @unchecked Sendable {}
extension Types_EventPool: @unchecked Sendable {}
extension Types_PoolAmt: @unchecked Sendable {}
extension Types_EventRewards: @unchecked Sendable {}
extension Types_EventRefund: @unchecked Sendable {}
extension Types_EventBond: @unchecked Sendable {}
extension Types_GasPool: @unchecked Sendable {}
extension Types_EventGas: @unchecked Sendable {}
extension Types_EventReserve: @unchecked Sendable {}
extension Types_EventScheduledOutbound: @unchecked Sendable {}
extension Types_EventSecurity: @unchecked Sendable {}
extension Types_EventSlash: @unchecked Sendable {}
extension Types_EventErrata: @unchecked Sendable {}
extension Types_EventFee: @unchecked Sendable {}
extension Types_EventOutbound: @unchecked Sendable {}
extension Types_EventTssKeygenSuccess: @unchecked Sendable {}
extension Types_EventTssKeygenFailure: @unchecked Sendable {}
extension Types_EventTssKeygenMetric: @unchecked Sendable {}
extension Types_EventTssKeysignMetric: @unchecked Sendable {}
extension Types_EventSlashPoint: @unchecked Sendable {}
extension Types_EventPoolBalanceChanged: @unchecked Sendable {}
extension Types_EventMintBurn: @unchecked Sendable {}
extension Types_EventTradeAccountDeposit: @unchecked Sendable {}
extension Types_EventTradeAccountWithdraw: @unchecked Sendable {}
extension Types_EventRUNEPoolDeposit: @unchecked Sendable {}
extension Types_EventRUNEPoolWithdraw: @unchecked Sendable {}
extension Types_EventLoanOpen: @unchecked Sendable {}
extension Types_EventLoanRepayment: @unchecked Sendable {}
extension Types_EventTHORName: @unchecked Sendable {}
extension Types_EventSetMimir: @unchecked Sendable {}
extension Types_EventSetNodeMimir: @unchecked Sendable {}
extension Types_EventVersion: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "types"

extension Types_PendingLiquidityType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "add"),
    1: .same(proto: "withdraw"),
  ]
}

extension Types_BondType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "bond_paid"),
    1: .same(proto: "bond_returned"),
    2: .same(proto: "bond_reward"),
    3: .same(proto: "bond_cost"),
  ]
}

extension Types_MintBurnSupplyType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "mint"),
    1: .same(proto: "burn"),
  ]
}

extension Types_PoolMod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolMod"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asset"),
    2: .standard(proto: "rune_amt"),
    3: .standard(proto: "rune_add"),
    4: .standard(proto: "asset_amt"),
    5: .standard(proto: "asset_add"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runeAmt) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.runeAdd) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.assetAmt) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.assetAdd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.runeAmt.isEmpty {
      try visitor.visitSingularStringField(value: self.runeAmt, fieldNumber: 2)
    }
    if self.runeAdd != false {
      try visitor.visitSingularBoolField(value: self.runeAdd, fieldNumber: 3)
    }
    if !self.assetAmt.isEmpty {
      try visitor.visitSingularStringField(value: self.assetAmt, fieldNumber: 4)
    }
    if self.assetAdd != false {
      try visitor.visitSingularBoolField(value: self.assetAdd, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PoolMod, rhs: Types_PoolMod) -> Bool {
    if lhs._asset != rhs._asset {return false}
    if lhs.runeAmt != rhs.runeAmt {return false}
    if lhs.runeAdd != rhs.runeAdd {return false}
    if lhs.assetAmt != rhs.assetAmt {return false}
    if lhs.assetAdd != rhs.assetAdd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "target"),
    3: .standard(proto: "tx_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._target) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.txID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.txID.isEmpty {
      try visitor.visitSingularStringField(value: self.txID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventLimitOrder, rhs: Types_EventLimitOrder) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs._target != rhs._target {return false}
    if lhs.txID != rhs.txID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventStreamingSwap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventStreamingSwap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .same(proto: "interval"),
    3: .same(proto: "quantity"),
    4: .same(proto: "count"),
    5: .standard(proto: "last_height"),
    6: .standard(proto: "trade_target"),
    7: .same(proto: "deposit"),
    8: .same(proto: "in"),
    9: .same(proto: "out"),
    10: .standard(proto: "failed_swaps"),
    11: .standard(proto: "failed_swap_reasons"),
  ]

  fileprivate class _StorageClass {
    var _txID: String = String()
    var _interval: UInt64 = 0
    var _quantity: UInt64 = 0
    var _count: UInt64 = 0
    var _lastHeight: Int64 = 0
    var _tradeTarget: String = String()
    var _deposit: Common_Coin? = nil
    var _in: Common_Coin? = nil
    var _out: Common_Coin? = nil
    var _failedSwaps: [UInt64] = []
    var _failedSwapReasons: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _txID = source._txID
      _interval = source._interval
      _quantity = source._quantity
      _count = source._count
      _lastHeight = source._lastHeight
      _tradeTarget = source._tradeTarget
      _deposit = source._deposit
      _in = source._in
      _out = source._out
      _failedSwaps = source._failedSwaps
      _failedSwapReasons = source._failedSwapReasons
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._txID) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._interval) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._quantity) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._count) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._lastHeight) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._tradeTarget) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._deposit) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._in) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._out) }()
        case 10: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._failedSwaps) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._failedSwapReasons) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._txID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._txID, fieldNumber: 1)
      }
      if _storage._interval != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._interval, fieldNumber: 2)
      }
      if _storage._quantity != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._quantity, fieldNumber: 3)
      }
      if _storage._count != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._count, fieldNumber: 4)
      }
      if _storage._lastHeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastHeight, fieldNumber: 5)
      }
      if !_storage._tradeTarget.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tradeTarget, fieldNumber: 6)
      }
      try { if let v = _storage._deposit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._in {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._out {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._failedSwaps.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._failedSwaps, fieldNumber: 10)
      }
      if !_storage._failedSwapReasons.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._failedSwapReasons, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventStreamingSwap, rhs: Types_EventStreamingSwap) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._txID != rhs_storage._txID {return false}
        if _storage._interval != rhs_storage._interval {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._count != rhs_storage._count {return false}
        if _storage._lastHeight != rhs_storage._lastHeight {return false}
        if _storage._tradeTarget != rhs_storage._tradeTarget {return false}
        if _storage._deposit != rhs_storage._deposit {return false}
        if _storage._in != rhs_storage._in {return false}
        if _storage._out != rhs_storage._out {return false}
        if _storage._failedSwaps != rhs_storage._failedSwaps {return false}
        if _storage._failedSwapReasons != rhs_storage._failedSwapReasons {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventSwap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSwap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
    2: .standard(proto: "swap_target"),
    3: .standard(proto: "swap_slip"),
    4: .standard(proto: "liquidity_fee"),
    5: .standard(proto: "liquidity_fee_in_rune"),
    6: .standard(proto: "in_tx"),
    7: .standard(proto: "out_txs"),
    8: .standard(proto: "emit_asset"),
    9: .standard(proto: "synth_units"),
    10: .standard(proto: "streaming_swap_quantity"),
    11: .standard(proto: "streaming_swap_count"),
    12: .standard(proto: "pool_slip"),
  ]

  fileprivate class _StorageClass {
    var _pool: Common_Asset? = nil
    var _swapTarget: String = String()
    var _swapSlip: String = String()
    var _liquidityFee: String = String()
    var _liquidityFeeInRune: String = String()
    var _inTx: Common_Tx? = nil
    var _outTxs: Common_Tx? = nil
    var _emitAsset: Common_Coin? = nil
    var _synthUnits: String = String()
    var _streamingSwapQuantity: UInt64 = 0
    var _streamingSwapCount: UInt64 = 0
    var _poolSlip: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pool = source._pool
      _swapTarget = source._swapTarget
      _swapSlip = source._swapSlip
      _liquidityFee = source._liquidityFee
      _liquidityFeeInRune = source._liquidityFeeInRune
      _inTx = source._inTx
      _outTxs = source._outTxs
      _emitAsset = source._emitAsset
      _synthUnits = source._synthUnits
      _streamingSwapQuantity = source._streamingSwapQuantity
      _streamingSwapCount = source._streamingSwapCount
      _poolSlip = source._poolSlip
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._pool) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._swapTarget) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._swapSlip) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._liquidityFee) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._liquidityFeeInRune) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._inTx) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._outTxs) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._emitAsset) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._synthUnits) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._streamingSwapQuantity) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._streamingSwapCount) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._poolSlip) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._pool {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._swapTarget.isEmpty {
        try visitor.visitSingularStringField(value: _storage._swapTarget, fieldNumber: 2)
      }
      if !_storage._swapSlip.isEmpty {
        try visitor.visitSingularStringField(value: _storage._swapSlip, fieldNumber: 3)
      }
      if !_storage._liquidityFee.isEmpty {
        try visitor.visitSingularStringField(value: _storage._liquidityFee, fieldNumber: 4)
      }
      if !_storage._liquidityFeeInRune.isEmpty {
        try visitor.visitSingularStringField(value: _storage._liquidityFeeInRune, fieldNumber: 5)
      }
      try { if let v = _storage._inTx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._outTxs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._emitAsset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._synthUnits.isEmpty {
        try visitor.visitSingularStringField(value: _storage._synthUnits, fieldNumber: 9)
      }
      if _storage._streamingSwapQuantity != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._streamingSwapQuantity, fieldNumber: 10)
      }
      if _storage._streamingSwapCount != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._streamingSwapCount, fieldNumber: 11)
      }
      if !_storage._poolSlip.isEmpty {
        try visitor.visitSingularStringField(value: _storage._poolSlip, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventSwap, rhs: Types_EventSwap) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pool != rhs_storage._pool {return false}
        if _storage._swapTarget != rhs_storage._swapTarget {return false}
        if _storage._swapSlip != rhs_storage._swapSlip {return false}
        if _storage._liquidityFee != rhs_storage._liquidityFee {return false}
        if _storage._liquidityFeeInRune != rhs_storage._liquidityFeeInRune {return false}
        if _storage._inTx != rhs_storage._inTx {return false}
        if _storage._outTxs != rhs_storage._outTxs {return false}
        if _storage._emitAsset != rhs_storage._emitAsset {return false}
        if _storage._synthUnits != rhs_storage._synthUnits {return false}
        if _storage._streamingSwapQuantity != rhs_storage._streamingSwapQuantity {return false}
        if _storage._streamingSwapCount != rhs_storage._streamingSwapCount {return false}
        if _storage._poolSlip != rhs_storage._poolSlip {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventAddLiquidity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventAddLiquidity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
    2: .standard(proto: "provider_units"),
    3: .standard(proto: "rune_address"),
    4: .standard(proto: "rune_amount"),
    5: .standard(proto: "asset_amount"),
    6: .standard(proto: "rune_tx_id"),
    7: .standard(proto: "asset_tx_id"),
    8: .standard(proto: "asset_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pool) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.providerUnits) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runeAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.runeAmount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.assetAmount) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.runeTxID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.assetTxID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.assetAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.providerUnits.isEmpty {
      try visitor.visitSingularStringField(value: self.providerUnits, fieldNumber: 2)
    }
    if !self.runeAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.runeAddress, fieldNumber: 3)
    }
    if !self.runeAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.runeAmount, fieldNumber: 4)
    }
    if !self.assetAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.assetAmount, fieldNumber: 5)
    }
    if !self.runeTxID.isEmpty {
      try visitor.visitSingularStringField(value: self.runeTxID, fieldNumber: 6)
    }
    if !self.assetTxID.isEmpty {
      try visitor.visitSingularStringField(value: self.assetTxID, fieldNumber: 7)
    }
    if !self.assetAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.assetAddress, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventAddLiquidity, rhs: Types_EventAddLiquidity) -> Bool {
    if lhs._pool != rhs._pool {return false}
    if lhs.providerUnits != rhs.providerUnits {return false}
    if lhs.runeAddress != rhs.runeAddress {return false}
    if lhs.runeAmount != rhs.runeAmount {return false}
    if lhs.assetAmount != rhs.assetAmount {return false}
    if lhs.runeTxID != rhs.runeTxID {return false}
    if lhs.assetTxID != rhs.assetTxID {return false}
    if lhs.assetAddress != rhs.assetAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
    2: .standard(proto: "provider_units"),
    3: .standard(proto: "basis_points"),
    4: .same(proto: "asymmetry"),
    5: .standard(proto: "in_tx"),
    6: .standard(proto: "emit_asset"),
    7: .standard(proto: "emit_rune"),
  ]

  fileprivate class _StorageClass {
    var _pool: Common_Asset? = nil
    var _providerUnits: String = String()
    var _basisPoints: Int64 = 0
    var _asymmetry: Data = Data()
    var _inTx: Common_Tx? = nil
    var _emitAsset: String = String()
    var _emitRune: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pool = source._pool
      _providerUnits = source._providerUnits
      _basisPoints = source._basisPoints
      _asymmetry = source._asymmetry
      _inTx = source._inTx
      _emitAsset = source._emitAsset
      _emitRune = source._emitRune
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._pool) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._providerUnits) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._basisPoints) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._asymmetry) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._inTx) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._emitAsset) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._emitRune) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._pool {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._providerUnits.isEmpty {
        try visitor.visitSingularStringField(value: _storage._providerUnits, fieldNumber: 2)
      }
      if _storage._basisPoints != 0 {
        try visitor.visitSingularInt64Field(value: _storage._basisPoints, fieldNumber: 3)
      }
      if !_storage._asymmetry.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._asymmetry, fieldNumber: 4)
      }
      try { if let v = _storage._inTx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._emitAsset.isEmpty {
        try visitor.visitSingularStringField(value: _storage._emitAsset, fieldNumber: 6)
      }
      if !_storage._emitRune.isEmpty {
        try visitor.visitSingularStringField(value: _storage._emitRune, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventWithdraw, rhs: Types_EventWithdraw) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pool != rhs_storage._pool {return false}
        if _storage._providerUnits != rhs_storage._providerUnits {return false}
        if _storage._basisPoints != rhs_storage._basisPoints {return false}
        if _storage._asymmetry != rhs_storage._asymmetry {return false}
        if _storage._inTx != rhs_storage._inTx {return false}
        if _storage._emitAsset != rhs_storage._emitAsset {return false}
        if _storage._emitRune != rhs_storage._emitRune {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventPendingLiquidity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventPendingLiquidity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
    2: .standard(proto: "pending_type"),
    3: .standard(proto: "rune_address"),
    4: .standard(proto: "rune_amount"),
    5: .standard(proto: "asset_address"),
    6: .standard(proto: "asset_amount"),
    7: .standard(proto: "rune_tx_id"),
    8: .standard(proto: "asset_tx_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pool) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.pendingType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runeAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.runeAmount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.assetAddress) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.assetAmount) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.runeTxID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.assetTxID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.pendingType != .add {
      try visitor.visitSingularEnumField(value: self.pendingType, fieldNumber: 2)
    }
    if !self.runeAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.runeAddress, fieldNumber: 3)
    }
    if !self.runeAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.runeAmount, fieldNumber: 4)
    }
    if !self.assetAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.assetAddress, fieldNumber: 5)
    }
    if !self.assetAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.assetAmount, fieldNumber: 6)
    }
    if !self.runeTxID.isEmpty {
      try visitor.visitSingularStringField(value: self.runeTxID, fieldNumber: 7)
    }
    if !self.assetTxID.isEmpty {
      try visitor.visitSingularStringField(value: self.assetTxID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventPendingLiquidity, rhs: Types_EventPendingLiquidity) -> Bool {
    if lhs._pool != rhs._pool {return false}
    if lhs.pendingType != rhs.pendingType {return false}
    if lhs.runeAddress != rhs.runeAddress {return false}
    if lhs.runeAmount != rhs.runeAmount {return false}
    if lhs.assetAddress != rhs.assetAddress {return false}
    if lhs.assetAmount != rhs.assetAmount {return false}
    if lhs.runeTxID != rhs.runeTxID {return false}
    if lhs.assetTxID != rhs.assetTxID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventDonate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventDonate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
    2: .standard(proto: "in_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pool) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventDonate, rhs: Types_EventDonate) -> Bool {
    if lhs._pool != rhs._pool {return false}
    if lhs._inTx != rhs._inTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventPool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventPool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
    2: .same(proto: "Status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pool) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.status != .unknownPoolStatus {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventPool, rhs: Types_EventPool) -> Bool {
    if lhs._pool != rhs._pool {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PoolAmt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolAmt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asset"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PoolAmt, rhs: Types_PoolAmt) -> Bool {
    if lhs._asset != rhs._asset {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_reward"),
    2: .standard(proto: "pool_rewards"),
    3: .standard(proto: "dev_fund_reward"),
    4: .standard(proto: "income_burn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondReward) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.poolRewards) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.devFundReward) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.incomeBurn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondReward.isEmpty {
      try visitor.visitSingularStringField(value: self.bondReward, fieldNumber: 1)
    }
    if !self.poolRewards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.poolRewards, fieldNumber: 2)
    }
    if !self.devFundReward.isEmpty {
      try visitor.visitSingularStringField(value: self.devFundReward, fieldNumber: 3)
    }
    if !self.incomeBurn.isEmpty {
      try visitor.visitSingularStringField(value: self.incomeBurn, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventRewards, rhs: Types_EventRewards) -> Bool {
    if lhs.bondReward != rhs.bondReward {return false}
    if lhs.poolRewards != rhs.poolRewards {return false}
    if lhs.devFundReward != rhs.devFundReward {return false}
    if lhs.incomeBurn != rhs.incomeBurn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventRefund: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventRefund"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "reason"),
    3: .standard(proto: "in_tx"),
    4: .same(proto: "fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._inTx) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._fee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try { if let v = self._inTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._fee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventRefund, rhs: Types_EventRefund) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._inTx != rhs._inTx {return false}
    if lhs._fee != rhs._fee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventBond: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBond"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .standard(proto: "bond_type"),
    3: .standard(proto: "tx_in"),
    4: .standard(proto: "node_address"),
    5: .standard(proto: "bond_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.bondType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._txIn) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.nodeAddress) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.bondAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    if self.bondType != .bondPaid {
      try visitor.visitSingularEnumField(value: self.bondType, fieldNumber: 2)
    }
    try { if let v = self._txIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.nodeAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeAddress, fieldNumber: 4)
    }
    if !self.bondAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.bondAddress, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventBond, rhs: Types_EventBond) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.bondType != rhs.bondType {return false}
    if lhs._txIn != rhs._txIn {return false}
    if lhs.nodeAddress != rhs.nodeAddress {return false}
    if lhs.bondAddress != rhs.bondAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_GasPool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GasPool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asset"),
    2: .standard(proto: "rune_amt"),
    3: .standard(proto: "asset_amt"),
    4: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runeAmt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.assetAmt) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.runeAmt.isEmpty {
      try visitor.visitSingularStringField(value: self.runeAmt, fieldNumber: 2)
    }
    if !self.assetAmt.isEmpty {
      try visitor.visitSingularStringField(value: self.assetAmt, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_GasPool, rhs: Types_GasPool) -> Bool {
    if lhs._asset != rhs._asset {return false}
    if lhs.runeAmt != rhs.runeAmt {return false}
    if lhs.assetAmt != rhs.assetAmt {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventGas: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventGas"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pools"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pools) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pools, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventGas, rhs: Types_EventGas) -> Bool {
    if lhs.pools != rhs.pools {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventReserve: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventReserve"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reserve_contributor"),
    2: .standard(proto: "in_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._reserveContributor) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._reserveContributor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventReserve, rhs: Types_EventReserve) -> Bool {
    if lhs._reserveContributor != rhs._reserveContributor {return false}
    if lhs._inTx != rhs._inTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventScheduledOutbound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventScheduledOutbound"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "out_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventScheduledOutbound, rhs: Types_EventScheduledOutbound) -> Bool {
    if lhs._outTx != rhs._outTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventSecurity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSecurity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 1)
    }
    try { if let v = self._tx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventSecurity, rhs: Types_EventSecurity) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs._tx != rhs._tx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventSlash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSlash"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
    2: .standard(proto: "slash_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pool) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.slashAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.slashAmount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slashAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventSlash, rhs: Types_EventSlash) -> Bool {
    if lhs._pool != rhs._pool {return false}
    if lhs.slashAmount != rhs.slashAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventErrata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventErrata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .same(proto: "pools"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pools) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitSingularStringField(value: self.txID, fieldNumber: 1)
    }
    if !self.pools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pools, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventErrata, rhs: Types_EventErrata) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.pools != rhs.pools {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventFee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventFee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .same(proto: "fee"),
    3: .standard(proto: "synth_units"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fee) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.synthUnits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.txID.isEmpty {
      try visitor.visitSingularStringField(value: self.txID, fieldNumber: 1)
    }
    try { if let v = self._fee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.synthUnits.isEmpty {
      try visitor.visitSingularStringField(value: self.synthUnits, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventFee, rhs: Types_EventFee) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs._fee != rhs._fee {return false}
    if lhs.synthUnits != rhs.synthUnits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventOutbound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventOutbound"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "in_tx_id"),
    2: .same(proto: "tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.inTxID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.inTxID.isEmpty {
      try visitor.visitSingularStringField(value: self.inTxID, fieldNumber: 1)
    }
    try { if let v = self._tx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventOutbound, rhs: Types_EventOutbound) -> Bool {
    if lhs.inTxID != rhs.inTxID {return false}
    if lhs._tx != rhs._tx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventTssKeygenSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTssKeygenSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "members"),
    3: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.members) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedStringField(value: self.members, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventTssKeygenSuccess, rhs: Types_EventTssKeygenSuccess) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.members != rhs.members {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventTssKeygenFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTssKeygenFailure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fail_reason"),
    2: .standard(proto: "is_unicast"),
    3: .standard(proto: "blame_nodes"),
    4: .same(proto: "round"),
    5: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.failReason) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isUnicast) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.blameNodes) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.round) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.failReason.isEmpty {
      try visitor.visitSingularStringField(value: self.failReason, fieldNumber: 1)
    }
    if self.isUnicast != false {
      try visitor.visitSingularBoolField(value: self.isUnicast, fieldNumber: 2)
    }
    if !self.blameNodes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blameNodes, fieldNumber: 3)
    }
    if !self.round.isEmpty {
      try visitor.visitSingularStringField(value: self.round, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventTssKeygenFailure, rhs: Types_EventTssKeygenFailure) -> Bool {
    if lhs.failReason != rhs.failReason {return false}
    if lhs.isUnicast != rhs.isUnicast {return false}
    if lhs.blameNodes != rhs.blameNodes {return false}
    if lhs.round != rhs.round {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventTssKeygenMetric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTssKeygenMetric"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .standard(proto: "median_duration_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubKey) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.medianDurationMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if self.medianDurationMs != 0 {
      try visitor.visitSingularInt64Field(value: self.medianDurationMs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventTssKeygenMetric, rhs: Types_EventTssKeygenMetric) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.medianDurationMs != rhs.medianDurationMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventTssKeysignMetric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTssKeysignMetric"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .standard(proto: "median_duration_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.medianDurationMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitSingularStringField(value: self.txID, fieldNumber: 1)
    }
    if self.medianDurationMs != 0 {
      try visitor.visitSingularInt64Field(value: self.medianDurationMs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventTssKeysignMetric, rhs: Types_EventTssKeysignMetric) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.medianDurationMs != rhs.medianDurationMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventSlashPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSlashPoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_address"),
    2: .standard(proto: "slash_points"),
    3: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nodeAddress) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.slashPoints) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeAddress, fieldNumber: 1)
    }
    if self.slashPoints != 0 {
      try visitor.visitSingularInt64Field(value: self.slashPoints, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventSlashPoint, rhs: Types_EventSlashPoint) -> Bool {
    if lhs.nodeAddress != rhs.nodeAddress {return false}
    if lhs.slashPoints != rhs.slashPoints {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventPoolBalanceChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventPoolBalanceChanged"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_change"),
    2: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._poolChange) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._poolChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventPoolBalanceChanged, rhs: Types_EventPoolBalanceChanged) -> Bool {
    if lhs._poolChange != rhs._poolChange {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventMintBurn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMintBurn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "supply"),
    2: .same(proto: "denom"),
    3: .same(proto: "amount"),
    4: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.supply) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.supply != .mint {
      try visitor.visitSingularEnumField(value: self.supply, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventMintBurn, rhs: Types_EventMintBurn) -> Bool {
    if lhs.supply != rhs.supply {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventTradeAccountDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTradeAccountDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "asset"),
    3: .standard(proto: "asset_address"),
    4: .standard(proto: "rune_address"),
    5: .standard(proto: "tx_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.assetAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.runeAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.txID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.assetAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.assetAddress, fieldNumber: 3)
    }
    if !self.runeAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.runeAddress, fieldNumber: 4)
    }
    if !self.txID.isEmpty {
      try visitor.visitSingularStringField(value: self.txID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventTradeAccountDeposit, rhs: Types_EventTradeAccountDeposit) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.assetAddress != rhs.assetAddress {return false}
    if lhs.runeAddress != rhs.runeAddress {return false}
    if lhs.txID != rhs.txID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventTradeAccountWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTradeAccountWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "asset"),
    3: .standard(proto: "asset_address"),
    4: .standard(proto: "rune_address"),
    5: .standard(proto: "tx_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.assetAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.runeAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.txID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.assetAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.assetAddress, fieldNumber: 3)
    }
    if !self.runeAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.runeAddress, fieldNumber: 4)
    }
    if !self.txID.isEmpty {
      try visitor.visitSingularStringField(value: self.txID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventTradeAccountWithdraw, rhs: Types_EventTradeAccountWithdraw) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.assetAddress != rhs.assetAddress {return false}
    if lhs.runeAddress != rhs.runeAddress {return false}
    if lhs.txID != rhs.txID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventRUNEPoolDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventRUNEPoolDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rune_address"),
    2: .standard(proto: "rune_amount"),
    3: .same(proto: "units"),
    4: .standard(proto: "tx_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.runeAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runeAmount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.units) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.txID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.runeAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.runeAddress, fieldNumber: 1)
    }
    if !self.runeAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.runeAmount, fieldNumber: 2)
    }
    if !self.units.isEmpty {
      try visitor.visitSingularStringField(value: self.units, fieldNumber: 3)
    }
    if !self.txID.isEmpty {
      try visitor.visitSingularStringField(value: self.txID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventRUNEPoolDeposit, rhs: Types_EventRUNEPoolDeposit) -> Bool {
    if lhs.runeAddress != rhs.runeAddress {return false}
    if lhs.runeAmount != rhs.runeAmount {return false}
    if lhs.units != rhs.units {return false}
    if lhs.txID != rhs.txID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventRUNEPoolWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventRUNEPoolWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rune_address"),
    2: .standard(proto: "basis_points"),
    3: .standard(proto: "rune_amount"),
    4: .same(proto: "units"),
    5: .standard(proto: "tx_id"),
    6: .standard(proto: "affiliate_basis_pts"),
    7: .standard(proto: "affiliate_amount"),
    8: .standard(proto: "affiliate_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.runeAddress) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.basisPoints) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runeAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.units) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.txID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.affiliateBasisPts) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.affiliateAmount) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.affiliateAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.runeAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.runeAddress, fieldNumber: 1)
    }
    if self.basisPoints != 0 {
      try visitor.visitSingularInt64Field(value: self.basisPoints, fieldNumber: 2)
    }
    if !self.runeAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.runeAmount, fieldNumber: 3)
    }
    if !self.units.isEmpty {
      try visitor.visitSingularStringField(value: self.units, fieldNumber: 4)
    }
    if !self.txID.isEmpty {
      try visitor.visitSingularStringField(value: self.txID, fieldNumber: 5)
    }
    if self.affiliateBasisPts != 0 {
      try visitor.visitSingularInt64Field(value: self.affiliateBasisPts, fieldNumber: 6)
    }
    if !self.affiliateAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.affiliateAmount, fieldNumber: 7)
    }
    if !self.affiliateAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.affiliateAddress, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventRUNEPoolWithdraw, rhs: Types_EventRUNEPoolWithdraw) -> Bool {
    if lhs.runeAddress != rhs.runeAddress {return false}
    if lhs.basisPoints != rhs.basisPoints {return false}
    if lhs.runeAmount != rhs.runeAmount {return false}
    if lhs.units != rhs.units {return false}
    if lhs.txID != rhs.txID {return false}
    if lhs.affiliateBasisPts != rhs.affiliateBasisPts {return false}
    if lhs.affiliateAmount != rhs.affiliateAmount {return false}
    if lhs.affiliateAddress != rhs.affiliateAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventLoanOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventLoanOpen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collateral_deposited"),
    2: .standard(proto: "collateral_asset"),
    3: .standard(proto: "collateralization_ratio"),
    4: .standard(proto: "debt_issued"),
    5: .same(proto: "owner"),
    6: .standard(proto: "target_asset"),
    7: .standard(proto: "tx_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collateralDeposited) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._collateralAsset) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.collateralizationRatio) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.debtIssued) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._targetAsset) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.txID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collateralDeposited.isEmpty {
      try visitor.visitSingularStringField(value: self.collateralDeposited, fieldNumber: 1)
    }
    try { if let v = self._collateralAsset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.collateralizationRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.collateralizationRatio, fieldNumber: 3)
    }
    if !self.debtIssued.isEmpty {
      try visitor.visitSingularStringField(value: self.debtIssued, fieldNumber: 4)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 5)
    }
    try { if let v = self._targetAsset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.txID.isEmpty {
      try visitor.visitSingularStringField(value: self.txID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventLoanOpen, rhs: Types_EventLoanOpen) -> Bool {
    if lhs.collateralDeposited != rhs.collateralDeposited {return false}
    if lhs._collateralAsset != rhs._collateralAsset {return false}
    if lhs.collateralizationRatio != rhs.collateralizationRatio {return false}
    if lhs.debtIssued != rhs.debtIssued {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs._targetAsset != rhs._targetAsset {return false}
    if lhs.txID != rhs.txID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventLoanRepayment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventLoanRepayment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collateral_withdrawn"),
    2: .standard(proto: "collateral_asset"),
    3: .standard(proto: "debt_repaid"),
    4: .same(proto: "owner"),
    7: .standard(proto: "tx_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collateralWithdrawn) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._collateralAsset) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.debtRepaid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.txID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collateralWithdrawn.isEmpty {
      try visitor.visitSingularStringField(value: self.collateralWithdrawn, fieldNumber: 1)
    }
    try { if let v = self._collateralAsset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.debtRepaid.isEmpty {
      try visitor.visitSingularStringField(value: self.debtRepaid, fieldNumber: 3)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 4)
    }
    if !self.txID.isEmpty {
      try visitor.visitSingularStringField(value: self.txID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventLoanRepayment, rhs: Types_EventLoanRepayment) -> Bool {
    if lhs.collateralWithdrawn != rhs.collateralWithdrawn {return false}
    if lhs._collateralAsset != rhs._collateralAsset {return false}
    if lhs.debtRepaid != rhs.debtRepaid {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.txID != rhs.txID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventTHORName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTHORName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "chain"),
    3: .same(proto: "address"),
    4: .standard(proto: "registration_fee"),
    5: .standard(proto: "fund_amt"),
    6: .same(proto: "expire"),
    7: .same(proto: "owner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.registrationFee) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fundAmt) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.expire) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.owner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 2)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    if !self.registrationFee.isEmpty {
      try visitor.visitSingularStringField(value: self.registrationFee, fieldNumber: 4)
    }
    if !self.fundAmt.isEmpty {
      try visitor.visitSingularStringField(value: self.fundAmt, fieldNumber: 5)
    }
    if self.expire != 0 {
      try visitor.visitSingularInt64Field(value: self.expire, fieldNumber: 6)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularBytesField(value: self.owner, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventTHORName, rhs: Types_EventTHORName) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.address != rhs.address {return false}
    if lhs.registrationFee != rhs.registrationFee {return false}
    if lhs.fundAmt != rhs.fundAmt {return false}
    if lhs.expire != rhs.expire {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventSetMimir: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSetMimir"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventSetMimir, rhs: Types_EventSetMimir) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventSetNodeMimir: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSetNodeMimir"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventSetNodeMimir, rhs: Types_EventSetNodeMimir) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_EventVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventVersion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_EventVersion, rhs: Types_EventVersion) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
