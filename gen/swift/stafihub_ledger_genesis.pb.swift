// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: stafihub/ledger/genesis.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// GenesisState defines the ledger module's genesis state.
struct Stafihub_Stafihub_Ledger_GenesisState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var exchangeRateList: [Stafihub_Stafihub_Ledger_ExchangeRate] {
    get {return _storage._exchangeRateList}
    set {_uniqueStorage()._exchangeRateList = newValue}
  }

  var eraExchangeRateList: [Stafihub_Stafihub_Ledger_EraExchangeRate] {
    get {return _storage._eraExchangeRateList}
    set {_uniqueStorage()._eraExchangeRateList = newValue}
  }

  var totalProtocolFeeList: [Stafihub_Stafihub_Ledger_TotalProtocolFee] {
    get {return _storage._totalProtocolFeeList}
    set {_uniqueStorage()._totalProtocolFeeList = newValue}
  }

  var unbondSwitchList: [Stafihub_Stafihub_Ledger_UnbondSwitch] {
    get {return _storage._unbondSwitchList}
    set {_uniqueStorage()._unbondSwitchList = newValue}
  }

  var bondedPoolList: [Stafihub_Stafihub_Ledger_Pool] {
    get {return _storage._bondedPoolList}
    set {_uniqueStorage()._bondedPoolList = newValue}
  }

  var bondPipelineList: [Stafihub_Stafihub_Ledger_BondPipeline] {
    get {return _storage._bondPipelineList}
    set {_uniqueStorage()._bondPipelineList = newValue}
  }

  var eraUnbondLimitList: [Stafihub_Stafihub_Ledger_EraUnbondLimit] {
    get {return _storage._eraUnbondLimitList}
    set {_uniqueStorage()._eraUnbondLimitList = newValue}
  }

  var poolDetailList: [Stafihub_Stafihub_Ledger_PoolDetail] {
    get {return _storage._poolDetailList}
    set {_uniqueStorage()._poolDetailList = newValue}
  }

  var currentEraSnapshotList: [Stafihub_Stafihub_Ledger_EraSnapshot] {
    get {return _storage._currentEraSnapshotList}
    set {_uniqueStorage()._currentEraSnapshotList = newValue}
  }

  var snapshotList: [Stafihub_Stafihub_Ledger_GenesisSnapshot] {
    get {return _storage._snapshotList}
    set {_uniqueStorage()._snapshotList = newValue}
  }

  var eraSnapshotList: [Stafihub_Stafihub_Ledger_GenesisEraSnapshot] {
    get {return _storage._eraSnapshotList}
    set {_uniqueStorage()._eraSnapshotList = newValue}
  }

  var chainEraList: [Stafihub_Stafihub_Ledger_ChainEra] {
    get {return _storage._chainEraList}
    set {_uniqueStorage()._chainEraList = newValue}
  }

  var stakingRewardCommissionList: [Stafihub_Stafihub_Ledger_StakingRewardCommission] {
    get {return _storage._stakingRewardCommissionList}
    set {_uniqueStorage()._stakingRewardCommissionList = newValue}
  }

  var protocolFeeReceiver: String {
    get {return _storage._protocolFeeReceiver}
    set {_uniqueStorage()._protocolFeeReceiver = newValue}
  }

  var relayFeeReceiverList: [Stafihub_Stafihub_Ledger_RelayFeeReceiver] {
    get {return _storage._relayFeeReceiverList}
    set {_uniqueStorage()._relayFeeReceiverList = newValue}
  }

  var totalExpectedActiveList: [Stafihub_Stafihub_Ledger_TotalExpectedActive] {
    get {return _storage._totalExpectedActiveList}
    set {_uniqueStorage()._totalExpectedActiveList = newValue}
  }

  var poolUnbondingList: [Stafihub_Stafihub_Ledger_GenesisPoolUnbonding] {
    get {return _storage._poolUnbondingList}
    set {_uniqueStorage()._poolUnbondingList = newValue}
  }

  var unbondRelayFeeList: [Stafihub_Stafihub_Ledger_UnbondRelayFee] {
    get {return _storage._unbondRelayFeeList}
    set {_uniqueStorage()._unbondRelayFeeList = newValue}
  }

  var unbondCommissionList: [Stafihub_Stafihub_Ledger_UnbondCommission] {
    get {return _storage._unbondCommissionList}
    set {_uniqueStorage()._unbondCommissionList = newValue}
  }

  var bondRecordList: [Stafihub_Stafihub_Ledger_BondRecord] {
    get {return _storage._bondRecordList}
    set {_uniqueStorage()._bondRecordList = newValue}
  }

  var rparamsList: [Stafihub_Stafihub_Ledger_RParams] {
    get {return _storage._rparamsList}
    set {_uniqueStorage()._rparamsList = newValue}
  }

  var signatureList: [Stafihub_Stafihub_Ledger_Signature] {
    get {return _storage._signatureList}
    set {_uniqueStorage()._signatureList = newValue}
  }

  var migrateIsSealed: Bool {
    get {return _storage._migrateIsSealed}
    set {_uniqueStorage()._migrateIsSealed = newValue}
  }

  var icaPoolDetailList: [Stafihub_Stafihub_Ledger_IcaPoolDetail] {
    get {return _storage._icaPoolDetailList}
    set {_uniqueStorage()._icaPoolDetailList = newValue}
  }

  var interchainTxProposalInfoList: [Stafihub_Stafihub_Ledger_GenesisInterchainTxProposalInfo] {
    get {return _storage._interchainTxProposalInfoList}
    set {_uniqueStorage()._interchainTxProposalInfoList = newValue}
  }

  /// this line is used by starport scaffolding # genesis/proto/state
  var totalExpectedFeeList: [Stafihub_Stafihub_Ledger_TotalExpectedFee] {
    get {return _storage._totalExpectedFeeList}
    set {_uniqueStorage()._totalExpectedFeeList = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Stafihub_Stafihub_Ledger_UnbondSwitch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var `switch`: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_GenesisEraSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var era: UInt32 = 0

  var shotIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_StakingRewardCommission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_UnbondCommission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_RelayFeeReceiver {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_TotalExpectedActive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var era: UInt32 = 0

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_TotalExpectedFee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var era: UInt32 = 0

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_GenesisPoolUnbonding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var era: UInt32 = 0

  var pool: String = String()

  var sequence: UInt32 = 0

  var unbonding: Stafihub_Stafihub_Ledger_Unbonding {
    get {return _unbonding ?? Stafihub_Stafihub_Ledger_Unbonding()}
    set {_unbonding = newValue}
  }
  /// Returns true if `unbonding` has been explicitly set.
  var hasUnbonding: Bool {return self._unbonding != nil}
  /// Clears the value of `unbonding`. Subsequent reads from it will return its default value.
  mutating func clearUnbonding() {self._unbonding = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _unbonding: Stafihub_Stafihub_Ledger_Unbonding? = nil
}

struct Stafihub_Stafihub_Ledger_GenesisSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shotID: String = String()

  var snapshot: Stafihub_Stafihub_Ledger_BondSnapshot {
    get {return _snapshot ?? Stafihub_Stafihub_Ledger_BondSnapshot()}
    set {_snapshot = newValue}
  }
  /// Returns true if `snapshot` has been explicitly set.
  var hasSnapshot: Bool {return self._snapshot != nil}
  /// Clears the value of `snapshot`. Subsequent reads from it will return its default value.
  mutating func clearSnapshot() {self._snapshot = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _snapshot: Stafihub_Stafihub_Ledger_BondSnapshot? = nil
}

struct Stafihub_Stafihub_Ledger_GenesisInterchainTxProposalInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ctrlPortID: String = String()

  var ctrlChannelID: String = String()

  var sequence: UInt64 = 0

  var proposalID: String = String()

  var status: Stafihub_Stafihub_Ledger_InterchainTxStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stafihub_Stafihub_Ledger_GenesisState: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_UnbondSwitch: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_GenesisEraSnapshot: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_StakingRewardCommission: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_UnbondCommission: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_RelayFeeReceiver: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_TotalExpectedActive: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_TotalExpectedFee: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_GenesisPoolUnbonding: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_GenesisSnapshot: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_GenesisInterchainTxProposalInfo: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stafihub.stafihub.ledger"

extension Stafihub_Stafihub_Ledger_GenesisState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exchangeRateList"),
    2: .same(proto: "eraExchangeRateList"),
    3: .same(proto: "totalProtocolFeeList"),
    4: .same(proto: "unbondSwitchList"),
    5: .same(proto: "bondedPoolList"),
    6: .same(proto: "bondPipelineList"),
    7: .same(proto: "eraUnbondLimitList"),
    8: .same(proto: "poolDetailList"),
    9: .same(proto: "currentEraSnapshotList"),
    10: .same(proto: "snapshotList"),
    11: .same(proto: "eraSnapshotList"),
    12: .same(proto: "chainEraList"),
    13: .same(proto: "stakingRewardCommissionList"),
    14: .same(proto: "protocolFeeReceiver"),
    15: .same(proto: "relayFeeReceiverList"),
    16: .same(proto: "totalExpectedActiveList"),
    17: .same(proto: "poolUnbondingList"),
    18: .same(proto: "unbondRelayFeeList"),
    19: .same(proto: "unbondCommissionList"),
    20: .same(proto: "bondRecordList"),
    21: .same(proto: "rparamsList"),
    22: .same(proto: "signatureList"),
    23: .same(proto: "MigrateIsSealed"),
    24: .same(proto: "icaPoolDetailList"),
    25: .same(proto: "interchainTxProposalInfoList"),
    26: .same(proto: "totalExpectedFeeList"),
  ]

  fileprivate class _StorageClass {
    var _exchangeRateList: [Stafihub_Stafihub_Ledger_ExchangeRate] = []
    var _eraExchangeRateList: [Stafihub_Stafihub_Ledger_EraExchangeRate] = []
    var _totalProtocolFeeList: [Stafihub_Stafihub_Ledger_TotalProtocolFee] = []
    var _unbondSwitchList: [Stafihub_Stafihub_Ledger_UnbondSwitch] = []
    var _bondedPoolList: [Stafihub_Stafihub_Ledger_Pool] = []
    var _bondPipelineList: [Stafihub_Stafihub_Ledger_BondPipeline] = []
    var _eraUnbondLimitList: [Stafihub_Stafihub_Ledger_EraUnbondLimit] = []
    var _poolDetailList: [Stafihub_Stafihub_Ledger_PoolDetail] = []
    var _currentEraSnapshotList: [Stafihub_Stafihub_Ledger_EraSnapshot] = []
    var _snapshotList: [Stafihub_Stafihub_Ledger_GenesisSnapshot] = []
    var _eraSnapshotList: [Stafihub_Stafihub_Ledger_GenesisEraSnapshot] = []
    var _chainEraList: [Stafihub_Stafihub_Ledger_ChainEra] = []
    var _stakingRewardCommissionList: [Stafihub_Stafihub_Ledger_StakingRewardCommission] = []
    var _protocolFeeReceiver: String = String()
    var _relayFeeReceiverList: [Stafihub_Stafihub_Ledger_RelayFeeReceiver] = []
    var _totalExpectedActiveList: [Stafihub_Stafihub_Ledger_TotalExpectedActive] = []
    var _poolUnbondingList: [Stafihub_Stafihub_Ledger_GenesisPoolUnbonding] = []
    var _unbondRelayFeeList: [Stafihub_Stafihub_Ledger_UnbondRelayFee] = []
    var _unbondCommissionList: [Stafihub_Stafihub_Ledger_UnbondCommission] = []
    var _bondRecordList: [Stafihub_Stafihub_Ledger_BondRecord] = []
    var _rparamsList: [Stafihub_Stafihub_Ledger_RParams] = []
    var _signatureList: [Stafihub_Stafihub_Ledger_Signature] = []
    var _migrateIsSealed: Bool = false
    var _icaPoolDetailList: [Stafihub_Stafihub_Ledger_IcaPoolDetail] = []
    var _interchainTxProposalInfoList: [Stafihub_Stafihub_Ledger_GenesisInterchainTxProposalInfo] = []
    var _totalExpectedFeeList: [Stafihub_Stafihub_Ledger_TotalExpectedFee] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _exchangeRateList = source._exchangeRateList
      _eraExchangeRateList = source._eraExchangeRateList
      _totalProtocolFeeList = source._totalProtocolFeeList
      _unbondSwitchList = source._unbondSwitchList
      _bondedPoolList = source._bondedPoolList
      _bondPipelineList = source._bondPipelineList
      _eraUnbondLimitList = source._eraUnbondLimitList
      _poolDetailList = source._poolDetailList
      _currentEraSnapshotList = source._currentEraSnapshotList
      _snapshotList = source._snapshotList
      _eraSnapshotList = source._eraSnapshotList
      _chainEraList = source._chainEraList
      _stakingRewardCommissionList = source._stakingRewardCommissionList
      _protocolFeeReceiver = source._protocolFeeReceiver
      _relayFeeReceiverList = source._relayFeeReceiverList
      _totalExpectedActiveList = source._totalExpectedActiveList
      _poolUnbondingList = source._poolUnbondingList
      _unbondRelayFeeList = source._unbondRelayFeeList
      _unbondCommissionList = source._unbondCommissionList
      _bondRecordList = source._bondRecordList
      _rparamsList = source._rparamsList
      _signatureList = source._signatureList
      _migrateIsSealed = source._migrateIsSealed
      _icaPoolDetailList = source._icaPoolDetailList
      _interchainTxProposalInfoList = source._interchainTxProposalInfoList
      _totalExpectedFeeList = source._totalExpectedFeeList
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._exchangeRateList) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._eraExchangeRateList) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._totalProtocolFeeList) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._unbondSwitchList) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._bondedPoolList) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._bondPipelineList) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._eraUnbondLimitList) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._poolDetailList) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._currentEraSnapshotList) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._snapshotList) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._eraSnapshotList) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._chainEraList) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._stakingRewardCommissionList) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._protocolFeeReceiver) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._relayFeeReceiverList) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._totalExpectedActiveList) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._poolUnbondingList) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._unbondRelayFeeList) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._unbondCommissionList) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._bondRecordList) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._rparamsList) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._signatureList) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._migrateIsSealed) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._icaPoolDetailList) }()
        case 25: try { try decoder.decodeRepeatedMessageField(value: &_storage._interchainTxProposalInfoList) }()
        case 26: try { try decoder.decodeRepeatedMessageField(value: &_storage._totalExpectedFeeList) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._exchangeRateList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._exchangeRateList, fieldNumber: 1)
      }
      if !_storage._eraExchangeRateList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._eraExchangeRateList, fieldNumber: 2)
      }
      if !_storage._totalProtocolFeeList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._totalProtocolFeeList, fieldNumber: 3)
      }
      if !_storage._unbondSwitchList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._unbondSwitchList, fieldNumber: 4)
      }
      if !_storage._bondedPoolList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bondedPoolList, fieldNumber: 5)
      }
      if !_storage._bondPipelineList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bondPipelineList, fieldNumber: 6)
      }
      if !_storage._eraUnbondLimitList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._eraUnbondLimitList, fieldNumber: 7)
      }
      if !_storage._poolDetailList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._poolDetailList, fieldNumber: 8)
      }
      if !_storage._currentEraSnapshotList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._currentEraSnapshotList, fieldNumber: 9)
      }
      if !_storage._snapshotList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._snapshotList, fieldNumber: 10)
      }
      if !_storage._eraSnapshotList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._eraSnapshotList, fieldNumber: 11)
      }
      if !_storage._chainEraList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chainEraList, fieldNumber: 12)
      }
      if !_storage._stakingRewardCommissionList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stakingRewardCommissionList, fieldNumber: 13)
      }
      if !_storage._protocolFeeReceiver.isEmpty {
        try visitor.visitSingularStringField(value: _storage._protocolFeeReceiver, fieldNumber: 14)
      }
      if !_storage._relayFeeReceiverList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._relayFeeReceiverList, fieldNumber: 15)
      }
      if !_storage._totalExpectedActiveList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._totalExpectedActiveList, fieldNumber: 16)
      }
      if !_storage._poolUnbondingList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._poolUnbondingList, fieldNumber: 17)
      }
      if !_storage._unbondRelayFeeList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._unbondRelayFeeList, fieldNumber: 18)
      }
      if !_storage._unbondCommissionList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._unbondCommissionList, fieldNumber: 19)
      }
      if !_storage._bondRecordList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bondRecordList, fieldNumber: 20)
      }
      if !_storage._rparamsList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rparamsList, fieldNumber: 21)
      }
      if !_storage._signatureList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._signatureList, fieldNumber: 22)
      }
      if _storage._migrateIsSealed != false {
        try visitor.visitSingularBoolField(value: _storage._migrateIsSealed, fieldNumber: 23)
      }
      if !_storage._icaPoolDetailList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._icaPoolDetailList, fieldNumber: 24)
      }
      if !_storage._interchainTxProposalInfoList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._interchainTxProposalInfoList, fieldNumber: 25)
      }
      if !_storage._totalExpectedFeeList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._totalExpectedFeeList, fieldNumber: 26)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_GenesisState, rhs: Stafihub_Stafihub_Ledger_GenesisState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._exchangeRateList != rhs_storage._exchangeRateList {return false}
        if _storage._eraExchangeRateList != rhs_storage._eraExchangeRateList {return false}
        if _storage._totalProtocolFeeList != rhs_storage._totalProtocolFeeList {return false}
        if _storage._unbondSwitchList != rhs_storage._unbondSwitchList {return false}
        if _storage._bondedPoolList != rhs_storage._bondedPoolList {return false}
        if _storage._bondPipelineList != rhs_storage._bondPipelineList {return false}
        if _storage._eraUnbondLimitList != rhs_storage._eraUnbondLimitList {return false}
        if _storage._poolDetailList != rhs_storage._poolDetailList {return false}
        if _storage._currentEraSnapshotList != rhs_storage._currentEraSnapshotList {return false}
        if _storage._snapshotList != rhs_storage._snapshotList {return false}
        if _storage._eraSnapshotList != rhs_storage._eraSnapshotList {return false}
        if _storage._chainEraList != rhs_storage._chainEraList {return false}
        if _storage._stakingRewardCommissionList != rhs_storage._stakingRewardCommissionList {return false}
        if _storage._protocolFeeReceiver != rhs_storage._protocolFeeReceiver {return false}
        if _storage._relayFeeReceiverList != rhs_storage._relayFeeReceiverList {return false}
        if _storage._totalExpectedActiveList != rhs_storage._totalExpectedActiveList {return false}
        if _storage._poolUnbondingList != rhs_storage._poolUnbondingList {return false}
        if _storage._unbondRelayFeeList != rhs_storage._unbondRelayFeeList {return false}
        if _storage._unbondCommissionList != rhs_storage._unbondCommissionList {return false}
        if _storage._bondRecordList != rhs_storage._bondRecordList {return false}
        if _storage._rparamsList != rhs_storage._rparamsList {return false}
        if _storage._signatureList != rhs_storage._signatureList {return false}
        if _storage._migrateIsSealed != rhs_storage._migrateIsSealed {return false}
        if _storage._icaPoolDetailList != rhs_storage._icaPoolDetailList {return false}
        if _storage._interchainTxProposalInfoList != rhs_storage._interchainTxProposalInfoList {return false}
        if _storage._totalExpectedFeeList != rhs_storage._totalExpectedFeeList {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_UnbondSwitch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnbondSwitch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "switch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.`switch`) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.`switch` != false {
      try visitor.visitSingularBoolField(value: self.`switch`, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_UnbondSwitch, rhs: Stafihub_Stafihub_Ledger_UnbondSwitch) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.`switch` != rhs.`switch` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_GenesisEraSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisEraSnapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "era"),
    3: .same(proto: "shotIds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.era) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.shotIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.era != 0 {
      try visitor.visitSingularUInt32Field(value: self.era, fieldNumber: 2)
    }
    if !self.shotIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.shotIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_GenesisEraSnapshot, rhs: Stafihub_Stafihub_Ledger_GenesisEraSnapshot) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.era != rhs.era {return false}
    if lhs.shotIds != rhs.shotIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_StakingRewardCommission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StakingRewardCommission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_StakingRewardCommission, rhs: Stafihub_Stafihub_Ledger_StakingRewardCommission) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_UnbondCommission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnbondCommission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_UnbondCommission, rhs: Stafihub_Stafihub_Ledger_UnbondCommission) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_RelayFeeReceiver: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RelayFeeReceiver"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_RelayFeeReceiver, rhs: Stafihub_Stafihub_Ledger_RelayFeeReceiver) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_TotalExpectedActive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TotalExpectedActive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "era"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.era) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.era != 0 {
      try visitor.visitSingularUInt32Field(value: self.era, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_TotalExpectedActive, rhs: Stafihub_Stafihub_Ledger_TotalExpectedActive) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.era != rhs.era {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_TotalExpectedFee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TotalExpectedFee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "era"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.era) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.era != 0 {
      try visitor.visitSingularUInt32Field(value: self.era, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_TotalExpectedFee, rhs: Stafihub_Stafihub_Ledger_TotalExpectedFee) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.era != rhs.era {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_GenesisPoolUnbonding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisPoolUnbonding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "era"),
    3: .same(proto: "pool"),
    4: .same(proto: "sequence"),
    5: .same(proto: "unbonding"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.era) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pool) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.sequence) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._unbonding) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.era != 0 {
      try visitor.visitSingularUInt32Field(value: self.era, fieldNumber: 2)
    }
    if !self.pool.isEmpty {
      try visitor.visitSingularStringField(value: self.pool, fieldNumber: 3)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt32Field(value: self.sequence, fieldNumber: 4)
    }
    try { if let v = self._unbonding {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_GenesisPoolUnbonding, rhs: Stafihub_Stafihub_Ledger_GenesisPoolUnbonding) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.era != rhs.era {return false}
    if lhs.pool != rhs.pool {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs._unbonding != rhs._unbonding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_GenesisSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisSnapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shotId"),
    2: .same(proto: "snapshot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.shotID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._snapshot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.shotID.isEmpty {
      try visitor.visitSingularStringField(value: self.shotID, fieldNumber: 1)
    }
    try { if let v = self._snapshot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_GenesisSnapshot, rhs: Stafihub_Stafihub_Ledger_GenesisSnapshot) -> Bool {
    if lhs.shotID != rhs.shotID {return false}
    if lhs._snapshot != rhs._snapshot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_GenesisInterchainTxProposalInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisInterchainTxProposalInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ctrlPortId"),
    2: .same(proto: "ctrlChannelId"),
    3: .same(proto: "sequence"),
    4: .same(proto: "proposalId"),
    5: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ctrlPortID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ctrlChannelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.proposalID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ctrlPortID.isEmpty {
      try visitor.visitSingularStringField(value: self.ctrlPortID, fieldNumber: 1)
    }
    if !self.ctrlChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.ctrlChannelID, fieldNumber: 2)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 3)
    }
    if !self.proposalID.isEmpty {
      try visitor.visitSingularStringField(value: self.proposalID, fieldNumber: 4)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_GenesisInterchainTxProposalInfo, rhs: Stafihub_Stafihub_Ledger_GenesisInterchainTxProposalInfo) -> Bool {
    if lhs.ctrlPortID != rhs.ctrlPortID {return false}
    if lhs.ctrlChannelID != rhs.ctrlChannelID {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
