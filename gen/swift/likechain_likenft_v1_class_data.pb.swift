// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: likechain/likenft/v1/class_data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Likechain_Likenft_V1_ClassParentType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case iscn // = 1
  case account // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .iscn
    case 2: self = .account
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .iscn: return 1
    case .account: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Likechain_Likenft_V1_ClassParentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Likechain_Likenft_V1_ClassParentType] = [
    .unknown,
    .iscn,
    .account,
  ]
}

#endif  // swift(>=4.2)

struct Likechain_Likenft_V1_ClassData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Data = Data()

  var parent: Likechain_Likenft_V1_ClassParent {
    get {return _parent ?? Likechain_Likenft_V1_ClassParent()}
    set {_parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  var hasParent: Bool {return self._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  mutating func clearParent() {self._parent = nil}

  var config: Likechain_Likenft_V1_ClassConfig {
    get {return _config ?? Likechain_Likenft_V1_ClassConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {self._config = nil}

  var blindBoxState: Likechain_Likenft_V1_BlindBoxState {
    get {return _blindBoxState ?? Likechain_Likenft_V1_BlindBoxState()}
    set {_blindBoxState = newValue}
  }
  /// Returns true if `blindBoxState` has been explicitly set.
  var hasBlindBoxState: Bool {return self._blindBoxState != nil}
  /// Clears the value of `blindBoxState`. Subsequent reads from it will return its default value.
  mutating func clearBlindBoxState() {self._blindBoxState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _parent: Likechain_Likenft_V1_ClassParent? = nil
  fileprivate var _config: Likechain_Likenft_V1_ClassConfig? = nil
  fileprivate var _blindBoxState: Likechain_Likenft_V1_BlindBoxState? = nil
}

struct Likechain_Likenft_V1_ClassParent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Likechain_Likenft_V1_ClassParentType = .unknown

  var iscnIDPrefix: String = String()

  var iscnVersionAtMint: UInt64 = 0

  var account: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MintPeriod {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {self._startTime = nil}

  var allowedAddresses: [String] = []

  var mintPrice: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Likechain_Likenft_V1_ClassConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var burnable: Bool = false

  var maxSupply: UInt64 = 0

  var blindBoxConfig: Likechain_Likenft_V1_BlindBoxConfig {
    get {return _blindBoxConfig ?? Likechain_Likenft_V1_BlindBoxConfig()}
    set {_blindBoxConfig = newValue}
  }
  /// Returns true if `blindBoxConfig` has been explicitly set.
  var hasBlindBoxConfig: Bool {return self._blindBoxConfig != nil}
  /// Clears the value of `blindBoxConfig`. Subsequent reads from it will return its default value.
  mutating func clearBlindBoxConfig() {self._blindBoxConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blindBoxConfig: Likechain_Likenft_V1_BlindBoxConfig? = nil
}

struct Likechain_Likenft_V1_BlindBoxConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mintPeriods: [Likechain_Likenft_V1_MintPeriod] = []

  var revealTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _revealTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_revealTime = newValue}
  }
  /// Returns true if `revealTime` has been explicitly set.
  var hasRevealTime: Bool {return self._revealTime != nil}
  /// Clears the value of `revealTime`. Subsequent reads from it will return its default value.
  mutating func clearRevealTime() {self._revealTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _revealTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Likechain_Likenft_V1_BlindBoxState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contentCount: UInt64 = 0

  var toBeRevealed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Likechain_Likenft_V1_ClassParentType: @unchecked Sendable {}
extension Likechain_Likenft_V1_ClassData: @unchecked Sendable {}
extension Likechain_Likenft_V1_ClassParent: @unchecked Sendable {}
extension Likechain_Likenft_V1_MintPeriod: @unchecked Sendable {}
extension Likechain_Likenft_V1_ClassConfig: @unchecked Sendable {}
extension Likechain_Likenft_V1_BlindBoxConfig: @unchecked Sendable {}
extension Likechain_Likenft_V1_BlindBoxState: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "likechain.likenft.v1"

extension Likechain_Likenft_V1_ClassParentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ISCN"),
    2: .same(proto: "ACCOUNT"),
  ]
}

extension Likechain_Likenft_V1_ClassData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "parent"),
    3: .same(proto: "config"),
    4: .standard(proto: "blind_box_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parent) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._blindBoxState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 1)
    }
    try { if let v = self._parent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._blindBoxState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_ClassData, rhs: Likechain_Likenft_V1_ClassData) -> Bool {
    if lhs.metadata != rhs.metadata {return false}
    if lhs._parent != rhs._parent {return false}
    if lhs._config != rhs._config {return false}
    if lhs._blindBoxState != rhs._blindBoxState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_ClassParent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassParent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "iscn_id_prefix"),
    3: .standard(proto: "iscn_version_at_mint"),
    4: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.iscnIDPrefix) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.iscnVersionAtMint) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.iscnIDPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.iscnIDPrefix, fieldNumber: 2)
    }
    if self.iscnVersionAtMint != 0 {
      try visitor.visitSingularUInt64Field(value: self.iscnVersionAtMint, fieldNumber: 3)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_ClassParent, rhs: Likechain_Likenft_V1_ClassParent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.iscnIDPrefix != rhs.iscnIDPrefix {return false}
    if lhs.iscnVersionAtMint != rhs.iscnVersionAtMint {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MintPeriod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MintPeriod"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "allowed_addresses"),
    3: .standard(proto: "mint_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.allowedAddresses) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.mintPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.allowedAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedAddresses, fieldNumber: 2)
    }
    if self.mintPrice != 0 {
      try visitor.visitSingularUInt64Field(value: self.mintPrice, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MintPeriod, rhs: Likechain_Likenft_V1_MintPeriod) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs.allowedAddresses != rhs.allowedAddresses {return false}
    if lhs.mintPrice != rhs.mintPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_ClassConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "burnable"),
    2: .standard(proto: "max_supply"),
    3: .standard(proto: "blind_box_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.burnable) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.maxSupply) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blindBoxConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.burnable != false {
      try visitor.visitSingularBoolField(value: self.burnable, fieldNumber: 1)
    }
    if self.maxSupply != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxSupply, fieldNumber: 2)
    }
    try { if let v = self._blindBoxConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_ClassConfig, rhs: Likechain_Likenft_V1_ClassConfig) -> Bool {
    if lhs.burnable != rhs.burnable {return false}
    if lhs.maxSupply != rhs.maxSupply {return false}
    if lhs._blindBoxConfig != rhs._blindBoxConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_BlindBoxConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlindBoxConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mint_periods"),
    2: .standard(proto: "reveal_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.mintPeriods) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._revealTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.mintPeriods.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mintPeriods, fieldNumber: 1)
    }
    try { if let v = self._revealTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_BlindBoxConfig, rhs: Likechain_Likenft_V1_BlindBoxConfig) -> Bool {
    if lhs.mintPeriods != rhs.mintPeriods {return false}
    if lhs._revealTime != rhs._revealTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_BlindBoxState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlindBoxState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_count"),
    2: .standard(proto: "to_be_revealed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.contentCount) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.toBeRevealed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.contentCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.contentCount, fieldNumber: 1)
    }
    if self.toBeRevealed != false {
      try visitor.visitSingularBoolField(value: self.toBeRevealed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_BlindBoxState, rhs: Likechain_Likenft_V1_BlindBoxState) -> Bool {
    if lhs.contentCount != rhs.contentCount {return false}
    if lhs.toBeRevealed != rhs.toBeRevealed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
