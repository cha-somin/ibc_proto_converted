// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: umee/leverage/v1/leverage.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Params defines the parameters for the leverage module.
/// See https://github.com/umee-network/umee/blob/main/docs/design_docs/010-market-params.md
/// for more details.
struct Umee_Leverage_V1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Complete Liquidation Threshold determines how far between
  /// liquidation_threshold (LT) and collateral_value (CV) a borrower's
  /// borrowed value must have progressed in order to allow a full liquidation.
  /// 0.3 indicates 30% of the way from LT to CV.
  /// See also `minimum_close_factor` for more information.
  /// Valid values: 0-1.
  var completeLiquidationThreshold: String = String()

  /// Close Factor determines the portion of a borrower's position that can be
  /// liquidated in a single event. Minimum Close Factor is Close Factor at
  /// liquidation_threshold. 0.1 means that that 10% of the borrower position can
  /// be liquidated when the borrowed value passes the liquidation_threshold.
  /// close_factor scales linearly between minimum_close_factor and 1.0,
  /// reaching its maximum when borrowed value passes
  /// complete_liquidation_threshold. We can put it into the picture:
  ///
  ///             borrowed          CV := collateral
  ///             value                   value
  ///  --- | ------- | ----- | -------- | ------->
  ///     LV                 CL
  ///
  /// LV = liquidation value = liquidation_threshold * CV
  /// CL = LV + (CV-LV) * complete_liquidation_threshold
  ///    is the borrowed value above which close factor will be 1.
  ///
  /// Valid values: 0-1.
  var minimumCloseFactor: String = String()

  /// Oracle Reward Factor determines the portion of interest accrued on
  /// borrows that is sent to the oracle module to fund its reward pool.
  /// Valid values: 0-1.
  var oracleRewardFactor: String = String()

  /// Small Liquidation Size determines the USD value at which a borrow is
  /// considered small enough to be liquidated in a single transaction, bypassing
  /// dynamic close factor.
  var smallLiquidationSize: String = String()

  /// Direct Liquidation Fee is a reduction factor in liquidation incentive
  /// experienced by liquidators who choose to receive base assets instead of
  /// uTokens as liquidation rewards.
  /// Valid values: 0-1.
  var directLiquidationFee: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Token defines a token, along with its metadata and parameters, in the Umee
/// capital facility that can be supplied and borrowed.
/// See https://github.com/umee-network/umee/blob/main/docs/design_docs/010-market-params.md
/// for more details.
struct Umee_Leverage_V1_Token {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Base Denom is the denomination of the underlying base token. Must be the base
  /// denom as registered in the Bank module (so IBC denom for IBC tokens).
  var baseDenom: String {
    get {return _storage._baseDenom}
    set {_uniqueStorage()._baseDenom = newValue}
  }

  /// Reserve Factor defines what portion of accrued interest goes to reserves
  /// when this token is borrowed.
  /// Valid values: 0-1.
  var reserveFactor: String {
    get {return _storage._reserveFactor}
    set {_uniqueStorage()._reserveFactor = newValue}
  }

  /// Collateral Weight defines what portion of the total value of the asset
  /// can contribute to a users borrowing power. If the collateral weight is
  /// zero, using this asset as collateral against borrowing will be disabled.
  /// Must be smaller than `liquidation_threshold`.
  /// Valid values: 0-1.
  var collateralWeight: String {
    get {return _storage._collateralWeight}
    set {_uniqueStorage()._collateralWeight = newValue}
  }

  /// Liquidation Threshold defines what amount of the total value of the
  /// asset as a collateral can contribute to a user's liquidation threshold
  /// (above which they become eligible for liquidation).
  /// Must be bigger than `collateral_weight`.
  /// Valid values: 0-1.
  /// See also: min_close_factor.
  var liquidationThreshold: String {
    get {return _storage._liquidationThreshold}
    set {_uniqueStorage()._liquidationThreshold = newValue}
  }

  /// Base Borrow Rate defines the minimum interest rate for borrowing this
  /// asset.
  /// Valid values: 0-∞
  var baseBorrowRate: String {
    get {return _storage._baseBorrowRate}
    set {_uniqueStorage()._baseBorrowRate = newValue}
  }

  /// Kink Borrow Rate defines the interest rate for borrowing this
  /// asset when supply utilization is equal to 'kink_utilization'.
  /// Valid values: 0-∞
  var kinkBorrowRate: String {
    get {return _storage._kinkBorrowRate}
    set {_uniqueStorage()._kinkBorrowRate = newValue}
  }

  /// Max Borrow Rate defines the interest rate for borrowing this
  /// asset when supply utilization is at its maximum.
  /// Valid values: 0-∞
  var maxBorrowRate: String {
    get {return _storage._maxBorrowRate}
    set {_uniqueStorage()._maxBorrowRate = newValue}
  }

  /// Kink Utilization defines the supply utilization value where
  /// the kink in the borrow interest rate function occurs.
  /// Valid values: 0-1.
  var kinkUtilization: String {
    get {return _storage._kinkUtilization}
    set {_uniqueStorage()._kinkUtilization = newValue}
  }

  /// Liquidation Incentive determines the portion of bonus collateral of
  /// a token type liquidators receive as a liquidation reward.
  /// Valid values: 0-1.
  var liquidationIncentive: String {
    get {return _storage._liquidationIncentive}
    set {_uniqueStorage()._liquidationIncentive = newValue}
  }

  /// Symbol Denom is the human readable denomination of this token.
  var symbolDenom: String {
    get {return _storage._symbolDenom}
    set {_uniqueStorage()._symbolDenom = newValue}
  }

  /// Exponent is the power of ten by which to multiply, in order to convert
  /// an amount of the token denoted in its symbol denom to the actual amount
  /// of its base denom.
  var exponent: UInt32 {
    get {return _storage._exponent}
    set {_uniqueStorage()._exponent = newValue}
  }

  /// Enable Msg Supply allows supplying for lending or collateral using this
  /// token. `false` means that a token can no longer be supplied.
  /// Note that withdrawing is always enabled. Disabling supply would
  /// be one step in phasing out an asset type.
  var enableMsgSupply: Bool {
    get {return _storage._enableMsgSupply}
    set {_uniqueStorage()._enableMsgSupply = newValue}
  }

  /// Enable Msg Borrow allows borrowing of this token. Note that repaying is
  /// always enabled. Disabling borrowing would be one step in phasing out an
  /// asset type, but could also be used from the start for asset types meant
  /// to be collateral only, like meTokens.
  var enableMsgBorrow: Bool {
    get {return _storage._enableMsgBorrow}
    set {_uniqueStorage()._enableMsgBorrow = newValue}
  }

  /// Blacklist should only be used to eliminate an asset completely. A blacklisted
  /// asset is treated as though its oracle price is zero, and thus ignored by
  /// calculations such as collateral value and borrow limit. Can still be repaid
  /// or withdrawn, but not liquidated. A blacklisted token must have enable_msg_supply
  /// and enable_msg_borrow set to false. Such tokens can be safely removed from the
  /// oracle and price feeder as well.
  var blacklist: Bool {
    get {return _storage._blacklist}
    set {_uniqueStorage()._blacklist = newValue}
  }

  /// Max Collateral Share specifies how much of the system's overall collateral
  /// can be provided by a given token. 1.0 means that the token has no restriction.
  /// 0.1 means maximum 10% of system's total collateral value can be provided by this token.
  /// Valid values: 0-1.
  var maxCollateralShare: String {
    get {return _storage._maxCollateralShare}
    set {_uniqueStorage()._maxCollateralShare = newValue}
  }

  /// Max Supply Utilization specifies the maximum supply utilization a token is
  /// allowed to reach as a direct result of user borrowing. New borrows are not allowed when
  /// the supply utilization is above `max_supply_utilization`.
  ///    supply_utilization(token) = total_borrowed(token) / total_supply(token)
  /// Valid values: 0-1.
  var maxSupplyUtilization: String {
    get {return _storage._maxSupplyUtilization}
    set {_uniqueStorage()._maxSupplyUtilization = newValue}
  }

  /// Min Collateral Liquidity specifies min limit for the following function:
  ///    collateral_liquidity(token) = available(token) / total_collateral(token)
  /// Borrowing, collateralizing, or withdrawing assets is not allowed when the
  /// result of such action invalidates min_collateral_liquidity.
  /// Liquidity can only drop below this value due to interest or liquidations.
  /// The goal is to assure that there is enough available (not borrowed) token to be available
  /// for withdraw when there is a collateral liquidation and the liquidator needs to
  /// withdraw uToken.
  /// Valid values: 0 - inf
  var minCollateralLiquidity: String {
    get {return _storage._minCollateralLiquidity}
    set {_uniqueStorage()._minCollateralLiquidity = newValue}
  }

  /// Max Supply is the maximum amount of tokens the protocol can hold.
  /// Adding more supply of the given token to the protocol will return an error.
  /// Must be a non negative value. 0 means that there is no limit.
  /// To mark a token as not valid for supply, `msg_supply` must be set to false.
  var maxSupply: String {
    get {return _storage._maxSupply}
    set {_uniqueStorage()._maxSupply = newValue}
  }

  /// Historic Medians is the number of median historic prices to request from
  /// the oracle module when evaluating new borrow positions containing this token.
  /// All MsgBorrow, MsgWithdraw, and MsgDecollateralize must result in healthy
  /// borrow positions under both current and historic prices. The default value of
  /// zero for this field causes current price to be used in those calculations
  /// for the affected Token.
  /// The time span covered by the historic median will be:
  ///     oracle.Params.median_stamp_period * oracle.Params.historic_stamp_period * historic_medians.
  var historicMedians: UInt32 {
    get {return _storage._historicMedians}
    set {_uniqueStorage()._historicMedians = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Umee_Leverage_V1_Params: @unchecked Sendable {}
extension Umee_Leverage_V1_Token: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "umee.leverage.v1"

extension Umee_Leverage_V1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "complete_liquidation_threshold"),
    3: .standard(proto: "minimum_close_factor"),
    4: .standard(proto: "oracle_reward_factor"),
    5: .standard(proto: "small_liquidation_size"),
    6: .standard(proto: "direct_liquidation_fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.completeLiquidationThreshold) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.minimumCloseFactor) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.oracleRewardFactor) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.smallLiquidationSize) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.directLiquidationFee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.completeLiquidationThreshold.isEmpty {
      try visitor.visitSingularStringField(value: self.completeLiquidationThreshold, fieldNumber: 2)
    }
    if !self.minimumCloseFactor.isEmpty {
      try visitor.visitSingularStringField(value: self.minimumCloseFactor, fieldNumber: 3)
    }
    if !self.oracleRewardFactor.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleRewardFactor, fieldNumber: 4)
    }
    if !self.smallLiquidationSize.isEmpty {
      try visitor.visitSingularStringField(value: self.smallLiquidationSize, fieldNumber: 5)
    }
    if !self.directLiquidationFee.isEmpty {
      try visitor.visitSingularStringField(value: self.directLiquidationFee, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_Params, rhs: Umee_Leverage_V1_Params) -> Bool {
    if lhs.completeLiquidationThreshold != rhs.completeLiquidationThreshold {return false}
    if lhs.minimumCloseFactor != rhs.minimumCloseFactor {return false}
    if lhs.oracleRewardFactor != rhs.oracleRewardFactor {return false}
    if lhs.smallLiquidationSize != rhs.smallLiquidationSize {return false}
    if lhs.directLiquidationFee != rhs.directLiquidationFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Token"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_denom"),
    2: .standard(proto: "reserve_factor"),
    3: .standard(proto: "collateral_weight"),
    4: .standard(proto: "liquidation_threshold"),
    5: .standard(proto: "base_borrow_rate"),
    6: .standard(proto: "kink_borrow_rate"),
    7: .standard(proto: "max_borrow_rate"),
    8: .standard(proto: "kink_utilization"),
    9: .standard(proto: "liquidation_incentive"),
    10: .standard(proto: "symbol_denom"),
    11: .same(proto: "exponent"),
    12: .standard(proto: "enable_msg_supply"),
    13: .standard(proto: "enable_msg_borrow"),
    14: .same(proto: "blacklist"),
    15: .standard(proto: "max_collateral_share"),
    16: .standard(proto: "max_supply_utilization"),
    17: .standard(proto: "min_collateral_liquidity"),
    18: .standard(proto: "max_supply"),
    19: .standard(proto: "historic_medians"),
  ]

  fileprivate class _StorageClass {
    var _baseDenom: String = String()
    var _reserveFactor: String = String()
    var _collateralWeight: String = String()
    var _liquidationThreshold: String = String()
    var _baseBorrowRate: String = String()
    var _kinkBorrowRate: String = String()
    var _maxBorrowRate: String = String()
    var _kinkUtilization: String = String()
    var _liquidationIncentive: String = String()
    var _symbolDenom: String = String()
    var _exponent: UInt32 = 0
    var _enableMsgSupply: Bool = false
    var _enableMsgBorrow: Bool = false
    var _blacklist: Bool = false
    var _maxCollateralShare: String = String()
    var _maxSupplyUtilization: String = String()
    var _minCollateralLiquidity: String = String()
    var _maxSupply: String = String()
    var _historicMedians: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _baseDenom = source._baseDenom
      _reserveFactor = source._reserveFactor
      _collateralWeight = source._collateralWeight
      _liquidationThreshold = source._liquidationThreshold
      _baseBorrowRate = source._baseBorrowRate
      _kinkBorrowRate = source._kinkBorrowRate
      _maxBorrowRate = source._maxBorrowRate
      _kinkUtilization = source._kinkUtilization
      _liquidationIncentive = source._liquidationIncentive
      _symbolDenom = source._symbolDenom
      _exponent = source._exponent
      _enableMsgSupply = source._enableMsgSupply
      _enableMsgBorrow = source._enableMsgBorrow
      _blacklist = source._blacklist
      _maxCollateralShare = source._maxCollateralShare
      _maxSupplyUtilization = source._maxSupplyUtilization
      _minCollateralLiquidity = source._minCollateralLiquidity
      _maxSupply = source._maxSupply
      _historicMedians = source._historicMedians
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._baseDenom) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._reserveFactor) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._collateralWeight) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._liquidationThreshold) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._baseBorrowRate) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._kinkBorrowRate) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._maxBorrowRate) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._kinkUtilization) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._liquidationIncentive) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._symbolDenom) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._exponent) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._enableMsgSupply) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._enableMsgBorrow) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._blacklist) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._maxCollateralShare) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._maxSupplyUtilization) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._minCollateralLiquidity) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._maxSupply) }()
        case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._historicMedians) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._baseDenom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._baseDenom, fieldNumber: 1)
      }
      if !_storage._reserveFactor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reserveFactor, fieldNumber: 2)
      }
      if !_storage._collateralWeight.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collateralWeight, fieldNumber: 3)
      }
      if !_storage._liquidationThreshold.isEmpty {
        try visitor.visitSingularStringField(value: _storage._liquidationThreshold, fieldNumber: 4)
      }
      if !_storage._baseBorrowRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._baseBorrowRate, fieldNumber: 5)
      }
      if !_storage._kinkBorrowRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kinkBorrowRate, fieldNumber: 6)
      }
      if !_storage._maxBorrowRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxBorrowRate, fieldNumber: 7)
      }
      if !_storage._kinkUtilization.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kinkUtilization, fieldNumber: 8)
      }
      if !_storage._liquidationIncentive.isEmpty {
        try visitor.visitSingularStringField(value: _storage._liquidationIncentive, fieldNumber: 9)
      }
      if !_storage._symbolDenom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._symbolDenom, fieldNumber: 10)
      }
      if _storage._exponent != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._exponent, fieldNumber: 11)
      }
      if _storage._enableMsgSupply != false {
        try visitor.visitSingularBoolField(value: _storage._enableMsgSupply, fieldNumber: 12)
      }
      if _storage._enableMsgBorrow != false {
        try visitor.visitSingularBoolField(value: _storage._enableMsgBorrow, fieldNumber: 13)
      }
      if _storage._blacklist != false {
        try visitor.visitSingularBoolField(value: _storage._blacklist, fieldNumber: 14)
      }
      if !_storage._maxCollateralShare.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxCollateralShare, fieldNumber: 15)
      }
      if !_storage._maxSupplyUtilization.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxSupplyUtilization, fieldNumber: 16)
      }
      if !_storage._minCollateralLiquidity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minCollateralLiquidity, fieldNumber: 17)
      }
      if !_storage._maxSupply.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxSupply, fieldNumber: 18)
      }
      if _storage._historicMedians != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._historicMedians, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_Token, rhs: Umee_Leverage_V1_Token) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._baseDenom != rhs_storage._baseDenom {return false}
        if _storage._reserveFactor != rhs_storage._reserveFactor {return false}
        if _storage._collateralWeight != rhs_storage._collateralWeight {return false}
        if _storage._liquidationThreshold != rhs_storage._liquidationThreshold {return false}
        if _storage._baseBorrowRate != rhs_storage._baseBorrowRate {return false}
        if _storage._kinkBorrowRate != rhs_storage._kinkBorrowRate {return false}
        if _storage._maxBorrowRate != rhs_storage._maxBorrowRate {return false}
        if _storage._kinkUtilization != rhs_storage._kinkUtilization {return false}
        if _storage._liquidationIncentive != rhs_storage._liquidationIncentive {return false}
        if _storage._symbolDenom != rhs_storage._symbolDenom {return false}
        if _storage._exponent != rhs_storage._exponent {return false}
        if _storage._enableMsgSupply != rhs_storage._enableMsgSupply {return false}
        if _storage._enableMsgBorrow != rhs_storage._enableMsgBorrow {return false}
        if _storage._blacklist != rhs_storage._blacklist {return false}
        if _storage._maxCollateralShare != rhs_storage._maxCollateralShare {return false}
        if _storage._maxSupplyUtilization != rhs_storage._maxSupplyUtilization {return false}
        if _storage._minCollateralLiquidity != rhs_storage._minCollateralLiquidity {return false}
        if _storage._maxSupply != rhs_storage._maxSupply {return false}
        if _storage._historicMedians != rhs_storage._historicMedians {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
