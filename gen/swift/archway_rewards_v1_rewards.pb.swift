// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: archway/rewards/v1/rewards.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Params defines the module parameters.
struct Archway_Rewards_V1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// inflation_rewards_ratio defines the percentage of minted inflation tokens
  /// that are used for dApp rewards [0.0, 1.0]. If set to 0.0, no inflation
  /// rewards are distributed.
  var inflationRewardsRatio: String = String()

  /// tx_fee_rebate_ratio defines the percentage of tx fees that are used for
  /// dApp rewards [0.0, 1.0]. If set to 0.0, no fee rewards are distributed.
  var txFeeRebateRatio: String = String()

  /// max_withdraw_records defines the maximum number of RewardsRecord objects
  /// used for the withdrawal operation.
  var maxWithdrawRecords: UInt64 = 0

  /// min_price_of_gas defines the minimum price for each single unit of gas in
  /// the network. during the min consensus fee ante handler we will be taking
  /// the max between min consensus fee and minimum price of gas to compute the
  /// minimum tx computational fees, which are independent from contract flat
  /// fees (premiums)
  var minPriceOfGas: Cosmos_Base_V1beta1_DecCoin {
    get {return _minPriceOfGas ?? Cosmos_Base_V1beta1_DecCoin()}
    set {_minPriceOfGas = newValue}
  }
  /// Returns true if `minPriceOfGas` has been explicitly set.
  var hasMinPriceOfGas: Bool {return self._minPriceOfGas != nil}
  /// Clears the value of `minPriceOfGas`. Subsequent reads from it will return its default value.
  mutating func clearMinPriceOfGas() {self._minPriceOfGas = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _minPriceOfGas: Cosmos_Base_V1beta1_DecCoin? = nil
}

/// ContractMetadata defines the contract rewards distribution options for a
/// particular contract.
struct Archway_Rewards_V1_ContractMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// contract_address defines the contract address (bech32 encoded).
  var contractAddress: String = String()

  /// owner_address is the contract owner address that can modify contract reward
  /// options (bech32 encoded). That could be the contract admin or the contract
  /// itself. If owner_address is set to contract address, contract can modify
  /// the metadata on its own using WASM bindings.
  var ownerAddress: String = String()

  /// rewards_address is an address to distribute rewards to (bech32 encoded).
  /// If not set (empty), rewards are not distributed for this contract.
  var rewardsAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BlockRewards defines block related rewards distribution data.
struct Archway_Rewards_V1_BlockRewards {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// height defines the block height.
  var height: Int64 = 0

  /// inflation_rewards is the rewards to be distributed.
  var inflationRewards: Cosmos_Base_V1beta1_Coin {
    get {return _inflationRewards ?? Cosmos_Base_V1beta1_Coin()}
    set {_inflationRewards = newValue}
  }
  /// Returns true if `inflationRewards` has been explicitly set.
  var hasInflationRewards: Bool {return self._inflationRewards != nil}
  /// Clears the value of `inflationRewards`. Subsequent reads from it will return its default value.
  mutating func clearInflationRewards() {self._inflationRewards = nil}

  /// max_gas defines the maximum gas for the block that is used to distribute
  /// inflation rewards (consensus parameter).
  var maxGas: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _inflationRewards: Cosmos_Base_V1beta1_Coin? = nil
}

/// TxRewards defines transaction related rewards distribution data.
struct Archway_Rewards_V1_TxRewards {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// tx_id is the tracking transaction ID (x/tracking is the data source for
  /// this value).
  var txID: UInt64 = 0

  /// height defines the block height.
  var height: Int64 = 0

  /// fee_rewards is the rewards to be distributed.
  var feeRewards: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RewardsRecord defines a record that is used to distribute rewards later (lazy
/// distribution). This record is being created by the x/rewards EndBlocker and
/// pruned after the rewards are distributed. An actual rewards x/bank transfer
/// might be triggered by a Tx (via CLI for example) or by a contract via WASM
/// bindings. For a contract to trigger rewards transfer, contract address must
/// be set as the rewards_address in a corresponding ContractMetadata.
struct Archway_Rewards_V1_RewardsRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id is the unique ID of the record.
  var id: UInt64 = 0

  /// rewards_address is the address to distribute rewards to (bech32 encoded).
  var rewardsAddress: String = String()

  /// rewards are the rewards to be transferred later.
  var rewards: [Cosmos_Base_V1beta1_Coin] = []

  /// calculated_height defines the block height of rewards calculation event.
  var calculatedHeight: Int64 = 0

  /// calculated_time defines the block time of rewards calculation event.
  var calculatedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _calculatedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_calculatedTime = newValue}
  }
  /// Returns true if `calculatedTime` has been explicitly set.
  var hasCalculatedTime: Bool {return self._calculatedTime != nil}
  /// Clears the value of `calculatedTime`. Subsequent reads from it will return its default value.
  mutating func clearCalculatedTime() {self._calculatedTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _calculatedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// FlatFee defines the flat fee for a particular contract.
struct Archway_Rewards_V1_FlatFee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// contract_address defines the contract address (bech32 encoded).
  var contractAddress: String = String()

  /// flat_fee defines the minimum flat fee set by the contract_owner
  var flatFee: Cosmos_Base_V1beta1_Coin {
    get {return _flatFee ?? Cosmos_Base_V1beta1_Coin()}
    set {_flatFee = newValue}
  }
  /// Returns true if `flatFee` has been explicitly set.
  var hasFlatFee: Bool {return self._flatFee != nil}
  /// Clears the value of `flatFee`. Subsequent reads from it will return its default value.
  mutating func clearFlatFee() {self._flatFee = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _flatFee: Cosmos_Base_V1beta1_Coin? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Archway_Rewards_V1_Params: @unchecked Sendable {}
extension Archway_Rewards_V1_ContractMetadata: @unchecked Sendable {}
extension Archway_Rewards_V1_BlockRewards: @unchecked Sendable {}
extension Archway_Rewards_V1_TxRewards: @unchecked Sendable {}
extension Archway_Rewards_V1_RewardsRecord: @unchecked Sendable {}
extension Archway_Rewards_V1_FlatFee: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "archway.rewards.v1"

extension Archway_Rewards_V1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inflation_rewards_ratio"),
    2: .standard(proto: "tx_fee_rebate_ratio"),
    3: .standard(proto: "max_withdraw_records"),
    4: .standard(proto: "min_price_of_gas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.inflationRewardsRatio) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.txFeeRebateRatio) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.maxWithdrawRecords) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._minPriceOfGas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.inflationRewardsRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.inflationRewardsRatio, fieldNumber: 1)
    }
    if !self.txFeeRebateRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.txFeeRebateRatio, fieldNumber: 2)
    }
    if self.maxWithdrawRecords != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxWithdrawRecords, fieldNumber: 3)
    }
    try { if let v = self._minPriceOfGas {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Archway_Rewards_V1_Params, rhs: Archway_Rewards_V1_Params) -> Bool {
    if lhs.inflationRewardsRatio != rhs.inflationRewardsRatio {return false}
    if lhs.txFeeRebateRatio != rhs.txFeeRebateRatio {return false}
    if lhs.maxWithdrawRecords != rhs.maxWithdrawRecords {return false}
    if lhs._minPriceOfGas != rhs._minPriceOfGas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Archway_Rewards_V1_ContractMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_address"),
    2: .standard(proto: "owner_address"),
    3: .standard(proto: "rewards_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rewardsAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 1)
    }
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 2)
    }
    if !self.rewardsAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardsAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Archway_Rewards_V1_ContractMetadata, rhs: Archway_Rewards_V1_ContractMetadata) -> Bool {
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.rewardsAddress != rhs.rewardsAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Archway_Rewards_V1_BlockRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .standard(proto: "inflation_rewards"),
    3: .standard(proto: "max_gas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inflationRewards) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.maxGas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    try { if let v = self._inflationRewards {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.maxGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxGas, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Archway_Rewards_V1_BlockRewards, rhs: Archway_Rewards_V1_BlockRewards) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs._inflationRewards != rhs._inflationRewards {return false}
    if lhs.maxGas != rhs.maxGas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Archway_Rewards_V1_TxRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .same(proto: "height"),
    3: .standard(proto: "fee_rewards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.feeRewards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.txID != 0 {
      try visitor.visitSingularUInt64Field(value: self.txID, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 2)
    }
    if !self.feeRewards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.feeRewards, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Archway_Rewards_V1_TxRewards, rhs: Archway_Rewards_V1_TxRewards) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.height != rhs.height {return false}
    if lhs.feeRewards != rhs.feeRewards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Archway_Rewards_V1_RewardsRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RewardsRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "rewards_address"),
    3: .same(proto: "rewards"),
    4: .standard(proto: "calculated_height"),
    5: .standard(proto: "calculated_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rewardsAddress) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rewards) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.calculatedHeight) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._calculatedTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.rewardsAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardsAddress, fieldNumber: 2)
    }
    if !self.rewards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rewards, fieldNumber: 3)
    }
    if self.calculatedHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.calculatedHeight, fieldNumber: 4)
    }
    try { if let v = self._calculatedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Archway_Rewards_V1_RewardsRecord, rhs: Archway_Rewards_V1_RewardsRecord) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.rewardsAddress != rhs.rewardsAddress {return false}
    if lhs.rewards != rhs.rewards {return false}
    if lhs.calculatedHeight != rhs.calculatedHeight {return false}
    if lhs._calculatedTime != rhs._calculatedTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Archway_Rewards_V1_FlatFee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlatFee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_address"),
    2: .standard(proto: "flat_fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._flatFee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 1)
    }
    try { if let v = self._flatFee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Archway_Rewards_V1_FlatFee, rhs: Archway_Rewards_V1_FlatFee) -> Bool {
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs._flatFee != rhs._flatFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
