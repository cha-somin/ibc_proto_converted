// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: comdex/liquidity/v1beta1/liquidity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// PoolType enumerates pool types.
enum Comdex_Liquidity_V1beta1_PoolType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// POOL_TYPE_UNSPECIFIED specifies unknown pool type
  case unspecified // = 0

  /// POOL_TYPE_BASIC specifies the basic pool type
  case basic // = 1

  /// POOL_TYPE_RANGED specifies the ranged pool type
  case ranged // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .basic
    case 2: self = .ranged
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .basic: return 1
    case .ranged: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Comdex_Liquidity_V1beta1_PoolType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Comdex_Liquidity_V1beta1_PoolType] = [
    .unspecified,
    .basic,
    .ranged,
  ]
}

#endif  // swift(>=4.2)

/// OrderType enumerates order types.
enum Comdex_Liquidity_V1beta1_OrderType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// ORDER_TYPE_UNSPECIFIED specifies unknown order type.
  case unspecified // = 0

  /// ORDER_TYPE_LIMIT specifies limit order type.
  case limit // = 1

  /// ORDER_TYPE_MARKET specifies market order type.
  case market // = 2

  /// ORDER_TYPE_MM specifies MM(market making) order type.
  case mm // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .limit
    case 2: self = .market
    case 3: self = .mm
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .limit: return 1
    case .market: return 2
    case .mm: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Comdex_Liquidity_V1beta1_OrderType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Comdex_Liquidity_V1beta1_OrderType] = [
    .unspecified,
    .limit,
    .market,
    .mm,
  ]
}

#endif  // swift(>=4.2)

/// OrderDirection enumerates order directions.
enum Comdex_Liquidity_V1beta1_OrderDirection: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// ORDER_DIRECTION_UNSPECIFIED specifies unknown order direction
  case unspecified // = 0

  /// ORDER_DIRECTION_BUY specifies buy(swap quote coin to base coin) order direction
  case buy // = 1

  /// ORDER_DIRECTION_SELL specifies sell(swap base coin to quote coin) order direction
  case sell // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .buy
    case 2: self = .sell
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .buy: return 1
    case .sell: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Comdex_Liquidity_V1beta1_OrderDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Comdex_Liquidity_V1beta1_OrderDirection] = [
    .unspecified,
    .buy,
    .sell,
  ]
}

#endif  // swift(>=4.2)

/// RequestStatus enumerates request statuses.
enum Comdex_Liquidity_V1beta1_RequestStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// REQUEST_STATUS_UNSPECIFIED specifies unknown request status
  case unspecified // = 0

  /// REQUEST_STATUS_NOT_EXECUTED indicates the request is not executed yet
  case notExecuted // = 1

  /// REQUEST_STATUS_SUCCEEDED indicates the request has been succeeded
  case succeeded // = 2

  /// REQUEST_STATUS_FAILED indicates the request is failed
  case failed // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notExecuted
    case 2: self = .succeeded
    case 3: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notExecuted: return 1
    case .succeeded: return 2
    case .failed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Comdex_Liquidity_V1beta1_RequestStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Comdex_Liquidity_V1beta1_RequestStatus] = [
    .unspecified,
    .notExecuted,
    .succeeded,
    .failed,
  ]
}

#endif  // swift(>=4.2)

/// OrderStatus enumerates order statuses.
enum Comdex_Liquidity_V1beta1_OrderStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// ORDER_STATUS_UNSPECIFIED specifies unknown order status
  case unspecified // = 0

  /// ORDER_STATUS_NOT_EXECUTED indicates the order has not been executed yet
  case notExecuted // = 1

  /// ORDER_STATUS_NOT_MATCHED indicates the order has been executed but has no match
  case notMatched // = 2

  /// ORDER_STATUS_PARTIALLY_MATCHED indicates the order has been partially matched
  case partiallyMatched // = 3

  /// ORDER_STATUS_COMPLETED indicates the order has been fully matched and completed
  case completed // = 4

  /// ORDER_STATUS_CANCELED indicates the order has been canceled
  case canceled // = 5

  /// ORDER_STATUS_EXPIRED indicates the order has been expired
  case expired // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notExecuted
    case 2: self = .notMatched
    case 3: self = .partiallyMatched
    case 4: self = .completed
    case 5: self = .canceled
    case 6: self = .expired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notExecuted: return 1
    case .notMatched: return 2
    case .partiallyMatched: return 3
    case .completed: return 4
    case .canceled: return 5
    case .expired: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Comdex_Liquidity_V1beta1_OrderStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Comdex_Liquidity_V1beta1_OrderStatus] = [
    .unspecified,
    .notExecuted,
    .notMatched,
    .partiallyMatched,
    .completed,
    .canceled,
    .expired,
  ]
}

#endif  // swift(>=4.2)

/// AddressType enumerates the available types of a address.
enum Comdex_Liquidity_V1beta1_AddressType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// the 32 bytes length address type of ADR 028.
  case addressType32Bytes // = 0

  /// the default 20 bytes length address type.
  case addressType20Bytes // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .addressType32Bytes
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .addressType32Bytes
    case 1: self = .addressType20Bytes
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .addressType32Bytes: return 0
    case .addressType20Bytes: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Comdex_Liquidity_V1beta1_AddressType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Comdex_Liquidity_V1beta1_AddressType] = [
    .addressType32Bytes,
    .addressType20Bytes,
  ]
}

#endif  // swift(>=4.2)

/// Pair defines a coin pair.
struct Comdex_Liquidity_V1beta1_Pair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var baseCoinDenom: String = String()

  var quoteCoinDenom: String = String()

  var escrowAddress: String = String()

  var lastOrderID: UInt64 = 0

  var lastPrice: String = String()

  var currentBatchID: UInt64 = 0

  var swapFeeCollectorAddress: String = String()

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Pool defines a basic liquidity pool with no min-price and max-price.
struct Comdex_Liquidity_V1beta1_Pool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var pairID: UInt64 = 0

  var reserveAddress: String = String()

  var poolCoinDenom: String = String()

  var lastDepositRequestID: UInt64 = 0

  var lastWithdrawRequestID: UInt64 = 0

  var disabled: Bool = false

  var appID: UInt64 = 0

  var type: Comdex_Liquidity_V1beta1_PoolType = .unspecified

  var creator: String = String()

  var minPrice: String = String()

  var maxPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DepositRequest defines a deposit request.
struct Comdex_Liquidity_V1beta1_DepositRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id specifies the id for the request
  var id: UInt64 = 0

  /// pool_id specifies the pool id
  var poolID: UInt64 = 0

  /// msg_height specifies the block height when the request is stored for the batch execution
  var msgHeight: Int64 = 0

  /// depositor specifies the bech32-encoded address that makes a deposit to the pool
  var depositor: String = String()

  /// deposit_coins specifies the amount of coins to deposit.
  var depositCoins: [Cosmos_Base_V1beta1_Coin] = []

  /// accepted_coins specifies the amount of coins that are accepted.
  var acceptedCoins: [Cosmos_Base_V1beta1_Coin] = []

  var mintedPoolCoin: Cosmos_Base_V1beta1_Coin {
    get {return _mintedPoolCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_mintedPoolCoin = newValue}
  }
  /// Returns true if `mintedPoolCoin` has been explicitly set.
  var hasMintedPoolCoin: Bool {return self._mintedPoolCoin != nil}
  /// Clears the value of `mintedPoolCoin`. Subsequent reads from it will return its default value.
  mutating func clearMintedPoolCoin() {self._mintedPoolCoin = nil}

  var status: Comdex_Liquidity_V1beta1_RequestStatus = .unspecified

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mintedPoolCoin: Cosmos_Base_V1beta1_Coin? = nil
}

/// WithdrawRequest defines a withdraw request.
struct Comdex_Liquidity_V1beta1_WithdrawRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id specifies the id for the request
  var id: UInt64 = 0

  /// pool_id specifies the pool id
  var poolID: UInt64 = 0

  /// msg_height specifies the block height when the request is stored for the batch execution
  var msgHeight: Int64 = 0

  /// withdrawer specifies the bech32-encoded address that withdraws pool coin from the pool
  var withdrawer: String = String()

  /// pool_coin specifies the pool coin that is a proof of liquidity provider for the pool
  var poolCoin: Cosmos_Base_V1beta1_Coin {
    get {return _poolCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_poolCoin = newValue}
  }
  /// Returns true if `poolCoin` has been explicitly set.
  var hasPoolCoin: Bool {return self._poolCoin != nil}
  /// Clears the value of `poolCoin`. Subsequent reads from it will return its default value.
  mutating func clearPoolCoin() {self._poolCoin = nil}

  /// withdrawn_coins specifies the amount of coins that are withdrawn.
  var withdrawnCoins: [Cosmos_Base_V1beta1_Coin] = []

  var status: Comdex_Liquidity_V1beta1_RequestStatus = .unspecified

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _poolCoin: Cosmos_Base_V1beta1_Coin? = nil
}

/// Order defines an order.
struct Comdex_Liquidity_V1beta1_Order {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id specifies the id for the request
  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// pair_id specifies the pair id
  var pairID: UInt64 {
    get {return _storage._pairID}
    set {_uniqueStorage()._pairID = newValue}
  }

  /// msg_height specifies the block height when the request is stored for the batch execution
  var msgHeight: Int64 {
    get {return _storage._msgHeight}
    set {_uniqueStorage()._msgHeight = newValue}
  }

  /// orderer specifies the bech32-encoded address that makes an order
  var orderer: String {
    get {return _storage._orderer}
    set {_uniqueStorage()._orderer = newValue}
  }

  /// direction specifies the order direction; either buy or sell
  var direction: Comdex_Liquidity_V1beta1_OrderDirection {
    get {return _storage._direction}
    set {_uniqueStorage()._direction = newValue}
  }

  var offerCoin: Cosmos_Base_V1beta1_Coin {
    get {return _storage._offerCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._offerCoin = newValue}
  }
  /// Returns true if `offerCoin` has been explicitly set.
  var hasOfferCoin: Bool {return _storage._offerCoin != nil}
  /// Clears the value of `offerCoin`. Subsequent reads from it will return its default value.
  mutating func clearOfferCoin() {_uniqueStorage()._offerCoin = nil}

  /// remaining_offer_coin specifies the remaining offer coin
  var remainingOfferCoin: Cosmos_Base_V1beta1_Coin {
    get {return _storage._remainingOfferCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._remainingOfferCoin = newValue}
  }
  /// Returns true if `remainingOfferCoin` has been explicitly set.
  var hasRemainingOfferCoin: Bool {return _storage._remainingOfferCoin != nil}
  /// Clears the value of `remainingOfferCoin`. Subsequent reads from it will return its default value.
  mutating func clearRemainingOfferCoin() {_uniqueStorage()._remainingOfferCoin = nil}

  /// received_coin specifies the received coin after the swap
  var receivedCoin: Cosmos_Base_V1beta1_Coin {
    get {return _storage._receivedCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._receivedCoin = newValue}
  }
  /// Returns true if `receivedCoin` has been explicitly set.
  var hasReceivedCoin: Bool {return _storage._receivedCoin != nil}
  /// Clears the value of `receivedCoin`. Subsequent reads from it will return its default value.
  mutating func clearReceivedCoin() {_uniqueStorage()._receivedCoin = nil}

  /// price specifies the price that an orderer is willing to swap
  var price: String {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  var amount: String {
    get {return _storage._amount}
    set {_uniqueStorage()._amount = newValue}
  }

  var openAmount: String {
    get {return _storage._openAmount}
    set {_uniqueStorage()._openAmount = newValue}
  }

  /// batch_id specifies the pair's batch id when the request is stored
  var batchID: UInt64 {
    get {return _storage._batchID}
    set {_uniqueStorage()._batchID = newValue}
  }

  var expireAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expireAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expireAt = newValue}
  }
  /// Returns true if `expireAt` has been explicitly set.
  var hasExpireAt: Bool {return _storage._expireAt != nil}
  /// Clears the value of `expireAt`. Subsequent reads from it will return its default value.
  mutating func clearExpireAt() {_uniqueStorage()._expireAt = nil}

  var status: Comdex_Liquidity_V1beta1_OrderStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var appID: UInt64 {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  /// type specifies the typo of the order
  var type: Comdex_Liquidity_V1beta1_OrderType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MMOrderIndex defines an index type to quickly find market making orders
/// from an orderer.
struct Comdex_Liquidity_V1beta1_MMOrderIndex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderer: String = String()

  var appID: UInt64 = 0

  var pairID: UInt64 = 0

  var orderIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Liquidity_V1beta1_ActiveFarmer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt64 = 0

  var poolID: UInt64 = 0

  var farmer: String = String()

  var farmedPoolCoin: Cosmos_Base_V1beta1_Coin {
    get {return _farmedPoolCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_farmedPoolCoin = newValue}
  }
  /// Returns true if `farmedPoolCoin` has been explicitly set.
  var hasFarmedPoolCoin: Bool {return self._farmedPoolCoin != nil}
  /// Clears the value of `farmedPoolCoin`. Subsequent reads from it will return its default value.
  mutating func clearFarmedPoolCoin() {self._farmedPoolCoin = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _farmedPoolCoin: Cosmos_Base_V1beta1_Coin? = nil
}

struct Comdex_Liquidity_V1beta1_QueuedCoin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var farmedPoolCoin: Cosmos_Base_V1beta1_Coin {
    get {return _farmedPoolCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_farmedPoolCoin = newValue}
  }
  /// Returns true if `farmedPoolCoin` has been explicitly set.
  var hasFarmedPoolCoin: Bool {return self._farmedPoolCoin != nil}
  /// Clears the value of `farmedPoolCoin`. Subsequent reads from it will return its default value.
  mutating func clearFarmedPoolCoin() {self._farmedPoolCoin = nil}

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _farmedPoolCoin: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Comdex_Liquidity_V1beta1_QueuedFarmer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt64 = 0

  var poolID: UInt64 = 0

  var farmer: String = String()

  var queudCoins: [Comdex_Liquidity_V1beta1_QueuedCoin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Comdex_Liquidity_V1beta1_PoolType: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_OrderType: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_OrderDirection: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_RequestStatus: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_OrderStatus: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_AddressType: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_Pair: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_Pool: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_DepositRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_WithdrawRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_Order: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_MMOrderIndex: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_ActiveFarmer: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueuedCoin: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueuedFarmer: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "comdex.liquidity.v1beta1"

extension Comdex_Liquidity_V1beta1_PoolType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POOL_TYPE_UNSPECIFIED"),
    1: .same(proto: "POOL_TYPE_BASIC"),
    2: .same(proto: "POOL_TYPE_RANGED"),
  ]
}

extension Comdex_Liquidity_V1beta1_OrderType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_TYPE_UNSPECIFIED"),
    1: .same(proto: "ORDER_TYPE_LIMIT"),
    2: .same(proto: "ORDER_TYPE_MARKET"),
    3: .same(proto: "ORDER_TYPE_MM"),
  ]
}

extension Comdex_Liquidity_V1beta1_OrderDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_DIRECTION_UNSPECIFIED"),
    1: .same(proto: "ORDER_DIRECTION_BUY"),
    2: .same(proto: "ORDER_DIRECTION_SELL"),
  ]
}

extension Comdex_Liquidity_V1beta1_RequestStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUEST_STATUS_UNSPECIFIED"),
    1: .same(proto: "REQUEST_STATUS_NOT_EXECUTED"),
    2: .same(proto: "REQUEST_STATUS_SUCCEEDED"),
    3: .same(proto: "REQUEST_STATUS_FAILED"),
  ]
}

extension Comdex_Liquidity_V1beta1_OrderStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_STATUS_UNSPECIFIED"),
    1: .same(proto: "ORDER_STATUS_NOT_EXECUTED"),
    2: .same(proto: "ORDER_STATUS_NOT_MATCHED"),
    3: .same(proto: "ORDER_STATUS_PARTIALLY_MATCHED"),
    4: .same(proto: "ORDER_STATUS_COMPLETED"),
    5: .same(proto: "ORDER_STATUS_CANCELED"),
    6: .same(proto: "ORDER_STATUS_EXPIRED"),
  ]
}

extension Comdex_Liquidity_V1beta1_AddressType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADDRESS_TYPE_32_BYTES"),
    1: .same(proto: "ADDRESS_TYPE_20_BYTES"),
  ]
}

extension Comdex_Liquidity_V1beta1_Pair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "base_coin_denom"),
    3: .standard(proto: "quote_coin_denom"),
    4: .standard(proto: "escrow_address"),
    5: .standard(proto: "last_order_id"),
    6: .standard(proto: "last_price"),
    7: .standard(proto: "current_batch_id"),
    8: .standard(proto: "swap_fee_collector_address"),
    9: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.baseCoinDenom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quoteCoinDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.escrowAddress) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.lastOrderID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.lastPrice) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.currentBatchID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.swapFeeCollectorAddress) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.baseCoinDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.baseCoinDenom, fieldNumber: 2)
    }
    if !self.quoteCoinDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteCoinDenom, fieldNumber: 3)
    }
    if !self.escrowAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.escrowAddress, fieldNumber: 4)
    }
    if self.lastOrderID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastOrderID, fieldNumber: 5)
    }
    if !self.lastPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.lastPrice, fieldNumber: 6)
    }
    if self.currentBatchID != 0 {
      try visitor.visitSingularUInt64Field(value: self.currentBatchID, fieldNumber: 7)
    }
    if !self.swapFeeCollectorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.swapFeeCollectorAddress, fieldNumber: 8)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_Pair, rhs: Comdex_Liquidity_V1beta1_Pair) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.baseCoinDenom != rhs.baseCoinDenom {return false}
    if lhs.quoteCoinDenom != rhs.quoteCoinDenom {return false}
    if lhs.escrowAddress != rhs.escrowAddress {return false}
    if lhs.lastOrderID != rhs.lastOrderID {return false}
    if lhs.lastPrice != rhs.lastPrice {return false}
    if lhs.currentBatchID != rhs.currentBatchID {return false}
    if lhs.swapFeeCollectorAddress != rhs.swapFeeCollectorAddress {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_Pool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pair_id"),
    3: .standard(proto: "reserve_address"),
    4: .standard(proto: "pool_coin_denom"),
    5: .standard(proto: "last_deposit_request_id"),
    6: .standard(proto: "last_withdraw_request_id"),
    7: .same(proto: "disabled"),
    8: .standard(proto: "app_id"),
    9: .same(proto: "type"),
    10: .same(proto: "creator"),
    11: .standard(proto: "min_price"),
    12: .standard(proto: "max_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.pairID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reserveAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.poolCoinDenom) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.lastDepositRequestID) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.lastWithdrawRequestID) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.minPrice) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.maxPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.pairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pairID, fieldNumber: 2)
    }
    if !self.reserveAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.reserveAddress, fieldNumber: 3)
    }
    if !self.poolCoinDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.poolCoinDenom, fieldNumber: 4)
    }
    if self.lastDepositRequestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastDepositRequestID, fieldNumber: 5)
    }
    if self.lastWithdrawRequestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastWithdrawRequestID, fieldNumber: 6)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 7)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 8)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 9)
    }
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 10)
    }
    if !self.minPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.minPrice, fieldNumber: 11)
    }
    if !self.maxPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.maxPrice, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_Pool, rhs: Comdex_Liquidity_V1beta1_Pool) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.pairID != rhs.pairID {return false}
    if lhs.reserveAddress != rhs.reserveAddress {return false}
    if lhs.poolCoinDenom != rhs.poolCoinDenom {return false}
    if lhs.lastDepositRequestID != rhs.lastDepositRequestID {return false}
    if lhs.lastWithdrawRequestID != rhs.lastWithdrawRequestID {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.minPrice != rhs.minPrice {return false}
    if lhs.maxPrice != rhs.maxPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_DepositRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DepositRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pool_id"),
    3: .standard(proto: "msg_height"),
    4: .same(proto: "depositor"),
    5: .standard(proto: "deposit_coins"),
    6: .standard(proto: "accepted_coins"),
    7: .standard(proto: "minted_pool_coin"),
    8: .same(proto: "status"),
    9: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.msgHeight) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.depositor) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.depositCoins) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.acceptedCoins) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._mintedPoolCoin) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 2)
    }
    if self.msgHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.msgHeight, fieldNumber: 3)
    }
    if !self.depositor.isEmpty {
      try visitor.visitSingularStringField(value: self.depositor, fieldNumber: 4)
    }
    if !self.depositCoins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.depositCoins, fieldNumber: 5)
    }
    if !self.acceptedCoins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.acceptedCoins, fieldNumber: 6)
    }
    try { if let v = self._mintedPoolCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 8)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_DepositRequest, rhs: Comdex_Liquidity_V1beta1_DepositRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs.msgHeight != rhs.msgHeight {return false}
    if lhs.depositor != rhs.depositor {return false}
    if lhs.depositCoins != rhs.depositCoins {return false}
    if lhs.acceptedCoins != rhs.acceptedCoins {return false}
    if lhs._mintedPoolCoin != rhs._mintedPoolCoin {return false}
    if lhs.status != rhs.status {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_WithdrawRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WithdrawRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pool_id"),
    3: .standard(proto: "msg_height"),
    4: .same(proto: "withdrawer"),
    5: .standard(proto: "pool_coin"),
    6: .standard(proto: "withdrawn_coins"),
    7: .same(proto: "status"),
    8: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.msgHeight) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.withdrawer) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._poolCoin) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.withdrawnCoins) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 2)
    }
    if self.msgHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.msgHeight, fieldNumber: 3)
    }
    if !self.withdrawer.isEmpty {
      try visitor.visitSingularStringField(value: self.withdrawer, fieldNumber: 4)
    }
    try { if let v = self._poolCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.withdrawnCoins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.withdrawnCoins, fieldNumber: 6)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_WithdrawRequest, rhs: Comdex_Liquidity_V1beta1_WithdrawRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs.msgHeight != rhs.msgHeight {return false}
    if lhs.withdrawer != rhs.withdrawer {return false}
    if lhs._poolCoin != rhs._poolCoin {return false}
    if lhs.withdrawnCoins != rhs.withdrawnCoins {return false}
    if lhs.status != rhs.status {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Order"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pair_id"),
    3: .standard(proto: "msg_height"),
    4: .same(proto: "orderer"),
    5: .same(proto: "direction"),
    6: .standard(proto: "offer_coin"),
    7: .standard(proto: "remaining_offer_coin"),
    8: .standard(proto: "received_coin"),
    9: .same(proto: "price"),
    10: .same(proto: "amount"),
    11: .standard(proto: "open_amount"),
    12: .standard(proto: "batch_id"),
    13: .standard(proto: "expire_at"),
    14: .same(proto: "status"),
    15: .standard(proto: "app_id"),
    16: .same(proto: "type"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _pairID: UInt64 = 0
    var _msgHeight: Int64 = 0
    var _orderer: String = String()
    var _direction: Comdex_Liquidity_V1beta1_OrderDirection = .unspecified
    var _offerCoin: Cosmos_Base_V1beta1_Coin? = nil
    var _remainingOfferCoin: Cosmos_Base_V1beta1_Coin? = nil
    var _receivedCoin: Cosmos_Base_V1beta1_Coin? = nil
    var _price: String = String()
    var _amount: String = String()
    var _openAmount: String = String()
    var _batchID: UInt64 = 0
    var _expireAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _status: Comdex_Liquidity_V1beta1_OrderStatus = .unspecified
    var _appID: UInt64 = 0
    var _type: Comdex_Liquidity_V1beta1_OrderType = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _pairID = source._pairID
      _msgHeight = source._msgHeight
      _orderer = source._orderer
      _direction = source._direction
      _offerCoin = source._offerCoin
      _remainingOfferCoin = source._remainingOfferCoin
      _receivedCoin = source._receivedCoin
      _price = source._price
      _amount = source._amount
      _openAmount = source._openAmount
      _batchID = source._batchID
      _expireAt = source._expireAt
      _status = source._status
      _appID = source._appID
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._pairID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._msgHeight) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._orderer) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._direction) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._offerCoin) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._remainingOfferCoin) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._receivedCoin) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._price) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._amount) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._openAmount) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._batchID) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._expireAt) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._appID) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._pairID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._pairID, fieldNumber: 2)
      }
      if _storage._msgHeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._msgHeight, fieldNumber: 3)
      }
      if !_storage._orderer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._orderer, fieldNumber: 4)
      }
      if _storage._direction != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._direction, fieldNumber: 5)
      }
      try { if let v = _storage._offerCoin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._remainingOfferCoin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._receivedCoin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._price.isEmpty {
        try visitor.visitSingularStringField(value: _storage._price, fieldNumber: 9)
      }
      if !_storage._amount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._amount, fieldNumber: 10)
      }
      if !_storage._openAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._openAmount, fieldNumber: 11)
      }
      if _storage._batchID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._batchID, fieldNumber: 12)
      }
      try { if let v = _storage._expireAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 14)
      }
      if _storage._appID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._appID, fieldNumber: 15)
      }
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_Order, rhs: Comdex_Liquidity_V1beta1_Order) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._pairID != rhs_storage._pairID {return false}
        if _storage._msgHeight != rhs_storage._msgHeight {return false}
        if _storage._orderer != rhs_storage._orderer {return false}
        if _storage._direction != rhs_storage._direction {return false}
        if _storage._offerCoin != rhs_storage._offerCoin {return false}
        if _storage._remainingOfferCoin != rhs_storage._remainingOfferCoin {return false}
        if _storage._receivedCoin != rhs_storage._receivedCoin {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._openAmount != rhs_storage._openAmount {return false}
        if _storage._batchID != rhs_storage._batchID {return false}
        if _storage._expireAt != rhs_storage._expireAt {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_MMOrderIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MMOrderIndex"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orderer"),
    2: .standard(proto: "app_id"),
    3: .standard(proto: "pair_id"),
    4: .standard(proto: "order_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderer) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.pairID) }()
      case 4: try { try decoder.decodeRepeatedUInt64Field(value: &self.orderIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderer.isEmpty {
      try visitor.visitSingularStringField(value: self.orderer, fieldNumber: 1)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 2)
    }
    if self.pairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pairID, fieldNumber: 3)
    }
    if !self.orderIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.orderIds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_MMOrderIndex, rhs: Comdex_Liquidity_V1beta1_MMOrderIndex) -> Bool {
    if lhs.orderer != rhs.orderer {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.pairID != rhs.pairID {return false}
    if lhs.orderIds != rhs.orderIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_ActiveFarmer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActiveFarmer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "pool_id"),
    3: .same(proto: "farmer"),
    4: .standard(proto: "farmed_pool_coin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.farmer) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._farmedPoolCoin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 1)
    }
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 2)
    }
    if !self.farmer.isEmpty {
      try visitor.visitSingularStringField(value: self.farmer, fieldNumber: 3)
    }
    try { if let v = self._farmedPoolCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_ActiveFarmer, rhs: Comdex_Liquidity_V1beta1_ActiveFarmer) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs.farmer != rhs.farmer {return false}
    if lhs._farmedPoolCoin != rhs._farmedPoolCoin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueuedCoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueuedCoin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "farmed_pool_coin"),
    2: .standard(proto: "created_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._farmedPoolCoin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._farmedPoolCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueuedCoin, rhs: Comdex_Liquidity_V1beta1_QueuedCoin) -> Bool {
    if lhs._farmedPoolCoin != rhs._farmedPoolCoin {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueuedFarmer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueuedFarmer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "pool_id"),
    3: .same(proto: "farmer"),
    4: .standard(proto: "queud_coins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.farmer) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.queudCoins) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 1)
    }
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 2)
    }
    if !self.farmer.isEmpty {
      try visitor.visitSingularStringField(value: self.farmer, fieldNumber: 3)
    }
    if !self.queudCoins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queudCoins, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueuedFarmer, rhs: Comdex_Liquidity_V1beta1_QueuedFarmer) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs.farmer != rhs.farmer {return false}
    if lhs.queudCoins != rhs.queudCoins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
