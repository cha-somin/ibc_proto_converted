// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: injective/exchange/v1beta1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Injective_Exchange_V1beta1_ExchangeType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case exchangeUnspecified // = 0
  case spot // = 1
  case derivatives // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .exchangeUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .exchangeUnspecified
    case 1: self = .spot
    case 2: self = .derivatives
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .exchangeUnspecified: return 0
    case .spot: return 1
    case .derivatives: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Exchange_V1beta1_ExchangeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Exchange_V1beta1_ExchangeType] = [
    .exchangeUnspecified,
    .spot,
    .derivatives,
  ]
}

#endif  // swift(>=4.2)

struct Injective_Exchange_V1beta1_MsgUpdateParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authority is the address of the governance account.
  var authority: String = String()

  /// params defines the exchange parameters to update.
  ///
  /// NOTE: All parameters must be supplied.
  var params: Injective_Exchange_V1beta1_Params {
    get {return _params ?? Injective_Exchange_V1beta1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Injective_Exchange_V1beta1_Params? = nil
}

struct Injective_Exchange_V1beta1_MsgUpdateParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeposit defines a SDK message for transferring coins from the sender's
/// bank balance into the subaccount's exchange deposits
struct Injective_Exchange_V1beta1_MsgDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  /// (Optional) bytes32 subaccount ID to deposit funds into. If empty, the coin
  /// will be deposited to the sender's default subaccount address.
  var subaccountID: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgDepositResponse defines the Msg/Deposit response type.
struct Injective_Exchange_V1beta1_MsgDepositResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWithdraw defines a SDK message for withdrawing coins from a subaccount's
/// deposits to the user's bank balance
struct Injective_Exchange_V1beta1_MsgWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  /// bytes32 subaccount ID to withdraw funds from
  var subaccountID: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgWithdraw defines the Msg/Withdraw response type.
struct Injective_Exchange_V1beta1_MsgWithdrawResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateSpotLimitOrder defines a SDK message for creating a new spot limit
/// order.
struct Injective_Exchange_V1beta1_MsgCreateSpotLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var order: Injective_Exchange_V1beta1_SpotOrder {
    get {return _order ?? Injective_Exchange_V1beta1_SpotOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_SpotOrder? = nil
}

/// MsgCreateSpotLimitOrderResponse defines the Msg/CreateSpotOrder response
/// type.
struct Injective_Exchange_V1beta1_MsgCreateSpotLimitOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCreateSpotLimitOrders defines a SDK message for creating a new batch
/// of spot limit orders.
struct Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var orders: [Injective_Exchange_V1beta1_SpotOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCreateSpotLimitOrdersResponse defines the
/// Msg/BatchCreateSpotLimitOrders response type.
struct Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHashes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantSpotMarketLaunch defines a SDK message for creating a new spot
/// market by paying listing fee without governance
struct Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  /// Ticker for the spot market.
  var ticker: String = String()

  /// type of coin to use as the base currency
  var baseDenom: String = String()

  /// type of coin to use as the quote currency
  var quoteDenom: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's
  /// quantity
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantSpotMarketLaunchResponse defines the Msg/InstantSpotMarketLaunch
/// response type.
struct Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantPerpetualMarketLaunch defines a SDK message for creating a new
/// perpetual futures market by paying listing fee without governance
struct Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  /// Ticker for the derivative market.
  var ticker: String = String()

  /// type of coin to use as the base currency
  var quoteDenom: String = String()

  /// Oracle base currency
  var oracleBase: String = String()

  /// Oracle quote currency
  var oracleQuote: String = String()

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  /// maker_fee_rate defines the trade fee rate for makers on the perpetual
  /// market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the trade fee rate for takers on the perpetual
  /// market
  var takerFeeRate: String = String()

  /// initial_margin_ratio defines the initial margin ratio for the perpetual
  /// market
  var initialMarginRatio: String = String()

  /// maintenance_margin_ratio defines the maintenance margin ratio for the
  /// perpetual market
  var maintenanceMarginRatio: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price and
  /// margin
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's
  /// quantity
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantPerpetualMarketLaunchResponse defines the
/// Msg/InstantPerpetualMarketLaunchResponse response type.
struct Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantBinaryOptionsMarketLaunch defines a SDK message for creating a new
/// perpetual futures market by paying listing fee without governance
struct Injective_Exchange_V1beta1_MsgInstantBinaryOptionsMarketLaunch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  /// Ticker for the derivative contract.
  var ticker: String = String()

  /// Oracle symbol
  var oracleSymbol: String = String()

  /// Oracle Provider
  var oracleProvider: String = String()

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// maker_fee_rate defines the trade fee rate for makers on the perpetual
  /// market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the trade fee rate for takers on the perpetual
  /// market
  var takerFeeRate: String = String()

  /// expiration timestamp
  var expirationTimestamp: Int64 = 0

  /// expiration timestamp
  var settlementTimestamp: Int64 = 0

  /// admin of the market
  var admin: String = String()

  /// Address of the quote currency denomination for the binary options contract
  var quoteDenom: String = String()

  /// min_price_tick_size defines the minimum tick size that the price and margin
  /// required for orders in the market
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the quantity
  /// required for orders in the market
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantBinaryOptionsMarketLaunchResponse defines the
/// Msg/InstantBinaryOptionsMarketLaunchResponse response type.
struct Injective_Exchange_V1beta1_MsgInstantBinaryOptionsMarketLaunchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantExpiryFuturesMarketLaunch defines a SDK message for creating a new
/// expiry futures market by paying listing fee without governance
struct Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  /// Ticker for the derivative market.
  var ticker: String = String()

  /// type of coin to use as the quote currency
  var quoteDenom: String = String()

  /// Oracle base currency
  var oracleBase: String = String()

  /// Oracle quote currency
  var oracleQuote: String = String()

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// Expiration time of the market
  var expiry: Int64 = 0

  /// maker_fee_rate defines the trade fee rate for makers on the expiry futures
  /// market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the trade fee rate for takers on the expiry futures
  /// market
  var takerFeeRate: String = String()

  /// initial_margin_ratio defines the initial margin ratio for the derivative
  /// market
  var initialMarginRatio: String = String()

  /// maintenance_margin_ratio defines the maintenance margin ratio for the
  /// derivative market
  var maintenanceMarginRatio: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price and
  /// margin
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's
  /// quantity
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantExpiryFuturesMarketLaunchResponse defines the
/// Msg/InstantExpiryFuturesMarketLaunch response type.
struct Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateSpotMarketOrder defines a SDK message for creating a new spot market
/// order.
struct Injective_Exchange_V1beta1_MsgCreateSpotMarketOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var order: Injective_Exchange_V1beta1_SpotOrder {
    get {return _order ?? Injective_Exchange_V1beta1_SpotOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_SpotOrder? = nil
}

/// MsgCreateSpotMarketOrderResponse defines the Msg/CreateSpotMarketLimitOrder
/// response type.
struct Injective_Exchange_V1beta1_MsgCreateSpotMarketOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHash: String = String()

  var results: Injective_Exchange_V1beta1_SpotMarketOrderResults {
    get {return _results ?? Injective_Exchange_V1beta1_SpotMarketOrderResults()}
    set {_results = newValue}
  }
  /// Returns true if `results` has been explicitly set.
  var hasResults: Bool {return self._results != nil}
  /// Clears the value of `results`. Subsequent reads from it will return its default value.
  mutating func clearResults() {self._results = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _results: Injective_Exchange_V1beta1_SpotMarketOrderResults? = nil
}

struct Injective_Exchange_V1beta1_SpotMarketOrderResults {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var quantity: String = String()

  var price: String = String()

  var fee: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgCreateDerivativeLimitOrder
struct Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var order: Injective_Exchange_V1beta1_DerivativeOrder {
    get {return _order ?? Injective_Exchange_V1beta1_DerivativeOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_DerivativeOrder? = nil
}

/// MsgCreateDerivativeLimitOrderResponse defines the
/// Msg/CreateDerivativeMarketOrder response type.
struct Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgCreateBinaryOptionsLimitOrder
struct Injective_Exchange_V1beta1_MsgCreateBinaryOptionsLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var order: Injective_Exchange_V1beta1_DerivativeOrder {
    get {return _order ?? Injective_Exchange_V1beta1_DerivativeOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_DerivativeOrder? = nil
}

/// MsgCreateBinaryOptionsLimitOrderResponse defines the
/// Msg/CreateBinaryOptionsLimitOrder response type.
struct Injective_Exchange_V1beta1_MsgCreateBinaryOptionsLimitOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgBatchCreateDerivativeLimitOrders
struct Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var orders: [Injective_Exchange_V1beta1_DerivativeOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCreateDerivativeLimitOrdersResponse defines the
/// Msg/BatchCreateDerivativeLimitOrders response type.
struct Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHashes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCancelSpotOrder defines the Msg/CancelSpotOrder response type.
struct Injective_Exchange_V1beta1_MsgCancelSpotOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var marketID: String = String()

  var subaccountID: String = String()

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCancelSpotOrderResponse defines the Msg/CancelSpotOrder response type.
struct Injective_Exchange_V1beta1_MsgCancelSpotOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCancelSpotOrders defines the Msg/BatchCancelSpotOrders response type.
struct Injective_Exchange_V1beta1_MsgBatchCancelSpotOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var data: [Injective_Exchange_V1beta1_OrderData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCancelSpotOrdersResponse defines the Msg/BatchCancelSpotOrders
/// response type.
struct Injective_Exchange_V1beta1_MsgBatchCancelSpotOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: [Bool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCancelBinaryOptionsOrders defines the
/// Msg/BatchCancelBinaryOptionsOrders response type.
struct Injective_Exchange_V1beta1_MsgBatchCancelBinaryOptionsOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var data: [Injective_Exchange_V1beta1_OrderData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BatchCancelBinaryOptionsOrdersResponse defines the
/// Msg/BatchCancelBinaryOptionsOrders response type.
struct Injective_Exchange_V1beta1_MsgBatchCancelBinaryOptionsOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: [Bool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchUpdateOrders defines the Msg/BatchUpdateOrders response type.
struct Injective_Exchange_V1beta1_MsgBatchUpdateOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  /// subaccount_id only used for the spot_market_ids_to_cancel_all and
  /// derivative_market_ids_to_cancel_all.
  var subaccountID: String = String()

  var spotMarketIdsToCancelAll: [String] = []

  var derivativeMarketIdsToCancelAll: [String] = []

  var spotOrdersToCancel: [Injective_Exchange_V1beta1_OrderData] = []

  var derivativeOrdersToCancel: [Injective_Exchange_V1beta1_OrderData] = []

  var spotOrdersToCreate: [Injective_Exchange_V1beta1_SpotOrder] = []

  var derivativeOrdersToCreate: [Injective_Exchange_V1beta1_DerivativeOrder] = []

  var binaryOptionsOrdersToCancel: [Injective_Exchange_V1beta1_OrderData] = []

  var binaryOptionsMarketIdsToCancelAll: [String] = []

  var binaryOptionsOrdersToCreate: [Injective_Exchange_V1beta1_DerivativeOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchUpdateOrdersResponse defines the Msg/BatchUpdateOrders response type.
struct Injective_Exchange_V1beta1_MsgBatchUpdateOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var spotCancelSuccess: [Bool] = []

  var derivativeCancelSuccess: [Bool] = []

  var spotOrderHashes: [String] = []

  var derivativeOrderHashes: [String] = []

  var binaryOptionsCancelSuccess: [Bool] = []

  var binaryOptionsOrderHashes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgCreateDerivativeMarketOrder
struct Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var order: Injective_Exchange_V1beta1_DerivativeOrder {
    get {return _order ?? Injective_Exchange_V1beta1_DerivativeOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_DerivativeOrder? = nil
}

/// MsgCreateDerivativeMarketOrderResponse defines the
/// Msg/CreateDerivativeMarketOrder response type.
struct Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHash: String = String()

  var results: Injective_Exchange_V1beta1_DerivativeMarketOrderResults {
    get {return _results ?? Injective_Exchange_V1beta1_DerivativeMarketOrderResults()}
    set {_results = newValue}
  }
  /// Returns true if `results` has been explicitly set.
  var hasResults: Bool {return self._results != nil}
  /// Clears the value of `results`. Subsequent reads from it will return its default value.
  mutating func clearResults() {self._results = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _results: Injective_Exchange_V1beta1_DerivativeMarketOrderResults? = nil
}

struct Injective_Exchange_V1beta1_DerivativeMarketOrderResults {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var quantity: String = String()

  var price: String = String()

  var fee: String = String()

  var positionDelta: Injective_Exchange_V1beta1_PositionDelta {
    get {return _positionDelta ?? Injective_Exchange_V1beta1_PositionDelta()}
    set {_positionDelta = newValue}
  }
  /// Returns true if `positionDelta` has been explicitly set.
  var hasPositionDelta: Bool {return self._positionDelta != nil}
  /// Clears the value of `positionDelta`. Subsequent reads from it will return its default value.
  mutating func clearPositionDelta() {self._positionDelta = nil}

  var payout: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _positionDelta: Injective_Exchange_V1beta1_PositionDelta? = nil
}

/// A Cosmos-SDK MsgCreateBinaryOptionsMarketOrder
struct Injective_Exchange_V1beta1_MsgCreateBinaryOptionsMarketOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var order: Injective_Exchange_V1beta1_DerivativeOrder {
    get {return _order ?? Injective_Exchange_V1beta1_DerivativeOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_DerivativeOrder? = nil
}

/// MsgCreateBinaryOptionsMarketOrderResponse defines the
/// Msg/CreateBinaryOptionsMarketOrder response type.
struct Injective_Exchange_V1beta1_MsgCreateBinaryOptionsMarketOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHash: String = String()

  var results: Injective_Exchange_V1beta1_DerivativeMarketOrderResults {
    get {return _results ?? Injective_Exchange_V1beta1_DerivativeMarketOrderResults()}
    set {_results = newValue}
  }
  /// Returns true if `results` has been explicitly set.
  var hasResults: Bool {return self._results != nil}
  /// Clears the value of `results`. Subsequent reads from it will return its default value.
  mutating func clearResults() {self._results = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _results: Injective_Exchange_V1beta1_DerivativeMarketOrderResults? = nil
}

/// MsgCancelDerivativeOrder defines the Msg/CancelDerivativeOrder response type.
struct Injective_Exchange_V1beta1_MsgCancelDerivativeOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var marketID: String = String()

  var subaccountID: String = String()

  var orderHash: String = String()

  /// bitwise combination of OrderMask enum values
  var orderMask: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCancelDerivativeOrderResponse defines the
/// Msg/CancelDerivativeOrderResponse response type.
struct Injective_Exchange_V1beta1_MsgCancelDerivativeOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCancelBinaryOptionsOrder defines the Msg/CancelBinaryOptionsOrder response
/// type.
struct Injective_Exchange_V1beta1_MsgCancelBinaryOptionsOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var marketID: String = String()

  var subaccountID: String = String()

  var orderHash: String = String()

  /// bitwise combination of OrderMask enum values
  var orderMask: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCancelBinaryOptionsOrderResponse defines the
/// Msg/CancelBinaryOptionsOrderResponse response type.
struct Injective_Exchange_V1beta1_MsgCancelBinaryOptionsOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_OrderData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var subaccountID: String = String()

  var orderHash: String = String()

  /// bitwise combination of OrderMask enum values
  var orderMask: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCancelDerivativeOrders defines the Msg/CancelDerivativeOrders
/// response type.
struct Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var data: [Injective_Exchange_V1beta1_OrderData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCancelDerivativeOrdersResponse defines the
/// Msg/CancelDerivativeOrderResponse response type.
struct Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: [Bool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgSubaccountTransfer
struct Injective_Exchange_V1beta1_MsgSubaccountTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var sourceSubaccountID: String = String()

  var destinationSubaccountID: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgSubaccountTransferResponse defines the Msg/SubaccountTransfer response
/// type.
struct Injective_Exchange_V1beta1_MsgSubaccountTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgExternalTransfer
struct Injective_Exchange_V1beta1_MsgExternalTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var sourceSubaccountID: String = String()

  var destinationSubaccountID: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgExternalTransferResponse defines the Msg/ExternalTransfer response type.
struct Injective_Exchange_V1beta1_MsgExternalTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgLiquidatePosition
struct Injective_Exchange_V1beta1_MsgLiquidatePosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var subaccountID: String = String()

  var marketID: String = String()

  /// optional order to provide for liquidation
  var order: Injective_Exchange_V1beta1_DerivativeOrder {
    get {return _order ?? Injective_Exchange_V1beta1_DerivativeOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_DerivativeOrder? = nil
}

/// MsgLiquidatePositionResponse defines the Msg/LiquidatePosition response type.
struct Injective_Exchange_V1beta1_MsgLiquidatePositionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgIncreasePositionMargin
struct Injective_Exchange_V1beta1_MsgIncreasePositionMargin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var sourceSubaccountID: String = String()

  var destinationSubaccountID: String = String()

  var marketID: String = String()

  /// amount defines the amount of margin to add to the position
  var amount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgIncreasePositionMarginResponse defines the Msg/IncreasePositionMargin
/// response type.
struct Injective_Exchange_V1beta1_MsgIncreasePositionMarginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgPrivilegedExecuteContract defines the Msg/Exec message type
struct Injective_Exchange_V1beta1_MsgPrivilegedExecuteContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  /// funds defines the user's bank coins used to fund the execution (e.g.
  /// 100inj).
  var funds: String = String()

  /// contract_address defines the contract address to execute
  var contractAddress: String = String()

  /// data defines the call data used when executing the contract
  var data: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgPrivilegedExecuteContractResponse defines the Msg/Exec response type.
struct Injective_Exchange_V1beta1_MsgPrivilegedExecuteContractResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fundsDiff: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_SpotMarketParamUpdateProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var marketID: String = String()

  /// maker_fee_rate defines the trade fee rate for makers on the spot market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the trade fee rate for takers on the spot market
  var takerFeeRate: String = String()

  /// relayer_fee_share_rate defines the relayer fee share rate for the spot
  /// market
  var relayerFeeShareRate: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price and
  /// margin
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's
  /// quantity
  var minQuantityTickSize: String = String()

  var status: Injective_Exchange_V1beta1_MarketStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_ExchangeEnableProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var exchangeType: Injective_Exchange_V1beta1_ExchangeType = .exchangeUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_BatchExchangeModificationProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var spotMarketParamUpdateProposals: [Injective_Exchange_V1beta1_SpotMarketParamUpdateProposal] {
    get {return _storage._spotMarketParamUpdateProposals}
    set {_uniqueStorage()._spotMarketParamUpdateProposals = newValue}
  }

  var derivativeMarketParamUpdateProposals: [Injective_Exchange_V1beta1_DerivativeMarketParamUpdateProposal] {
    get {return _storage._derivativeMarketParamUpdateProposals}
    set {_uniqueStorage()._derivativeMarketParamUpdateProposals = newValue}
  }

  var spotMarketLaunchProposals: [Injective_Exchange_V1beta1_SpotMarketLaunchProposal] {
    get {return _storage._spotMarketLaunchProposals}
    set {_uniqueStorage()._spotMarketLaunchProposals = newValue}
  }

  var perpetualMarketLaunchProposals: [Injective_Exchange_V1beta1_PerpetualMarketLaunchProposal] {
    get {return _storage._perpetualMarketLaunchProposals}
    set {_uniqueStorage()._perpetualMarketLaunchProposals = newValue}
  }

  var expiryFuturesMarketLaunchProposals: [Injective_Exchange_V1beta1_ExpiryFuturesMarketLaunchProposal] {
    get {return _storage._expiryFuturesMarketLaunchProposals}
    set {_uniqueStorage()._expiryFuturesMarketLaunchProposals = newValue}
  }

  var tradingRewardCampaignUpdateProposal: Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal {
    get {return _storage._tradingRewardCampaignUpdateProposal ?? Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal()}
    set {_uniqueStorage()._tradingRewardCampaignUpdateProposal = newValue}
  }
  /// Returns true if `tradingRewardCampaignUpdateProposal` has been explicitly set.
  var hasTradingRewardCampaignUpdateProposal: Bool {return _storage._tradingRewardCampaignUpdateProposal != nil}
  /// Clears the value of `tradingRewardCampaignUpdateProposal`. Subsequent reads from it will return its default value.
  mutating func clearTradingRewardCampaignUpdateProposal() {_uniqueStorage()._tradingRewardCampaignUpdateProposal = nil}

  var binaryOptionsMarketLaunchProposals: [Injective_Exchange_V1beta1_BinaryOptionsMarketLaunchProposal] {
    get {return _storage._binaryOptionsMarketLaunchProposals}
    set {_uniqueStorage()._binaryOptionsMarketLaunchProposals = newValue}
  }

  var binaryOptionsParamUpdateProposals: [Injective_Exchange_V1beta1_BinaryOptionsMarketParamUpdateProposal] {
    get {return _storage._binaryOptionsParamUpdateProposals}
    set {_uniqueStorage()._binaryOptionsParamUpdateProposals = newValue}
  }

  var denomDecimalsUpdateProposal: Injective_Exchange_V1beta1_UpdateDenomDecimalsProposal {
    get {return _storage._denomDecimalsUpdateProposal ?? Injective_Exchange_V1beta1_UpdateDenomDecimalsProposal()}
    set {_uniqueStorage()._denomDecimalsUpdateProposal = newValue}
  }
  /// Returns true if `denomDecimalsUpdateProposal` has been explicitly set.
  var hasDenomDecimalsUpdateProposal: Bool {return _storage._denomDecimalsUpdateProposal != nil}
  /// Clears the value of `denomDecimalsUpdateProposal`. Subsequent reads from it will return its default value.
  mutating func clearDenomDecimalsUpdateProposal() {_uniqueStorage()._denomDecimalsUpdateProposal = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SpotMarketLaunchProposal defines a SDK message for proposing a new spot
/// market through governance
struct Injective_Exchange_V1beta1_SpotMarketLaunchProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  /// Ticker for the spot market.
  var ticker: String = String()

  /// type of coin to use as the base currency
  var baseDenom: String = String()

  /// type of coin to use as the quote currency
  var quoteDenom: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's
  /// quantity
  var minQuantityTickSize: String = String()

  /// maker_fee_rate defines the fee percentage makers pay when trading
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the fee percentage takers pay when trading
  var takerFeeRate: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PerpetualMarketLaunchProposal defines a SDK message for proposing a new
/// perpetual futures market through governance
struct Injective_Exchange_V1beta1_PerpetualMarketLaunchProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  /// Ticker for the derivative market.
  var ticker: String = String()

  /// type of coin to use as the base currency
  var quoteDenom: String = String()

  /// Oracle base currency
  var oracleBase: String = String()

  /// Oracle quote currency
  var oracleQuote: String = String()

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  /// initial_margin_ratio defines the initial margin ratio for the derivative
  /// market
  var initialMarginRatio: String = String()

  /// maintenance_margin_ratio defines the maintenance margin ratio for the
  /// derivative market
  var maintenanceMarginRatio: String = String()

  /// maker_fee_rate defines the exchange trade fee for makers for the derivative
  /// market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the exchange trade fee for takers for the derivative
  /// market
  var takerFeeRate: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price and
  /// margin
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's
  /// quantity
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_BinaryOptionsMarketLaunchProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  /// Ticker for the derivative contract.
  var ticker: String = String()

  /// Oracle symbol
  var oracleSymbol: String = String()

  /// Oracle Provider
  var oracleProvider: String = String()

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// expiration timestamp
  var expirationTimestamp: Int64 = 0

  /// expiration timestamp
  var settlementTimestamp: Int64 = 0

  /// admin of the market
  var admin: String = String()

  /// Address of the quote currency denomination for the binary options contract
  var quoteDenom: String = String()

  /// maker_fee_rate defines the maker fee rate of a binary options market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the taker fee rate of a derivative market
  var takerFeeRate: String = String()

  /// min_price_tick_size defines the minimum tick size that the price and margin
  /// required for orders in the market
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the quantity
  /// required for orders in the market
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ExpiryFuturesMarketLaunchProposal defines a SDK message for proposing a new
/// expiry futures market through governance
struct Injective_Exchange_V1beta1_ExpiryFuturesMarketLaunchProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  /// Ticker for the derivative market.
  var ticker: String = String()

  /// type of coin to use as the quote currency
  var quoteDenom: String = String()

  /// Oracle base currency
  var oracleBase: String = String()

  /// Oracle quote currency
  var oracleQuote: String = String()

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  /// Expiration time of the market
  var expiry: Int64 = 0

  /// initial_margin_ratio defines the initial margin ratio for the derivative
  /// market
  var initialMarginRatio: String = String()

  /// maintenance_margin_ratio defines the maintenance margin ratio for the
  /// derivative market
  var maintenanceMarginRatio: String = String()

  /// maker_fee_rate defines the exchange trade fee for makers for the derivative
  /// market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the exchange trade fee for takers for the derivative
  /// market
  var takerFeeRate: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price and
  /// margin
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's
  /// quantity
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_DerivativeMarketParamUpdateProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var marketID: String {
    get {return _storage._marketID}
    set {_uniqueStorage()._marketID = newValue}
  }

  /// initial_margin_ratio defines the initial margin ratio for the derivative
  /// market
  var initialMarginRatio: String {
    get {return _storage._initialMarginRatio}
    set {_uniqueStorage()._initialMarginRatio = newValue}
  }

  /// maintenance_margin_ratio defines the maintenance margin ratio for the
  /// derivative market
  var maintenanceMarginRatio: String {
    get {return _storage._maintenanceMarginRatio}
    set {_uniqueStorage()._maintenanceMarginRatio = newValue}
  }

  /// maker_fee_rate defines the exchange trade fee for makers for the derivative
  /// market
  var makerFeeRate: String {
    get {return _storage._makerFeeRate}
    set {_uniqueStorage()._makerFeeRate = newValue}
  }

  /// taker_fee_rate defines the exchange trade fee for takers for the derivative
  /// market
  var takerFeeRate: String {
    get {return _storage._takerFeeRate}
    set {_uniqueStorage()._takerFeeRate = newValue}
  }

  /// relayer_fee_share_rate defines the relayer fee share rate for the
  /// derivative market
  var relayerFeeShareRate: String {
    get {return _storage._relayerFeeShareRate}
    set {_uniqueStorage()._relayerFeeShareRate = newValue}
  }

  /// min_price_tick_size defines the minimum tick size of the order's price and
  /// margin
  var minPriceTickSize: String {
    get {return _storage._minPriceTickSize}
    set {_uniqueStorage()._minPriceTickSize = newValue}
  }

  /// min_quantity_tick_size defines the minimum tick size of the order's
  /// quantity
  var minQuantityTickSize: String {
    get {return _storage._minQuantityTickSize}
    set {_uniqueStorage()._minQuantityTickSize = newValue}
  }

  /// hourly_interest_rate defines the hourly interest rate
  var hourlyInterestRate: String {
    get {return _storage._hourlyInterestRate}
    set {_uniqueStorage()._hourlyInterestRate = newValue}
  }

  /// hourly_funding_rate_cap defines the maximum absolute value of the hourly
  /// funding rate
  var hourlyFundingRateCap: String {
    get {return _storage._hourlyFundingRateCap}
    set {_uniqueStorage()._hourlyFundingRateCap = newValue}
  }

  var status: Injective_Exchange_V1beta1_MarketStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var oracleParams: Injective_Exchange_V1beta1_OracleParams {
    get {return _storage._oracleParams ?? Injective_Exchange_V1beta1_OracleParams()}
    set {_uniqueStorage()._oracleParams = newValue}
  }
  /// Returns true if `oracleParams` has been explicitly set.
  var hasOracleParams: Bool {return _storage._oracleParams != nil}
  /// Clears the value of `oracleParams`. Subsequent reads from it will return its default value.
  mutating func clearOracleParams() {_uniqueStorage()._oracleParams = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_MarketForcedSettlementProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var marketID: String = String()

  var settlementPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_UpdateDenomDecimalsProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var denomDecimals: [Injective_Exchange_V1beta1_DenomDecimals] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_BinaryOptionsMarketParamUpdateProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var marketID: String {
    get {return _storage._marketID}
    set {_uniqueStorage()._marketID = newValue}
  }

  /// maker_fee_rate defines the exchange trade fee for makers for the derivative
  /// market
  var makerFeeRate: String {
    get {return _storage._makerFeeRate}
    set {_uniqueStorage()._makerFeeRate = newValue}
  }

  /// taker_fee_rate defines the exchange trade fee for takers for the derivative
  /// market
  var takerFeeRate: String {
    get {return _storage._takerFeeRate}
    set {_uniqueStorage()._takerFeeRate = newValue}
  }

  /// relayer_fee_share_rate defines the relayer fee share rate for the
  /// derivative market
  var relayerFeeShareRate: String {
    get {return _storage._relayerFeeShareRate}
    set {_uniqueStorage()._relayerFeeShareRate = newValue}
  }

  /// min_price_tick_size defines the minimum tick size of the order's price and
  /// margin
  var minPriceTickSize: String {
    get {return _storage._minPriceTickSize}
    set {_uniqueStorage()._minPriceTickSize = newValue}
  }

  /// min_quantity_tick_size defines the minimum tick size of the order's
  /// quantity
  var minQuantityTickSize: String {
    get {return _storage._minQuantityTickSize}
    set {_uniqueStorage()._minQuantityTickSize = newValue}
  }

  /// expiration timestamp
  var expirationTimestamp: Int64 {
    get {return _storage._expirationTimestamp}
    set {_uniqueStorage()._expirationTimestamp = newValue}
  }

  /// expiration timestamp
  var settlementTimestamp: Int64 {
    get {return _storage._settlementTimestamp}
    set {_uniqueStorage()._settlementTimestamp = newValue}
  }

  /// new price at which market will be settled
  var settlementPrice: String {
    get {return _storage._settlementPrice}
    set {_uniqueStorage()._settlementPrice = newValue}
  }

  /// admin of the market
  var admin: String {
    get {return _storage._admin}
    set {_uniqueStorage()._admin = newValue}
  }

  var status: Injective_Exchange_V1beta1_MarketStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var oracleParams: Injective_Exchange_V1beta1_ProviderOracleParams {
    get {return _storage._oracleParams ?? Injective_Exchange_V1beta1_ProviderOracleParams()}
    set {_uniqueStorage()._oracleParams = newValue}
  }
  /// Returns true if `oracleParams` has been explicitly set.
  var hasOracleParams: Bool {return _storage._oracleParams != nil}
  /// Clears the value of `oracleParams`. Subsequent reads from it will return its default value.
  mutating func clearOracleParams() {_uniqueStorage()._oracleParams = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_ProviderOracleParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Oracle base currency
  var symbol: String = String()

  /// Oracle quote currency
  var provider: String = String()

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_OracleParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Oracle base currency
  var oracleBase: String = String()

  /// Oracle quote currency
  var oracleQuote: String = String()

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradingRewardCampaignLaunchProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var campaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo {
    get {return _campaignInfo ?? Injective_Exchange_V1beta1_TradingRewardCampaignInfo()}
    set {_campaignInfo = newValue}
  }
  /// Returns true if `campaignInfo` has been explicitly set.
  var hasCampaignInfo: Bool {return self._campaignInfo != nil}
  /// Clears the value of `campaignInfo`. Subsequent reads from it will return its default value.
  mutating func clearCampaignInfo() {self._campaignInfo = nil}

  var campaignRewardPools: [Injective_Exchange_V1beta1_CampaignRewardPool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _campaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo? = nil
}

struct Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var campaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo {
    get {return _campaignInfo ?? Injective_Exchange_V1beta1_TradingRewardCampaignInfo()}
    set {_campaignInfo = newValue}
  }
  /// Returns true if `campaignInfo` has been explicitly set.
  var hasCampaignInfo: Bool {return self._campaignInfo != nil}
  /// Clears the value of `campaignInfo`. Subsequent reads from it will return its default value.
  mutating func clearCampaignInfo() {self._campaignInfo = nil}

  var campaignRewardPoolsAdditions: [Injective_Exchange_V1beta1_CampaignRewardPool] = []

  var campaignRewardPoolsUpdates: [Injective_Exchange_V1beta1_CampaignRewardPool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _campaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo? = nil
}

struct Injective_Exchange_V1beta1_RewardPointUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountAddress: String = String()

  /// new_points overwrites the current trading reward points for the account
  var newPoints: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradingRewardPendingPointsUpdateProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var pendingPoolTimestamp: Int64 = 0

  var rewardPointUpdates: [Injective_Exchange_V1beta1_RewardPointUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_FeeDiscountProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var schedule: Injective_Exchange_V1beta1_FeeDiscountSchedule {
    get {return _schedule ?? Injective_Exchange_V1beta1_FeeDiscountSchedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  mutating func clearSchedule() {self._schedule = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _schedule: Injective_Exchange_V1beta1_FeeDiscountSchedule? = nil
}

struct Injective_Exchange_V1beta1_BatchCommunityPoolSpendProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var proposals: [Cosmos_Distribution_V1beta1_CommunityPoolSpendProposal] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgRewardsOptOut
struct Injective_Exchange_V1beta1_MsgRewardsOptOut {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRewardsOptOutResponse defines the Msg/RewardsOptOut response type.
struct Injective_Exchange_V1beta1_MsgRewardsOptOutResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgReclaimLockedFunds
struct Injective_Exchange_V1beta1_MsgReclaimLockedFunds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var lockedAccountPubKey: Data = Data()

  var signature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgReclaimLockedFundsResponse defines the Msg/ReclaimLockedFunds response
/// type.
struct Injective_Exchange_V1beta1_MsgReclaimLockedFundsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSignData defines an arbitrary, general-purpose, off-chain message
struct Injective_Exchange_V1beta1_MsgSignData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Signer is the sdk.AccAddress of the message signer
  var signer: Data = Data()

  /// Data represents the raw bytes of the content that is signed (text, json,
  /// etc)
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSignDoc defines an arbitrary, general-purpose, off-chain message
struct Injective_Exchange_V1beta1_MsgSignDoc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signType: String = String()

  var value: Injective_Exchange_V1beta1_MsgSignData {
    get {return _value ?? Injective_Exchange_V1beta1_MsgSignData()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Injective_Exchange_V1beta1_MsgSignData? = nil
}

/// MsgAdminUpdateBinaryOptionsMarket is used by the market Admin to operate the
/// market
struct Injective_Exchange_V1beta1_MsgAdminUpdateBinaryOptionsMarket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var marketID: String = String()

  /// new price at which market will be settled
  var settlementPrice: String = String()

  /// expiration timestamp
  var expirationTimestamp: Int64 = 0

  /// expiration timestamp
  var settlementTimestamp: Int64 = 0

  /// Status of the market
  var status: Injective_Exchange_V1beta1_MarketStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAdminUpdateBinaryOptionsMarketResponse is the response for
/// AdminUpdateBinaryOptionsMarket rpc method
struct Injective_Exchange_V1beta1_MsgAdminUpdateBinaryOptionsMarketResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AtomicMarketOrderFeeMultiplierScheduleProposal defines a SDK message for
/// proposing new atomic take fee multipliers for specified markets
struct Injective_Exchange_V1beta1_AtomicMarketOrderFeeMultiplierScheduleProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var marketFeeMultipliers: [Injective_Exchange_V1beta1_MarketFeeMultiplier] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Injective_Exchange_V1beta1_ExchangeType: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgUpdateParams: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgUpdateParamsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgDeposit: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgDepositResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgWithdraw: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgWithdrawResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCreateSpotLimitOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCreateSpotLimitOrderResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrders: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrdersResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunch: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunchResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunch: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunchResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgInstantBinaryOptionsMarketLaunch: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgInstantBinaryOptionsMarketLaunchResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunch: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunchResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCreateSpotMarketOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCreateSpotMarketOrderResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SpotMarketOrderResults: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrderResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCreateBinaryOptionsLimitOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCreateBinaryOptionsLimitOrderResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrders: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrdersResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCancelSpotOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCancelSpotOrderResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgBatchCancelSpotOrders: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgBatchCancelSpotOrdersResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgBatchCancelBinaryOptionsOrders: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgBatchCancelBinaryOptionsOrdersResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgBatchUpdateOrders: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgBatchUpdateOrdersResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrderResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_DerivativeMarketOrderResults: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCreateBinaryOptionsMarketOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCreateBinaryOptionsMarketOrderResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCancelDerivativeOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCancelDerivativeOrderResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCancelBinaryOptionsOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgCancelBinaryOptionsOrderResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_OrderData: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrders: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrdersResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgSubaccountTransfer: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgSubaccountTransferResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgExternalTransfer: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgExternalTransferResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgLiquidatePosition: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgLiquidatePositionResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgIncreasePositionMargin: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgIncreasePositionMarginResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgPrivilegedExecuteContract: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgPrivilegedExecuteContractResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SpotMarketParamUpdateProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_ExchangeEnableProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_BatchExchangeModificationProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SpotMarketLaunchProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_PerpetualMarketLaunchProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_BinaryOptionsMarketLaunchProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_ExpiryFuturesMarketLaunchProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_DerivativeMarketParamUpdateProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MarketForcedSettlementProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_UpdateDenomDecimalsProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_BinaryOptionsMarketParamUpdateProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_ProviderOracleParams: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_OracleParams: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TradingRewardCampaignLaunchProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_RewardPointUpdate: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TradingRewardPendingPointsUpdateProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_FeeDiscountProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_BatchCommunityPoolSpendProposal: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgRewardsOptOut: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgRewardsOptOutResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgReclaimLockedFunds: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgReclaimLockedFundsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgSignData: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgSignDoc: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgAdminUpdateBinaryOptionsMarket: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MsgAdminUpdateBinaryOptionsMarketResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_AtomicMarketOrderFeeMultiplierScheduleProposal: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "injective.exchange.v1beta1"

extension Injective_Exchange_V1beta1_ExchangeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXCHANGE_UNSPECIFIED"),
    1: .same(proto: "SPOT"),
    2: .same(proto: "DERIVATIVES"),
  ]
}

extension Injective_Exchange_V1beta1_MsgUpdateParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgUpdateParams, rhs: Injective_Exchange_V1beta1_MsgUpdateParams) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgUpdateParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParamsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgUpdateParamsResponse, rhs: Injective_Exchange_V1beta1_MsgUpdateParamsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "subaccount_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgDeposit, rhs: Injective_Exchange_V1beta1_MsgDeposit) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgDepositResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDepositResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgDepositResponse, rhs: Injective_Exchange_V1beta1_MsgDepositResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "subaccount_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgWithdraw, rhs: Injective_Exchange_V1beta1_MsgWithdraw) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgWithdrawResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgWithdrawResponse, rhs: Injective_Exchange_V1beta1_MsgWithdrawResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateSpotLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateSpotLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    try { if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateSpotLimitOrder, rhs: Injective_Exchange_V1beta1_MsgCreateSpotLimitOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateSpotLimitOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateSpotLimitOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateSpotLimitOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCreateSpotLimitOrderResponse) -> Bool {
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCreateSpotLimitOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrders, rhs: Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrders) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCreateSpotLimitOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hashes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.orderHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.orderHashes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrdersResponse, rhs: Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrdersResponse) -> Bool {
    if lhs.orderHashes != rhs.orderHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantSpotMarketLaunch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "base_denom"),
    4: .standard(proto: "quote_denom"),
    5: .standard(proto: "min_price_tick_size"),
    6: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.baseDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 2)
    }
    if !self.baseDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.baseDenom, fieldNumber: 3)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 4)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 5)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunch, rhs: Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunch) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.baseDenom != rhs.baseDenom {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantSpotMarketLaunchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunchResponse, rhs: Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantPerpetualMarketLaunch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "quote_denom"),
    4: .standard(proto: "oracle_base"),
    5: .standard(proto: "oracle_quote"),
    6: .standard(proto: "oracle_scale_factor"),
    7: .standard(proto: "oracle_type"),
    8: .standard(proto: "maker_fee_rate"),
    9: .standard(proto: "taker_fee_rate"),
    10: .standard(proto: "initial_margin_ratio"),
    11: .standard(proto: "maintenance_margin_ratio"),
    12: .standard(proto: "min_price_tick_size"),
    13: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.oracleBase) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.oracleQuote) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.initialMarginRatio) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.maintenanceMarginRatio) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 2)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 3)
    }
    if !self.oracleBase.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleBase, fieldNumber: 4)
    }
    if !self.oracleQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleQuote, fieldNumber: 5)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 6)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 7)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 8)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 9)
    }
    if !self.initialMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.initialMarginRatio, fieldNumber: 10)
    }
    if !self.maintenanceMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.maintenanceMarginRatio, fieldNumber: 11)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 12)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunch, rhs: Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunch) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.oracleBase != rhs.oracleBase {return false}
    if lhs.oracleQuote != rhs.oracleQuote {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.initialMarginRatio != rhs.initialMarginRatio {return false}
    if lhs.maintenanceMarginRatio != rhs.maintenanceMarginRatio {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantPerpetualMarketLaunchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunchResponse, rhs: Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantBinaryOptionsMarketLaunch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantBinaryOptionsMarketLaunch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "oracle_symbol"),
    4: .standard(proto: "oracle_provider"),
    5: .standard(proto: "oracle_type"),
    6: .standard(proto: "oracle_scale_factor"),
    7: .standard(proto: "maker_fee_rate"),
    8: .standard(proto: "taker_fee_rate"),
    9: .standard(proto: "expiration_timestamp"),
    10: .standard(proto: "settlement_timestamp"),
    11: .same(proto: "admin"),
    12: .standard(proto: "quote_denom"),
    13: .standard(proto: "min_price_tick_size"),
    14: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.oracleSymbol) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.oracleProvider) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.expirationTimestamp) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.settlementTimestamp) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 2)
    }
    if !self.oracleSymbol.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleSymbol, fieldNumber: 3)
    }
    if !self.oracleProvider.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleProvider, fieldNumber: 4)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 5)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 6)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 7)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 8)
    }
    if self.expirationTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationTimestamp, fieldNumber: 9)
    }
    if self.settlementTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.settlementTimestamp, fieldNumber: 10)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 11)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 12)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 13)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantBinaryOptionsMarketLaunch, rhs: Injective_Exchange_V1beta1_MsgInstantBinaryOptionsMarketLaunch) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.oracleSymbol != rhs.oracleSymbol {return false}
    if lhs.oracleProvider != rhs.oracleProvider {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.expirationTimestamp != rhs.expirationTimestamp {return false}
    if lhs.settlementTimestamp != rhs.settlementTimestamp {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantBinaryOptionsMarketLaunchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantBinaryOptionsMarketLaunchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantBinaryOptionsMarketLaunchResponse, rhs: Injective_Exchange_V1beta1_MsgInstantBinaryOptionsMarketLaunchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantExpiryFuturesMarketLaunch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "quote_denom"),
    4: .standard(proto: "oracle_base"),
    5: .standard(proto: "oracle_quote"),
    6: .standard(proto: "oracle_type"),
    7: .standard(proto: "oracle_scale_factor"),
    8: .same(proto: "expiry"),
    9: .standard(proto: "maker_fee_rate"),
    10: .standard(proto: "taker_fee_rate"),
    11: .standard(proto: "initial_margin_ratio"),
    12: .standard(proto: "maintenance_margin_ratio"),
    13: .standard(proto: "min_price_tick_size"),
    14: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.oracleBase) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.oracleQuote) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.expiry) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.initialMarginRatio) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.maintenanceMarginRatio) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 2)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 3)
    }
    if !self.oracleBase.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleBase, fieldNumber: 4)
    }
    if !self.oracleQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleQuote, fieldNumber: 5)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 6)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 7)
    }
    if self.expiry != 0 {
      try visitor.visitSingularInt64Field(value: self.expiry, fieldNumber: 8)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 9)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 10)
    }
    if !self.initialMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.initialMarginRatio, fieldNumber: 11)
    }
    if !self.maintenanceMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.maintenanceMarginRatio, fieldNumber: 12)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 13)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunch, rhs: Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunch) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.oracleBase != rhs.oracleBase {return false}
    if lhs.oracleQuote != rhs.oracleQuote {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.initialMarginRatio != rhs.initialMarginRatio {return false}
    if lhs.maintenanceMarginRatio != rhs.maintenanceMarginRatio {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantExpiryFuturesMarketLaunchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunchResponse, rhs: Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateSpotMarketOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateSpotMarketOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    try { if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateSpotMarketOrder, rhs: Injective_Exchange_V1beta1_MsgCreateSpotMarketOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateSpotMarketOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateSpotMarketOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hash"),
    2: .same(proto: "results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._results) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 1)
    }
    try { if let v = self._results {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateSpotMarketOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCreateSpotMarketOrderResponse) -> Bool {
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs._results != rhs._results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotMarketOrderResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotMarketOrderResults"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quantity"),
    2: .same(proto: "price"),
    3: .same(proto: "fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 1)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 2)
    }
    if !self.fee.isEmpty {
      try visitor.visitSingularStringField(value: self.fee, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotMarketOrderResults, rhs: Injective_Exchange_V1beta1_SpotMarketOrderResults) -> Bool {
    if lhs.quantity != rhs.quantity {return false}
    if lhs.price != rhs.price {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateDerivativeLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    try { if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrder, rhs: Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateDerivativeLimitOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrderResponse) -> Bool {
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateBinaryOptionsLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBinaryOptionsLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    try { if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateBinaryOptionsLimitOrder, rhs: Injective_Exchange_V1beta1_MsgCreateBinaryOptionsLimitOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateBinaryOptionsLimitOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBinaryOptionsLimitOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateBinaryOptionsLimitOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCreateBinaryOptionsLimitOrderResponse) -> Bool {
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCreateDerivativeLimitOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrders, rhs: Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrders) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCreateDerivativeLimitOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hashes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.orderHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.orderHashes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrdersResponse, rhs: Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrdersResponse) -> Bool {
    if lhs.orderHashes != rhs.orderHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCancelSpotOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelSpotOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "market_id"),
    3: .standard(proto: "subaccount_id"),
    4: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 3)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCancelSpotOrder, rhs: Injective_Exchange_V1beta1_MsgCancelSpotOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCancelSpotOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelSpotOrderResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCancelSpotOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCancelSpotOrderResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCancelSpotOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCancelSpotOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCancelSpotOrders, rhs: Injective_Exchange_V1beta1_MsgBatchCancelSpotOrders) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCancelSpotOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCancelSpotOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.success.isEmpty {
      try visitor.visitPackedBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCancelSpotOrdersResponse, rhs: Injective_Exchange_V1beta1_MsgBatchCancelSpotOrdersResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCancelBinaryOptionsOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCancelBinaryOptionsOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCancelBinaryOptionsOrders, rhs: Injective_Exchange_V1beta1_MsgBatchCancelBinaryOptionsOrders) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCancelBinaryOptionsOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCancelBinaryOptionsOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.success.isEmpty {
      try visitor.visitPackedBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCancelBinaryOptionsOrdersResponse, rhs: Injective_Exchange_V1beta1_MsgBatchCancelBinaryOptionsOrdersResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchUpdateOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchUpdateOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "subaccount_id"),
    3: .standard(proto: "spot_market_ids_to_cancel_all"),
    4: .standard(proto: "derivative_market_ids_to_cancel_all"),
    5: .standard(proto: "spot_orders_to_cancel"),
    6: .standard(proto: "derivative_orders_to_cancel"),
    7: .standard(proto: "spot_orders_to_create"),
    8: .standard(proto: "derivative_orders_to_create"),
    9: .standard(proto: "binary_options_orders_to_cancel"),
    10: .standard(proto: "binary_options_market_ids_to_cancel_all"),
    11: .standard(proto: "binary_options_orders_to_create"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.spotMarketIdsToCancelAll) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.derivativeMarketIdsToCancelAll) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.spotOrdersToCancel) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.derivativeOrdersToCancel) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.spotOrdersToCreate) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.derivativeOrdersToCreate) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.binaryOptionsOrdersToCancel) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.binaryOptionsMarketIdsToCancelAll) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.binaryOptionsOrdersToCreate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    if !self.spotMarketIdsToCancelAll.isEmpty {
      try visitor.visitRepeatedStringField(value: self.spotMarketIdsToCancelAll, fieldNumber: 3)
    }
    if !self.derivativeMarketIdsToCancelAll.isEmpty {
      try visitor.visitRepeatedStringField(value: self.derivativeMarketIdsToCancelAll, fieldNumber: 4)
    }
    if !self.spotOrdersToCancel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spotOrdersToCancel, fieldNumber: 5)
    }
    if !self.derivativeOrdersToCancel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.derivativeOrdersToCancel, fieldNumber: 6)
    }
    if !self.spotOrdersToCreate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spotOrdersToCreate, fieldNumber: 7)
    }
    if !self.derivativeOrdersToCreate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.derivativeOrdersToCreate, fieldNumber: 8)
    }
    if !self.binaryOptionsOrdersToCancel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.binaryOptionsOrdersToCancel, fieldNumber: 9)
    }
    if !self.binaryOptionsMarketIdsToCancelAll.isEmpty {
      try visitor.visitRepeatedStringField(value: self.binaryOptionsMarketIdsToCancelAll, fieldNumber: 10)
    }
    if !self.binaryOptionsOrdersToCreate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.binaryOptionsOrdersToCreate, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchUpdateOrders, rhs: Injective_Exchange_V1beta1_MsgBatchUpdateOrders) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.spotMarketIdsToCancelAll != rhs.spotMarketIdsToCancelAll {return false}
    if lhs.derivativeMarketIdsToCancelAll != rhs.derivativeMarketIdsToCancelAll {return false}
    if lhs.spotOrdersToCancel != rhs.spotOrdersToCancel {return false}
    if lhs.derivativeOrdersToCancel != rhs.derivativeOrdersToCancel {return false}
    if lhs.spotOrdersToCreate != rhs.spotOrdersToCreate {return false}
    if lhs.derivativeOrdersToCreate != rhs.derivativeOrdersToCreate {return false}
    if lhs.binaryOptionsOrdersToCancel != rhs.binaryOptionsOrdersToCancel {return false}
    if lhs.binaryOptionsMarketIdsToCancelAll != rhs.binaryOptionsMarketIdsToCancelAll {return false}
    if lhs.binaryOptionsOrdersToCreate != rhs.binaryOptionsOrdersToCreate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchUpdateOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchUpdateOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "spot_cancel_success"),
    2: .standard(proto: "derivative_cancel_success"),
    3: .standard(proto: "spot_order_hashes"),
    4: .standard(proto: "derivative_order_hashes"),
    5: .standard(proto: "binary_options_cancel_success"),
    6: .standard(proto: "binary_options_order_hashes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.spotCancelSuccess) }()
      case 2: try { try decoder.decodeRepeatedBoolField(value: &self.derivativeCancelSuccess) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.spotOrderHashes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.derivativeOrderHashes) }()
      case 5: try { try decoder.decodeRepeatedBoolField(value: &self.binaryOptionsCancelSuccess) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.binaryOptionsOrderHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spotCancelSuccess.isEmpty {
      try visitor.visitPackedBoolField(value: self.spotCancelSuccess, fieldNumber: 1)
    }
    if !self.derivativeCancelSuccess.isEmpty {
      try visitor.visitPackedBoolField(value: self.derivativeCancelSuccess, fieldNumber: 2)
    }
    if !self.spotOrderHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.spotOrderHashes, fieldNumber: 3)
    }
    if !self.derivativeOrderHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.derivativeOrderHashes, fieldNumber: 4)
    }
    if !self.binaryOptionsCancelSuccess.isEmpty {
      try visitor.visitPackedBoolField(value: self.binaryOptionsCancelSuccess, fieldNumber: 5)
    }
    if !self.binaryOptionsOrderHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.binaryOptionsOrderHashes, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchUpdateOrdersResponse, rhs: Injective_Exchange_V1beta1_MsgBatchUpdateOrdersResponse) -> Bool {
    if lhs.spotCancelSuccess != rhs.spotCancelSuccess {return false}
    if lhs.derivativeCancelSuccess != rhs.derivativeCancelSuccess {return false}
    if lhs.spotOrderHashes != rhs.spotOrderHashes {return false}
    if lhs.derivativeOrderHashes != rhs.derivativeOrderHashes {return false}
    if lhs.binaryOptionsCancelSuccess != rhs.binaryOptionsCancelSuccess {return false}
    if lhs.binaryOptionsOrderHashes != rhs.binaryOptionsOrderHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateDerivativeMarketOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    try { if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrder, rhs: Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateDerivativeMarketOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hash"),
    2: .same(proto: "results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._results) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 1)
    }
    try { if let v = self._results {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrderResponse) -> Bool {
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs._results != rhs._results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeMarketOrderResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeMarketOrderResults"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quantity"),
    2: .same(proto: "price"),
    3: .same(proto: "fee"),
    4: .standard(proto: "position_delta"),
    5: .same(proto: "payout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fee) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._positionDelta) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.payout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 1)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 2)
    }
    if !self.fee.isEmpty {
      try visitor.visitSingularStringField(value: self.fee, fieldNumber: 3)
    }
    try { if let v = self._positionDelta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.payout.isEmpty {
      try visitor.visitSingularStringField(value: self.payout, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeMarketOrderResults, rhs: Injective_Exchange_V1beta1_DerivativeMarketOrderResults) -> Bool {
    if lhs.quantity != rhs.quantity {return false}
    if lhs.price != rhs.price {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs._positionDelta != rhs._positionDelta {return false}
    if lhs.payout != rhs.payout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateBinaryOptionsMarketOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBinaryOptionsMarketOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    try { if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateBinaryOptionsMarketOrder, rhs: Injective_Exchange_V1beta1_MsgCreateBinaryOptionsMarketOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateBinaryOptionsMarketOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBinaryOptionsMarketOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hash"),
    2: .same(proto: "results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._results) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 1)
    }
    try { if let v = self._results {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateBinaryOptionsMarketOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCreateBinaryOptionsMarketOrderResponse) -> Bool {
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs._results != rhs._results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCancelDerivativeOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelDerivativeOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "market_id"),
    3: .standard(proto: "subaccount_id"),
    4: .standard(proto: "order_hash"),
    5: .standard(proto: "order_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.orderMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 3)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 4)
    }
    if self.orderMask != 0 {
      try visitor.visitSingularInt32Field(value: self.orderMask, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCancelDerivativeOrder, rhs: Injective_Exchange_V1beta1_MsgCancelDerivativeOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.orderMask != rhs.orderMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCancelDerivativeOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelDerivativeOrderResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCancelDerivativeOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCancelDerivativeOrderResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCancelBinaryOptionsOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelBinaryOptionsOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "market_id"),
    3: .standard(proto: "subaccount_id"),
    4: .standard(proto: "order_hash"),
    5: .standard(proto: "order_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.orderMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 3)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 4)
    }
    if self.orderMask != 0 {
      try visitor.visitSingularInt32Field(value: self.orderMask, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCancelBinaryOptionsOrder, rhs: Injective_Exchange_V1beta1_MsgCancelBinaryOptionsOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.orderMask != rhs.orderMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCancelBinaryOptionsOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelBinaryOptionsOrderResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCancelBinaryOptionsOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCancelBinaryOptionsOrderResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_OrderData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "subaccount_id"),
    3: .standard(proto: "order_hash"),
    4: .standard(proto: "order_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.orderMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 3)
    }
    if self.orderMask != 0 {
      try visitor.visitSingularInt32Field(value: self.orderMask, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_OrderData, rhs: Injective_Exchange_V1beta1_OrderData) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.orderMask != rhs.orderMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCancelDerivativeOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrders, rhs: Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrders) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCancelDerivativeOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.success.isEmpty {
      try visitor.visitPackedBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrdersResponse, rhs: Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrdersResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgSubaccountTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSubaccountTransfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "source_subaccount_id"),
    3: .standard(proto: "destination_subaccount_id"),
    4: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceSubaccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationSubaccountID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.sourceSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceSubaccountID, fieldNumber: 2)
    }
    if !self.destinationSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationSubaccountID, fieldNumber: 3)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgSubaccountTransfer, rhs: Injective_Exchange_V1beta1_MsgSubaccountTransfer) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.sourceSubaccountID != rhs.sourceSubaccountID {return false}
    if lhs.destinationSubaccountID != rhs.destinationSubaccountID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgSubaccountTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSubaccountTransferResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgSubaccountTransferResponse, rhs: Injective_Exchange_V1beta1_MsgSubaccountTransferResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgExternalTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgExternalTransfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "source_subaccount_id"),
    3: .standard(proto: "destination_subaccount_id"),
    4: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceSubaccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationSubaccountID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.sourceSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceSubaccountID, fieldNumber: 2)
    }
    if !self.destinationSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationSubaccountID, fieldNumber: 3)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgExternalTransfer, rhs: Injective_Exchange_V1beta1_MsgExternalTransfer) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.sourceSubaccountID != rhs.sourceSubaccountID {return false}
    if lhs.destinationSubaccountID != rhs.destinationSubaccountID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgExternalTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgExternalTransferResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgExternalTransferResponse, rhs: Injective_Exchange_V1beta1_MsgExternalTransferResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgLiquidatePosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgLiquidatePosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "subaccount_id"),
    3: .standard(proto: "market_id"),
    4: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 3)
    }
    try { if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgLiquidatePosition, rhs: Injective_Exchange_V1beta1_MsgLiquidatePosition) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgLiquidatePositionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgLiquidatePositionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgLiquidatePositionResponse, rhs: Injective_Exchange_V1beta1_MsgLiquidatePositionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgIncreasePositionMargin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgIncreasePositionMargin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "source_subaccount_id"),
    3: .standard(proto: "destination_subaccount_id"),
    4: .standard(proto: "market_id"),
    5: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceSubaccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationSubaccountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.sourceSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceSubaccountID, fieldNumber: 2)
    }
    if !self.destinationSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationSubaccountID, fieldNumber: 3)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 4)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgIncreasePositionMargin, rhs: Injective_Exchange_V1beta1_MsgIncreasePositionMargin) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.sourceSubaccountID != rhs.sourceSubaccountID {return false}
    if lhs.destinationSubaccountID != rhs.destinationSubaccountID {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgIncreasePositionMarginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgIncreasePositionMarginResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgIncreasePositionMarginResponse, rhs: Injective_Exchange_V1beta1_MsgIncreasePositionMarginResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgPrivilegedExecuteContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPrivilegedExecuteContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "funds"),
    3: .standard(proto: "contract_address"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.funds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.funds.isEmpty {
      try visitor.visitSingularStringField(value: self.funds, fieldNumber: 2)
    }
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgPrivilegedExecuteContract, rhs: Injective_Exchange_V1beta1_MsgPrivilegedExecuteContract) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.funds != rhs.funds {return false}
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgPrivilegedExecuteContractResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPrivilegedExecuteContractResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funds_diff"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fundsDiff) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fundsDiff.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fundsDiff, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgPrivilegedExecuteContractResponse, rhs: Injective_Exchange_V1beta1_MsgPrivilegedExecuteContractResponse) -> Bool {
    if lhs.fundsDiff != rhs.fundsDiff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotMarketParamUpdateProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotMarketParamUpdateProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "market_id"),
    4: .standard(proto: "maker_fee_rate"),
    5: .standard(proto: "taker_fee_rate"),
    6: .standard(proto: "relayer_fee_share_rate"),
    7: .standard(proto: "min_price_tick_size"),
    8: .standard(proto: "min_quantity_tick_size"),
    9: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.relayerFeeShareRate) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 3)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 4)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 5)
    }
    if !self.relayerFeeShareRate.isEmpty {
      try visitor.visitSingularStringField(value: self.relayerFeeShareRate, fieldNumber: 6)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 7)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 8)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotMarketParamUpdateProposal, rhs: Injective_Exchange_V1beta1_SpotMarketParamUpdateProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.relayerFeeShareRate != rhs.relayerFeeShareRate {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_ExchangeEnableProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExchangeEnableProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "exchangeType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.exchangeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if self.exchangeType != .exchangeUnspecified {
      try visitor.visitSingularEnumField(value: self.exchangeType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_ExchangeEnableProposal, rhs: Injective_Exchange_V1beta1_ExchangeEnableProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.exchangeType != rhs.exchangeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_BatchExchangeModificationProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchExchangeModificationProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "spot_market_param_update_proposals"),
    4: .standard(proto: "derivative_market_param_update_proposals"),
    5: .standard(proto: "spot_market_launch_proposals"),
    6: .standard(proto: "perpetual_market_launch_proposals"),
    7: .standard(proto: "expiry_futures_market_launch_proposals"),
    8: .standard(proto: "trading_reward_campaign_update_proposal"),
    9: .standard(proto: "binary_options_market_launch_proposals"),
    10: .standard(proto: "binary_options_param_update_proposals"),
    11: .standard(proto: "denom_decimals_update_proposal"),
  ]

  fileprivate class _StorageClass {
    var _title: String = String()
    var _description_p: String = String()
    var _spotMarketParamUpdateProposals: [Injective_Exchange_V1beta1_SpotMarketParamUpdateProposal] = []
    var _derivativeMarketParamUpdateProposals: [Injective_Exchange_V1beta1_DerivativeMarketParamUpdateProposal] = []
    var _spotMarketLaunchProposals: [Injective_Exchange_V1beta1_SpotMarketLaunchProposal] = []
    var _perpetualMarketLaunchProposals: [Injective_Exchange_V1beta1_PerpetualMarketLaunchProposal] = []
    var _expiryFuturesMarketLaunchProposals: [Injective_Exchange_V1beta1_ExpiryFuturesMarketLaunchProposal] = []
    var _tradingRewardCampaignUpdateProposal: Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal? = nil
    var _binaryOptionsMarketLaunchProposals: [Injective_Exchange_V1beta1_BinaryOptionsMarketLaunchProposal] = []
    var _binaryOptionsParamUpdateProposals: [Injective_Exchange_V1beta1_BinaryOptionsMarketParamUpdateProposal] = []
    var _denomDecimalsUpdateProposal: Injective_Exchange_V1beta1_UpdateDenomDecimalsProposal? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _title = source._title
      _description_p = source._description_p
      _spotMarketParamUpdateProposals = source._spotMarketParamUpdateProposals
      _derivativeMarketParamUpdateProposals = source._derivativeMarketParamUpdateProposals
      _spotMarketLaunchProposals = source._spotMarketLaunchProposals
      _perpetualMarketLaunchProposals = source._perpetualMarketLaunchProposals
      _expiryFuturesMarketLaunchProposals = source._expiryFuturesMarketLaunchProposals
      _tradingRewardCampaignUpdateProposal = source._tradingRewardCampaignUpdateProposal
      _binaryOptionsMarketLaunchProposals = source._binaryOptionsMarketLaunchProposals
      _binaryOptionsParamUpdateProposals = source._binaryOptionsParamUpdateProposals
      _denomDecimalsUpdateProposal = source._denomDecimalsUpdateProposal
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._spotMarketParamUpdateProposals) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._derivativeMarketParamUpdateProposals) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._spotMarketLaunchProposals) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._perpetualMarketLaunchProposals) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._expiryFuturesMarketLaunchProposals) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._tradingRewardCampaignUpdateProposal) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._binaryOptionsMarketLaunchProposals) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._binaryOptionsParamUpdateProposals) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._denomDecimalsUpdateProposal) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._spotMarketParamUpdateProposals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._spotMarketParamUpdateProposals, fieldNumber: 3)
      }
      if !_storage._derivativeMarketParamUpdateProposals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._derivativeMarketParamUpdateProposals, fieldNumber: 4)
      }
      if !_storage._spotMarketLaunchProposals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._spotMarketLaunchProposals, fieldNumber: 5)
      }
      if !_storage._perpetualMarketLaunchProposals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._perpetualMarketLaunchProposals, fieldNumber: 6)
      }
      if !_storage._expiryFuturesMarketLaunchProposals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._expiryFuturesMarketLaunchProposals, fieldNumber: 7)
      }
      try { if let v = _storage._tradingRewardCampaignUpdateProposal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._binaryOptionsMarketLaunchProposals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._binaryOptionsMarketLaunchProposals, fieldNumber: 9)
      }
      if !_storage._binaryOptionsParamUpdateProposals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._binaryOptionsParamUpdateProposals, fieldNumber: 10)
      }
      try { if let v = _storage._denomDecimalsUpdateProposal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_BatchExchangeModificationProposal, rhs: Injective_Exchange_V1beta1_BatchExchangeModificationProposal) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._spotMarketParamUpdateProposals != rhs_storage._spotMarketParamUpdateProposals {return false}
        if _storage._derivativeMarketParamUpdateProposals != rhs_storage._derivativeMarketParamUpdateProposals {return false}
        if _storage._spotMarketLaunchProposals != rhs_storage._spotMarketLaunchProposals {return false}
        if _storage._perpetualMarketLaunchProposals != rhs_storage._perpetualMarketLaunchProposals {return false}
        if _storage._expiryFuturesMarketLaunchProposals != rhs_storage._expiryFuturesMarketLaunchProposals {return false}
        if _storage._tradingRewardCampaignUpdateProposal != rhs_storage._tradingRewardCampaignUpdateProposal {return false}
        if _storage._binaryOptionsMarketLaunchProposals != rhs_storage._binaryOptionsMarketLaunchProposals {return false}
        if _storage._binaryOptionsParamUpdateProposals != rhs_storage._binaryOptionsParamUpdateProposals {return false}
        if _storage._denomDecimalsUpdateProposal != rhs_storage._denomDecimalsUpdateProposal {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotMarketLaunchProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotMarketLaunchProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "ticker"),
    4: .standard(proto: "base_denom"),
    5: .standard(proto: "quote_denom"),
    6: .standard(proto: "min_price_tick_size"),
    7: .standard(proto: "min_quantity_tick_size"),
    8: .standard(proto: "maker_fee_rate"),
    9: .standard(proto: "taker_fee_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.baseDenom) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 3)
    }
    if !self.baseDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.baseDenom, fieldNumber: 4)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 5)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 6)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 7)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 8)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotMarketLaunchProposal, rhs: Injective_Exchange_V1beta1_SpotMarketLaunchProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.baseDenom != rhs.baseDenom {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PerpetualMarketLaunchProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PerpetualMarketLaunchProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "ticker"),
    4: .standard(proto: "quote_denom"),
    5: .standard(proto: "oracle_base"),
    6: .standard(proto: "oracle_quote"),
    7: .standard(proto: "oracle_scale_factor"),
    8: .standard(proto: "oracle_type"),
    9: .standard(proto: "initial_margin_ratio"),
    10: .standard(proto: "maintenance_margin_ratio"),
    11: .standard(proto: "maker_fee_rate"),
    12: .standard(proto: "taker_fee_rate"),
    13: .standard(proto: "min_price_tick_size"),
    14: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.oracleBase) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.oracleQuote) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.initialMarginRatio) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.maintenanceMarginRatio) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 3)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 4)
    }
    if !self.oracleBase.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleBase, fieldNumber: 5)
    }
    if !self.oracleQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleQuote, fieldNumber: 6)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 7)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 8)
    }
    if !self.initialMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.initialMarginRatio, fieldNumber: 9)
    }
    if !self.maintenanceMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.maintenanceMarginRatio, fieldNumber: 10)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 11)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 12)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 13)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PerpetualMarketLaunchProposal, rhs: Injective_Exchange_V1beta1_PerpetualMarketLaunchProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.oracleBase != rhs.oracleBase {return false}
    if lhs.oracleQuote != rhs.oracleQuote {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.initialMarginRatio != rhs.initialMarginRatio {return false}
    if lhs.maintenanceMarginRatio != rhs.maintenanceMarginRatio {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_BinaryOptionsMarketLaunchProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BinaryOptionsMarketLaunchProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "ticker"),
    4: .standard(proto: "oracle_symbol"),
    5: .standard(proto: "oracle_provider"),
    6: .standard(proto: "oracle_type"),
    7: .standard(proto: "oracle_scale_factor"),
    8: .standard(proto: "expiration_timestamp"),
    9: .standard(proto: "settlement_timestamp"),
    10: .same(proto: "admin"),
    11: .standard(proto: "quote_denom"),
    12: .standard(proto: "maker_fee_rate"),
    13: .standard(proto: "taker_fee_rate"),
    14: .standard(proto: "min_price_tick_size"),
    15: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.oracleSymbol) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.oracleProvider) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.expirationTimestamp) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.settlementTimestamp) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 3)
    }
    if !self.oracleSymbol.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleSymbol, fieldNumber: 4)
    }
    if !self.oracleProvider.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleProvider, fieldNumber: 5)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 6)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 7)
    }
    if self.expirationTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationTimestamp, fieldNumber: 8)
    }
    if self.settlementTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.settlementTimestamp, fieldNumber: 9)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 10)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 11)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 12)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 13)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 14)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_BinaryOptionsMarketLaunchProposal, rhs: Injective_Exchange_V1beta1_BinaryOptionsMarketLaunchProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.oracleSymbol != rhs.oracleSymbol {return false}
    if lhs.oracleProvider != rhs.oracleProvider {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.expirationTimestamp != rhs.expirationTimestamp {return false}
    if lhs.settlementTimestamp != rhs.settlementTimestamp {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_ExpiryFuturesMarketLaunchProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpiryFuturesMarketLaunchProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "ticker"),
    4: .standard(proto: "quote_denom"),
    5: .standard(proto: "oracle_base"),
    6: .standard(proto: "oracle_quote"),
    7: .standard(proto: "oracle_scale_factor"),
    8: .standard(proto: "oracle_type"),
    9: .same(proto: "expiry"),
    10: .standard(proto: "initial_margin_ratio"),
    11: .standard(proto: "maintenance_margin_ratio"),
    12: .standard(proto: "maker_fee_rate"),
    13: .standard(proto: "taker_fee_rate"),
    14: .standard(proto: "min_price_tick_size"),
    15: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.oracleBase) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.oracleQuote) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.expiry) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.initialMarginRatio) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.maintenanceMarginRatio) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 3)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 4)
    }
    if !self.oracleBase.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleBase, fieldNumber: 5)
    }
    if !self.oracleQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleQuote, fieldNumber: 6)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 7)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 8)
    }
    if self.expiry != 0 {
      try visitor.visitSingularInt64Field(value: self.expiry, fieldNumber: 9)
    }
    if !self.initialMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.initialMarginRatio, fieldNumber: 10)
    }
    if !self.maintenanceMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.maintenanceMarginRatio, fieldNumber: 11)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 12)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 13)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 14)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_ExpiryFuturesMarketLaunchProposal, rhs: Injective_Exchange_V1beta1_ExpiryFuturesMarketLaunchProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.oracleBase != rhs.oracleBase {return false}
    if lhs.oracleQuote != rhs.oracleQuote {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs.initialMarginRatio != rhs.initialMarginRatio {return false}
    if lhs.maintenanceMarginRatio != rhs.maintenanceMarginRatio {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeMarketParamUpdateProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeMarketParamUpdateProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "market_id"),
    4: .standard(proto: "initial_margin_ratio"),
    5: .standard(proto: "maintenance_margin_ratio"),
    6: .standard(proto: "maker_fee_rate"),
    7: .standard(proto: "taker_fee_rate"),
    8: .standard(proto: "relayer_fee_share_rate"),
    9: .standard(proto: "min_price_tick_size"),
    10: .standard(proto: "min_quantity_tick_size"),
    11: .same(proto: "HourlyInterestRate"),
    12: .same(proto: "HourlyFundingRateCap"),
    13: .same(proto: "status"),
    14: .standard(proto: "oracle_params"),
  ]

  fileprivate class _StorageClass {
    var _title: String = String()
    var _description_p: String = String()
    var _marketID: String = String()
    var _initialMarginRatio: String = String()
    var _maintenanceMarginRatio: String = String()
    var _makerFeeRate: String = String()
    var _takerFeeRate: String = String()
    var _relayerFeeShareRate: String = String()
    var _minPriceTickSize: String = String()
    var _minQuantityTickSize: String = String()
    var _hourlyInterestRate: String = String()
    var _hourlyFundingRateCap: String = String()
    var _status: Injective_Exchange_V1beta1_MarketStatus = .unspecified
    var _oracleParams: Injective_Exchange_V1beta1_OracleParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _title = source._title
      _description_p = source._description_p
      _marketID = source._marketID
      _initialMarginRatio = source._initialMarginRatio
      _maintenanceMarginRatio = source._maintenanceMarginRatio
      _makerFeeRate = source._makerFeeRate
      _takerFeeRate = source._takerFeeRate
      _relayerFeeShareRate = source._relayerFeeShareRate
      _minPriceTickSize = source._minPriceTickSize
      _minQuantityTickSize = source._minQuantityTickSize
      _hourlyInterestRate = source._hourlyInterestRate
      _hourlyFundingRateCap = source._hourlyFundingRateCap
      _status = source._status
      _oracleParams = source._oracleParams
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._marketID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._initialMarginRatio) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._maintenanceMarginRatio) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._makerFeeRate) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._takerFeeRate) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._relayerFeeShareRate) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._minPriceTickSize) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._minQuantityTickSize) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._hourlyInterestRate) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._hourlyFundingRateCap) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._oracleParams) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._marketID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._marketID, fieldNumber: 3)
      }
      if !_storage._initialMarginRatio.isEmpty {
        try visitor.visitSingularStringField(value: _storage._initialMarginRatio, fieldNumber: 4)
      }
      if !_storage._maintenanceMarginRatio.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maintenanceMarginRatio, fieldNumber: 5)
      }
      if !_storage._makerFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._makerFeeRate, fieldNumber: 6)
      }
      if !_storage._takerFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._takerFeeRate, fieldNumber: 7)
      }
      if !_storage._relayerFeeShareRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._relayerFeeShareRate, fieldNumber: 8)
      }
      if !_storage._minPriceTickSize.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minPriceTickSize, fieldNumber: 9)
      }
      if !_storage._minQuantityTickSize.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minQuantityTickSize, fieldNumber: 10)
      }
      if !_storage._hourlyInterestRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hourlyInterestRate, fieldNumber: 11)
      }
      if !_storage._hourlyFundingRateCap.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hourlyFundingRateCap, fieldNumber: 12)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 13)
      }
      try { if let v = _storage._oracleParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeMarketParamUpdateProposal, rhs: Injective_Exchange_V1beta1_DerivativeMarketParamUpdateProposal) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._marketID != rhs_storage._marketID {return false}
        if _storage._initialMarginRatio != rhs_storage._initialMarginRatio {return false}
        if _storage._maintenanceMarginRatio != rhs_storage._maintenanceMarginRatio {return false}
        if _storage._makerFeeRate != rhs_storage._makerFeeRate {return false}
        if _storage._takerFeeRate != rhs_storage._takerFeeRate {return false}
        if _storage._relayerFeeShareRate != rhs_storage._relayerFeeShareRate {return false}
        if _storage._minPriceTickSize != rhs_storage._minPriceTickSize {return false}
        if _storage._minQuantityTickSize != rhs_storage._minQuantityTickSize {return false}
        if _storage._hourlyInterestRate != rhs_storage._hourlyInterestRate {return false}
        if _storage._hourlyFundingRateCap != rhs_storage._hourlyFundingRateCap {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._oracleParams != rhs_storage._oracleParams {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MarketForcedSettlementProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MarketForcedSettlementProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "market_id"),
    4: .standard(proto: "settlement_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.settlementPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 3)
    }
    if !self.settlementPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.settlementPrice, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MarketForcedSettlementProposal, rhs: Injective_Exchange_V1beta1_MarketForcedSettlementProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.settlementPrice != rhs.settlementPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_UpdateDenomDecimalsProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateDenomDecimalsProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "denom_decimals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.denomDecimals) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.denomDecimals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.denomDecimals, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_UpdateDenomDecimalsProposal, rhs: Injective_Exchange_V1beta1_UpdateDenomDecimalsProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.denomDecimals != rhs.denomDecimals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_BinaryOptionsMarketParamUpdateProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BinaryOptionsMarketParamUpdateProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "market_id"),
    4: .standard(proto: "maker_fee_rate"),
    5: .standard(proto: "taker_fee_rate"),
    6: .standard(proto: "relayer_fee_share_rate"),
    7: .standard(proto: "min_price_tick_size"),
    8: .standard(proto: "min_quantity_tick_size"),
    9: .standard(proto: "expiration_timestamp"),
    10: .standard(proto: "settlement_timestamp"),
    11: .standard(proto: "settlement_price"),
    12: .same(proto: "admin"),
    13: .same(proto: "status"),
    14: .standard(proto: "oracle_params"),
  ]

  fileprivate class _StorageClass {
    var _title: String = String()
    var _description_p: String = String()
    var _marketID: String = String()
    var _makerFeeRate: String = String()
    var _takerFeeRate: String = String()
    var _relayerFeeShareRate: String = String()
    var _minPriceTickSize: String = String()
    var _minQuantityTickSize: String = String()
    var _expirationTimestamp: Int64 = 0
    var _settlementTimestamp: Int64 = 0
    var _settlementPrice: String = String()
    var _admin: String = String()
    var _status: Injective_Exchange_V1beta1_MarketStatus = .unspecified
    var _oracleParams: Injective_Exchange_V1beta1_ProviderOracleParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _title = source._title
      _description_p = source._description_p
      _marketID = source._marketID
      _makerFeeRate = source._makerFeeRate
      _takerFeeRate = source._takerFeeRate
      _relayerFeeShareRate = source._relayerFeeShareRate
      _minPriceTickSize = source._minPriceTickSize
      _minQuantityTickSize = source._minQuantityTickSize
      _expirationTimestamp = source._expirationTimestamp
      _settlementTimestamp = source._settlementTimestamp
      _settlementPrice = source._settlementPrice
      _admin = source._admin
      _status = source._status
      _oracleParams = source._oracleParams
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._marketID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._makerFeeRate) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._takerFeeRate) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._relayerFeeShareRate) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._minPriceTickSize) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._minQuantityTickSize) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._expirationTimestamp) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._settlementTimestamp) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._settlementPrice) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._admin) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._oracleParams) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._marketID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._marketID, fieldNumber: 3)
      }
      if !_storage._makerFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._makerFeeRate, fieldNumber: 4)
      }
      if !_storage._takerFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._takerFeeRate, fieldNumber: 5)
      }
      if !_storage._relayerFeeShareRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._relayerFeeShareRate, fieldNumber: 6)
      }
      if !_storage._minPriceTickSize.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minPriceTickSize, fieldNumber: 7)
      }
      if !_storage._minQuantityTickSize.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minQuantityTickSize, fieldNumber: 8)
      }
      if _storage._expirationTimestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._expirationTimestamp, fieldNumber: 9)
      }
      if _storage._settlementTimestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._settlementTimestamp, fieldNumber: 10)
      }
      if !_storage._settlementPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._settlementPrice, fieldNumber: 11)
      }
      if !_storage._admin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._admin, fieldNumber: 12)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 13)
      }
      try { if let v = _storage._oracleParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_BinaryOptionsMarketParamUpdateProposal, rhs: Injective_Exchange_V1beta1_BinaryOptionsMarketParamUpdateProposal) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._marketID != rhs_storage._marketID {return false}
        if _storage._makerFeeRate != rhs_storage._makerFeeRate {return false}
        if _storage._takerFeeRate != rhs_storage._takerFeeRate {return false}
        if _storage._relayerFeeShareRate != rhs_storage._relayerFeeShareRate {return false}
        if _storage._minPriceTickSize != rhs_storage._minPriceTickSize {return false}
        if _storage._minQuantityTickSize != rhs_storage._minQuantityTickSize {return false}
        if _storage._expirationTimestamp != rhs_storage._expirationTimestamp {return false}
        if _storage._settlementTimestamp != rhs_storage._settlementTimestamp {return false}
        if _storage._settlementPrice != rhs_storage._settlementPrice {return false}
        if _storage._admin != rhs_storage._admin {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._oracleParams != rhs_storage._oracleParams {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_ProviderOracleParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProviderOracleParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbol"),
    2: .same(proto: "provider"),
    3: .standard(proto: "oracle_scale_factor"),
    4: .standard(proto: "oracle_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 1)
    }
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 2)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 3)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_ProviderOracleParams, rhs: Injective_Exchange_V1beta1_ProviderOracleParams) -> Bool {
    if lhs.symbol != rhs.symbol {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_OracleParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OracleParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "oracle_base"),
    2: .standard(proto: "oracle_quote"),
    3: .standard(proto: "oracle_scale_factor"),
    4: .standard(proto: "oracle_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.oracleBase) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.oracleQuote) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.oracleBase.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleBase, fieldNumber: 1)
    }
    if !self.oracleQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleQuote, fieldNumber: 2)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 3)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_OracleParams, rhs: Injective_Exchange_V1beta1_OracleParams) -> Bool {
    if lhs.oracleBase != rhs.oracleBase {return false}
    if lhs.oracleQuote != rhs.oracleQuote {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradingRewardCampaignLaunchProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingRewardCampaignLaunchProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "campaign_info"),
    4: .standard(proto: "campaign_reward_pools"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._campaignInfo) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.campaignRewardPools) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try { if let v = self._campaignInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.campaignRewardPools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.campaignRewardPools, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradingRewardCampaignLaunchProposal, rhs: Injective_Exchange_V1beta1_TradingRewardCampaignLaunchProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._campaignInfo != rhs._campaignInfo {return false}
    if lhs.campaignRewardPools != rhs.campaignRewardPools {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingRewardCampaignUpdateProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "campaign_info"),
    4: .standard(proto: "campaign_reward_pools_additions"),
    5: .standard(proto: "campaign_reward_pools_updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._campaignInfo) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.campaignRewardPoolsAdditions) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.campaignRewardPoolsUpdates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try { if let v = self._campaignInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.campaignRewardPoolsAdditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.campaignRewardPoolsAdditions, fieldNumber: 4)
    }
    if !self.campaignRewardPoolsUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.campaignRewardPoolsUpdates, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal, rhs: Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._campaignInfo != rhs._campaignInfo {return false}
    if lhs.campaignRewardPoolsAdditions != rhs.campaignRewardPoolsAdditions {return false}
    if lhs.campaignRewardPoolsUpdates != rhs.campaignRewardPoolsUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_RewardPointUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RewardPointUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_address"),
    12: .standard(proto: "new_points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountAddress) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.newPoints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.accountAddress, fieldNumber: 1)
    }
    if !self.newPoints.isEmpty {
      try visitor.visitSingularStringField(value: self.newPoints, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_RewardPointUpdate, rhs: Injective_Exchange_V1beta1_RewardPointUpdate) -> Bool {
    if lhs.accountAddress != rhs.accountAddress {return false}
    if lhs.newPoints != rhs.newPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradingRewardPendingPointsUpdateProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingRewardPendingPointsUpdateProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "pending_pool_timestamp"),
    4: .standard(proto: "reward_point_updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pendingPoolTimestamp) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rewardPointUpdates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if self.pendingPoolTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.pendingPoolTimestamp, fieldNumber: 3)
    }
    if !self.rewardPointUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rewardPointUpdates, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradingRewardPendingPointsUpdateProposal, rhs: Injective_Exchange_V1beta1_TradingRewardPendingPointsUpdateProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.pendingPoolTimestamp != rhs.pendingPoolTimestamp {return false}
    if lhs.rewardPointUpdates != rhs.rewardPointUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FeeDiscountProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeDiscountProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "schedule"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try { if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FeeDiscountProposal, rhs: Injective_Exchange_V1beta1_FeeDiscountProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_BatchCommunityPoolSpendProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchCommunityPoolSpendProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "proposals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.proposals) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.proposals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.proposals, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_BatchCommunityPoolSpendProposal, rhs: Injective_Exchange_V1beta1_BatchCommunityPoolSpendProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.proposals != rhs.proposals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgRewardsOptOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRewardsOptOut"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgRewardsOptOut, rhs: Injective_Exchange_V1beta1_MsgRewardsOptOut) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgRewardsOptOutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRewardsOptOutResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgRewardsOptOutResponse, rhs: Injective_Exchange_V1beta1_MsgRewardsOptOutResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgReclaimLockedFunds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgReclaimLockedFunds"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "lockedAccountPubKey"),
    3: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.lockedAccountPubKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.lockedAccountPubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.lockedAccountPubKey, fieldNumber: 2)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgReclaimLockedFunds, rhs: Injective_Exchange_V1beta1_MsgReclaimLockedFunds) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.lockedAccountPubKey != rhs.lockedAccountPubKey {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgReclaimLockedFundsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgReclaimLockedFundsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgReclaimLockedFundsResponse, rhs: Injective_Exchange_V1beta1_MsgReclaimLockedFundsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgSignData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSignData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Signer"),
    2: .same(proto: "Data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signer) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signer.isEmpty {
      try visitor.visitSingularBytesField(value: self.signer, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgSignData, rhs: Injective_Exchange_V1beta1_MsgSignData) -> Bool {
    if lhs.signer != rhs.signer {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgSignDoc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSignDoc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sign_type"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.signType.isEmpty {
      try visitor.visitSingularStringField(value: self.signType, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgSignDoc, rhs: Injective_Exchange_V1beta1_MsgSignDoc) -> Bool {
    if lhs.signType != rhs.signType {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgAdminUpdateBinaryOptionsMarket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAdminUpdateBinaryOptionsMarket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "market_id"),
    3: .standard(proto: "settlement_price"),
    4: .standard(proto: "expiration_timestamp"),
    5: .standard(proto: "settlement_timestamp"),
    6: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.settlementPrice) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.expirationTimestamp) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.settlementTimestamp) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    if !self.settlementPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.settlementPrice, fieldNumber: 3)
    }
    if self.expirationTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationTimestamp, fieldNumber: 4)
    }
    if self.settlementTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.settlementTimestamp, fieldNumber: 5)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgAdminUpdateBinaryOptionsMarket, rhs: Injective_Exchange_V1beta1_MsgAdminUpdateBinaryOptionsMarket) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.settlementPrice != rhs.settlementPrice {return false}
    if lhs.expirationTimestamp != rhs.expirationTimestamp {return false}
    if lhs.settlementTimestamp != rhs.settlementTimestamp {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgAdminUpdateBinaryOptionsMarketResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAdminUpdateBinaryOptionsMarketResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgAdminUpdateBinaryOptionsMarketResponse, rhs: Injective_Exchange_V1beta1_MsgAdminUpdateBinaryOptionsMarketResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_AtomicMarketOrderFeeMultiplierScheduleProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AtomicMarketOrderFeeMultiplierScheduleProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "market_fee_multipliers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.marketFeeMultipliers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.marketFeeMultipliers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.marketFeeMultipliers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_AtomicMarketOrderFeeMultiplierScheduleProposal, rhs: Injective_Exchange_V1beta1_AtomicMarketOrderFeeMultiplierScheduleProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.marketFeeMultipliers != rhs.marketFeeMultipliers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
