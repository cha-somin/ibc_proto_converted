// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: stafihub/ledger/ledger.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Stafihub_Stafihub_Ledger_PoolStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case active // = 0
  case notActive // = 1
  case reserved // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .active
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .active
    case 1: self = .notActive
    case 2: self = .reserved
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .active: return 0
    case .notActive: return 1
    case .reserved: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stafihub_Stafihub_Ledger_PoolStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stafihub_Stafihub_Ledger_PoolStatus] = [
    .active,
    .notActive,
    .reserved,
  ]
}

#endif  // swift(>=4.2)

enum Stafihub_Stafihub_Ledger_PoolBondState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case eraUpdated // = 0
  case bondReported // = 1
  case activeReported // = 2
  case transferSkipped // = 3
  case transferReported // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .eraUpdated
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .eraUpdated
    case 1: self = .bondReported
    case 2: self = .activeReported
    case 3: self = .transferSkipped
    case 4: self = .transferReported
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .eraUpdated: return 0
    case .bondReported: return 1
    case .activeReported: return 2
    case .transferSkipped: return 3
    case .transferReported: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stafihub_Stafihub_Ledger_PoolBondState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stafihub_Stafihub_Ledger_PoolBondState] = [
    .eraUpdated,
    .bondReported,
    .activeReported,
    .transferSkipped,
    .transferReported,
  ]
}

#endif  // swift(>=4.2)

enum Stafihub_Stafihub_Ledger_BondAction: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case bondOnly // = 0
  case unbondOnly // = 1
  case bothBondUnbond // = 2
  case eitherBondUnbond // = 3
  case interDeduct // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .bondOnly
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bondOnly
    case 1: self = .unbondOnly
    case 2: self = .bothBondUnbond
    case 3: self = .eitherBondUnbond
    case 4: self = .interDeduct
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .bondOnly: return 0
    case .unbondOnly: return 1
    case .bothBondUnbond: return 2
    case .eitherBondUnbond: return 3
    case .interDeduct: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stafihub_Stafihub_Ledger_BondAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stafihub_Stafihub_Ledger_BondAction] = [
    .bondOnly,
    .unbondOnly,
    .bothBondUnbond,
    .eitherBondUnbond,
    .interDeduct,
  ]
}

#endif  // swift(>=4.2)

enum Stafihub_Stafihub_Ledger_LiquidityBondState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case verifyOk // = 0
  case denomUnmatch // = 1
  case bonderUnmatch // = 2
  case poolUnmatch // = 3
  case amountUnmatch // = 4
  case memoUnmatch // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .verifyOk
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .verifyOk
    case 1: self = .denomUnmatch
    case 2: self = .bonderUnmatch
    case 3: self = .poolUnmatch
    case 4: self = .amountUnmatch
    case 5: self = .memoUnmatch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .verifyOk: return 0
    case .denomUnmatch: return 1
    case .bonderUnmatch: return 2
    case .poolUnmatch: return 3
    case .amountUnmatch: return 4
    case .memoUnmatch: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stafihub_Stafihub_Ledger_LiquidityBondState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stafihub_Stafihub_Ledger_LiquidityBondState] = [
    .verifyOk,
    .denomUnmatch,
    .bonderUnmatch,
    .poolUnmatch,
    .amountUnmatch,
    .memoUnmatch,
  ]
}

#endif  // swift(>=4.2)

/// OriginalTxType enumerates the tx type of a signature.
enum Stafihub_Stafihub_Ledger_OriginalTxType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case dealEraupdated // = 0
  case dealBondreported // = 1
  case dealActivereported // = 2
  case dealValidatorupdated // = 3
  case reserved // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .dealEraupdated
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .dealEraupdated
    case 1: self = .dealBondreported
    case 2: self = .dealActivereported
    case 3: self = .dealValidatorupdated
    case 4: self = .reserved
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .dealEraupdated: return 0
    case .dealBondreported: return 1
    case .dealActivereported: return 2
    case .dealValidatorupdated: return 3
    case .reserved: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stafihub_Stafihub_Ledger_OriginalTxType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stafihub_Stafihub_Ledger_OriginalTxType] = [
    .dealEraupdated,
    .dealBondreported,
    .dealActivereported,
    .dealValidatorupdated,
    .reserved,
  ]
}

#endif  // swift(>=4.2)

enum Stafihub_Stafihub_Ledger_IcaPoolStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case init_ // = 1
  case createOne // = 2
  case createTwo // = 3
  case setWithdrawal // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .init_
    case 2: self = .createOne
    case 3: self = .createTwo
    case 4: self = .setWithdrawal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .init_: return 1
    case .createOne: return 2
    case .createTwo: return 3
    case .setWithdrawal: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stafihub_Stafihub_Ledger_IcaPoolStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stafihub_Stafihub_Ledger_IcaPoolStatus] = [
    .unspecified,
    .init_,
    .createOne,
    .createTwo,
    .setWithdrawal,
  ]
}

#endif  // swift(>=4.2)

enum Stafihub_Stafihub_Ledger_InterchainTxStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case init_ // = 1
  case success // = 2
  case failed // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .init_
    case 2: self = .success
    case 3: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .init_: return 1
    case .success: return 2
    case .failed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stafihub_Stafihub_Ledger_InterchainTxStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stafihub_Stafihub_Ledger_InterchainTxStatus] = [
    .unspecified,
    .init_,
    .success,
    .failed,
  ]
}

#endif  // swift(>=4.2)

struct Stafihub_Stafihub_Ledger_ChainEra {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var era: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_Pool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var addrs: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_BondPipeline {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var pool: String = String()

  var chunk: Stafihub_Stafihub_Ledger_LinkChunk {
    get {return _chunk ?? Stafihub_Stafihub_Ledger_LinkChunk()}
    set {_chunk = newValue}
  }
  /// Returns true if `chunk` has been explicitly set.
  var hasChunk: Bool {return self._chunk != nil}
  /// Clears the value of `chunk`. Subsequent reads from it will return its default value.
  mutating func clearChunk() {self._chunk = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chunk: Stafihub_Stafihub_Ledger_LinkChunk? = nil
}

struct Stafihub_Stafihub_Ledger_EraSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var shotIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_EraUnbondLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var limit: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_PoolDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var pool: String = String()

  var subAccounts: [String] = []

  var threshold: UInt32 = 0

  var status: Stafihub_Stafihub_Ledger_PoolStatus = .active

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_LinkChunk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bond: String = String()

  var unbond: String = String()

  var active: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_BondSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var pool: String = String()

  var era: UInt32 = 0

  var chunk: Stafihub_Stafihub_Ledger_LinkChunk {
    get {return _chunk ?? Stafihub_Stafihub_Ledger_LinkChunk()}
    set {_chunk = newValue}
  }
  /// Returns true if `chunk` has been explicitly set.
  var hasChunk: Bool {return self._chunk != nil}
  /// Clears the value of `chunk`. Subsequent reads from it will return its default value.
  mutating func clearChunk() {self._chunk = nil}

  var bondState: Stafihub_Stafihub_Ledger_PoolBondState = .eraUpdated

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chunk: Stafihub_Stafihub_Ledger_LinkChunk? = nil
}

struct Stafihub_Stafihub_Ledger_ExchangeRate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_TotalProtocolFee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_EraExchangeRate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var era: UInt32 = 0

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_UnbondRelayFee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var value: Cosmos_Base_V1beta1_Coin {
    get {return _value ?? Cosmos_Base_V1beta1_Coin()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Cosmos_Base_V1beta1_Coin? = nil
}

struct Stafihub_Stafihub_Ledger_Unbonding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unbonder: String = String()

  var amount: String = String()

  var recipient: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_BondRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var bonder: String = String()

  var pool: String = String()

  var txhash: String = String()

  var amount: String = String()

  var state: Stafihub_Stafihub_Ledger_LiquidityBondState = .verifyOk

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_Signature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var era: UInt32 = 0

  var pool: String = String()

  var txType: Stafihub_Stafihub_Ledger_OriginalTxType = .dealEraupdated

  var propID: String = String()

  var sigs: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_RParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var gasPrice: String = String()

  var eraSeconds: UInt32 = 0

  var offset: Int32 = 0

  var bondingDuration: UInt32 = 0

  var leastBond: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_IcaAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var owner: String = String()

  var address: String = String()

  var ctrlConnectionID: String = String()

  var ctrlPortID: String = String()

  var ctrlChannelID: String = String()

  var hostConnectionID: String = String()

  var hostPortID: String = String()

  var hostChannelID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Ledger_IcaPoolDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String {
    get {return _storage._denom}
    set {_uniqueStorage()._denom = newValue}
  }

  var index: UInt32 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  var status: Stafihub_Stafihub_Ledger_IcaPoolStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var delegationAccount: Stafihub_Stafihub_Ledger_IcaAccount {
    get {return _storage._delegationAccount ?? Stafihub_Stafihub_Ledger_IcaAccount()}
    set {_uniqueStorage()._delegationAccount = newValue}
  }
  /// Returns true if `delegationAccount` has been explicitly set.
  var hasDelegationAccount: Bool {return _storage._delegationAccount != nil}
  /// Clears the value of `delegationAccount`. Subsequent reads from it will return its default value.
  mutating func clearDelegationAccount() {_uniqueStorage()._delegationAccount = nil}

  var withdrawalAccount: Stafihub_Stafihub_Ledger_IcaAccount {
    get {return _storage._withdrawalAccount ?? Stafihub_Stafihub_Ledger_IcaAccount()}
    set {_uniqueStorage()._withdrawalAccount = newValue}
  }
  /// Returns true if `withdrawalAccount` has been explicitly set.
  var hasWithdrawalAccount: Bool {return _storage._withdrawalAccount != nil}
  /// Clears the value of `withdrawalAccount`. Subsequent reads from it will return its default value.
  mutating func clearWithdrawalAccount() {_uniqueStorage()._withdrawalAccount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stafihub_Stafihub_Ledger_PoolStatus: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_PoolBondState: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_BondAction: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_LiquidityBondState: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_OriginalTxType: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_IcaPoolStatus: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_InterchainTxStatus: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_ChainEra: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_Pool: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_BondPipeline: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_EraSnapshot: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_EraUnbondLimit: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_PoolDetail: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_LinkChunk: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_BondSnapshot: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_ExchangeRate: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_TotalProtocolFee: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_EraExchangeRate: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_UnbondRelayFee: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_Unbonding: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_BondRecord: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_Signature: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_RParams: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_IcaAccount: @unchecked Sendable {}
extension Stafihub_Stafihub_Ledger_IcaPoolDetail: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stafihub.stafihub.ledger"

extension Stafihub_Stafihub_Ledger_PoolStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTIVE"),
    1: .same(proto: "NOT_ACTIVE"),
    2: .same(proto: "RESERVED"),
  ]
}

extension Stafihub_Stafihub_Ledger_PoolBondState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERA_UPDATED"),
    1: .same(proto: "BOND_REPORTED"),
    2: .same(proto: "ACTIVE_REPORTED"),
    3: .same(proto: "TRANSFER_SKIPPED"),
    4: .same(proto: "TRANSFER_REPORTED"),
  ]
}

extension Stafihub_Stafihub_Ledger_BondAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOND_ONLY"),
    1: .same(proto: "UNBOND_ONLY"),
    2: .same(proto: "BOTH_BOND_UNBOND"),
    3: .same(proto: "EITHER_BOND_UNBOND"),
    4: .same(proto: "INTER_DEDUCT"),
  ]
}

extension Stafihub_Stafihub_Ledger_LiquidityBondState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LIQUIDITY_BOND_STATE_VERIFY_OK"),
    1: .same(proto: "LIQUIDITY_BOND_STATE_DENOM_UNMATCH"),
    2: .same(proto: "LIQUIDITY_BOND_STATE_BONDER_UNMATCH"),
    3: .same(proto: "LIQUIDITY_BOND_STATE_POOL_UNMATCH"),
    4: .same(proto: "LIQUIDITY_BOND_STATE_AMOUNT_UNMATCH"),
    5: .same(proto: "LIQUIDITY_BOND_STATE_MEMO_UNMATCH"),
  ]
}

extension Stafihub_Stafihub_Ledger_OriginalTxType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORIGINAL_TX_TYPE_DEAL_ERAUPDATED"),
    1: .same(proto: "ORIGINAL_TX_TYPE_DEAL_BONDREPORTED"),
    2: .same(proto: "ORIGINAL_TX_TYPE_DEAL_ACTIVEREPORTED"),
    3: .same(proto: "ORIGINAL_TX_TYPE_DEAL_VALIDATORUPDATED"),
    4: .same(proto: "ORIGINAL_TX_TYPE_RESERVED"),
  ]
}

extension Stafihub_Stafihub_Ledger_IcaPoolStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ICA_POOL_STATUS_UNSPECIFIED"),
    1: .same(proto: "ICA_POOL_STATUS_INIT"),
    2: .same(proto: "ICA_POOL_STATUS_CREATE_ONE"),
    3: .same(proto: "ICA_POOL_STATUS_CREATE_TWO"),
    4: .same(proto: "ICA_POOL_STATUS_SET_WITHDRAWAL"),
  ]
}

extension Stafihub_Stafihub_Ledger_InterchainTxStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERCHAIN_TX_STATUS_UNSPECIFIED"),
    1: .same(proto: "INTERCHAIN_TX_STATUS_INIT"),
    2: .same(proto: "INTERCHAIN_TX_STATUS_SUCCESS"),
    3: .same(proto: "INTERCHAIN_TX_STATUS_FAILED"),
  ]
}

extension Stafihub_Stafihub_Ledger_ChainEra: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainEra"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "era"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.era) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.era != 0 {
      try visitor.visitSingularUInt32Field(value: self.era, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_ChainEra, rhs: Stafihub_Stafihub_Ledger_ChainEra) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.era != rhs.era {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_Pool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "addrs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.addrs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.addrs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addrs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_Pool, rhs: Stafihub_Stafihub_Ledger_Pool) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.addrs != rhs.addrs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_BondPipeline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BondPipeline"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "pool"),
    3: .same(proto: "chunk"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pool) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._chunk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.pool.isEmpty {
      try visitor.visitSingularStringField(value: self.pool, fieldNumber: 2)
    }
    try { if let v = self._chunk {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_BondPipeline, rhs: Stafihub_Stafihub_Ledger_BondPipeline) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.pool != rhs.pool {return false}
    if lhs._chunk != rhs._chunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_EraSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EraSnapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    3: .same(proto: "shotIds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.shotIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.shotIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.shotIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_EraSnapshot, rhs: Stafihub_Stafihub_Ledger_EraSnapshot) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.shotIds != rhs.shotIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_EraUnbondLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EraUnbondLimit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_EraUnbondLimit, rhs: Stafihub_Stafihub_Ledger_EraUnbondLimit) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_PoolDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "pool"),
    3: .same(proto: "subAccounts"),
    4: .same(proto: "threshold"),
    5: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pool) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.subAccounts) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.threshold) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.pool.isEmpty {
      try visitor.visitSingularStringField(value: self.pool, fieldNumber: 2)
    }
    if !self.subAccounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subAccounts, fieldNumber: 3)
    }
    if self.threshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.threshold, fieldNumber: 4)
    }
    if self.status != .active {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_PoolDetail, rhs: Stafihub_Stafihub_Ledger_PoolDetail) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.pool != rhs.pool {return false}
    if lhs.subAccounts != rhs.subAccounts {return false}
    if lhs.threshold != rhs.threshold {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_LinkChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinkChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bond"),
    2: .same(proto: "unbond"),
    3: .same(proto: "active"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bond) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.unbond) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.active) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bond.isEmpty {
      try visitor.visitSingularStringField(value: self.bond, fieldNumber: 1)
    }
    if !self.unbond.isEmpty {
      try visitor.visitSingularStringField(value: self.unbond, fieldNumber: 2)
    }
    if !self.active.isEmpty {
      try visitor.visitSingularStringField(value: self.active, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_LinkChunk, rhs: Stafihub_Stafihub_Ledger_LinkChunk) -> Bool {
    if lhs.bond != rhs.bond {return false}
    if lhs.unbond != rhs.unbond {return false}
    if lhs.active != rhs.active {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_BondSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BondSnapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "pool"),
    3: .same(proto: "era"),
    4: .same(proto: "chunk"),
    6: .standard(proto: "bond_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pool) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.era) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._chunk) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.bondState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.pool.isEmpty {
      try visitor.visitSingularStringField(value: self.pool, fieldNumber: 2)
    }
    if self.era != 0 {
      try visitor.visitSingularUInt32Field(value: self.era, fieldNumber: 3)
    }
    try { if let v = self._chunk {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.bondState != .eraUpdated {
      try visitor.visitSingularEnumField(value: self.bondState, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_BondSnapshot, rhs: Stafihub_Stafihub_Ledger_BondSnapshot) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.pool != rhs.pool {return false}
    if lhs.era != rhs.era {return false}
    if lhs._chunk != rhs._chunk {return false}
    if lhs.bondState != rhs.bondState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_ExchangeRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExchangeRate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_ExchangeRate, rhs: Stafihub_Stafihub_Ledger_ExchangeRate) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_TotalProtocolFee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TotalProtocolFee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_TotalProtocolFee, rhs: Stafihub_Stafihub_Ledger_TotalProtocolFee) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_EraExchangeRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EraExchangeRate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "era"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.era) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.era != 0 {
      try visitor.visitSingularUInt32Field(value: self.era, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_EraExchangeRate, rhs: Stafihub_Stafihub_Ledger_EraExchangeRate) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.era != rhs.era {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_UnbondRelayFee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnbondRelayFee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_UnbondRelayFee, rhs: Stafihub_Stafihub_Ledger_UnbondRelayFee) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_Unbonding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Unbonding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unbonder"),
    2: .same(proto: "amount"),
    3: .same(proto: "recipient"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.unbonder) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.recipient) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.unbonder.isEmpty {
      try visitor.visitSingularStringField(value: self.unbonder, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_Unbonding, rhs: Stafihub_Stafihub_Ledger_Unbonding) -> Bool {
    if lhs.unbonder != rhs.unbonder {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_BondRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BondRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "bonder"),
    3: .same(proto: "pool"),
    4: .same(proto: "txhash"),
    5: .same(proto: "amount"),
    6: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bonder) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pool) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.txhash) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.bonder.isEmpty {
      try visitor.visitSingularStringField(value: self.bonder, fieldNumber: 2)
    }
    if !self.pool.isEmpty {
      try visitor.visitSingularStringField(value: self.pool, fieldNumber: 3)
    }
    if !self.txhash.isEmpty {
      try visitor.visitSingularStringField(value: self.txhash, fieldNumber: 4)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 5)
    }
    if self.state != .verifyOk {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_BondRecord, rhs: Stafihub_Stafihub_Ledger_BondRecord) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.bonder != rhs.bonder {return false}
    if lhs.pool != rhs.pool {return false}
    if lhs.txhash != rhs.txhash {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Signature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "era"),
    3: .same(proto: "pool"),
    4: .same(proto: "txType"),
    5: .same(proto: "propId"),
    6: .same(proto: "sigs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.era) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pool) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.txType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.propID) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.sigs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.era != 0 {
      try visitor.visitSingularUInt32Field(value: self.era, fieldNumber: 2)
    }
    if !self.pool.isEmpty {
      try visitor.visitSingularStringField(value: self.pool, fieldNumber: 3)
    }
    if self.txType != .dealEraupdated {
      try visitor.visitSingularEnumField(value: self.txType, fieldNumber: 4)
    }
    if !self.propID.isEmpty {
      try visitor.visitSingularStringField(value: self.propID, fieldNumber: 5)
    }
    if !self.sigs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sigs, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_Signature, rhs: Stafihub_Stafihub_Ledger_Signature) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.era != rhs.era {return false}
    if lhs.pool != rhs.pool {return false}
    if lhs.txType != rhs.txType {return false}
    if lhs.propID != rhs.propID {return false}
    if lhs.sigs != rhs.sigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_RParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "gasPrice"),
    3: .same(proto: "eraSeconds"),
    4: .same(proto: "offset"),
    5: .same(proto: "bondingDuration"),
    6: .same(proto: "leastBond"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gasPrice) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.eraSeconds) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.bondingDuration) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.leastBond) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.gasPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.gasPrice, fieldNumber: 2)
    }
    if self.eraSeconds != 0 {
      try visitor.visitSingularUInt32Field(value: self.eraSeconds, fieldNumber: 3)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 4)
    }
    if self.bondingDuration != 0 {
      try visitor.visitSingularUInt32Field(value: self.bondingDuration, fieldNumber: 5)
    }
    if !self.leastBond.isEmpty {
      try visitor.visitSingularStringField(value: self.leastBond, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_RParams, rhs: Stafihub_Stafihub_Ledger_RParams) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.gasPrice != rhs.gasPrice {return false}
    if lhs.eraSeconds != rhs.eraSeconds {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.bondingDuration != rhs.bondingDuration {return false}
    if lhs.leastBond != rhs.leastBond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_IcaAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IcaAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "address"),
    3: .same(proto: "ctrlConnectionId"),
    4: .same(proto: "ctrlPortId"),
    5: .same(proto: "ctrlChannelId"),
    6: .same(proto: "hostConnectionId"),
    7: .same(proto: "hostPortId"),
    8: .same(proto: "hostChannelId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ctrlConnectionID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ctrlPortID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ctrlChannelID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.hostConnectionID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.hostPortID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.hostChannelID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.ctrlConnectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.ctrlConnectionID, fieldNumber: 3)
    }
    if !self.ctrlPortID.isEmpty {
      try visitor.visitSingularStringField(value: self.ctrlPortID, fieldNumber: 4)
    }
    if !self.ctrlChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.ctrlChannelID, fieldNumber: 5)
    }
    if !self.hostConnectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostConnectionID, fieldNumber: 6)
    }
    if !self.hostPortID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostPortID, fieldNumber: 7)
    }
    if !self.hostChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostChannelID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_IcaAccount, rhs: Stafihub_Stafihub_Ledger_IcaAccount) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.address != rhs.address {return false}
    if lhs.ctrlConnectionID != rhs.ctrlConnectionID {return false}
    if lhs.ctrlPortID != rhs.ctrlPortID {return false}
    if lhs.ctrlChannelID != rhs.ctrlChannelID {return false}
    if lhs.hostConnectionID != rhs.hostConnectionID {return false}
    if lhs.hostPortID != rhs.hostPortID {return false}
    if lhs.hostChannelID != rhs.hostChannelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Ledger_IcaPoolDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IcaPoolDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "index"),
    3: .same(proto: "status"),
    4: .same(proto: "DelegationAccount"),
    5: .same(proto: "WithdrawalAccount"),
  ]

  fileprivate class _StorageClass {
    var _denom: String = String()
    var _index: UInt32 = 0
    var _status: Stafihub_Stafihub_Ledger_IcaPoolStatus = .unspecified
    var _delegationAccount: Stafihub_Stafihub_Ledger_IcaAccount? = nil
    var _withdrawalAccount: Stafihub_Stafihub_Ledger_IcaAccount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _denom = source._denom
      _index = source._index
      _status = source._status
      _delegationAccount = source._delegationAccount
      _withdrawalAccount = source._withdrawalAccount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._denom) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._index) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._delegationAccount) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._withdrawalAccount) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._denom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._denom, fieldNumber: 1)
      }
      if _storage._index != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._index, fieldNumber: 2)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 3)
      }
      try { if let v = _storage._delegationAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._withdrawalAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Ledger_IcaPoolDetail, rhs: Stafihub_Stafihub_Ledger_IcaPoolDetail) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._denom != rhs_storage._denom {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._delegationAccount != rhs_storage._delegationAccount {return false}
        if _storage._withdrawalAccount != rhs_storage._withdrawalAccount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
