// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: zrchain/validation/hybrid_validation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Validator defines a validator, together with the total amount of the
/// Validator's bond shares and their exchange rate to coins. Slashing results in
/// a decrease in the exchange rate, allowing correct calculation of future
/// undelegations without iterating over delegators. When coins are delegated to
/// this validator, the validator is credited with a delegation whose number of
/// bond shares is based on the amount of coins delegated divided by the current
/// exchange rate. Voting power can be calculated as total bonded shares
/// multiplied by exchange rate.
struct Zrchain_Validation_ValidatorHV {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// operator_address defines the address of the validator's operator; bech
  /// encoded in JSON.
  var operatorAddress: String {
    get {return _storage._operatorAddress}
    set {_uniqueStorage()._operatorAddress = newValue}
  }

  /// consensus_pubkey is the consensus public key of the validator, as a
  /// Protobuf Any.
  var consensusPubkey: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._consensusPubkey ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._consensusPubkey = newValue}
  }
  /// Returns true if `consensusPubkey` has been explicitly set.
  var hasConsensusPubkey: Bool {return _storage._consensusPubkey != nil}
  /// Clears the value of `consensusPubkey`. Subsequent reads from it will return its default value.
  mutating func clearConsensusPubkey() {_uniqueStorage()._consensusPubkey = nil}

  /// jailed defined whether the validator has been jailed from bonded status or
  /// not.
  var jailed: Bool {
    get {return _storage._jailed}
    set {_uniqueStorage()._jailed = newValue}
  }

  /// status is the validator status (bonded/unbonding/unbonded).
  var status: Zrchain_Validation_BondStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// tokens define the delegated tokens (incl. self-delegation).
  var tokensNative: String {
    get {return _storage._tokensNative}
    set {_uniqueStorage()._tokensNative = newValue}
  }

  var tokensAvs: String {
    get {return _storage._tokensAvs}
    set {_uniqueStorage()._tokensAvs = newValue}
  }

  /// delegator_shares defines total shares issued to a validator's delegators.
  var delegatorShares: String {
    get {return _storage._delegatorShares}
    set {_uniqueStorage()._delegatorShares = newValue}
  }

  /// description defines the description terms for the validator.
  var description_p: Zrchain_Validation_Description {
    get {return _storage._description_p ?? Zrchain_Validation_Description()}
    set {_uniqueStorage()._description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return _storage._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {_uniqueStorage()._description_p = nil}

  /// unbonding_height defines, if unbonding, the height at which this validator
  /// has begun unbonding.
  var unbondingHeight: Int64 {
    get {return _storage._unbondingHeight}
    set {_uniqueStorage()._unbondingHeight = newValue}
  }

  /// unbonding_time defines, if unbonding, the min time for the validator to
  /// complete unbonding.
  var unbondingTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._unbondingTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._unbondingTime = newValue}
  }
  /// Returns true if `unbondingTime` has been explicitly set.
  var hasUnbondingTime: Bool {return _storage._unbondingTime != nil}
  /// Clears the value of `unbondingTime`. Subsequent reads from it will return its default value.
  mutating func clearUnbondingTime() {_uniqueStorage()._unbondingTime = nil}

  /// commission defines the commission parameters.
  var commission: Zrchain_Validation_Commission {
    get {return _storage._commission ?? Zrchain_Validation_Commission()}
    set {_uniqueStorage()._commission = newValue}
  }
  /// Returns true if `commission` has been explicitly set.
  var hasCommission: Bool {return _storage._commission != nil}
  /// Clears the value of `commission`. Subsequent reads from it will return its default value.
  mutating func clearCommission() {_uniqueStorage()._commission = nil}

  /// min_self_delegation is the validator's self declared minimum self
  /// delegation.
  var minSelfDelegation: String {
    get {return _storage._minSelfDelegation}
    set {_uniqueStorage()._minSelfDelegation = newValue}
  }

  /// strictly positive if this validator's unbonding has been stopped by
  /// external modules
  var unbondingOnHoldRefCount: Int64 {
    get {return _storage._unbondingOnHoldRefCount}
    set {_uniqueStorage()._unbondingOnHoldRefCount = newValue}
  }

  /// list of unbonding ids, each uniquely identifying an unbonding of this
  /// validator
  var unbondingIds: [UInt64] {
    get {return _storage._unbondingIds}
    set {_uniqueStorage()._unbondingIds = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// HistoricalInfo contains header and validator information for a given block.
/// It is stored as part of staking module's state, which persists the `n` most
/// recent HistoricalInfo
/// (`n` is set by the staking module's `historical_entries` parameter).
struct Zrchain_Validation_HistoricalInfoHV {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: Tendermint_Types_Header {
    get {return _header ?? Tendermint_Types_Header()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var valset: [Zrchain_Validation_ValidatorHV] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Tendermint_Types_Header? = nil
}

struct Zrchain_Validation_SlashEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockHeight: Int64 = 0

  var validatorAddr: String = String()

  var percentageSlashed: String = String()

  var tokensSlashedNative: String = String()

  var tokensSlashedAvs: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Zrchain_Validation_HVParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// % APR
  var avsrewardsRate: String = String()

  /// seconds
  var blockTime: Int64 = 0

  var stakeableAssets: [Zrchain_Validation_AssetData] = []

  var authority: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Zrchain_Validation_ValidationInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonVotingValidators: [String] = []

  var mismatchedVoteExtensions: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Zrchain_Validation_ValidatorHV: @unchecked Sendable {}
extension Zrchain_Validation_HistoricalInfoHV: @unchecked Sendable {}
extension Zrchain_Validation_SlashEvent: @unchecked Sendable {}
extension Zrchain_Validation_HVParams: @unchecked Sendable {}
extension Zrchain_Validation_ValidationInfo: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "zrchain.validation"

extension Zrchain_Validation_ValidatorHV: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatorHV"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operator_address"),
    2: .standard(proto: "consensus_pubkey"),
    3: .same(proto: "jailed"),
    4: .same(proto: "status"),
    5: .same(proto: "tokensNative"),
    6: .same(proto: "tokensAVS"),
    7: .standard(proto: "delegator_shares"),
    8: .same(proto: "description"),
    9: .standard(proto: "unbonding_height"),
    10: .standard(proto: "unbonding_time"),
    11: .same(proto: "commission"),
    12: .standard(proto: "min_self_delegation"),
    13: .standard(proto: "unbonding_on_hold_ref_count"),
    14: .standard(proto: "unbonding_ids"),
  ]

  fileprivate class _StorageClass {
    var _operatorAddress: String = String()
    var _consensusPubkey: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _jailed: Bool = false
    var _status: Zrchain_Validation_BondStatus = .unspecified
    var _tokensNative: String = String()
    var _tokensAvs: String = String()
    var _delegatorShares: String = String()
    var _description_p: Zrchain_Validation_Description? = nil
    var _unbondingHeight: Int64 = 0
    var _unbondingTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _commission: Zrchain_Validation_Commission? = nil
    var _minSelfDelegation: String = String()
    var _unbondingOnHoldRefCount: Int64 = 0
    var _unbondingIds: [UInt64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _operatorAddress = source._operatorAddress
      _consensusPubkey = source._consensusPubkey
      _jailed = source._jailed
      _status = source._status
      _tokensNative = source._tokensNative
      _tokensAvs = source._tokensAvs
      _delegatorShares = source._delegatorShares
      _description_p = source._description_p
      _unbondingHeight = source._unbondingHeight
      _unbondingTime = source._unbondingTime
      _commission = source._commission
      _minSelfDelegation = source._minSelfDelegation
      _unbondingOnHoldRefCount = source._unbondingOnHoldRefCount
      _unbondingIds = source._unbondingIds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._operatorAddress) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._consensusPubkey) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._jailed) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._tokensNative) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._tokensAvs) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._delegatorShares) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._description_p) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._unbondingHeight) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._unbondingTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._commission) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._minSelfDelegation) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._unbondingOnHoldRefCount) }()
        case 14: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._unbondingIds) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._operatorAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._operatorAddress, fieldNumber: 1)
      }
      try { if let v = _storage._consensusPubkey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._jailed != false {
        try visitor.visitSingularBoolField(value: _storage._jailed, fieldNumber: 3)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 4)
      }
      if !_storage._tokensNative.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tokensNative, fieldNumber: 5)
      }
      if !_storage._tokensAvs.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tokensAvs, fieldNumber: 6)
      }
      if !_storage._delegatorShares.isEmpty {
        try visitor.visitSingularStringField(value: _storage._delegatorShares, fieldNumber: 7)
      }
      try { if let v = _storage._description_p {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._unbondingHeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unbondingHeight, fieldNumber: 9)
      }
      try { if let v = _storage._unbondingTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._commission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._minSelfDelegation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minSelfDelegation, fieldNumber: 12)
      }
      if _storage._unbondingOnHoldRefCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unbondingOnHoldRefCount, fieldNumber: 13)
      }
      if !_storage._unbondingIds.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._unbondingIds, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Validation_ValidatorHV, rhs: Zrchain_Validation_ValidatorHV) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operatorAddress != rhs_storage._operatorAddress {return false}
        if _storage._consensusPubkey != rhs_storage._consensusPubkey {return false}
        if _storage._jailed != rhs_storage._jailed {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._tokensNative != rhs_storage._tokensNative {return false}
        if _storage._tokensAvs != rhs_storage._tokensAvs {return false}
        if _storage._delegatorShares != rhs_storage._delegatorShares {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._unbondingHeight != rhs_storage._unbondingHeight {return false}
        if _storage._unbondingTime != rhs_storage._unbondingTime {return false}
        if _storage._commission != rhs_storage._commission {return false}
        if _storage._minSelfDelegation != rhs_storage._minSelfDelegation {return false}
        if _storage._unbondingOnHoldRefCount != rhs_storage._unbondingOnHoldRefCount {return false}
        if _storage._unbondingIds != rhs_storage._unbondingIds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Validation_HistoricalInfoHV: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HistoricalInfoHV"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "valset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.valset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.valset.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.valset, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Validation_HistoricalInfoHV, rhs: Zrchain_Validation_HistoricalInfoHV) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.valset != rhs.valset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Validation_SlashEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlashEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockHeight"),
    2: .same(proto: "validatorAddr"),
    3: .same(proto: "percentageSlashed"),
    4: .same(proto: "tokensSlashedNative"),
    5: .same(proto: "tokensSlashedAVS"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.blockHeight) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.validatorAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.percentageSlashed) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tokensSlashedNative) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.tokensSlashedAvs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blockHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.blockHeight, fieldNumber: 1)
    }
    if !self.validatorAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddr, fieldNumber: 2)
    }
    if !self.percentageSlashed.isEmpty {
      try visitor.visitSingularStringField(value: self.percentageSlashed, fieldNumber: 3)
    }
    if !self.tokensSlashedNative.isEmpty {
      try visitor.visitSingularStringField(value: self.tokensSlashedNative, fieldNumber: 4)
    }
    if !self.tokensSlashedAvs.isEmpty {
      try visitor.visitSingularStringField(value: self.tokensSlashedAvs, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Validation_SlashEvent, rhs: Zrchain_Validation_SlashEvent) -> Bool {
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.validatorAddr != rhs.validatorAddr {return false}
    if lhs.percentageSlashed != rhs.percentageSlashed {return false}
    if lhs.tokensSlashedNative != rhs.tokensSlashedNative {return false}
    if lhs.tokensSlashedAvs != rhs.tokensSlashedAvs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Validation_HVParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HVParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AVSRewardsRate"),
    2: .same(proto: "BlockTime"),
    3: .same(proto: "stakeableAssets"),
    4: .same(proto: "authority"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.avsrewardsRate) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.blockTime) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.stakeableAssets) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.avsrewardsRate.isEmpty {
      try visitor.visitSingularStringField(value: self.avsrewardsRate, fieldNumber: 1)
    }
    if self.blockTime != 0 {
      try visitor.visitSingularInt64Field(value: self.blockTime, fieldNumber: 2)
    }
    if !self.stakeableAssets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stakeableAssets, fieldNumber: 3)
    }
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Validation_HVParams, rhs: Zrchain_Validation_HVParams) -> Bool {
    if lhs.avsrewardsRate != rhs.avsrewardsRate {return false}
    if lhs.blockTime != rhs.blockTime {return false}
    if lhs.stakeableAssets != rhs.stakeableAssets {return false}
    if lhs.authority != rhs.authority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Validation_ValidationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidationInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "non_voting_validators"),
    2: .standard(proto: "mismatched_vote_extensions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.nonVotingValidators) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.mismatchedVoteExtensions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nonVotingValidators.isEmpty {
      try visitor.visitRepeatedStringField(value: self.nonVotingValidators, fieldNumber: 1)
    }
    if !self.mismatchedVoteExtensions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mismatchedVoteExtensions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Validation_ValidationInfo, rhs: Zrchain_Validation_ValidationInfo) -> Bool {
    if lhs.nonVotingValidators != rhs.nonVotingValidators {return false}
    if lhs.mismatchedVoteExtensions != rhs.mismatchedVoteExtensions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
