// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: osmosis/protorev/v1beta1/genesis.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// GenesisState defines the protorev module's genesis state.
struct Osmosis_Protorev_V1beta1_GenesisState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parameters for the protorev module.
  var params: Osmosis_Protorev_V1beta1_Params {
    get {return _storage._params ?? Osmosis_Protorev_V1beta1_Params()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {_uniqueStorage()._params = nil}

  /// Token pair arb routes for the protorev module (hot routes).
  var tokenPairArbRoutes: [Osmosis_Protorev_V1beta1_TokenPairArbRoutes] {
    get {return _storage._tokenPairArbRoutes}
    set {_uniqueStorage()._tokenPairArbRoutes = newValue}
  }

  /// The base denominations being used to create cyclic arbitrage routes via the
  /// highest liquidity method.
  var baseDenoms: [Osmosis_Protorev_V1beta1_BaseDenom] {
    get {return _storage._baseDenoms}
    set {_uniqueStorage()._baseDenoms = newValue}
  }

  /// DEPRECATED: pool_weights are weights that are being used to calculate the
  /// compute cost of each route. This field is deprecated.
  /// It is replaced by the `info_by_pool_type` field.
  var poolWeights: Osmosis_Protorev_V1beta1_PoolWeights {
    get {return _storage._poolWeights ?? Osmosis_Protorev_V1beta1_PoolWeights()}
    set {_uniqueStorage()._poolWeights = newValue}
  }
  /// Returns true if `poolWeights` has been explicitly set.
  var hasPoolWeights: Bool {return _storage._poolWeights != nil}
  /// Clears the value of `poolWeights`. Subsequent reads from it will return its default value.
  mutating func clearPoolWeights() {_uniqueStorage()._poolWeights = nil}

  /// The number of days since module genesis.
  var daysSinceModuleGenesis: UInt64 {
    get {return _storage._daysSinceModuleGenesis}
    set {_uniqueStorage()._daysSinceModuleGenesis = newValue}
  }

  /// The fees the developer account has accumulated over time.
  var developerFees: [Cosmos_Base_V1beta1_Coin] {
    get {return _storage._developerFees}
    set {_uniqueStorage()._developerFees = newValue}
  }

  /// The latest block height that the module has processed.
  var latestBlockHeight: UInt64 {
    get {return _storage._latestBlockHeight}
    set {_uniqueStorage()._latestBlockHeight = newValue}
  }

  /// The developer account address of the module.
  var developerAddress: String {
    get {return _storage._developerAddress}
    set {_uniqueStorage()._developerAddress = newValue}
  }

  /// Max pool points per block i.e. the maximum compute time (in ms)
  /// that protorev can use per block.
  var maxPoolPointsPerBlock: UInt64 {
    get {return _storage._maxPoolPointsPerBlock}
    set {_uniqueStorage()._maxPoolPointsPerBlock = newValue}
  }

  /// Max pool points per tx i.e. the maximum compute time (in ms) that
  /// protorev can use per tx.
  var maxPoolPointsPerTx: UInt64 {
    get {return _storage._maxPoolPointsPerTx}
    set {_uniqueStorage()._maxPoolPointsPerTx = newValue}
  }

  /// The number of pool points that have been consumed in the current block.
  var pointCountForBlock: UInt64 {
    get {return _storage._pointCountForBlock}
    set {_uniqueStorage()._pointCountForBlock = newValue}
  }

  /// All of the profits that have been accumulated by the module.
  var profits: [Cosmos_Base_V1beta1_Coin] {
    get {return _storage._profits}
    set {_uniqueStorage()._profits = newValue}
  }

  /// Information that is used to estimate execution time / gas
  /// consumption of a swap on a given pool type.
  var infoByPoolType: Osmosis_Protorev_V1beta1_InfoByPoolType {
    get {return _storage._infoByPoolType ?? Osmosis_Protorev_V1beta1_InfoByPoolType()}
    set {_uniqueStorage()._infoByPoolType = newValue}
  }
  /// Returns true if `infoByPoolType` has been explicitly set.
  var hasInfoByPoolType: Bool {return _storage._infoByPoolType != nil}
  /// Clears the value of `infoByPoolType`. Subsequent reads from it will return its default value.
  mutating func clearInfoByPoolType() {_uniqueStorage()._infoByPoolType = nil}

  var cyclicArbTracker: Osmosis_Protorev_V1beta1_CyclicArbTracker {
    get {return _storage._cyclicArbTracker ?? Osmosis_Protorev_V1beta1_CyclicArbTracker()}
    set {_uniqueStorage()._cyclicArbTracker = newValue}
  }
  /// Returns true if `cyclicArbTracker` has been explicitly set.
  var hasCyclicArbTracker: Bool {return _storage._cyclicArbTracker != nil}
  /// Clears the value of `cyclicArbTracker`. Subsequent reads from it will return its default value.
  mutating func clearCyclicArbTracker() {_uniqueStorage()._cyclicArbTracker = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Osmosis_Protorev_V1beta1_GenesisState: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "osmosis.protorev.v1beta1"

extension Osmosis_Protorev_V1beta1_GenesisState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .standard(proto: "token_pair_arb_routes"),
    3: .standard(proto: "base_denoms"),
    4: .standard(proto: "pool_weights"),
    5: .standard(proto: "days_since_module_genesis"),
    6: .standard(proto: "developer_fees"),
    7: .standard(proto: "latest_block_height"),
    8: .standard(proto: "developer_address"),
    9: .standard(proto: "max_pool_points_per_block"),
    10: .standard(proto: "max_pool_points_per_tx"),
    11: .standard(proto: "point_count_for_block"),
    12: .same(proto: "profits"),
    13: .standard(proto: "info_by_pool_type"),
    14: .standard(proto: "cyclic_arb_tracker"),
  ]

  fileprivate class _StorageClass {
    var _params: Osmosis_Protorev_V1beta1_Params? = nil
    var _tokenPairArbRoutes: [Osmosis_Protorev_V1beta1_TokenPairArbRoutes] = []
    var _baseDenoms: [Osmosis_Protorev_V1beta1_BaseDenom] = []
    var _poolWeights: Osmosis_Protorev_V1beta1_PoolWeights? = nil
    var _daysSinceModuleGenesis: UInt64 = 0
    var _developerFees: [Cosmos_Base_V1beta1_Coin] = []
    var _latestBlockHeight: UInt64 = 0
    var _developerAddress: String = String()
    var _maxPoolPointsPerBlock: UInt64 = 0
    var _maxPoolPointsPerTx: UInt64 = 0
    var _pointCountForBlock: UInt64 = 0
    var _profits: [Cosmos_Base_V1beta1_Coin] = []
    var _infoByPoolType: Osmosis_Protorev_V1beta1_InfoByPoolType? = nil
    var _cyclicArbTracker: Osmosis_Protorev_V1beta1_CyclicArbTracker? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _params = source._params
      _tokenPairArbRoutes = source._tokenPairArbRoutes
      _baseDenoms = source._baseDenoms
      _poolWeights = source._poolWeights
      _daysSinceModuleGenesis = source._daysSinceModuleGenesis
      _developerFees = source._developerFees
      _latestBlockHeight = source._latestBlockHeight
      _developerAddress = source._developerAddress
      _maxPoolPointsPerBlock = source._maxPoolPointsPerBlock
      _maxPoolPointsPerTx = source._maxPoolPointsPerTx
      _pointCountForBlock = source._pointCountForBlock
      _profits = source._profits
      _infoByPoolType = source._infoByPoolType
      _cyclicArbTracker = source._cyclicArbTracker
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._tokenPairArbRoutes) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._baseDenoms) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._poolWeights) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._daysSinceModuleGenesis) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._developerFees) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._latestBlockHeight) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._developerAddress) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxPoolPointsPerBlock) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxPoolPointsPerTx) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._pointCountForBlock) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._profits) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._infoByPoolType) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._cyclicArbTracker) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._tokenPairArbRoutes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokenPairArbRoutes, fieldNumber: 2)
      }
      if !_storage._baseDenoms.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._baseDenoms, fieldNumber: 3)
      }
      try { if let v = _storage._poolWeights {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._daysSinceModuleGenesis != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._daysSinceModuleGenesis, fieldNumber: 5)
      }
      if !_storage._developerFees.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._developerFees, fieldNumber: 6)
      }
      if _storage._latestBlockHeight != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._latestBlockHeight, fieldNumber: 7)
      }
      if !_storage._developerAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._developerAddress, fieldNumber: 8)
      }
      if _storage._maxPoolPointsPerBlock != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._maxPoolPointsPerBlock, fieldNumber: 9)
      }
      if _storage._maxPoolPointsPerTx != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._maxPoolPointsPerTx, fieldNumber: 10)
      }
      if _storage._pointCountForBlock != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._pointCountForBlock, fieldNumber: 11)
      }
      if !_storage._profits.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._profits, fieldNumber: 12)
      }
      try { if let v = _storage._infoByPoolType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._cyclicArbTracker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Protorev_V1beta1_GenesisState, rhs: Osmosis_Protorev_V1beta1_GenesisState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._params != rhs_storage._params {return false}
        if _storage._tokenPairArbRoutes != rhs_storage._tokenPairArbRoutes {return false}
        if _storage._baseDenoms != rhs_storage._baseDenoms {return false}
        if _storage._poolWeights != rhs_storage._poolWeights {return false}
        if _storage._daysSinceModuleGenesis != rhs_storage._daysSinceModuleGenesis {return false}
        if _storage._developerFees != rhs_storage._developerFees {return false}
        if _storage._latestBlockHeight != rhs_storage._latestBlockHeight {return false}
        if _storage._developerAddress != rhs_storage._developerAddress {return false}
        if _storage._maxPoolPointsPerBlock != rhs_storage._maxPoolPointsPerBlock {return false}
        if _storage._maxPoolPointsPerTx != rhs_storage._maxPoolPointsPerTx {return false}
        if _storage._pointCountForBlock != rhs_storage._pointCountForBlock {return false}
        if _storage._profits != rhs_storage._profits {return false}
        if _storage._infoByPoolType != rhs_storage._infoByPoolType {return false}
        if _storage._cyclicArbTracker != rhs_storage._cyclicArbTracker {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
