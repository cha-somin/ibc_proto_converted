// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: umee/leverage/v1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgSupply represents a user's request to supply assets to the module.
struct Umee_Leverage_V1_MsgSupply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Supplier is the account address supplying assets and the signer of the message.
  var supplier: String = String()

  var asset: Cosmos_Base_V1beta1_Coin {
    get {return _asset ?? Cosmos_Base_V1beta1_Coin()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgWithdraw represents a user's request to withdraw supplied assets.
/// Asset must be a uToken.
struct Umee_Leverage_V1_MsgWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Supplier is the account address withdrawing assets and the signer of the message.
  var supplier: String = String()

  var asset: Cosmos_Base_V1beta1_Coin {
    get {return _asset ?? Cosmos_Base_V1beta1_Coin()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgMaxWithdraw represents a user's request to withdraw the maximum valid amount of supplied assets.
struct Umee_Leverage_V1_MsgMaxWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Supplier is the account address withdrawing assets and the signer of the message.
  var supplier: String = String()

  /// Denom is base token denom to withdraw
  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCollateralize represents a user's request to enable selected
/// uTokens as collateral.
struct Umee_Leverage_V1_MsgCollateralize {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Borrower is the account address adding collateral and the signer of the message.
  var borrower: String = String()

  var asset: Cosmos_Base_V1beta1_Coin {
    get {return _asset ?? Cosmos_Base_V1beta1_Coin()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgDecollateralize represents a user's request to disable selected
/// uTokens as collateral.
struct Umee_Leverage_V1_MsgDecollateralize {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Borrower is the account address removing collateral and the signer of the message.
  var borrower: String = String()

  var asset: Cosmos_Base_V1beta1_Coin {
    get {return _asset ?? Cosmos_Base_V1beta1_Coin()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgBorrow represents a user's request to borrow a base asset type
/// from the module.
struct Umee_Leverage_V1_MsgBorrow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Borrower is the account address taking a loan and the signer
  /// of the message.
  var borrower: String = String()

  var asset: Cosmos_Base_V1beta1_Coin {
    get {return _asset ?? Cosmos_Base_V1beta1_Coin()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgMaxBorrow represents a user's request to borrow a base asset type
/// from the module, using the maximum available amount.
struct Umee_Leverage_V1_MsgMaxBorrow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Borrower is the account address taking a loan and the signer
  /// of the message.
  var borrower: String = String()

  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRepay represents a user's request to repay a borrowed base asset
/// type to the module.
struct Umee_Leverage_V1_MsgRepay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Borrower is the account address repaying a loan and the signer
  /// of the message.
  var borrower: String = String()

  var asset: Cosmos_Base_V1beta1_Coin {
    get {return _asset ?? Cosmos_Base_V1beta1_Coin()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgLiquidate is the request structure for the Liquidate RPC.
struct Umee_Leverage_V1_MsgLiquidate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Liquidator is the account address performing a liquidation and the signer
  /// of the message.
  var liquidator: String = String()

  /// Borrower is the account whose borrow is being repaid, and collateral consumed,
  /// by the liquidation. It does not sign the message.
  var borrower: String = String()

  /// Repayment is the maximum amount of base tokens that the liquidator is willing
  /// to repay.
  var repayment: Cosmos_Base_V1beta1_Coin {
    get {return _repayment ?? Cosmos_Base_V1beta1_Coin()}
    set {_repayment = newValue}
  }
  /// Returns true if `repayment` has been explicitly set.
  var hasRepayment: Bool {return self._repayment != nil}
  /// Clears the value of `repayment`. Subsequent reads from it will return its default value.
  mutating func clearRepayment() {self._repayment = nil}

  /// RewardDenom is the denom that the liquidator will receive as a liquidation reward.
  /// If it is a uToken, the liquidator will receive uTokens from the borrower's
  /// collateral. If it is a base token, the uTokens will be redeemed directly at
  /// a reduced Liquidation Incentive, and the liquidator will receive base tokens.
  var rewardDenom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _repayment: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgSupplyCollateral represents a user's request to supply and collateralize assets to the module.
struct Umee_Leverage_V1_MsgSupplyCollateral {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Supplier is the account address supplying assets and the signer of the message.
  var supplier: String = String()

  var asset: Cosmos_Base_V1beta1_Coin {
    get {return _asset ?? Cosmos_Base_V1beta1_Coin()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgSupplyResponse defines the Msg/Supply response type.
struct Umee_Leverage_V1_MsgSupplyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Received is the amount of uTokens received.
  var received: Cosmos_Base_V1beta1_Coin {
    get {return _received ?? Cosmos_Base_V1beta1_Coin()}
    set {_received = newValue}
  }
  /// Returns true if `received` has been explicitly set.
  var hasReceived: Bool {return self._received != nil}
  /// Clears the value of `received`. Subsequent reads from it will return its default value.
  mutating func clearReceived() {self._received = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _received: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgWithdrawResponse defines the Msg/Withdraw response type.
struct Umee_Leverage_V1_MsgWithdrawResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Received is the amount of base tokens received.
  var received: Cosmos_Base_V1beta1_Coin {
    get {return _received ?? Cosmos_Base_V1beta1_Coin()}
    set {_received = newValue}
  }
  /// Returns true if `received` has been explicitly set.
  var hasReceived: Bool {return self._received != nil}
  /// Clears the value of `received`. Subsequent reads from it will return its default value.
  mutating func clearReceived() {self._received = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _received: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgMaxWithdrawResponse defines the Msg/MaxWithdraw response type.
struct Umee_Leverage_V1_MsgMaxWithdrawResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Withdrawn is the amount of uTokens withdrawn.
  var withdrawn: Cosmos_Base_V1beta1_Coin {
    get {return _withdrawn ?? Cosmos_Base_V1beta1_Coin()}
    set {_withdrawn = newValue}
  }
  /// Returns true if `withdrawn` has been explicitly set.
  var hasWithdrawn: Bool {return self._withdrawn != nil}
  /// Clears the value of `withdrawn`. Subsequent reads from it will return its default value.
  mutating func clearWithdrawn() {self._withdrawn = nil}

  /// Received is the amount of base tokens received.
  var received: Cosmos_Base_V1beta1_Coin {
    get {return _received ?? Cosmos_Base_V1beta1_Coin()}
    set {_received = newValue}
  }
  /// Returns true if `received` has been explicitly set.
  var hasReceived: Bool {return self._received != nil}
  /// Clears the value of `received`. Subsequent reads from it will return its default value.
  mutating func clearReceived() {self._received = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _withdrawn: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _received: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgCollateralizeResponse defines the Msg/Collateralize response type.
struct Umee_Leverage_V1_MsgCollateralizeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDecollateralizeResponse defines the Msg/Decollateralize response type.
struct Umee_Leverage_V1_MsgDecollateralizeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBorrowResponse defines the Msg/Borrow response type.
struct Umee_Leverage_V1_MsgBorrowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgMaxBorrowResponse defines the Msg/MaxBorrow response type.
struct Umee_Leverage_V1_MsgMaxBorrowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Borrowed is the amount of tokens borrowed.
  var borrowed: Cosmos_Base_V1beta1_Coin {
    get {return _borrowed ?? Cosmos_Base_V1beta1_Coin()}
    set {_borrowed = newValue}
  }
  /// Returns true if `borrowed` has been explicitly set.
  var hasBorrowed: Bool {return self._borrowed != nil}
  /// Clears the value of `borrowed`. Subsequent reads from it will return its default value.
  mutating func clearBorrowed() {self._borrowed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _borrowed: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgRepayResponse defines the Msg/Repay response type.
struct Umee_Leverage_V1_MsgRepayResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Repaid is the amount of base tokens repaid to the module.
  var repaid: Cosmos_Base_V1beta1_Coin {
    get {return _repaid ?? Cosmos_Base_V1beta1_Coin()}
    set {_repaid = newValue}
  }
  /// Returns true if `repaid` has been explicitly set.
  var hasRepaid: Bool {return self._repaid != nil}
  /// Clears the value of `repaid`. Subsequent reads from it will return its default value.
  mutating func clearRepaid() {self._repaid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _repaid: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgLiquidateResponse defines the Msg/Liquidate response type.
struct Umee_Leverage_V1_MsgLiquidateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Repaid is the amount of borrowed base tokens that the liquidator repaid
  /// to the module on behalf of the borrower.
  var repaid: Cosmos_Base_V1beta1_Coin {
    get {return _repaid ?? Cosmos_Base_V1beta1_Coin()}
    set {_repaid = newValue}
  }
  /// Returns true if `repaid` has been explicitly set.
  var hasRepaid: Bool {return self._repaid != nil}
  /// Clears the value of `repaid`. Subsequent reads from it will return its default value.
  mutating func clearRepaid() {self._repaid = nil}

  /// Collateral is the amount of the borrower's uToken collateral that
  /// was liquidated.
  var collateral: Cosmos_Base_V1beta1_Coin {
    get {return _collateral ?? Cosmos_Base_V1beta1_Coin()}
    set {_collateral = newValue}
  }
  /// Returns true if `collateral` has been explicitly set.
  var hasCollateral: Bool {return self._collateral != nil}
  /// Clears the value of `collateral`. Subsequent reads from it will return its default value.
  mutating func clearCollateral() {self._collateral = nil}

  /// Reward is the amount of base tokens that the liquidator received from
  /// the module as reward for the liquidation.
  var reward: Cosmos_Base_V1beta1_Coin {
    get {return _reward ?? Cosmos_Base_V1beta1_Coin()}
    set {_reward = newValue}
  }
  /// Returns true if `reward` has been explicitly set.
  var hasReward: Bool {return self._reward != nil}
  /// Clears the value of `reward`. Subsequent reads from it will return its default value.
  mutating func clearReward() {self._reward = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _repaid: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _collateral: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _reward: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgSupplyCollateralResponse defines the Msg/SupplyCollateral response type.
struct Umee_Leverage_V1_MsgSupplyCollateralResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Collateralized is the amount of uTokens collateralized.
  var collateralized: Cosmos_Base_V1beta1_Coin {
    get {return _collateralized ?? Cosmos_Base_V1beta1_Coin()}
    set {_collateralized = newValue}
  }
  /// Returns true if `collateralized` has been explicitly set.
  var hasCollateralized: Bool {return self._collateralized != nil}
  /// Clears the value of `collateralized`. Subsequent reads from it will return its default value.
  mutating func clearCollateralized() {self._collateralized = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _collateralized: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgGovUpdateRegistry defines the Msg/GovUpdateRegistry request type.
struct Umee_Leverage_V1_MsgGovUpdateRegistry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authority is the address of the governance account.
  var authority: String = String()

  var title: String = String()

  var description_p: String = String()

  /// add_tokens defines new token settings.
  var addTokens: [Umee_Leverage_V1_Token] = []

  /// update_tokens defines the new settings for existed tokens.
  var updateTokens: [Umee_Leverage_V1_Token] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgGovUpdateRegistryResponse defines the Msg/GovUpdateRegistry response type.
struct Umee_Leverage_V1_MsgGovUpdateRegistryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Umee_Leverage_V1_MsgSupply: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgWithdraw: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgMaxWithdraw: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgCollateralize: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgDecollateralize: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgBorrow: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgMaxBorrow: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgRepay: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgLiquidate: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgSupplyCollateral: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgSupplyResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgWithdrawResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgMaxWithdrawResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgCollateralizeResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgDecollateralizeResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgBorrowResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgMaxBorrowResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgRepayResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgLiquidateResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgSupplyCollateralResponse: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgGovUpdateRegistry: @unchecked Sendable {}
extension Umee_Leverage_V1_MsgGovUpdateRegistryResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "umee.leverage.v1"

extension Umee_Leverage_V1_MsgSupply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSupply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "supplier"),
    2: .same(proto: "asset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.supplier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.supplier.isEmpty {
      try visitor.visitSingularStringField(value: self.supplier, fieldNumber: 1)
    }
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgSupply, rhs: Umee_Leverage_V1_MsgSupply) -> Bool {
    if lhs.supplier != rhs.supplier {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "supplier"),
    2: .same(proto: "asset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.supplier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.supplier.isEmpty {
      try visitor.visitSingularStringField(value: self.supplier, fieldNumber: 1)
    }
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgWithdraw, rhs: Umee_Leverage_V1_MsgWithdraw) -> Bool {
    if lhs.supplier != rhs.supplier {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgMaxWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMaxWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "supplier"),
    2: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.supplier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.supplier.isEmpty {
      try visitor.visitSingularStringField(value: self.supplier, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgMaxWithdraw, rhs: Umee_Leverage_V1_MsgMaxWithdraw) -> Bool {
    if lhs.supplier != rhs.supplier {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgCollateralize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCollateralize"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "borrower"),
    2: .same(proto: "asset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.borrower) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.borrower.isEmpty {
      try visitor.visitSingularStringField(value: self.borrower, fieldNumber: 1)
    }
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgCollateralize, rhs: Umee_Leverage_V1_MsgCollateralize) -> Bool {
    if lhs.borrower != rhs.borrower {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgDecollateralize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDecollateralize"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "borrower"),
    2: .same(proto: "asset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.borrower) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.borrower.isEmpty {
      try visitor.visitSingularStringField(value: self.borrower, fieldNumber: 1)
    }
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgDecollateralize, rhs: Umee_Leverage_V1_MsgDecollateralize) -> Bool {
    if lhs.borrower != rhs.borrower {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgBorrow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBorrow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "borrower"),
    2: .same(proto: "asset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.borrower) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.borrower.isEmpty {
      try visitor.visitSingularStringField(value: self.borrower, fieldNumber: 1)
    }
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgBorrow, rhs: Umee_Leverage_V1_MsgBorrow) -> Bool {
    if lhs.borrower != rhs.borrower {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgMaxBorrow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMaxBorrow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "borrower"),
    2: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.borrower) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.borrower.isEmpty {
      try visitor.visitSingularStringField(value: self.borrower, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgMaxBorrow, rhs: Umee_Leverage_V1_MsgMaxBorrow) -> Bool {
    if lhs.borrower != rhs.borrower {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgRepay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRepay"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "borrower"),
    2: .same(proto: "asset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.borrower) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.borrower.isEmpty {
      try visitor.visitSingularStringField(value: self.borrower, fieldNumber: 1)
    }
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgRepay, rhs: Umee_Leverage_V1_MsgRepay) -> Bool {
    if lhs.borrower != rhs.borrower {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgLiquidate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgLiquidate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "liquidator"),
    2: .same(proto: "borrower"),
    3: .same(proto: "repayment"),
    4: .standard(proto: "reward_denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.liquidator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.borrower) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._repayment) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.rewardDenom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.liquidator.isEmpty {
      try visitor.visitSingularStringField(value: self.liquidator, fieldNumber: 1)
    }
    if !self.borrower.isEmpty {
      try visitor.visitSingularStringField(value: self.borrower, fieldNumber: 2)
    }
    try { if let v = self._repayment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.rewardDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardDenom, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgLiquidate, rhs: Umee_Leverage_V1_MsgLiquidate) -> Bool {
    if lhs.liquidator != rhs.liquidator {return false}
    if lhs.borrower != rhs.borrower {return false}
    if lhs._repayment != rhs._repayment {return false}
    if lhs.rewardDenom != rhs.rewardDenom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgSupplyCollateral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSupplyCollateral"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "supplier"),
    2: .same(proto: "asset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.supplier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.supplier.isEmpty {
      try visitor.visitSingularStringField(value: self.supplier, fieldNumber: 1)
    }
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgSupplyCollateral, rhs: Umee_Leverage_V1_MsgSupplyCollateral) -> Bool {
    if lhs.supplier != rhs.supplier {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgSupplyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSupplyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "received"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._received) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._received {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgSupplyResponse, rhs: Umee_Leverage_V1_MsgSupplyResponse) -> Bool {
    if lhs._received != rhs._received {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgWithdrawResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "received"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._received) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._received {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgWithdrawResponse, rhs: Umee_Leverage_V1_MsgWithdrawResponse) -> Bool {
    if lhs._received != rhs._received {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgMaxWithdrawResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMaxWithdrawResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "withdrawn"),
    2: .same(proto: "received"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._withdrawn) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._received) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._withdrawn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._received {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgMaxWithdrawResponse, rhs: Umee_Leverage_V1_MsgMaxWithdrawResponse) -> Bool {
    if lhs._withdrawn != rhs._withdrawn {return false}
    if lhs._received != rhs._received {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgCollateralizeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCollateralizeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgCollateralizeResponse, rhs: Umee_Leverage_V1_MsgCollateralizeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgDecollateralizeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDecollateralizeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgDecollateralizeResponse, rhs: Umee_Leverage_V1_MsgDecollateralizeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgBorrowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBorrowResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgBorrowResponse, rhs: Umee_Leverage_V1_MsgBorrowResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgMaxBorrowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMaxBorrowResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "borrowed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._borrowed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._borrowed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgMaxBorrowResponse, rhs: Umee_Leverage_V1_MsgMaxBorrowResponse) -> Bool {
    if lhs._borrowed != rhs._borrowed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgRepayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRepayResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "repaid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._repaid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._repaid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgRepayResponse, rhs: Umee_Leverage_V1_MsgRepayResponse) -> Bool {
    if lhs._repaid != rhs._repaid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgLiquidateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgLiquidateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "repaid"),
    2: .same(proto: "collateral"),
    3: .same(proto: "reward"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._repaid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._collateral) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._reward) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._repaid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._collateral {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._reward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgLiquidateResponse, rhs: Umee_Leverage_V1_MsgLiquidateResponse) -> Bool {
    if lhs._repaid != rhs._repaid {return false}
    if lhs._collateral != rhs._collateral {return false}
    if lhs._reward != rhs._reward {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgSupplyCollateralResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSupplyCollateralResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collateralized"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._collateralized) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._collateralized {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgSupplyCollateralResponse, rhs: Umee_Leverage_V1_MsgSupplyCollateralResponse) -> Bool {
    if lhs._collateralized != rhs._collateralized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgGovUpdateRegistry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGovUpdateRegistry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "title"),
    3: .same(proto: "description"),
    4: .standard(proto: "add_tokens"),
    5: .standard(proto: "update_tokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.addTokens) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.updateTokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.addTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addTokens, fieldNumber: 4)
    }
    if !self.updateTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updateTokens, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgGovUpdateRegistry, rhs: Umee_Leverage_V1_MsgGovUpdateRegistry) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.addTokens != rhs.addTokens {return false}
    if lhs.updateTokens != rhs.updateTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Leverage_V1_MsgGovUpdateRegistryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGovUpdateRegistryResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Leverage_V1_MsgGovUpdateRegistryResponse, rhs: Umee_Leverage_V1_MsgGovUpdateRegistryResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
