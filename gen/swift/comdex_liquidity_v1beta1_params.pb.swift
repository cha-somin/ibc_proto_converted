// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: comdex/liquidity/v1beta1/params.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Params defines the parameters for the liquidity module.
struct Comdex_Liquidity_V1beta1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Params defines the parameters for the liquidity module.
struct Comdex_Liquidity_V1beta1_GenericParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var batchSize: UInt64 {
    get {return _storage._batchSize}
    set {_uniqueStorage()._batchSize = newValue}
  }

  var tickPrecision: UInt64 {
    get {return _storage._tickPrecision}
    set {_uniqueStorage()._tickPrecision = newValue}
  }

  var feeCollectorAddress: String {
    get {return _storage._feeCollectorAddress}
    set {_uniqueStorage()._feeCollectorAddress = newValue}
  }

  var dustCollectorAddress: String {
    get {return _storage._dustCollectorAddress}
    set {_uniqueStorage()._dustCollectorAddress = newValue}
  }

  var minInitialPoolCoinSupply: String {
    get {return _storage._minInitialPoolCoinSupply}
    set {_uniqueStorage()._minInitialPoolCoinSupply = newValue}
  }

  var pairCreationFee: [Cosmos_Base_V1beta1_Coin] {
    get {return _storage._pairCreationFee}
    set {_uniqueStorage()._pairCreationFee = newValue}
  }

  var poolCreationFee: [Cosmos_Base_V1beta1_Coin] {
    get {return _storage._poolCreationFee}
    set {_uniqueStorage()._poolCreationFee = newValue}
  }

  var minInitialDepositAmount: String {
    get {return _storage._minInitialDepositAmount}
    set {_uniqueStorage()._minInitialDepositAmount = newValue}
  }

  var maxPriceLimitRatio: String {
    get {return _storage._maxPriceLimitRatio}
    set {_uniqueStorage()._maxPriceLimitRatio = newValue}
  }

  var maxOrderLifespan: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._maxOrderLifespan ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._maxOrderLifespan = newValue}
  }
  /// Returns true if `maxOrderLifespan` has been explicitly set.
  var hasMaxOrderLifespan: Bool {return _storage._maxOrderLifespan != nil}
  /// Clears the value of `maxOrderLifespan`. Subsequent reads from it will return its default value.
  mutating func clearMaxOrderLifespan() {_uniqueStorage()._maxOrderLifespan = nil}

  var swapFeeRate: String {
    get {return _storage._swapFeeRate}
    set {_uniqueStorage()._swapFeeRate = newValue}
  }

  var withdrawFeeRate: String {
    get {return _storage._withdrawFeeRate}
    set {_uniqueStorage()._withdrawFeeRate = newValue}
  }

  var depositExtraGas: UInt64 {
    get {return _storage._depositExtraGas}
    set {_uniqueStorage()._depositExtraGas = newValue}
  }

  var withdrawExtraGas: UInt64 {
    get {return _storage._withdrawExtraGas}
    set {_uniqueStorage()._withdrawExtraGas = newValue}
  }

  var orderExtraGas: UInt64 {
    get {return _storage._orderExtraGas}
    set {_uniqueStorage()._orderExtraGas = newValue}
  }

  var swapFeeDistrDenom: String {
    get {return _storage._swapFeeDistrDenom}
    set {_uniqueStorage()._swapFeeDistrDenom = newValue}
  }

  var swapFeeBurnRate: String {
    get {return _storage._swapFeeBurnRate}
    set {_uniqueStorage()._swapFeeBurnRate = newValue}
  }

  var appID: UInt64 {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  var maxNumMarketMakingOrderTicks: UInt64 {
    get {return _storage._maxNumMarketMakingOrderTicks}
    set {_uniqueStorage()._maxNumMarketMakingOrderTicks = newValue}
  }

  var maxNumActivePoolsPerPair: UInt64 {
    get {return _storage._maxNumActivePoolsPerPair}
    set {_uniqueStorage()._maxNumActivePoolsPerPair = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Comdex_Liquidity_V1beta1_Params: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_GenericParams: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "comdex.liquidity.v1beta1"

extension Comdex_Liquidity_V1beta1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_Params, rhs: Comdex_Liquidity_V1beta1_Params) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_GenericParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenericParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_size"),
    2: .standard(proto: "tick_precision"),
    3: .standard(proto: "fee_collector_address"),
    4: .standard(proto: "dust_collector_address"),
    5: .standard(proto: "min_initial_pool_coin_supply"),
    6: .standard(proto: "pair_creation_fee"),
    7: .standard(proto: "pool_creation_fee"),
    8: .standard(proto: "min_initial_deposit_amount"),
    9: .standard(proto: "max_price_limit_ratio"),
    10: .standard(proto: "max_order_lifespan"),
    11: .standard(proto: "swap_fee_rate"),
    12: .standard(proto: "withdraw_fee_rate"),
    13: .standard(proto: "deposit_extra_gas"),
    14: .standard(proto: "withdraw_extra_gas"),
    15: .standard(proto: "order_extra_gas"),
    16: .standard(proto: "swap_fee_distr_denom"),
    17: .standard(proto: "swap_fee_burn_rate"),
    18: .standard(proto: "app_id"),
    19: .standard(proto: "max_num_market_making_order_ticks"),
    20: .standard(proto: "max_num_active_pools_per_pair"),
  ]

  fileprivate class _StorageClass {
    var _batchSize: UInt64 = 0
    var _tickPrecision: UInt64 = 0
    var _feeCollectorAddress: String = String()
    var _dustCollectorAddress: String = String()
    var _minInitialPoolCoinSupply: String = String()
    var _pairCreationFee: [Cosmos_Base_V1beta1_Coin] = []
    var _poolCreationFee: [Cosmos_Base_V1beta1_Coin] = []
    var _minInitialDepositAmount: String = String()
    var _maxPriceLimitRatio: String = String()
    var _maxOrderLifespan: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _swapFeeRate: String = String()
    var _withdrawFeeRate: String = String()
    var _depositExtraGas: UInt64 = 0
    var _withdrawExtraGas: UInt64 = 0
    var _orderExtraGas: UInt64 = 0
    var _swapFeeDistrDenom: String = String()
    var _swapFeeBurnRate: String = String()
    var _appID: UInt64 = 0
    var _maxNumMarketMakingOrderTicks: UInt64 = 0
    var _maxNumActivePoolsPerPair: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _batchSize = source._batchSize
      _tickPrecision = source._tickPrecision
      _feeCollectorAddress = source._feeCollectorAddress
      _dustCollectorAddress = source._dustCollectorAddress
      _minInitialPoolCoinSupply = source._minInitialPoolCoinSupply
      _pairCreationFee = source._pairCreationFee
      _poolCreationFee = source._poolCreationFee
      _minInitialDepositAmount = source._minInitialDepositAmount
      _maxPriceLimitRatio = source._maxPriceLimitRatio
      _maxOrderLifespan = source._maxOrderLifespan
      _swapFeeRate = source._swapFeeRate
      _withdrawFeeRate = source._withdrawFeeRate
      _depositExtraGas = source._depositExtraGas
      _withdrawExtraGas = source._withdrawExtraGas
      _orderExtraGas = source._orderExtraGas
      _swapFeeDistrDenom = source._swapFeeDistrDenom
      _swapFeeBurnRate = source._swapFeeBurnRate
      _appID = source._appID
      _maxNumMarketMakingOrderTicks = source._maxNumMarketMakingOrderTicks
      _maxNumActivePoolsPerPair = source._maxNumActivePoolsPerPair
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._batchSize) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._tickPrecision) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._feeCollectorAddress) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._dustCollectorAddress) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._minInitialPoolCoinSupply) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._pairCreationFee) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._poolCreationFee) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._minInitialDepositAmount) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._maxPriceLimitRatio) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._maxOrderLifespan) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._swapFeeRate) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._withdrawFeeRate) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._depositExtraGas) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._withdrawExtraGas) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._orderExtraGas) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._swapFeeDistrDenom) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._swapFeeBurnRate) }()
        case 18: try { try decoder.decodeSingularUInt64Field(value: &_storage._appID) }()
        case 19: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxNumMarketMakingOrderTicks) }()
        case 20: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxNumActivePoolsPerPair) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._batchSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._batchSize, fieldNumber: 1)
      }
      if _storage._tickPrecision != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._tickPrecision, fieldNumber: 2)
      }
      if !_storage._feeCollectorAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._feeCollectorAddress, fieldNumber: 3)
      }
      if !_storage._dustCollectorAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dustCollectorAddress, fieldNumber: 4)
      }
      if !_storage._minInitialPoolCoinSupply.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minInitialPoolCoinSupply, fieldNumber: 5)
      }
      if !_storage._pairCreationFee.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pairCreationFee, fieldNumber: 6)
      }
      if !_storage._poolCreationFee.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._poolCreationFee, fieldNumber: 7)
      }
      if !_storage._minInitialDepositAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minInitialDepositAmount, fieldNumber: 8)
      }
      if !_storage._maxPriceLimitRatio.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxPriceLimitRatio, fieldNumber: 9)
      }
      try { if let v = _storage._maxOrderLifespan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._swapFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._swapFeeRate, fieldNumber: 11)
      }
      if !_storage._withdrawFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._withdrawFeeRate, fieldNumber: 12)
      }
      if _storage._depositExtraGas != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._depositExtraGas, fieldNumber: 13)
      }
      if _storage._withdrawExtraGas != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._withdrawExtraGas, fieldNumber: 14)
      }
      if _storage._orderExtraGas != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._orderExtraGas, fieldNumber: 15)
      }
      if !_storage._swapFeeDistrDenom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._swapFeeDistrDenom, fieldNumber: 16)
      }
      if !_storage._swapFeeBurnRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._swapFeeBurnRate, fieldNumber: 17)
      }
      if _storage._appID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._appID, fieldNumber: 18)
      }
      if _storage._maxNumMarketMakingOrderTicks != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._maxNumMarketMakingOrderTicks, fieldNumber: 19)
      }
      if _storage._maxNumActivePoolsPerPair != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._maxNumActivePoolsPerPair, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_GenericParams, rhs: Comdex_Liquidity_V1beta1_GenericParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._batchSize != rhs_storage._batchSize {return false}
        if _storage._tickPrecision != rhs_storage._tickPrecision {return false}
        if _storage._feeCollectorAddress != rhs_storage._feeCollectorAddress {return false}
        if _storage._dustCollectorAddress != rhs_storage._dustCollectorAddress {return false}
        if _storage._minInitialPoolCoinSupply != rhs_storage._minInitialPoolCoinSupply {return false}
        if _storage._pairCreationFee != rhs_storage._pairCreationFee {return false}
        if _storage._poolCreationFee != rhs_storage._poolCreationFee {return false}
        if _storage._minInitialDepositAmount != rhs_storage._minInitialDepositAmount {return false}
        if _storage._maxPriceLimitRatio != rhs_storage._maxPriceLimitRatio {return false}
        if _storage._maxOrderLifespan != rhs_storage._maxOrderLifespan {return false}
        if _storage._swapFeeRate != rhs_storage._swapFeeRate {return false}
        if _storage._withdrawFeeRate != rhs_storage._withdrawFeeRate {return false}
        if _storage._depositExtraGas != rhs_storage._depositExtraGas {return false}
        if _storage._withdrawExtraGas != rhs_storage._withdrawExtraGas {return false}
        if _storage._orderExtraGas != rhs_storage._orderExtraGas {return false}
        if _storage._swapFeeDistrDenom != rhs_storage._swapFeeDistrDenom {return false}
        if _storage._swapFeeBurnRate != rhs_storage._swapFeeBurnRate {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._maxNumMarketMakingOrderTicks != rhs_storage._maxNumMarketMakingOrderTicks {return false}
        if _storage._maxNumActivePoolsPerPair != rhs_storage._maxNumActivePoolsPerPair {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
