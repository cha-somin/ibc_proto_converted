// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: secret/compute/v1beta1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Secret_Compute_V1beta1_QuerySecretContractRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the bech32 human readable address of the contract
  var contractAddress: String = String()

  var query: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Secret_Compute_V1beta1_QueryByLabelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Secret_Compute_V1beta1_QueryByContractAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the bech32 human readable address of the contract
  var contractAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Secret_Compute_V1beta1_QueryByCodeIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var codeID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Secret_Compute_V1beta1_QuerySecretContractResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryContractInfoResponse is the response type for the Query/ContractInfo RPC method
struct Secret_Compute_V1beta1_QueryContractInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// contract_address is the bech32 human readable address of the contract
  var contractAddress: String = String()

  var contractInfo: Secret_Compute_V1beta1_ContractInfo {
    get {return _contractInfo ?? Secret_Compute_V1beta1_ContractInfo()}
    set {_contractInfo = newValue}
  }
  /// Returns true if `contractInfo` has been explicitly set.
  var hasContractInfo: Bool {return self._contractInfo != nil}
  /// Clears the value of `contractInfo`. Subsequent reads from it will return its default value.
  mutating func clearContractInfo() {self._contractInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contractInfo: Secret_Compute_V1beta1_ContractInfo? = nil
}

/// ContractInfoWithAddress adds the contract address to the ContractInfo representation
struct Secret_Compute_V1beta1_ContractInfoWithAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// contract_address is the bech32 human readable address of the contract
  var contractAddress: String = String()

  var contractInfo: Secret_Compute_V1beta1_ContractInfo {
    get {return _contractInfo ?? Secret_Compute_V1beta1_ContractInfo()}
    set {_contractInfo = newValue}
  }
  /// Returns true if `contractInfo` has been explicitly set.
  var hasContractInfo: Bool {return self._contractInfo != nil}
  /// Clears the value of `contractInfo`. Subsequent reads from it will return its default value.
  mutating func clearContractInfo() {self._contractInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contractInfo: Secret_Compute_V1beta1_ContractInfo? = nil
}

struct Secret_Compute_V1beta1_QueryContractsByCodeIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contractInfos: [Secret_Compute_V1beta1_ContractInfoWithAddress] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Secret_Compute_V1beta1_CodeInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var codeID: UInt64 = 0

  /// creator is the bech32 human readable address of the contract
  var creator: String = String()

  var codeHash: String = String()

  var source: String = String()

  var builder: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Secret_Compute_V1beta1_QueryCodeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var codeInfo: Secret_Compute_V1beta1_CodeInfoResponse {
    get {return _codeInfo ?? Secret_Compute_V1beta1_CodeInfoResponse()}
    set {_codeInfo = newValue}
  }
  /// Returns true if `codeInfo` has been explicitly set.
  var hasCodeInfo: Bool {return self._codeInfo != nil}
  /// Clears the value of `codeInfo`. Subsequent reads from it will return its default value.
  mutating func clearCodeInfo() {self._codeInfo = nil}

  var wasm: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _codeInfo: Secret_Compute_V1beta1_CodeInfoResponse? = nil
}

struct Secret_Compute_V1beta1_QueryCodesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var codeInfos: [Secret_Compute_V1beta1_CodeInfoResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Secret_Compute_V1beta1_QueryContractAddressResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the bech32 human readable address of the contract
  var contractAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Secret_Compute_V1beta1_QueryContractLabelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Secret_Compute_V1beta1_QueryCodeHashResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var codeHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DecryptedAnswer is a struct that represents a decrypted tx-query
struct Secret_Compute_V1beta1_DecryptedAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var input: String = String()

  var outputData: String = String()

  var outputDataAsString: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Secret_Compute_V1beta1_DecryptedAnswers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var answers: [Secret_Compute_V1beta1_DecryptedAnswer] = []

  var outputLogs: [Cosmos_Base_Abci_V1beta1_StringEvent] = []

  var outputError: String = String()

  var plaintextError: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Secret_Compute_V1beta1_QuerySecretContractRequest: @unchecked Sendable {}
extension Secret_Compute_V1beta1_QueryByLabelRequest: @unchecked Sendable {}
extension Secret_Compute_V1beta1_QueryByContractAddressRequest: @unchecked Sendable {}
extension Secret_Compute_V1beta1_QueryByCodeIdRequest: @unchecked Sendable {}
extension Secret_Compute_V1beta1_QuerySecretContractResponse: @unchecked Sendable {}
extension Secret_Compute_V1beta1_QueryContractInfoResponse: @unchecked Sendable {}
extension Secret_Compute_V1beta1_ContractInfoWithAddress: @unchecked Sendable {}
extension Secret_Compute_V1beta1_QueryContractsByCodeIdResponse: @unchecked Sendable {}
extension Secret_Compute_V1beta1_CodeInfoResponse: @unchecked Sendable {}
extension Secret_Compute_V1beta1_QueryCodeResponse: @unchecked Sendable {}
extension Secret_Compute_V1beta1_QueryCodesResponse: @unchecked Sendable {}
extension Secret_Compute_V1beta1_QueryContractAddressResponse: @unchecked Sendable {}
extension Secret_Compute_V1beta1_QueryContractLabelResponse: @unchecked Sendable {}
extension Secret_Compute_V1beta1_QueryCodeHashResponse: @unchecked Sendable {}
extension Secret_Compute_V1beta1_DecryptedAnswer: @unchecked Sendable {}
extension Secret_Compute_V1beta1_DecryptedAnswers: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "secret.compute.v1beta1"

extension Secret_Compute_V1beta1_QuerySecretContractRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySecretContractRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_address"),
    2: .same(proto: "query"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.query) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularBytesField(value: self.query, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_QuerySecretContractRequest, rhs: Secret_Compute_V1beta1_QuerySecretContractRequest) -> Bool {
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_QueryByLabelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryByLabelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_QueryByLabelRequest, rhs: Secret_Compute_V1beta1_QueryByLabelRequest) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_QueryByContractAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryByContractAddressRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_QueryByContractAddressRequest, rhs: Secret_Compute_V1beta1_QueryByContractAddressRequest) -> Bool {
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_QueryByCodeIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryByCodeIdRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "code_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.codeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.codeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.codeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_QueryByCodeIdRequest, rhs: Secret_Compute_V1beta1_QueryByCodeIdRequest) -> Bool {
    if lhs.codeID != rhs.codeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_QuerySecretContractResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySecretContractResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_QuerySecretContractResponse, rhs: Secret_Compute_V1beta1_QuerySecretContractResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_QueryContractInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryContractInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_address"),
    2: .same(proto: "ContractInfo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contractInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 1)
    }
    try { if let v = self._contractInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_QueryContractInfoResponse, rhs: Secret_Compute_V1beta1_QueryContractInfoResponse) -> Bool {
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs._contractInfo != rhs._contractInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_ContractInfoWithAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractInfoWithAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_address"),
    2: .same(proto: "ContractInfo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contractInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 1)
    }
    try { if let v = self._contractInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_ContractInfoWithAddress, rhs: Secret_Compute_V1beta1_ContractInfoWithAddress) -> Bool {
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs._contractInfo != rhs._contractInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_QueryContractsByCodeIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryContractsByCodeIdResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_infos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.contractInfos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contractInfos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_QueryContractsByCodeIdResponse, rhs: Secret_Compute_V1beta1_QueryContractsByCodeIdResponse) -> Bool {
    if lhs.contractInfos != rhs.contractInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_CodeInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CodeInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "code_id"),
    2: .same(proto: "creator"),
    3: .standard(proto: "code_hash"),
    4: .same(proto: "source"),
    5: .same(proto: "builder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.codeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.codeHash) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.builder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.codeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.codeID, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 2)
    }
    if !self.codeHash.isEmpty {
      try visitor.visitSingularStringField(value: self.codeHash, fieldNumber: 3)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 4)
    }
    if !self.builder.isEmpty {
      try visitor.visitSingularStringField(value: self.builder, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_CodeInfoResponse, rhs: Secret_Compute_V1beta1_CodeInfoResponse) -> Bool {
    if lhs.codeID != rhs.codeID {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.codeHash != rhs.codeHash {return false}
    if lhs.source != rhs.source {return false}
    if lhs.builder != rhs.builder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_QueryCodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCodeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "code_info"),
    2: .same(proto: "wasm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._codeInfo) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.wasm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._codeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.wasm.isEmpty {
      try visitor.visitSingularBytesField(value: self.wasm, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_QueryCodeResponse, rhs: Secret_Compute_V1beta1_QueryCodeResponse) -> Bool {
    if lhs._codeInfo != rhs._codeInfo {return false}
    if lhs.wasm != rhs.wasm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_QueryCodesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCodesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "code_infos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.codeInfos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.codeInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.codeInfos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_QueryCodesResponse, rhs: Secret_Compute_V1beta1_QueryCodesResponse) -> Bool {
    if lhs.codeInfos != rhs.codeInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_QueryContractAddressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryContractAddressResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_QueryContractAddressResponse, rhs: Secret_Compute_V1beta1_QueryContractAddressResponse) -> Bool {
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_QueryContractLabelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryContractLabelResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_QueryContractLabelResponse, rhs: Secret_Compute_V1beta1_QueryContractLabelResponse) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_QueryCodeHashResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCodeHashResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "code_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.codeHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.codeHash.isEmpty {
      try visitor.visitSingularStringField(value: self.codeHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_QueryCodeHashResponse, rhs: Secret_Compute_V1beta1_QueryCodeHashResponse) -> Bool {
    if lhs.codeHash != rhs.codeHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_DecryptedAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecryptedAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "input"),
    3: .standard(proto: "output_data"),
    4: .standard(proto: "output_data_as_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.input) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.outputData) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.outputDataAsString) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.input.isEmpty {
      try visitor.visitSingularStringField(value: self.input, fieldNumber: 2)
    }
    if !self.outputData.isEmpty {
      try visitor.visitSingularStringField(value: self.outputData, fieldNumber: 3)
    }
    if !self.outputDataAsString.isEmpty {
      try visitor.visitSingularStringField(value: self.outputDataAsString, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_DecryptedAnswer, rhs: Secret_Compute_V1beta1_DecryptedAnswer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.input != rhs.input {return false}
    if lhs.outputData != rhs.outputData {return false}
    if lhs.outputDataAsString != rhs.outputDataAsString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Secret_Compute_V1beta1_DecryptedAnswers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecryptedAnswers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "answers"),
    2: .standard(proto: "output_logs"),
    3: .standard(proto: "output_error"),
    4: .standard(proto: "plaintext_error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.answers) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outputLogs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.outputError) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.plaintextError) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.answers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.answers, fieldNumber: 1)
    }
    if !self.outputLogs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputLogs, fieldNumber: 2)
    }
    if !self.outputError.isEmpty {
      try visitor.visitSingularStringField(value: self.outputError, fieldNumber: 3)
    }
    if !self.plaintextError.isEmpty {
      try visitor.visitSingularStringField(value: self.plaintextError, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Secret_Compute_V1beta1_DecryptedAnswers, rhs: Secret_Compute_V1beta1_DecryptedAnswers) -> Bool {
    if lhs.answers != rhs.answers {return false}
    if lhs.outputLogs != rhs.outputLogs {return false}
    if lhs.outputError != rhs.outputError {return false}
    if lhs.plaintextError != rhs.plaintextError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
