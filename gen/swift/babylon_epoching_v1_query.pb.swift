// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: babylon/epoching/v1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryParamsRequest is the request type for the Query/Params RPC method.
struct Babylon_Epoching_V1_QueryParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryParamsResponse is the response type for the Query/Params RPC method.
struct Babylon_Epoching_V1_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// params holds all the parameters of this module.
  var params: Babylon_Epoching_V1_Params {
    get {return _params ?? Babylon_Epoching_V1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Babylon_Epoching_V1_Params? = nil
}

/// QueryEpochInfoRequest is the request type for the Query/EpochInfo method
struct Babylon_Epoching_V1_QueryEpochInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epochNum: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryEpochInfoRequest is the response type for the Query/EpochInfo method
struct Babylon_Epoching_V1_QueryEpochInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epoch: Babylon_Epoching_V1_EpochResponse {
    get {return _epoch ?? Babylon_Epoching_V1_EpochResponse()}
    set {_epoch = newValue}
  }
  /// Returns true if `epoch` has been explicitly set.
  var hasEpoch: Bool {return self._epoch != nil}
  /// Clears the value of `epoch`. Subsequent reads from it will return its default value.
  mutating func clearEpoch() {self._epoch = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _epoch: Babylon_Epoching_V1_EpochResponse? = nil
}

/// QueryEpochInfosRequest is the request type for the Query/EpochInfos method
struct Babylon_Epoching_V1_QueryEpochsInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pagination defines whether to have the pagination in the request
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryEpochsInfoResponse is the response type for the Query/EpochInfos method
struct Babylon_Epoching_V1_QueryEpochsInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epochs: [Babylon_Epoching_V1_EpochResponse] = []

  /// pagination defines the pagination in the response
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryCurrentEpochRequest is the request type for the Query/CurrentEpoch RPC
/// method
struct Babylon_Epoching_V1_QueryCurrentEpochRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCurrentEpochResponse is the response type for the Query/CurrentEpoch RPC
/// method
struct Babylon_Epoching_V1_QueryCurrentEpochResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// current_epoch is the current epoch number
  var currentEpoch: UInt64 = 0

  /// epoch_boundary is the height of this epoch's last block
  var epochBoundary: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryEpochMsgsRequest is the request type for the Query/EpochMsgs RPC method
struct Babylon_Epoching_V1_QueryEpochMsgsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// epoch_num is the number of epoch of the requested msg queue
  var epochNum: UInt64 = 0

  /// pagination defines whether to have the pagination in the request
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryEpochMsgsResponse is the response type for the Query/EpochMsgs RPC
/// method
struct Babylon_Epoching_V1_QueryEpochMsgsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// msgs is the list of messages queued in the current epoch
  var msgs: [Babylon_Epoching_V1_QueuedMessageResponse] = []

  /// pagination defines the pagination in the response
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryLatestEpochMsgsRequest is the request type for the Query/LatestEpochMsgs
/// RPC method it returns epoch msgs within epoch [max(1,
/// end_epoch-epoch_count+1), end_epoch]
struct Babylon_Epoching_V1_QueryLatestEpochMsgsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// end_epoch is the number of the last epoch to query
  var endEpoch: UInt64 = 0

  /// epoch_count is the number of epochs to query
  var epochCount: UInt64 = 0

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryLatestEpochMsgsResponse is the response type for the
/// Query/LatestEpochMsgs RPC method
struct Babylon_Epoching_V1_QueryLatestEpochMsgsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// latest_epoch_msgs is a list of QueuedMessageList
  /// each QueuedMessageList has a field identifying the epoch number
  var latestEpochMsgs: [Babylon_Epoching_V1_QueuedMessageList] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryValidatorLifecycleRequest is the request type for the
/// Query/ValidatorLifecycle RPC method
struct Babylon_Epoching_V1_QueryValidatorLifecycleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryValidatorLifecycleResponse is the response type for the
/// Query/ValidatorLifecycle RPC method
struct Babylon_Epoching_V1_QueryValidatorLifecycleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valAddr: String = String()

  var valLife: [Babylon_Epoching_V1_ValStateUpdateResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDelegationLifecycleRequest is the request type for the
/// Query/DelegationLifecycle RPC method
struct Babylon_Epoching_V1_QueryDelegationLifecycleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDelegationLifecycleRequest is the response type for the
/// Query/DelegationLifecycle RPC method
struct Babylon_Epoching_V1_QueryDelegationLifecycleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delLife: Babylon_Epoching_V1_DelegationLifecycle {
    get {return _delLife ?? Babylon_Epoching_V1_DelegationLifecycle()}
    set {_delLife = newValue}
  }
  /// Returns true if `delLife` has been explicitly set.
  var hasDelLife: Bool {return self._delLife != nil}
  /// Clears the value of `delLife`. Subsequent reads from it will return its default value.
  mutating func clearDelLife() {self._delLife = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _delLife: Babylon_Epoching_V1_DelegationLifecycle? = nil
}

/// QueryEpochValSetRequest is the request type for the Query/EpochValSet RPC
/// method
struct Babylon_Epoching_V1_QueryEpochValSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epochNum: UInt64 = 0

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryEpochValSetRequest is the response type for the Query/EpochValSet RPC
/// method
struct Babylon_Epoching_V1_QueryEpochValSetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var validators: [Babylon_Epoching_V1_Validator] = []

  var totalVotingPower: Int64 = 0

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// EpochResponse is a structure that contains the metadata of an epoch
struct Babylon_Epoching_V1_EpochResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// epoch_number is the number of this epoch
  var epochNumber: UInt64 = 0

  /// current_epoch_interval is the epoch interval at the time of this epoch
  var currentEpochInterval: UInt64 = 0

  /// first_block_height is the height of the first block in this epoch
  var firstBlockHeight: UInt64 = 0

  /// last_block_time is the time of the last block in this epoch.
  /// Babylon needs to remember the last header's time of each epoch to complete
  /// unbonding validators/delegations when a previous epoch's checkpoint is
  /// finalised. The last_block_time field is nil in the epoch's beginning, and
  /// is set upon the end of this epoch.
  var lastBlockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastBlockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastBlockTime = newValue}
  }
  /// Returns true if `lastBlockTime` has been explicitly set.
  var hasLastBlockTime: Bool {return self._lastBlockTime != nil}
  /// Clears the value of `lastBlockTime`. Subsequent reads from it will return its default value.
  mutating func clearLastBlockTime() {self._lastBlockTime = nil}

  /// sealer is the last block of the sealed epoch
  /// sealer_app_hash points to the sealer but stored in the 1st header
  /// of the next epoch as hex string.
  var sealerAppHashHex: String = String()

  /// sealer_block_hash is the hash of the sealer
  /// the validator set has generated a BLS multisig on the hash,
  /// i.e., hash of the last block in the epoch as hex string.
  var sealerBlockHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastBlockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// QueuedMessageResponse is a message that can change the validator set and is delayed
/// to the end of an epoch
struct Babylon_Epoching_V1_QueuedMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// tx_id is the ID of the tx that contains the message as hex.
  var txID: String = String()

  /// msg_id is the original message ID, i.e., hash of the marshaled message as hex.
  var msgID: String = String()

  /// block_height is the height when this msg is submitted to Babylon
  var blockHeight: UInt64 = 0

  /// block_time is the timestamp when this msg is submitted to Babylon
  var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  var hasBlockTime: Bool {return self._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  mutating func clearBlockTime() {self._blockTime = nil}

  /// msg is the actual message that is sent by a user and is queued by the
  /// epoching module as string.
  var msg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// QueuedMessageList is a message that contains a list of staking-related
/// messages queued for an epoch
struct Babylon_Epoching_V1_QueuedMessageList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epochNumber: UInt64 = 0

  var msgs: [Babylon_Epoching_V1_QueuedMessageResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ValStateUpdateResponse is a message response that records a state update of a validator.
struct Babylon_Epoching_V1_ValStateUpdateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// StateDesc defines the descriptive state.
  var stateDesc: String = String()

  var blockHeight: UInt64 = 0

  var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  var hasBlockTime: Bool {return self._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  mutating func clearBlockTime() {self._blockTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Babylon_Epoching_V1_QueryParamsRequest: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryParamsResponse: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryEpochInfoRequest: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryEpochInfoResponse: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryEpochsInfoRequest: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryEpochsInfoResponse: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryCurrentEpochRequest: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryCurrentEpochResponse: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryEpochMsgsRequest: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryEpochMsgsResponse: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryLatestEpochMsgsRequest: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryLatestEpochMsgsResponse: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryValidatorLifecycleRequest: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryValidatorLifecycleResponse: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryDelegationLifecycleRequest: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryDelegationLifecycleResponse: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryEpochValSetRequest: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueryEpochValSetResponse: @unchecked Sendable {}
extension Babylon_Epoching_V1_EpochResponse: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueuedMessageResponse: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueuedMessageList: @unchecked Sendable {}
extension Babylon_Epoching_V1_ValStateUpdateResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "babylon.epoching.v1"

extension Babylon_Epoching_V1_QueryParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryParamsRequest, rhs: Babylon_Epoching_V1_QueryParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryParamsResponse, rhs: Babylon_Epoching_V1_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryEpochInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEpochInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_num"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochNum != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryEpochInfoRequest, rhs: Babylon_Epoching_V1_QueryEpochInfoRequest) -> Bool {
    if lhs.epochNum != rhs.epochNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryEpochInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEpochInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "epoch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._epoch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._epoch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryEpochInfoResponse, rhs: Babylon_Epoching_V1_QueryEpochInfoResponse) -> Bool {
    if lhs._epoch != rhs._epoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryEpochsInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEpochsInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryEpochsInfoRequest, rhs: Babylon_Epoching_V1_QueryEpochsInfoRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryEpochsInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEpochsInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "epochs"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.epochs) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.epochs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.epochs, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryEpochsInfoResponse, rhs: Babylon_Epoching_V1_QueryEpochsInfoResponse) -> Bool {
    if lhs.epochs != rhs.epochs {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryCurrentEpochRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCurrentEpochRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryCurrentEpochRequest, rhs: Babylon_Epoching_V1_QueryCurrentEpochRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryCurrentEpochResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCurrentEpochResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_epoch"),
    2: .standard(proto: "epoch_boundary"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.currentEpoch) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.epochBoundary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.currentEpoch != 0 {
      try visitor.visitSingularUInt64Field(value: self.currentEpoch, fieldNumber: 1)
    }
    if self.epochBoundary != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochBoundary, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryCurrentEpochResponse, rhs: Babylon_Epoching_V1_QueryCurrentEpochResponse) -> Bool {
    if lhs.currentEpoch != rhs.currentEpoch {return false}
    if lhs.epochBoundary != rhs.epochBoundary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryEpochMsgsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEpochMsgsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_num"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNum) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.epochNum != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNum, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryEpochMsgsRequest, rhs: Babylon_Epoching_V1_QueryEpochMsgsRequest) -> Bool {
    if lhs.epochNum != rhs.epochNum {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryEpochMsgsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEpochMsgsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msgs"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.msgs) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.msgs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.msgs, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryEpochMsgsResponse, rhs: Babylon_Epoching_V1_QueryEpochMsgsResponse) -> Bool {
    if lhs.msgs != rhs.msgs {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryLatestEpochMsgsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryLatestEpochMsgsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "end_epoch"),
    2: .standard(proto: "epoch_count"),
    3: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.endEpoch) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.epochCount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.endEpoch != 0 {
      try visitor.visitSingularUInt64Field(value: self.endEpoch, fieldNumber: 1)
    }
    if self.epochCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochCount, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryLatestEpochMsgsRequest, rhs: Babylon_Epoching_V1_QueryLatestEpochMsgsRequest) -> Bool {
    if lhs.endEpoch != rhs.endEpoch {return false}
    if lhs.epochCount != rhs.epochCount {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryLatestEpochMsgsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryLatestEpochMsgsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "latest_epoch_msgs"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.latestEpochMsgs) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.latestEpochMsgs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.latestEpochMsgs, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryLatestEpochMsgsResponse, rhs: Babylon_Epoching_V1_QueryLatestEpochMsgsResponse) -> Bool {
    if lhs.latestEpochMsgs != rhs.latestEpochMsgs {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryValidatorLifecycleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryValidatorLifecycleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "val_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.valAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.valAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.valAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryValidatorLifecycleRequest, rhs: Babylon_Epoching_V1_QueryValidatorLifecycleRequest) -> Bool {
    if lhs.valAddr != rhs.valAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryValidatorLifecycleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryValidatorLifecycleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "val_addr"),
    2: .standard(proto: "val_life"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.valAddr) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.valLife) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.valAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.valAddr, fieldNumber: 1)
    }
    if !self.valLife.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.valLife, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryValidatorLifecycleResponse, rhs: Babylon_Epoching_V1_QueryValidatorLifecycleResponse) -> Bool {
    if lhs.valAddr != rhs.valAddr {return false}
    if lhs.valLife != rhs.valLife {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryDelegationLifecycleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDelegationLifecycleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "del_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.delAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.delAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.delAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryDelegationLifecycleRequest, rhs: Babylon_Epoching_V1_QueryDelegationLifecycleRequest) -> Bool {
    if lhs.delAddr != rhs.delAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryDelegationLifecycleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDelegationLifecycleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "del_life"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._delLife) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._delLife {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryDelegationLifecycleResponse, rhs: Babylon_Epoching_V1_QueryDelegationLifecycleResponse) -> Bool {
    if lhs._delLife != rhs._delLife {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryEpochValSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEpochValSetRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_num"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNum) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.epochNum != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNum, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryEpochValSetRequest, rhs: Babylon_Epoching_V1_QueryEpochValSetRequest) -> Bool {
    if lhs.epochNum != rhs.epochNum {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueryEpochValSetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEpochValSetResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validators"),
    2: .standard(proto: "total_voting_power"),
    3: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalVotingPower) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 1)
    }
    if self.totalVotingPower != 0 {
      try visitor.visitSingularInt64Field(value: self.totalVotingPower, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueryEpochValSetResponse, rhs: Babylon_Epoching_V1_QueryEpochValSetResponse) -> Bool {
    if lhs.validators != rhs.validators {return false}
    if lhs.totalVotingPower != rhs.totalVotingPower {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_EpochResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EpochResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_number"),
    2: .standard(proto: "current_epoch_interval"),
    3: .standard(proto: "first_block_height"),
    4: .standard(proto: "last_block_time"),
    5: .standard(proto: "sealer_app_hash_hex"),
    6: .standard(proto: "sealer_block_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNumber) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.currentEpochInterval) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.firstBlockHeight) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lastBlockTime) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sealerAppHashHex) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.sealerBlockHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.epochNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNumber, fieldNumber: 1)
    }
    if self.currentEpochInterval != 0 {
      try visitor.visitSingularUInt64Field(value: self.currentEpochInterval, fieldNumber: 2)
    }
    if self.firstBlockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.firstBlockHeight, fieldNumber: 3)
    }
    try { if let v = self._lastBlockTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.sealerAppHashHex.isEmpty {
      try visitor.visitSingularStringField(value: self.sealerAppHashHex, fieldNumber: 5)
    }
    if !self.sealerBlockHash.isEmpty {
      try visitor.visitSingularStringField(value: self.sealerBlockHash, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_EpochResponse, rhs: Babylon_Epoching_V1_EpochResponse) -> Bool {
    if lhs.epochNumber != rhs.epochNumber {return false}
    if lhs.currentEpochInterval != rhs.currentEpochInterval {return false}
    if lhs.firstBlockHeight != rhs.firstBlockHeight {return false}
    if lhs._lastBlockTime != rhs._lastBlockTime {return false}
    if lhs.sealerAppHashHex != rhs.sealerAppHashHex {return false}
    if lhs.sealerBlockHash != rhs.sealerBlockHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueuedMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueuedMessageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .standard(proto: "msg_id"),
    3: .standard(proto: "block_height"),
    4: .standard(proto: "block_time"),
    5: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.blockHeight) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._blockTime) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.txID.isEmpty {
      try visitor.visitSingularStringField(value: self.txID, fieldNumber: 1)
    }
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 2)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 3)
    }
    try { if let v = self._blockTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueuedMessageResponse, rhs: Babylon_Epoching_V1_QueuedMessageResponse) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.msgID != rhs.msgID {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs._blockTime != rhs._blockTime {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueuedMessageList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueuedMessageList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_number"),
    2: .same(proto: "msgs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNumber) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.msgs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNumber, fieldNumber: 1)
    }
    if !self.msgs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.msgs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueuedMessageList, rhs: Babylon_Epoching_V1_QueuedMessageList) -> Bool {
    if lhs.epochNumber != rhs.epochNumber {return false}
    if lhs.msgs != rhs.msgs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_ValStateUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValStateUpdateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "state_desc"),
    2: .standard(proto: "block_height"),
    3: .standard(proto: "block_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stateDesc) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.blockHeight) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blockTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.stateDesc.isEmpty {
      try visitor.visitSingularStringField(value: self.stateDesc, fieldNumber: 1)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 2)
    }
    try { if let v = self._blockTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_ValStateUpdateResponse, rhs: Babylon_Epoching_V1_ValStateUpdateResponse) -> Bool {
    if lhs.stateDesc != rhs.stateDesc {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs._blockTime != rhs._blockTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
