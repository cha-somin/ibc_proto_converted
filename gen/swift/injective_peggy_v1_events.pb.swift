// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: injective/peggy/v1/events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Injective_Peggy_V1_EventAttestationObserved {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var attestationType: Injective_Peggy_V1_ClaimType = .unknown

  var bridgeContract: String = String()

  var bridgeChainID: UInt64 = 0

  var attestationID: Data = Data()

  var nonce: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventBridgeWithdrawCanceled {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bridgeContract: String = String()

  var bridgeChainID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventOutgoingBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var orchestratorAddress: String = String()

  var batchNonce: UInt64 = 0

  var batchTimeout: UInt64 = 0

  var batchTxIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventOutgoingBatchCanceled {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bridgeContract: String = String()

  var bridgeChainID: UInt64 = 0

  var batchID: UInt64 = 0

  var nonce: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventValsetUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valsetNonce: UInt64 = 0

  var valsetHeight: UInt64 = 0

  var valsetMembers: [Injective_Peggy_V1_BridgeValidator] = []

  var rewardAmount: String = String()

  var rewardToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventSetOrchestratorAddresses {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var validatorAddress: String = String()

  var orchestratorAddress: String = String()

  var operatorEthAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventValsetConfirm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valsetNonce: UInt64 = 0

  var orchestratorAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventSendToEth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var outgoingTxID: UInt64 = 0

  var sender: String = String()

  var receiver: String = String()

  var amount: String = String()

  var bridgeFee: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventConfirmBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var batchNonce: UInt64 = 0

  var orchestratorAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventAttestationVote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var attestationID: Data = Data()

  var voter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventDepositClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var eventHeight: UInt64 = 0

  var attestationID: Data = Data()

  var ethereumSender: String = String()

  var cosmosReceiver: String = String()

  var tokenContract: String = String()

  var amount: String = String()

  var orchestratorAddress: String = String()

  var data: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventWithdrawClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var eventHeight: UInt64 = 0

  var attestationID: Data = Data()

  var batchNonce: UInt64 = 0

  var tokenContract: String = String()

  var orchestratorAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventERC20DeployedClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var eventHeight: UInt64 = 0

  var attestationID: Data = Data()

  var cosmosDenom: String = String()

  var tokenContract: String = String()

  var name: String = String()

  var symbol: String = String()

  var decimals: UInt64 = 0

  var orchestratorAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventValsetUpdateClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var eventHeight: UInt64 = 0

  var attestationID: Data = Data()

  var valsetNonce: UInt64 = 0

  var valsetMembers: [Injective_Peggy_V1_BridgeValidator] = []

  var rewardAmount: String = String()

  var rewardToken: String = String()

  var orchestratorAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventCancelSendToEth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var outgoingTxID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventSubmitBadSignatureEvidence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var badEthSignature: String = String()

  var badEthSignatureSubject: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Peggy_V1_EventValidatorSlash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var power: Int64 = 0

  var reason: String = String()

  var consensusAddress: String = String()

  var operatorAddress: String = String()

  var moniker: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Injective_Peggy_V1_EventAttestationObserved: @unchecked Sendable {}
extension Injective_Peggy_V1_EventBridgeWithdrawCanceled: @unchecked Sendable {}
extension Injective_Peggy_V1_EventOutgoingBatch: @unchecked Sendable {}
extension Injective_Peggy_V1_EventOutgoingBatchCanceled: @unchecked Sendable {}
extension Injective_Peggy_V1_EventValsetUpdateRequest: @unchecked Sendable {}
extension Injective_Peggy_V1_EventSetOrchestratorAddresses: @unchecked Sendable {}
extension Injective_Peggy_V1_EventValsetConfirm: @unchecked Sendable {}
extension Injective_Peggy_V1_EventSendToEth: @unchecked Sendable {}
extension Injective_Peggy_V1_EventConfirmBatch: @unchecked Sendable {}
extension Injective_Peggy_V1_EventAttestationVote: @unchecked Sendable {}
extension Injective_Peggy_V1_EventDepositClaim: @unchecked Sendable {}
extension Injective_Peggy_V1_EventWithdrawClaim: @unchecked Sendable {}
extension Injective_Peggy_V1_EventERC20DeployedClaim: @unchecked Sendable {}
extension Injective_Peggy_V1_EventValsetUpdateClaim: @unchecked Sendable {}
extension Injective_Peggy_V1_EventCancelSendToEth: @unchecked Sendable {}
extension Injective_Peggy_V1_EventSubmitBadSignatureEvidence: @unchecked Sendable {}
extension Injective_Peggy_V1_EventValidatorSlash: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "injective.peggy.v1"

extension Injective_Peggy_V1_EventAttestationObserved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventAttestationObserved"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attestation_type"),
    2: .standard(proto: "bridge_contract"),
    3: .standard(proto: "bridge_chain_id"),
    4: .standard(proto: "attestation_id"),
    5: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.attestationType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bridgeContract) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.bridgeChainID) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.attestationID) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.attestationType != .unknown {
      try visitor.visitSingularEnumField(value: self.attestationType, fieldNumber: 1)
    }
    if !self.bridgeContract.isEmpty {
      try visitor.visitSingularStringField(value: self.bridgeContract, fieldNumber: 2)
    }
    if self.bridgeChainID != 0 {
      try visitor.visitSingularUInt64Field(value: self.bridgeChainID, fieldNumber: 3)
    }
    if !self.attestationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.attestationID, fieldNumber: 4)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventAttestationObserved, rhs: Injective_Peggy_V1_EventAttestationObserved) -> Bool {
    if lhs.attestationType != rhs.attestationType {return false}
    if lhs.bridgeContract != rhs.bridgeContract {return false}
    if lhs.bridgeChainID != rhs.bridgeChainID {return false}
    if lhs.attestationID != rhs.attestationID {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventBridgeWithdrawCanceled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBridgeWithdrawCanceled"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bridge_contract"),
    2: .standard(proto: "bridge_chain_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bridgeContract) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.bridgeChainID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bridgeContract.isEmpty {
      try visitor.visitSingularStringField(value: self.bridgeContract, fieldNumber: 1)
    }
    if self.bridgeChainID != 0 {
      try visitor.visitSingularUInt64Field(value: self.bridgeChainID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventBridgeWithdrawCanceled, rhs: Injective_Peggy_V1_EventBridgeWithdrawCanceled) -> Bool {
    if lhs.bridgeContract != rhs.bridgeContract {return false}
    if lhs.bridgeChainID != rhs.bridgeChainID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventOutgoingBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventOutgoingBatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .standard(proto: "orchestrator_address"),
    3: .standard(proto: "batch_nonce"),
    4: .standard(proto: "batch_timeout"),
    5: .standard(proto: "batch_tx_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.orchestratorAddress) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.batchNonce) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.batchTimeout) }()
      case 5: try { try decoder.decodeRepeatedUInt64Field(value: &self.batchTxIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.orchestratorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestratorAddress, fieldNumber: 2)
    }
    if self.batchNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.batchNonce, fieldNumber: 3)
    }
    if self.batchTimeout != 0 {
      try visitor.visitSingularUInt64Field(value: self.batchTimeout, fieldNumber: 4)
    }
    if !self.batchTxIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.batchTxIds, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventOutgoingBatch, rhs: Injective_Peggy_V1_EventOutgoingBatch) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.orchestratorAddress != rhs.orchestratorAddress {return false}
    if lhs.batchNonce != rhs.batchNonce {return false}
    if lhs.batchTimeout != rhs.batchTimeout {return false}
    if lhs.batchTxIds != rhs.batchTxIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventOutgoingBatchCanceled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventOutgoingBatchCanceled"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bridge_contract"),
    2: .standard(proto: "bridge_chain_id"),
    3: .standard(proto: "batch_id"),
    4: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bridgeContract) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.bridgeChainID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.batchID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bridgeContract.isEmpty {
      try visitor.visitSingularStringField(value: self.bridgeContract, fieldNumber: 1)
    }
    if self.bridgeChainID != 0 {
      try visitor.visitSingularUInt64Field(value: self.bridgeChainID, fieldNumber: 2)
    }
    if self.batchID != 0 {
      try visitor.visitSingularUInt64Field(value: self.batchID, fieldNumber: 3)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventOutgoingBatchCanceled, rhs: Injective_Peggy_V1_EventOutgoingBatchCanceled) -> Bool {
    if lhs.bridgeContract != rhs.bridgeContract {return false}
    if lhs.bridgeChainID != rhs.bridgeChainID {return false}
    if lhs.batchID != rhs.batchID {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventValsetUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventValsetUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "valset_nonce"),
    2: .standard(proto: "valset_height"),
    3: .standard(proto: "valset_members"),
    4: .standard(proto: "reward_amount"),
    5: .standard(proto: "reward_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.valsetNonce) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.valsetHeight) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.valsetMembers) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.rewardAmount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.rewardToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valsetNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.valsetNonce, fieldNumber: 1)
    }
    if self.valsetHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.valsetHeight, fieldNumber: 2)
    }
    if !self.valsetMembers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.valsetMembers, fieldNumber: 3)
    }
    if !self.rewardAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardAmount, fieldNumber: 4)
    }
    if !self.rewardToken.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventValsetUpdateRequest, rhs: Injective_Peggy_V1_EventValsetUpdateRequest) -> Bool {
    if lhs.valsetNonce != rhs.valsetNonce {return false}
    if lhs.valsetHeight != rhs.valsetHeight {return false}
    if lhs.valsetMembers != rhs.valsetMembers {return false}
    if lhs.rewardAmount != rhs.rewardAmount {return false}
    if lhs.rewardToken != rhs.rewardToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventSetOrchestratorAddresses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSetOrchestratorAddresses"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_address"),
    2: .standard(proto: "orchestrator_address"),
    3: .standard(proto: "operator_eth_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.orchestratorAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.operatorEthAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 1)
    }
    if !self.orchestratorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestratorAddress, fieldNumber: 2)
    }
    if !self.operatorEthAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.operatorEthAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventSetOrchestratorAddresses, rhs: Injective_Peggy_V1_EventSetOrchestratorAddresses) -> Bool {
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs.orchestratorAddress != rhs.orchestratorAddress {return false}
    if lhs.operatorEthAddress != rhs.operatorEthAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventValsetConfirm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventValsetConfirm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "valset_nonce"),
    2: .standard(proto: "orchestrator_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.valsetNonce) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.orchestratorAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valsetNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.valsetNonce, fieldNumber: 1)
    }
    if !self.orchestratorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestratorAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventValsetConfirm, rhs: Injective_Peggy_V1_EventValsetConfirm) -> Bool {
    if lhs.valsetNonce != rhs.valsetNonce {return false}
    if lhs.orchestratorAddress != rhs.orchestratorAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventSendToEth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSendToEth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "outgoing_tx_id"),
    2: .same(proto: "sender"),
    3: .same(proto: "receiver"),
    4: .same(proto: "amount"),
    5: .standard(proto: "bridge_fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.outgoingTxID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.receiver) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.bridgeFee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.outgoingTxID != 0 {
      try visitor.visitSingularUInt64Field(value: self.outgoingTxID, fieldNumber: 1)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 2)
    }
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 3)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 4)
    }
    if !self.bridgeFee.isEmpty {
      try visitor.visitSingularStringField(value: self.bridgeFee, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventSendToEth, rhs: Injective_Peggy_V1_EventSendToEth) -> Bool {
    if lhs.outgoingTxID != rhs.outgoingTxID {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.receiver != rhs.receiver {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.bridgeFee != rhs.bridgeFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventConfirmBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventConfirmBatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_nonce"),
    2: .standard(proto: "orchestrator_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.batchNonce) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.orchestratorAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.batchNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.batchNonce, fieldNumber: 1)
    }
    if !self.orchestratorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestratorAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventConfirmBatch, rhs: Injective_Peggy_V1_EventConfirmBatch) -> Bool {
    if lhs.batchNonce != rhs.batchNonce {return false}
    if lhs.orchestratorAddress != rhs.orchestratorAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventAttestationVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventAttestationVote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "attestation_id"),
    3: .same(proto: "voter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.eventNonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.attestationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.voter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if !self.attestationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.attestationID, fieldNumber: 2)
    }
    if !self.voter.isEmpty {
      try visitor.visitSingularStringField(value: self.voter, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventAttestationVote, rhs: Injective_Peggy_V1_EventAttestationVote) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.attestationID != rhs.attestationID {return false}
    if lhs.voter != rhs.voter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventDepositClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventDepositClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "event_height"),
    3: .standard(proto: "attestation_id"),
    4: .standard(proto: "ethereum_sender"),
    5: .standard(proto: "cosmos_receiver"),
    6: .standard(proto: "token_contract"),
    7: .same(proto: "amount"),
    8: .standard(proto: "orchestrator_address"),
    9: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.eventNonce) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.eventHeight) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.attestationID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ethereumSender) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.cosmosReceiver) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.tokenContract) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.orchestratorAddress) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if self.eventHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventHeight, fieldNumber: 2)
    }
    if !self.attestationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.attestationID, fieldNumber: 3)
    }
    if !self.ethereumSender.isEmpty {
      try visitor.visitSingularStringField(value: self.ethereumSender, fieldNumber: 4)
    }
    if !self.cosmosReceiver.isEmpty {
      try visitor.visitSingularStringField(value: self.cosmosReceiver, fieldNumber: 5)
    }
    if !self.tokenContract.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenContract, fieldNumber: 6)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 7)
    }
    if !self.orchestratorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestratorAddress, fieldNumber: 8)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventDepositClaim, rhs: Injective_Peggy_V1_EventDepositClaim) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.eventHeight != rhs.eventHeight {return false}
    if lhs.attestationID != rhs.attestationID {return false}
    if lhs.ethereumSender != rhs.ethereumSender {return false}
    if lhs.cosmosReceiver != rhs.cosmosReceiver {return false}
    if lhs.tokenContract != rhs.tokenContract {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.orchestratorAddress != rhs.orchestratorAddress {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventWithdrawClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventWithdrawClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "event_height"),
    3: .standard(proto: "attestation_id"),
    4: .standard(proto: "batch_nonce"),
    5: .standard(proto: "token_contract"),
    6: .standard(proto: "orchestrator_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.eventNonce) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.eventHeight) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.attestationID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.batchNonce) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.tokenContract) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.orchestratorAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if self.eventHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventHeight, fieldNumber: 2)
    }
    if !self.attestationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.attestationID, fieldNumber: 3)
    }
    if self.batchNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.batchNonce, fieldNumber: 4)
    }
    if !self.tokenContract.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenContract, fieldNumber: 5)
    }
    if !self.orchestratorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestratorAddress, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventWithdrawClaim, rhs: Injective_Peggy_V1_EventWithdrawClaim) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.eventHeight != rhs.eventHeight {return false}
    if lhs.attestationID != rhs.attestationID {return false}
    if lhs.batchNonce != rhs.batchNonce {return false}
    if lhs.tokenContract != rhs.tokenContract {return false}
    if lhs.orchestratorAddress != rhs.orchestratorAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventERC20DeployedClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventERC20DeployedClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "event_height"),
    3: .standard(proto: "attestation_id"),
    4: .standard(proto: "cosmos_denom"),
    5: .standard(proto: "token_contract"),
    6: .same(proto: "name"),
    7: .same(proto: "symbol"),
    8: .same(proto: "decimals"),
    9: .standard(proto: "orchestrator_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.eventNonce) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.eventHeight) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.attestationID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cosmosDenom) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.tokenContract) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.decimals) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.orchestratorAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if self.eventHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventHeight, fieldNumber: 2)
    }
    if !self.attestationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.attestationID, fieldNumber: 3)
    }
    if !self.cosmosDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.cosmosDenom, fieldNumber: 4)
    }
    if !self.tokenContract.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenContract, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 7)
    }
    if self.decimals != 0 {
      try visitor.visitSingularUInt64Field(value: self.decimals, fieldNumber: 8)
    }
    if !self.orchestratorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestratorAddress, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventERC20DeployedClaim, rhs: Injective_Peggy_V1_EventERC20DeployedClaim) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.eventHeight != rhs.eventHeight {return false}
    if lhs.attestationID != rhs.attestationID {return false}
    if lhs.cosmosDenom != rhs.cosmosDenom {return false}
    if lhs.tokenContract != rhs.tokenContract {return false}
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.orchestratorAddress != rhs.orchestratorAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventValsetUpdateClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventValsetUpdateClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "event_height"),
    3: .standard(proto: "attestation_id"),
    4: .standard(proto: "valset_nonce"),
    5: .standard(proto: "valset_members"),
    6: .standard(proto: "reward_amount"),
    7: .standard(proto: "reward_token"),
    8: .standard(proto: "orchestrator_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.eventNonce) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.eventHeight) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.attestationID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.valsetNonce) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.valsetMembers) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.rewardAmount) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.rewardToken) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.orchestratorAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if self.eventHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventHeight, fieldNumber: 2)
    }
    if !self.attestationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.attestationID, fieldNumber: 3)
    }
    if self.valsetNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.valsetNonce, fieldNumber: 4)
    }
    if !self.valsetMembers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.valsetMembers, fieldNumber: 5)
    }
    if !self.rewardAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardAmount, fieldNumber: 6)
    }
    if !self.rewardToken.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardToken, fieldNumber: 7)
    }
    if !self.orchestratorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestratorAddress, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventValsetUpdateClaim, rhs: Injective_Peggy_V1_EventValsetUpdateClaim) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.eventHeight != rhs.eventHeight {return false}
    if lhs.attestationID != rhs.attestationID {return false}
    if lhs.valsetNonce != rhs.valsetNonce {return false}
    if lhs.valsetMembers != rhs.valsetMembers {return false}
    if lhs.rewardAmount != rhs.rewardAmount {return false}
    if lhs.rewardToken != rhs.rewardToken {return false}
    if lhs.orchestratorAddress != rhs.orchestratorAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventCancelSendToEth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCancelSendToEth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "outgoing_tx_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.outgoingTxID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.outgoingTxID != 0 {
      try visitor.visitSingularUInt64Field(value: self.outgoingTxID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventCancelSendToEth, rhs: Injective_Peggy_V1_EventCancelSendToEth) -> Bool {
    if lhs.outgoingTxID != rhs.outgoingTxID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventSubmitBadSignatureEvidence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSubmitBadSignatureEvidence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bad_eth_signature"),
    2: .standard(proto: "bad_eth_signature_subject"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.badEthSignature) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.badEthSignatureSubject) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.badEthSignature.isEmpty {
      try visitor.visitSingularStringField(value: self.badEthSignature, fieldNumber: 1)
    }
    if !self.badEthSignatureSubject.isEmpty {
      try visitor.visitSingularStringField(value: self.badEthSignatureSubject, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventSubmitBadSignatureEvidence, rhs: Injective_Peggy_V1_EventSubmitBadSignatureEvidence) -> Bool {
    if lhs.badEthSignature != rhs.badEthSignature {return false}
    if lhs.badEthSignatureSubject != rhs.badEthSignatureSubject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Peggy_V1_EventValidatorSlash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventValidatorSlash"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "power"),
    2: .same(proto: "reason"),
    3: .standard(proto: "consensus_address"),
    4: .standard(proto: "operator_address"),
    5: .same(proto: "moniker"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.power) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.consensusAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.operatorAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.moniker) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.power != 0 {
      try visitor.visitSingularInt64Field(value: self.power, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if !self.consensusAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.consensusAddress, fieldNumber: 3)
    }
    if !self.operatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.operatorAddress, fieldNumber: 4)
    }
    if !self.moniker.isEmpty {
      try visitor.visitSingularStringField(value: self.moniker, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Peggy_V1_EventValidatorSlash, rhs: Injective_Peggy_V1_EventValidatorSlash) -> Bool {
    if lhs.power != rhs.power {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.consensusAddress != rhs.consensusAddress {return false}
    if lhs.operatorAddress != rhs.operatorAddress {return false}
    if lhs.moniker != rhs.moniker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
