// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: kyve/team/v1beta1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryAccountsRequest is request type for the Query/TeamInfo RPC method.
struct Kyve_Team_V1beta1_QueryTeamInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountsResponse is response type for the Query/TeamInfo RPC method.
struct Kyve_Team_V1beta1_QueryTeamInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// foundation is the authority foundation address
  var foundationAuthority: String = String()

  /// bcp is the authority bcp address
  var bcpAuthority: String = String()

  /// total_team_allocation is the total allocation in $KYVE the team module has in order to reward team members
  var totalTeamAllocation: UInt64 = 0

  /// issued_team_allocation is the amount in $KYVE tied to team vesting accounts and which are not available anymore
  var issuedTeamAllocation: UInt64 = 0

  /// available_team_allocation is the amount in $KYVE with which further team vesting accounts can be created.
  /// if the available amount is zero no new vesting accounts can be created
  var availableTeamAllocation: UInt64 = 0

  /// total_authority_rewards is the amount in $KYVE the authority has earned in total with inflation rewards.
  /// Those rewards can be payed out for different purposes
  var totalAuthorityRewards: UInt64 = 0

  /// claimed_authority_rewards is the amount in $KYVE of how much the authority already claimed
  var claimedAuthorityRewards: UInt64 = 0

  /// available_authority_rewards is the amount in $KYVE of how much rewards the authority can claim right now
  var availableAuthorityRewards: UInt64 = 0

  /// total_account_rewards is the amount in $KYVE all team vesting accounts have ever received
  var totalAccountRewards: UInt64 = 0

  /// claimed_account_rewards is the amount in $KYVE all team vesting accounts have ever claimed
  var claimedAccountRewards: UInt64 = 0

  /// available_account_rewards is the total amount of $KYVE all team vesting accounts can currently claim
  var availableAccountRewards: UInt64 = 0

  /// required_module_balance is the balance the team module should have. If this is less than the module balance
  /// something went wrong
  var requiredModuleBalance: UInt64 = 0

  /// team_module_balance is the team module balance in $KYVE
  var teamModuleBalance: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountsRequest is request type for the Query/TeamVestingAccounts RPC method.
struct Kyve_Team_V1beta1_QueryTeamVestingAccountsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountsResponse is response type for the Query/TeamVestingAccounts RPC method.
struct Kyve_Team_V1beta1_QueryTeamVestingAccountsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// accounts holds all the team vesting accounts of this module.
  var accounts: [Kyve_Team_V1beta1_TeamVestingAccount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTeamVestingAccountRequest is request type for the Query/TeamVestingAccount RPC method.
struct Kyve_Team_V1beta1_QueryTeamVestingAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id is a unique identify for each vesting account, tied to a single team member.
  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTeamVestingAccountResponse is the response type for the Query/TeamVestingAccount RPC method.
struct Kyve_Team_V1beta1_QueryTeamVestingAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// account holds the requested team vesting account
  var account: Kyve_Team_V1beta1_TeamVestingAccount {
    get {return _account ?? Kyve_Team_V1beta1_TeamVestingAccount()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: Kyve_Team_V1beta1_TeamVestingAccount? = nil
}

/// QueryTeamCurrentVestingStatusRequest is request type for the Query/TeamCurrentVestingStatus RPC method.
struct Kyve_Team_V1beta1_QueryTeamVestingStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id is a unique identify for each vesting account, tied to a single team member.
  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTeamCurrentVestingStatusResponse is the response type for the Query/TeamCurrentVestingStatus RPC method.
struct Kyve_Team_V1beta1_QueryTeamVestingStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// request_date ..
  var requestDate: String {
    get {return _storage._requestDate}
    set {_uniqueStorage()._requestDate = newValue}
  }

  /// plan ...
  var plan: Kyve_Team_V1beta1_QueryVestingPlan {
    get {return _storage._plan ?? Kyve_Team_V1beta1_QueryVestingPlan()}
    set {_uniqueStorage()._plan = newValue}
  }
  /// Returns true if `plan` has been explicitly set.
  var hasPlan: Bool {return _storage._plan != nil}
  /// Clears the value of `plan`. Subsequent reads from it will return its default value.
  mutating func clearPlan() {_uniqueStorage()._plan = nil}

  /// status ..
  var status: Kyve_Team_V1beta1_QueryVestingStatus {
    get {return _storage._status ?? Kyve_Team_V1beta1_QueryVestingStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// QueryTeamVestingStatusByTimeRequest is request type for the Query/TeamCurrentVestingByTimeStatus RPC method.
struct Kyve_Team_V1beta1_QueryTeamVestingStatusByTimeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id is a unique identify for each vesting account, tied to a single team member.
  var id: UInt64 = 0

  /// time is a unix timestamp of the time the vesting progress should be calculated
  var time: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTeamVestingStatusByTimeResponse is the response type for the Query/TeamCurrentVestingByTimeStatus RPC method.
struct Kyve_Team_V1beta1_QueryTeamVestingStatusByTimeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// request_date ..
  var requestDate: String {
    get {return _storage._requestDate}
    set {_uniqueStorage()._requestDate = newValue}
  }

  /// plan ...
  var plan: Kyve_Team_V1beta1_QueryVestingPlan {
    get {return _storage._plan ?? Kyve_Team_V1beta1_QueryVestingPlan()}
    set {_uniqueStorage()._plan = newValue}
  }
  /// Returns true if `plan` has been explicitly set.
  var hasPlan: Bool {return _storage._plan != nil}
  /// Clears the value of `plan`. Subsequent reads from it will return its default value.
  mutating func clearPlan() {_uniqueStorage()._plan = nil}

  /// status ..
  var status: Kyve_Team_V1beta1_QueryVestingStatus {
    get {return _storage._status ?? Kyve_Team_V1beta1_QueryVestingStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// QueryVestingStatus is a type holding information about the account's vesting progress
struct Kyve_Team_V1beta1_QueryVestingStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total_vested_amount ...
  var totalVestedAmount: UInt64 = 0

  /// total_unlocked_amount ...
  var totalUnlockedAmount: UInt64 = 0

  /// current_claimable_amount ...
  var currentClaimableAmount: UInt64 = 0

  /// locked_vested_amount ...
  var lockedVestedAmount: UInt64 = 0

  /// remaining_unvested_amount ...
  var remainingUnvestedAmount: UInt64 = 0

  /// claimed_amount ...
  var claimedAmount: UInt64 = 0

  /// total_rewards ...
  var totalRewards: UInt64 = 0

  /// claimed_rewards ...
  var claimedRewards: UInt64 = 0

  /// available_rewards ...
  var availableRewards: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryVestingPlan is a type holding information about the account's vesting data which does not change
struct Kyve_Team_V1beta1_QueryVestingPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// commencement ...
  var commencement: String = String()

  /// token_vesting_start ...
  var tokenVestingStart: String = String()

  /// token_vesting_finished ...
  var tokenVestingFinished: String = String()

  /// token_unlock_start ...
  var tokenUnlockStart: String = String()

  /// token_unlock_finished ...
  var tokenUnlockFinished: String = String()

  /// clawback ...
  var clawback: UInt64 = 0

  /// clawback_amount ...
  var clawbackAmount: UInt64 = 0

  /// maximum_vesting_amount ...
  var maximumVestingAmount: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Kyve_Team_V1beta1_QueryTeamInfoRequest: @unchecked Sendable {}
extension Kyve_Team_V1beta1_QueryTeamInfoResponse: @unchecked Sendable {}
extension Kyve_Team_V1beta1_QueryTeamVestingAccountsRequest: @unchecked Sendable {}
extension Kyve_Team_V1beta1_QueryTeamVestingAccountsResponse: @unchecked Sendable {}
extension Kyve_Team_V1beta1_QueryTeamVestingAccountRequest: @unchecked Sendable {}
extension Kyve_Team_V1beta1_QueryTeamVestingAccountResponse: @unchecked Sendable {}
extension Kyve_Team_V1beta1_QueryTeamVestingStatusRequest: @unchecked Sendable {}
extension Kyve_Team_V1beta1_QueryTeamVestingStatusResponse: @unchecked Sendable {}
extension Kyve_Team_V1beta1_QueryTeamVestingStatusByTimeRequest: @unchecked Sendable {}
extension Kyve_Team_V1beta1_QueryTeamVestingStatusByTimeResponse: @unchecked Sendable {}
extension Kyve_Team_V1beta1_QueryVestingStatus: @unchecked Sendable {}
extension Kyve_Team_V1beta1_QueryVestingPlan: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "kyve.team.v1beta1"

extension Kyve_Team_V1beta1_QueryTeamInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTeamInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kyve_Team_V1beta1_QueryTeamInfoRequest, rhs: Kyve_Team_V1beta1_QueryTeamInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kyve_Team_V1beta1_QueryTeamInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTeamInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "foundation_authority"),
    2: .standard(proto: "bcp_authority"),
    3: .standard(proto: "total_team_allocation"),
    4: .standard(proto: "issued_team_allocation"),
    5: .standard(proto: "available_team_allocation"),
    6: .standard(proto: "total_authority_rewards"),
    7: .standard(proto: "claimed_authority_rewards"),
    8: .standard(proto: "available_authority_rewards"),
    9: .standard(proto: "total_account_rewards"),
    10: .standard(proto: "claimed_account_rewards"),
    11: .standard(proto: "available_account_rewards"),
    12: .standard(proto: "required_module_balance"),
    13: .standard(proto: "team_module_balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.foundationAuthority) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bcpAuthority) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.totalTeamAllocation) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.issuedTeamAllocation) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.availableTeamAllocation) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.totalAuthorityRewards) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.claimedAuthorityRewards) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.availableAuthorityRewards) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.totalAccountRewards) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.claimedAccountRewards) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.availableAccountRewards) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self.requiredModuleBalance) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.teamModuleBalance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.foundationAuthority.isEmpty {
      try visitor.visitSingularStringField(value: self.foundationAuthority, fieldNumber: 1)
    }
    if !self.bcpAuthority.isEmpty {
      try visitor.visitSingularStringField(value: self.bcpAuthority, fieldNumber: 2)
    }
    if self.totalTeamAllocation != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalTeamAllocation, fieldNumber: 3)
    }
    if self.issuedTeamAllocation != 0 {
      try visitor.visitSingularUInt64Field(value: self.issuedTeamAllocation, fieldNumber: 4)
    }
    if self.availableTeamAllocation != 0 {
      try visitor.visitSingularUInt64Field(value: self.availableTeamAllocation, fieldNumber: 5)
    }
    if self.totalAuthorityRewards != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalAuthorityRewards, fieldNumber: 6)
    }
    if self.claimedAuthorityRewards != 0 {
      try visitor.visitSingularUInt64Field(value: self.claimedAuthorityRewards, fieldNumber: 7)
    }
    if self.availableAuthorityRewards != 0 {
      try visitor.visitSingularUInt64Field(value: self.availableAuthorityRewards, fieldNumber: 8)
    }
    if self.totalAccountRewards != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalAccountRewards, fieldNumber: 9)
    }
    if self.claimedAccountRewards != 0 {
      try visitor.visitSingularUInt64Field(value: self.claimedAccountRewards, fieldNumber: 10)
    }
    if self.availableAccountRewards != 0 {
      try visitor.visitSingularUInt64Field(value: self.availableAccountRewards, fieldNumber: 11)
    }
    if self.requiredModuleBalance != 0 {
      try visitor.visitSingularUInt64Field(value: self.requiredModuleBalance, fieldNumber: 12)
    }
    if self.teamModuleBalance != 0 {
      try visitor.visitSingularUInt64Field(value: self.teamModuleBalance, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kyve_Team_V1beta1_QueryTeamInfoResponse, rhs: Kyve_Team_V1beta1_QueryTeamInfoResponse) -> Bool {
    if lhs.foundationAuthority != rhs.foundationAuthority {return false}
    if lhs.bcpAuthority != rhs.bcpAuthority {return false}
    if lhs.totalTeamAllocation != rhs.totalTeamAllocation {return false}
    if lhs.issuedTeamAllocation != rhs.issuedTeamAllocation {return false}
    if lhs.availableTeamAllocation != rhs.availableTeamAllocation {return false}
    if lhs.totalAuthorityRewards != rhs.totalAuthorityRewards {return false}
    if lhs.claimedAuthorityRewards != rhs.claimedAuthorityRewards {return false}
    if lhs.availableAuthorityRewards != rhs.availableAuthorityRewards {return false}
    if lhs.totalAccountRewards != rhs.totalAccountRewards {return false}
    if lhs.claimedAccountRewards != rhs.claimedAccountRewards {return false}
    if lhs.availableAccountRewards != rhs.availableAccountRewards {return false}
    if lhs.requiredModuleBalance != rhs.requiredModuleBalance {return false}
    if lhs.teamModuleBalance != rhs.teamModuleBalance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kyve_Team_V1beta1_QueryTeamVestingAccountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTeamVestingAccountsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kyve_Team_V1beta1_QueryTeamVestingAccountsRequest, rhs: Kyve_Team_V1beta1_QueryTeamVestingAccountsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kyve_Team_V1beta1_QueryTeamVestingAccountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTeamVestingAccountsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kyve_Team_V1beta1_QueryTeamVestingAccountsResponse, rhs: Kyve_Team_V1beta1_QueryTeamVestingAccountsResponse) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kyve_Team_V1beta1_QueryTeamVestingAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTeamVestingAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kyve_Team_V1beta1_QueryTeamVestingAccountRequest, rhs: Kyve_Team_V1beta1_QueryTeamVestingAccountRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kyve_Team_V1beta1_QueryTeamVestingAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTeamVestingAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kyve_Team_V1beta1_QueryTeamVestingAccountResponse, rhs: Kyve_Team_V1beta1_QueryTeamVestingAccountResponse) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kyve_Team_V1beta1_QueryTeamVestingStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTeamVestingStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kyve_Team_V1beta1_QueryTeamVestingStatusRequest, rhs: Kyve_Team_V1beta1_QueryTeamVestingStatusRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kyve_Team_V1beta1_QueryTeamVestingStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTeamVestingStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_date"),
    2: .same(proto: "plan"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _requestDate: String = String()
    var _plan: Kyve_Team_V1beta1_QueryVestingPlan? = nil
    var _status: Kyve_Team_V1beta1_QueryVestingStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _requestDate = source._requestDate
      _plan = source._plan
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._requestDate) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._plan) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._requestDate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestDate, fieldNumber: 1)
      }
      try { if let v = _storage._plan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kyve_Team_V1beta1_QueryTeamVestingStatusResponse, rhs: Kyve_Team_V1beta1_QueryTeamVestingStatusResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._requestDate != rhs_storage._requestDate {return false}
        if _storage._plan != rhs_storage._plan {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kyve_Team_V1beta1_QueryTeamVestingStatusByTimeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTeamVestingStatusByTimeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kyve_Team_V1beta1_QueryTeamVestingStatusByTimeRequest, rhs: Kyve_Team_V1beta1_QueryTeamVestingStatusByTimeRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kyve_Team_V1beta1_QueryTeamVestingStatusByTimeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTeamVestingStatusByTimeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_date"),
    2: .same(proto: "plan"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _requestDate: String = String()
    var _plan: Kyve_Team_V1beta1_QueryVestingPlan? = nil
    var _status: Kyve_Team_V1beta1_QueryVestingStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _requestDate = source._requestDate
      _plan = source._plan
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._requestDate) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._plan) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._requestDate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestDate, fieldNumber: 1)
      }
      try { if let v = _storage._plan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kyve_Team_V1beta1_QueryTeamVestingStatusByTimeResponse, rhs: Kyve_Team_V1beta1_QueryTeamVestingStatusByTimeResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._requestDate != rhs_storage._requestDate {return false}
        if _storage._plan != rhs_storage._plan {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kyve_Team_V1beta1_QueryVestingStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryVestingStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_vested_amount"),
    2: .standard(proto: "total_unlocked_amount"),
    3: .standard(proto: "current_claimable_amount"),
    4: .standard(proto: "locked_vested_amount"),
    5: .standard(proto: "remaining_unvested_amount"),
    6: .standard(proto: "claimed_amount"),
    7: .standard(proto: "total_rewards"),
    8: .standard(proto: "claimed_rewards"),
    9: .standard(proto: "available_rewards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.totalVestedAmount) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.totalUnlockedAmount) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.currentClaimableAmount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.lockedVestedAmount) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.remainingUnvestedAmount) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.claimedAmount) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.totalRewards) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.claimedRewards) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.availableRewards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalVestedAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalVestedAmount, fieldNumber: 1)
    }
    if self.totalUnlockedAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalUnlockedAmount, fieldNumber: 2)
    }
    if self.currentClaimableAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.currentClaimableAmount, fieldNumber: 3)
    }
    if self.lockedVestedAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.lockedVestedAmount, fieldNumber: 4)
    }
    if self.remainingUnvestedAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.remainingUnvestedAmount, fieldNumber: 5)
    }
    if self.claimedAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.claimedAmount, fieldNumber: 6)
    }
    if self.totalRewards != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalRewards, fieldNumber: 7)
    }
    if self.claimedRewards != 0 {
      try visitor.visitSingularUInt64Field(value: self.claimedRewards, fieldNumber: 8)
    }
    if self.availableRewards != 0 {
      try visitor.visitSingularUInt64Field(value: self.availableRewards, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kyve_Team_V1beta1_QueryVestingStatus, rhs: Kyve_Team_V1beta1_QueryVestingStatus) -> Bool {
    if lhs.totalVestedAmount != rhs.totalVestedAmount {return false}
    if lhs.totalUnlockedAmount != rhs.totalUnlockedAmount {return false}
    if lhs.currentClaimableAmount != rhs.currentClaimableAmount {return false}
    if lhs.lockedVestedAmount != rhs.lockedVestedAmount {return false}
    if lhs.remainingUnvestedAmount != rhs.remainingUnvestedAmount {return false}
    if lhs.claimedAmount != rhs.claimedAmount {return false}
    if lhs.totalRewards != rhs.totalRewards {return false}
    if lhs.claimedRewards != rhs.claimedRewards {return false}
    if lhs.availableRewards != rhs.availableRewards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kyve_Team_V1beta1_QueryVestingPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryVestingPlan"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commencement"),
    2: .standard(proto: "token_vesting_start"),
    3: .standard(proto: "token_vesting_finished"),
    4: .standard(proto: "token_unlock_start"),
    5: .standard(proto: "token_unlock_finished"),
    6: .same(proto: "clawback"),
    7: .standard(proto: "clawback_amount"),
    8: .standard(proto: "maximum_vesting_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.commencement) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenVestingStart) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tokenVestingFinished) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tokenUnlockStart) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.tokenUnlockFinished) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.clawback) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.clawbackAmount) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.maximumVestingAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commencement.isEmpty {
      try visitor.visitSingularStringField(value: self.commencement, fieldNumber: 1)
    }
    if !self.tokenVestingStart.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenVestingStart, fieldNumber: 2)
    }
    if !self.tokenVestingFinished.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenVestingFinished, fieldNumber: 3)
    }
    if !self.tokenUnlockStart.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenUnlockStart, fieldNumber: 4)
    }
    if !self.tokenUnlockFinished.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenUnlockFinished, fieldNumber: 5)
    }
    if self.clawback != 0 {
      try visitor.visitSingularUInt64Field(value: self.clawback, fieldNumber: 6)
    }
    if self.clawbackAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.clawbackAmount, fieldNumber: 7)
    }
    if self.maximumVestingAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.maximumVestingAmount, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kyve_Team_V1beta1_QueryVestingPlan, rhs: Kyve_Team_V1beta1_QueryVestingPlan) -> Bool {
    if lhs.commencement != rhs.commencement {return false}
    if lhs.tokenVestingStart != rhs.tokenVestingStart {return false}
    if lhs.tokenVestingFinished != rhs.tokenVestingFinished {return false}
    if lhs.tokenUnlockStart != rhs.tokenUnlockStart {return false}
    if lhs.tokenUnlockFinished != rhs.tokenUnlockFinished {return false}
    if lhs.clawback != rhs.clawback {return false}
    if lhs.clawbackAmount != rhs.clawbackAmount {return false}
    if lhs.maximumVestingAmount != rhs.maximumVestingAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
