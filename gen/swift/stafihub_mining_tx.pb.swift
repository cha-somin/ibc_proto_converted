// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: stafihub/mining/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Stafihub_Stafihub_Mining_MsgAddStakePool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var stakeTokenDenom: String = String()

  var rewardPoolInfoList: [Stafihub_Stafihub_Mining_CreateRewardPoolInfo] = []

  var stakeItemInfoList: [Stafihub_Stafihub_Mining_CreateStakeItemInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_CreateRewardPoolInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rewardTokenDenom: String = String()

  var totalRewardAmount: String = String()

  var rewardPerSecond: String = String()

  var startTimestamp: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_CreateStakeItemInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lockSecond: UInt64 = 0

  /// user stakedPower = powerRewardRate * stakedAmount
  var powerRewardRate: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgAddStakePoolResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgAddStakeItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var stakePoolIndex: UInt32 = 0

  var lockSecond: UInt64 = 0

  var powerRewardRate: String = String()

  var enable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgAddStakeItemResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgAddRewardPool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var stakePoolIndex: UInt32 = 0

  var rewardTokenDenom: String = String()

  var totalRewardAmount: String = String()

  var rewardPerSecond: String = String()

  var startTimestamp: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgAddRewardPoolResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgStake {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var stakePoolIndex: UInt32 = 0

  var stakeAmount: String = String()

  var stakeItemIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgStakeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgClaimReward {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var stakePoolIndex: UInt32 = 0

  var stakeRecordIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgClaimRewardResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var stakePoolIndex: UInt32 = 0

  var stakeRecordIndex: UInt32 = 0

  var withdrawAmount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgWithdrawResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgUpdateStakeItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var index: UInt32 = 0

  var stakePoolIndex: UInt32 = 0

  var lockSecond: UInt64 = 0

  var powerRewardRate: String = String()

  var enable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgUpdateStakeItemResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgAddMiningProvider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var userAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgAddMiningProviderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgRmMiningProvider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var userAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgRmMiningProviderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgAddRewardToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var denom: String = String()

  var minTotalRewardAmount: String = String()

  var minRewardPerSecond: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgAddRewardTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgSetMaxRewardPoolNumber {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var number: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgSetMaxRewardPoolNumberResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgUpdateRewardPool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var stakePoolIndex: UInt32 = 0

  var rewardPoolIndex: UInt32 = 0

  var rewardPerSecond: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgUpdateRewardPoolResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgToggleProviderSwitch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgToggleProviderSwitchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgSetMaxStakeItemNumber {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var number: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgSetMaxStakeItemNumberResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgAddReward {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var stakePoolIndex: UInt32 = 0

  var rewardPoolIndex: UInt32 = 0

  var addAmount: String = String()

  var startTimestamp: UInt64 = 0

  var rewardPerSecond: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgAddRewardResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgToggleEmergencySwitch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var stakePoolIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgToggleEmergencySwitchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgEmergencyWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var stakePoolIndex: UInt32 = 0

  var stakeRecordIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgEmergencyWithdrawResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgAddStakeToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgAddStakeTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgRmRewardToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgRmRewardTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgRmStakeToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgRmStakeTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgSetStakeItemLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var maxLockSecond: UInt64 = 0

  var maxPowerRewardRate: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgSetStakeItemLimitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgWithdrawRewardToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var stakePoolIndex: UInt32 = 0

  var rewardPoolIndex: UInt32 = 0

  var withdrawAmount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stafihub_Stafihub_Mining_MsgWithdrawRewardTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stafihub_Stafihub_Mining_MsgAddStakePool: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_CreateRewardPoolInfo: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_CreateStakeItemInfo: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgAddStakePoolResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgAddStakeItem: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgAddStakeItemResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgAddRewardPool: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgAddRewardPoolResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgStake: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgStakeResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgClaimReward: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgClaimRewardResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgWithdraw: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgWithdrawResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgUpdateStakeItem: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgUpdateStakeItemResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgAddMiningProvider: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgAddMiningProviderResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgRmMiningProvider: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgRmMiningProviderResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgAddRewardToken: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgAddRewardTokenResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgSetMaxRewardPoolNumber: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgSetMaxRewardPoolNumberResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgUpdateRewardPool: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgUpdateRewardPoolResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgToggleProviderSwitch: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgToggleProviderSwitchResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgSetMaxStakeItemNumber: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgSetMaxStakeItemNumberResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgAddReward: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgAddRewardResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgToggleEmergencySwitch: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgToggleEmergencySwitchResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgEmergencyWithdraw: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgEmergencyWithdrawResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgAddStakeToken: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgAddStakeTokenResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgRmRewardToken: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgRmRewardTokenResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgRmStakeToken: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgRmStakeTokenResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgSetStakeItemLimit: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgSetStakeItemLimitResponse: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgWithdrawRewardToken: @unchecked Sendable {}
extension Stafihub_Stafihub_Mining_MsgWithdrawRewardTokenResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stafihub.stafihub.mining"

extension Stafihub_Stafihub_Mining_MsgAddStakePool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddStakePool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "stakeTokenDenom"),
    3: .same(proto: "rewardPoolInfoList"),
    4: .same(proto: "stakeItemInfoList"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stakeTokenDenom) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rewardPoolInfoList) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.stakeItemInfoList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.stakeTokenDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.stakeTokenDenom, fieldNumber: 2)
    }
    if !self.rewardPoolInfoList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rewardPoolInfoList, fieldNumber: 3)
    }
    if !self.stakeItemInfoList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stakeItemInfoList, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddStakePool, rhs: Stafihub_Stafihub_Mining_MsgAddStakePool) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.stakeTokenDenom != rhs.stakeTokenDenom {return false}
    if lhs.rewardPoolInfoList != rhs.rewardPoolInfoList {return false}
    if lhs.stakeItemInfoList != rhs.stakeItemInfoList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_CreateRewardPoolInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateRewardPoolInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rewardTokenDenom"),
    2: .same(proto: "totalRewardAmount"),
    3: .same(proto: "rewardPerSecond"),
    4: .same(proto: "startTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rewardTokenDenom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.totalRewardAmount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rewardPerSecond) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.startTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rewardTokenDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardTokenDenom, fieldNumber: 1)
    }
    if !self.totalRewardAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.totalRewardAmount, fieldNumber: 2)
    }
    if !self.rewardPerSecond.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardPerSecond, fieldNumber: 3)
    }
    if self.startTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTimestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_CreateRewardPoolInfo, rhs: Stafihub_Stafihub_Mining_CreateRewardPoolInfo) -> Bool {
    if lhs.rewardTokenDenom != rhs.rewardTokenDenom {return false}
    if lhs.totalRewardAmount != rhs.totalRewardAmount {return false}
    if lhs.rewardPerSecond != rhs.rewardPerSecond {return false}
    if lhs.startTimestamp != rhs.startTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_CreateStakeItemInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateStakeItemInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lockSecond"),
    2: .same(proto: "powerRewardRate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.lockSecond) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.powerRewardRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lockSecond != 0 {
      try visitor.visitSingularUInt64Field(value: self.lockSecond, fieldNumber: 1)
    }
    if !self.powerRewardRate.isEmpty {
      try visitor.visitSingularStringField(value: self.powerRewardRate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_CreateStakeItemInfo, rhs: Stafihub_Stafihub_Mining_CreateStakeItemInfo) -> Bool {
    if lhs.lockSecond != rhs.lockSecond {return false}
    if lhs.powerRewardRate != rhs.powerRewardRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgAddStakePoolResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddStakePoolResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddStakePoolResponse, rhs: Stafihub_Stafihub_Mining_MsgAddStakePoolResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgAddStakeItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddStakeItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "stakePoolIndex"),
    3: .same(proto: "lockSecond"),
    4: .same(proto: "powerRewardRate"),
    5: .same(proto: "enable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stakePoolIndex) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.lockSecond) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.powerRewardRate) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.stakePoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakePoolIndex, fieldNumber: 2)
    }
    if self.lockSecond != 0 {
      try visitor.visitSingularUInt64Field(value: self.lockSecond, fieldNumber: 3)
    }
    if !self.powerRewardRate.isEmpty {
      try visitor.visitSingularStringField(value: self.powerRewardRate, fieldNumber: 4)
    }
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddStakeItem, rhs: Stafihub_Stafihub_Mining_MsgAddStakeItem) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.stakePoolIndex != rhs.stakePoolIndex {return false}
    if lhs.lockSecond != rhs.lockSecond {return false}
    if lhs.powerRewardRate != rhs.powerRewardRate {return false}
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgAddStakeItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddStakeItemResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddStakeItemResponse, rhs: Stafihub_Stafihub_Mining_MsgAddStakeItemResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgAddRewardPool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddRewardPool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "stakePoolIndex"),
    3: .same(proto: "rewardTokenDenom"),
    4: .same(proto: "totalRewardAmount"),
    5: .same(proto: "rewardPerSecond"),
    6: .same(proto: "startTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stakePoolIndex) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rewardTokenDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.totalRewardAmount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.rewardPerSecond) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.startTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.stakePoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakePoolIndex, fieldNumber: 2)
    }
    if !self.rewardTokenDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardTokenDenom, fieldNumber: 3)
    }
    if !self.totalRewardAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.totalRewardAmount, fieldNumber: 4)
    }
    if !self.rewardPerSecond.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardPerSecond, fieldNumber: 5)
    }
    if self.startTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTimestamp, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddRewardPool, rhs: Stafihub_Stafihub_Mining_MsgAddRewardPool) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.stakePoolIndex != rhs.stakePoolIndex {return false}
    if lhs.rewardTokenDenom != rhs.rewardTokenDenom {return false}
    if lhs.totalRewardAmount != rhs.totalRewardAmount {return false}
    if lhs.rewardPerSecond != rhs.rewardPerSecond {return false}
    if lhs.startTimestamp != rhs.startTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgAddRewardPoolResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddRewardPoolResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddRewardPoolResponse, rhs: Stafihub_Stafihub_Mining_MsgAddRewardPoolResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgStake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgStake"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "stakePoolIndex"),
    3: .same(proto: "stakeAmount"),
    4: .same(proto: "stakeItemIndex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stakePoolIndex) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.stakeAmount) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.stakeItemIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.stakePoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakePoolIndex, fieldNumber: 2)
    }
    if !self.stakeAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.stakeAmount, fieldNumber: 3)
    }
    if self.stakeItemIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakeItemIndex, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgStake, rhs: Stafihub_Stafihub_Mining_MsgStake) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.stakePoolIndex != rhs.stakePoolIndex {return false}
    if lhs.stakeAmount != rhs.stakeAmount {return false}
    if lhs.stakeItemIndex != rhs.stakeItemIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgStakeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgStakeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgStakeResponse, rhs: Stafihub_Stafihub_Mining_MsgStakeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgClaimReward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgClaimReward"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "stakePoolIndex"),
    3: .same(proto: "stakeRecordIndex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stakePoolIndex) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.stakeRecordIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.stakePoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakePoolIndex, fieldNumber: 2)
    }
    if self.stakeRecordIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakeRecordIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgClaimReward, rhs: Stafihub_Stafihub_Mining_MsgClaimReward) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.stakePoolIndex != rhs.stakePoolIndex {return false}
    if lhs.stakeRecordIndex != rhs.stakeRecordIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgClaimRewardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgClaimRewardResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgClaimRewardResponse, rhs: Stafihub_Stafihub_Mining_MsgClaimRewardResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "stakePoolIndex"),
    3: .same(proto: "stakeRecordIndex"),
    4: .same(proto: "withdrawAmount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stakePoolIndex) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.stakeRecordIndex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.withdrawAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.stakePoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakePoolIndex, fieldNumber: 2)
    }
    if self.stakeRecordIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakeRecordIndex, fieldNumber: 3)
    }
    if !self.withdrawAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.withdrawAmount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgWithdraw, rhs: Stafihub_Stafihub_Mining_MsgWithdraw) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.stakePoolIndex != rhs.stakePoolIndex {return false}
    if lhs.stakeRecordIndex != rhs.stakeRecordIndex {return false}
    if lhs.withdrawAmount != rhs.withdrawAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgWithdrawResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgWithdrawResponse, rhs: Stafihub_Stafihub_Mining_MsgWithdrawResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgUpdateStakeItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateStakeItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "index"),
    3: .same(proto: "stakePoolIndex"),
    4: .same(proto: "lockSecond"),
    5: .same(proto: "powerRewardRate"),
    6: .same(proto: "enable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.stakePoolIndex) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.lockSecond) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.powerRewardRate) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    if self.stakePoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakePoolIndex, fieldNumber: 3)
    }
    if self.lockSecond != 0 {
      try visitor.visitSingularUInt64Field(value: self.lockSecond, fieldNumber: 4)
    }
    if !self.powerRewardRate.isEmpty {
      try visitor.visitSingularStringField(value: self.powerRewardRate, fieldNumber: 5)
    }
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgUpdateStakeItem, rhs: Stafihub_Stafihub_Mining_MsgUpdateStakeItem) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.index != rhs.index {return false}
    if lhs.stakePoolIndex != rhs.stakePoolIndex {return false}
    if lhs.lockSecond != rhs.lockSecond {return false}
    if lhs.powerRewardRate != rhs.powerRewardRate {return false}
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgUpdateStakeItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateStakeItemResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgUpdateStakeItemResponse, rhs: Stafihub_Stafihub_Mining_MsgUpdateStakeItemResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgAddMiningProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddMiningProvider"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "userAddress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.userAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.userAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddMiningProvider, rhs: Stafihub_Stafihub_Mining_MsgAddMiningProvider) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.userAddress != rhs.userAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgAddMiningProviderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddMiningProviderResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddMiningProviderResponse, rhs: Stafihub_Stafihub_Mining_MsgAddMiningProviderResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgRmMiningProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRmMiningProvider"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "userAddress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.userAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.userAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgRmMiningProvider, rhs: Stafihub_Stafihub_Mining_MsgRmMiningProvider) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.userAddress != rhs.userAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgRmMiningProviderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRmMiningProviderResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgRmMiningProviderResponse, rhs: Stafihub_Stafihub_Mining_MsgRmMiningProviderResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgAddRewardToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddRewardToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "denom"),
    3: .same(proto: "minTotalRewardAmount"),
    4: .same(proto: "minRewardPerSecond"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.minTotalRewardAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.minRewardPerSecond) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    if !self.minTotalRewardAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.minTotalRewardAmount, fieldNumber: 3)
    }
    if !self.minRewardPerSecond.isEmpty {
      try visitor.visitSingularStringField(value: self.minRewardPerSecond, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddRewardToken, rhs: Stafihub_Stafihub_Mining_MsgAddRewardToken) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.minTotalRewardAmount != rhs.minTotalRewardAmount {return false}
    if lhs.minRewardPerSecond != rhs.minRewardPerSecond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgAddRewardTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddRewardTokenResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddRewardTokenResponse, rhs: Stafihub_Stafihub_Mining_MsgAddRewardTokenResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgSetMaxRewardPoolNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetMaxRewardPoolNumber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.number) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.number != 0 {
      try visitor.visitSingularUInt32Field(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgSetMaxRewardPoolNumber, rhs: Stafihub_Stafihub_Mining_MsgSetMaxRewardPoolNumber) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgSetMaxRewardPoolNumberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetMaxRewardPoolNumberResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgSetMaxRewardPoolNumberResponse, rhs: Stafihub_Stafihub_Mining_MsgSetMaxRewardPoolNumberResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgUpdateRewardPool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateRewardPool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "stakePoolIndex"),
    3: .same(proto: "rewardPoolIndex"),
    4: .same(proto: "rewardPerSecond"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stakePoolIndex) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.rewardPoolIndex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.rewardPerSecond) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.stakePoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakePoolIndex, fieldNumber: 2)
    }
    if self.rewardPoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.rewardPoolIndex, fieldNumber: 3)
    }
    if !self.rewardPerSecond.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardPerSecond, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgUpdateRewardPool, rhs: Stafihub_Stafihub_Mining_MsgUpdateRewardPool) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.stakePoolIndex != rhs.stakePoolIndex {return false}
    if lhs.rewardPoolIndex != rhs.rewardPoolIndex {return false}
    if lhs.rewardPerSecond != rhs.rewardPerSecond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgUpdateRewardPoolResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateRewardPoolResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgUpdateRewardPoolResponse, rhs: Stafihub_Stafihub_Mining_MsgUpdateRewardPoolResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgToggleProviderSwitch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgToggleProviderSwitch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgToggleProviderSwitch, rhs: Stafihub_Stafihub_Mining_MsgToggleProviderSwitch) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgToggleProviderSwitchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgToggleProviderSwitchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgToggleProviderSwitchResponse, rhs: Stafihub_Stafihub_Mining_MsgToggleProviderSwitchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgSetMaxStakeItemNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetMaxStakeItemNumber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.number) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.number != 0 {
      try visitor.visitSingularUInt32Field(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgSetMaxStakeItemNumber, rhs: Stafihub_Stafihub_Mining_MsgSetMaxStakeItemNumber) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgSetMaxStakeItemNumberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetMaxStakeItemNumberResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgSetMaxStakeItemNumberResponse, rhs: Stafihub_Stafihub_Mining_MsgSetMaxStakeItemNumberResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgAddReward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddReward"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "stakePoolIndex"),
    3: .same(proto: "rewardPoolIndex"),
    4: .same(proto: "addAmount"),
    5: .same(proto: "startTimestamp"),
    6: .same(proto: "rewardPerSecond"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stakePoolIndex) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.rewardPoolIndex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.addAmount) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.startTimestamp) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.rewardPerSecond) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.stakePoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakePoolIndex, fieldNumber: 2)
    }
    if self.rewardPoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.rewardPoolIndex, fieldNumber: 3)
    }
    if !self.addAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.addAmount, fieldNumber: 4)
    }
    if self.startTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTimestamp, fieldNumber: 5)
    }
    if !self.rewardPerSecond.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardPerSecond, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddReward, rhs: Stafihub_Stafihub_Mining_MsgAddReward) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.stakePoolIndex != rhs.stakePoolIndex {return false}
    if lhs.rewardPoolIndex != rhs.rewardPoolIndex {return false}
    if lhs.addAmount != rhs.addAmount {return false}
    if lhs.startTimestamp != rhs.startTimestamp {return false}
    if lhs.rewardPerSecond != rhs.rewardPerSecond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgAddRewardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddRewardResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddRewardResponse, rhs: Stafihub_Stafihub_Mining_MsgAddRewardResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgToggleEmergencySwitch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgToggleEmergencySwitch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "stakePoolIndex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stakePoolIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.stakePoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakePoolIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgToggleEmergencySwitch, rhs: Stafihub_Stafihub_Mining_MsgToggleEmergencySwitch) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.stakePoolIndex != rhs.stakePoolIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgToggleEmergencySwitchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgToggleEmergencySwitchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgToggleEmergencySwitchResponse, rhs: Stafihub_Stafihub_Mining_MsgToggleEmergencySwitchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgEmergencyWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgEmergencyWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "stakePoolIndex"),
    3: .same(proto: "stakeRecordIndex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stakePoolIndex) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.stakeRecordIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.stakePoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakePoolIndex, fieldNumber: 2)
    }
    if self.stakeRecordIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakeRecordIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgEmergencyWithdraw, rhs: Stafihub_Stafihub_Mining_MsgEmergencyWithdraw) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.stakePoolIndex != rhs.stakePoolIndex {return false}
    if lhs.stakeRecordIndex != rhs.stakeRecordIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgEmergencyWithdrawResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgEmergencyWithdrawResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgEmergencyWithdrawResponse, rhs: Stafihub_Stafihub_Mining_MsgEmergencyWithdrawResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgAddStakeToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddStakeToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddStakeToken, rhs: Stafihub_Stafihub_Mining_MsgAddStakeToken) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgAddStakeTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddStakeTokenResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgAddStakeTokenResponse, rhs: Stafihub_Stafihub_Mining_MsgAddStakeTokenResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgRmRewardToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRmRewardToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgRmRewardToken, rhs: Stafihub_Stafihub_Mining_MsgRmRewardToken) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgRmRewardTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRmRewardTokenResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgRmRewardTokenResponse, rhs: Stafihub_Stafihub_Mining_MsgRmRewardTokenResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgRmStakeToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRmStakeToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgRmStakeToken, rhs: Stafihub_Stafihub_Mining_MsgRmStakeToken) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgRmStakeTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRmStakeTokenResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgRmStakeTokenResponse, rhs: Stafihub_Stafihub_Mining_MsgRmStakeTokenResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgSetStakeItemLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetStakeItemLimit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "maxLockSecond"),
    3: .same(proto: "maxPowerRewardRate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.maxLockSecond) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.maxPowerRewardRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.maxLockSecond != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxLockSecond, fieldNumber: 2)
    }
    if !self.maxPowerRewardRate.isEmpty {
      try visitor.visitSingularStringField(value: self.maxPowerRewardRate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgSetStakeItemLimit, rhs: Stafihub_Stafihub_Mining_MsgSetStakeItemLimit) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.maxLockSecond != rhs.maxLockSecond {return false}
    if lhs.maxPowerRewardRate != rhs.maxPowerRewardRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgSetStakeItemLimitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetStakeItemLimitResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgSetStakeItemLimitResponse, rhs: Stafihub_Stafihub_Mining_MsgSetStakeItemLimitResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgWithdrawRewardToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawRewardToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "stakePoolIndex"),
    3: .same(proto: "rewardPoolIndex"),
    4: .same(proto: "withdrawAmount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.stakePoolIndex) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.rewardPoolIndex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.withdrawAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.stakePoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stakePoolIndex, fieldNumber: 2)
    }
    if self.rewardPoolIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.rewardPoolIndex, fieldNumber: 3)
    }
    if !self.withdrawAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.withdrawAmount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgWithdrawRewardToken, rhs: Stafihub_Stafihub_Mining_MsgWithdrawRewardToken) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.stakePoolIndex != rhs.stakePoolIndex {return false}
    if lhs.rewardPoolIndex != rhs.rewardPoolIndex {return false}
    if lhs.withdrawAmount != rhs.withdrawAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stafihub_Stafihub_Mining_MsgWithdrawRewardTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawRewardTokenResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stafihub_Stafihub_Mining_MsgWithdrawRewardTokenResponse, rhs: Stafihub_Stafihub_Mining_MsgWithdrawRewardTokenResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
