// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: babylon/btcstaking/v1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgCreateFinalityProvider is the message for creating a finality provider
struct Babylon_Btcstaking_V1_MsgCreateFinalityProvider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// addr defines the address of the finality provider that will receive
  /// the commissions to all the delegations.
  var addr: String = String()

  /// description defines the description terms for the finality provider
  var description_p: Cosmos_Staking_V1beta1_Description {
    get {return _description_p ?? Cosmos_Staking_V1beta1_Description()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  /// commission defines the commission rate of the finality provider
  var commission: String = String()

  /// btc_pk is the Bitcoin secp256k1 PK of this finality provider
  /// the PK follows encoding in BIP-340 spec
  var btcPk: Data = Data()

  /// pop is the proof of possession of btc_pk over the FP signer address.
  var pop: Babylon_Btcstaking_V1_ProofOfPossessionBTC {
    get {return _pop ?? Babylon_Btcstaking_V1_ProofOfPossessionBTC()}
    set {_pop = newValue}
  }
  /// Returns true if `pop` has been explicitly set.
  var hasPop: Bool {return self._pop != nil}
  /// Clears the value of `pop`. Subsequent reads from it will return its default value.
  mutating func clearPop() {self._pop = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _description_p: Cosmos_Staking_V1beta1_Description? = nil
  fileprivate var _pop: Babylon_Btcstaking_V1_ProofOfPossessionBTC? = nil
}

/// MsgCreateFinalityProviderResponse is the response for MsgCreateFinalityProvider
struct Babylon_Btcstaking_V1_MsgCreateFinalityProviderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgEditFinalityProvider is the message for editing an existing finality provider
struct Babylon_Btcstaking_V1_MsgEditFinalityProvider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// addr the address of the finality provider that whishes to edit his information.
  var addr: String = String()

  /// btc_pk is the Bitcoin secp256k1 PK of the finality provider to be edited
  var btcPk: Data = Data()

  /// description defines the updated description terms for the finality provider
  var description_p: Cosmos_Staking_V1beta1_Description {
    get {return _description_p ?? Cosmos_Staking_V1beta1_Description()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  /// commission defines the updated commission rate of the finality provider
  var commission: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _description_p: Cosmos_Staking_V1beta1_Description? = nil
}

/// MsgEditFinalityProviderResponse is the response for MsgEditFinalityProvider
struct Babylon_Btcstaking_V1_MsgEditFinalityProviderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateBTCDelegation is the message for creating a BTC delegation
struct Babylon_Btcstaking_V1_MsgCreateBTCDelegation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// staker_addr is the address to receive rewards from BTC delegation.
  var stakerAddr: String {
    get {return _storage._stakerAddr}
    set {_uniqueStorage()._stakerAddr = newValue}
  }

  /// pop is the proof of possession of btc_pk by the staker_addr.
  var pop: Babylon_Btcstaking_V1_ProofOfPossessionBTC {
    get {return _storage._pop ?? Babylon_Btcstaking_V1_ProofOfPossessionBTC()}
    set {_uniqueStorage()._pop = newValue}
  }
  /// Returns true if `pop` has been explicitly set.
  var hasPop: Bool {return _storage._pop != nil}
  /// Clears the value of `pop`. Subsequent reads from it will return its default value.
  mutating func clearPop() {_uniqueStorage()._pop = nil}

  /// btc_pk is the Bitcoin secp256k1 PK of the BTC delegator
  var btcPk: Data {
    get {return _storage._btcPk}
    set {_uniqueStorage()._btcPk = newValue}
  }

  /// fp_btc_pk_list is the list of Bitcoin secp256k1 PKs of the finality providers, if there is more than one
  /// finality provider pk it means that delegation is re-staked
  var fpBtcPkList: [Data] {
    get {return _storage._fpBtcPkList}
    set {_uniqueStorage()._fpBtcPkList = newValue}
  }

  /// staking_time is the time lock used in staking transaction
  var stakingTime: UInt32 {
    get {return _storage._stakingTime}
    set {_uniqueStorage()._stakingTime = newValue}
  }

  /// staking_value  is the amount of satoshis locked in staking output
  var stakingValue: Int64 {
    get {return _storage._stakingValue}
    set {_uniqueStorage()._stakingValue = newValue}
  }

  /// staking_tx is a bitcoin staking transaction i.e transaction that locks funds
  var stakingTx: Data {
    get {return _storage._stakingTx}
    set {_uniqueStorage()._stakingTx = newValue}
  }

  /// staking_tx_inclusion_proof is the inclusion proof of the staking tx in BTC chain
  var stakingTxInclusionProof: Babylon_Btcstaking_V1_InclusionProof {
    get {return _storage._stakingTxInclusionProof ?? Babylon_Btcstaking_V1_InclusionProof()}
    set {_uniqueStorage()._stakingTxInclusionProof = newValue}
  }
  /// Returns true if `stakingTxInclusionProof` has been explicitly set.
  var hasStakingTxInclusionProof: Bool {return _storage._stakingTxInclusionProof != nil}
  /// Clears the value of `stakingTxInclusionProof`. Subsequent reads from it will return its default value.
  mutating func clearStakingTxInclusionProof() {_uniqueStorage()._stakingTxInclusionProof = nil}

  /// slashing_tx is the slashing tx
  /// Note that the tx itself does not contain signatures, which are off-chain.
  var slashingTx: Data {
    get {return _storage._slashingTx}
    set {_uniqueStorage()._slashingTx = newValue}
  }

  /// delegator_slashing_sig is the signature on the slashing tx by the delegator (i.e., SK corresponding to btc_pk).
  /// It will be a part of the witness for the staking tx output.
  /// The staking tx output further needs signatures from covenant and finality provider in
  /// order to be spendable.
  var delegatorSlashingSig: Data {
    get {return _storage._delegatorSlashingSig}
    set {_uniqueStorage()._delegatorSlashingSig = newValue}
  }

  /// unbonding_time is the time lock used when funds are being unbonded. It is be used in:
  /// - unbonding transaction, time lock spending path
  /// - staking slashing transaction, change output
  /// - unbonding slashing transaction, change output
  /// It must be smaller than math.MaxUInt16 and larger that max(MinUnbondingTime, CheckpointFinalizationTimeout)
  var unbondingTime: UInt32 {
    get {return _storage._unbondingTime}
    set {_uniqueStorage()._unbondingTime = newValue}
  }

  /// fields related to unbonding transaction
  /// unbonding_tx is a bitcoin unbonding transaction i.e transaction that spends
  /// staking output and sends it to the unbonding output
  var unbondingTx: Data {
    get {return _storage._unbondingTx}
    set {_uniqueStorage()._unbondingTx = newValue}
  }

  /// unbonding_value is amount of satoshis locked in unbonding output.
  /// NOTE: staking_value and unbonding_value could be different because of the difference between the fee for staking tx and that for unbonding
  var unbondingValue: Int64 {
    get {return _storage._unbondingValue}
    set {_uniqueStorage()._unbondingValue = newValue}
  }

  /// unbonding_slashing_tx is the slashing tx which slash unbonding contract
  /// Note that the tx itself does not contain signatures, which are off-chain.
  var unbondingSlashingTx: Data {
    get {return _storage._unbondingSlashingTx}
    set {_uniqueStorage()._unbondingSlashingTx = newValue}
  }

  /// delegator_unbonding_slashing_sig is the signature on the slashing tx by the delegator (i.e., SK corresponding to btc_pk).
  var delegatorUnbondingSlashingSig: Data {
    get {return _storage._delegatorUnbondingSlashingSig}
    set {_uniqueStorage()._delegatorUnbondingSlashingSig = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MsgCreateBTCDelegationResponse is the response for MsgCreateBTCDelegation
struct Babylon_Btcstaking_V1_MsgCreateBTCDelegationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddBTCDelegationInclusionProof is the message for adding proof of inclusion of BTC delegation on BTC chain
struct Babylon_Btcstaking_V1_MsgAddBTCDelegationInclusionProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signer: String = String()

  /// staking_tx_hash is the hash of the staking tx.
  /// It uniquely identifies a BTC delegation
  var stakingTxHash: String = String()

  /// staking_tx_inclusion_proof is the inclusion proof of the staking tx in BTC chain
  var stakingTxInclusionProof: Babylon_Btcstaking_V1_InclusionProof {
    get {return _stakingTxInclusionProof ?? Babylon_Btcstaking_V1_InclusionProof()}
    set {_stakingTxInclusionProof = newValue}
  }
  /// Returns true if `stakingTxInclusionProof` has been explicitly set.
  var hasStakingTxInclusionProof: Bool {return self._stakingTxInclusionProof != nil}
  /// Clears the value of `stakingTxInclusionProof`. Subsequent reads from it will return its default value.
  mutating func clearStakingTxInclusionProof() {self._stakingTxInclusionProof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stakingTxInclusionProof: Babylon_Btcstaking_V1_InclusionProof? = nil
}

/// MsgAddBTCDelegationInclusionProofResponse is the response for MsgAddBTCDelegationInclusionProof
struct Babylon_Btcstaking_V1_MsgAddBTCDelegationInclusionProofResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddCovenantSigs is the message for handling signatures from a covenant member
struct Babylon_Btcstaking_V1_MsgAddCovenantSigs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signer: String = String()

  /// pk is the BTC public key of the covenant member
  var pk: Data = Data()

  /// staking_tx_hash is the hash of the staking tx.
  /// It uniquely identifies a BTC delegation
  var stakingTxHash: String = String()

  /// sigs is a list of adaptor signatures of the covenant
  /// the order of sigs should respect the order of finality providers
  /// of the corresponding delegation
  var slashingTxSigs: [Data] = []

  /// unbonding_tx_sig is the signature of the covenant on the unbonding tx submitted to babylon
  /// the signature follows encoding in BIP-340 spec
  var unbondingTxSig: Data = Data()

  /// slashing_unbonding_tx_sigs is a list of adaptor signatures of the covenant
  /// on slashing tx corresponding to unbonding tx submitted to babylon
  /// the order of sigs should respect the order of finality providers
  /// of the corresponding delegation
  var slashingUnbondingTxSigs: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddCovenantSigsResponse is the response for MsgAddCovenantSigs
struct Babylon_Btcstaking_V1_MsgAddCovenantSigsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBTCUndelegate is the message for handling signature on unbonding tx
/// from its delegator. This signature effectively proves that the delegator
/// wants to unbond this BTC delegation
struct Babylon_Btcstaking_V1_MsgBTCUndelegate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signer: String = String()

  /// staking_tx_hash is the hash of the staking tx.
  /// It uniquely identifies a BTC delegation
  var stakingTxHash: String = String()

  /// stake_spending_tx is a bitcoin transaction that spends the staking transaction
  /// i.e it has staking output as an input
  var stakeSpendingTx: Data = Data()

  /// spend_spending_tx_inclusion_proof is the proof of inclusion of the
  /// stake_spending_tx in the BTC chain
  var stakeSpendingTxInclusionProof: Babylon_Btcstaking_V1_InclusionProof {
    get {return _stakeSpendingTxInclusionProof ?? Babylon_Btcstaking_V1_InclusionProof()}
    set {_stakeSpendingTxInclusionProof = newValue}
  }
  /// Returns true if `stakeSpendingTxInclusionProof` has been explicitly set.
  var hasStakeSpendingTxInclusionProof: Bool {return self._stakeSpendingTxInclusionProof != nil}
  /// Clears the value of `stakeSpendingTxInclusionProof`. Subsequent reads from it will return its default value.
  mutating func clearStakeSpendingTxInclusionProof() {self._stakeSpendingTxInclusionProof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stakeSpendingTxInclusionProof: Babylon_Btcstaking_V1_InclusionProof? = nil
}

/// MsgBTCUndelegateResponse is the response for MsgBTCUndelegate
struct Babylon_Btcstaking_V1_MsgBTCUndelegateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSelectiveSlashingEvidence is the message for handling evidence of selective slashing
/// launched by a finality provider
struct Babylon_Btcstaking_V1_MsgSelectiveSlashingEvidence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signer: String = String()

  /// staking_tx_hash is the hash of the staking tx.
  /// It uniquely identifies a BTC delegation
  var stakingTxHash: String = String()

  /// recovered_fp_btc_sk is the BTC SK of the finality provider who
  /// launches the selective slashing offence. The SK is recovered by
  /// using a covenant adaptor signature and the corresponding Schnorr
  /// signature
  var recoveredFpBtcSk: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSelectiveSlashingEvidenceResponse is the response for MsgSelectiveSlashingEvidence
struct Babylon_Btcstaking_V1_MsgSelectiveSlashingEvidenceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateParams defines a message for updating btcstaking module parameters.
struct Babylon_Btcstaking_V1_MsgUpdateParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authority is the address of the governance account.
  /// just FYI: cosmos.AddressString marks that this field should use type alias
  /// for AddressString instead of string, but the functionality is not yet implemented
  /// in cosmos-proto
  var authority: String = String()

  /// params defines the finality parameters to update.
  ///
  /// NOTE: All parameters must be supplied.
  var params: Babylon_Btcstaking_V1_Params {
    get {return _params ?? Babylon_Btcstaking_V1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Babylon_Btcstaking_V1_Params? = nil
}

/// MsgUpdateParamsResponse is the response to the MsgUpdateParams message.
struct Babylon_Btcstaking_V1_MsgUpdateParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Babylon_Btcstaking_V1_MsgCreateFinalityProvider: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgCreateFinalityProviderResponse: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgEditFinalityProvider: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgEditFinalityProviderResponse: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgCreateBTCDelegation: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgCreateBTCDelegationResponse: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgAddBTCDelegationInclusionProof: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgAddBTCDelegationInclusionProofResponse: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgAddCovenantSigs: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgAddCovenantSigsResponse: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgBTCUndelegate: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgBTCUndelegateResponse: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgSelectiveSlashingEvidence: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgSelectiveSlashingEvidenceResponse: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgUpdateParams: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_MsgUpdateParamsResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "babylon.btcstaking.v1"

extension Babylon_Btcstaking_V1_MsgCreateFinalityProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateFinalityProvider"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
    2: .same(proto: "description"),
    3: .same(proto: "commission"),
    4: .standard(proto: "btc_pk"),
    5: .same(proto: "pop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.commission) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.btcPk) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._pop) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    try { if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.commission.isEmpty {
      try visitor.visitSingularStringField(value: self.commission, fieldNumber: 3)
    }
    if !self.btcPk.isEmpty {
      try visitor.visitSingularBytesField(value: self.btcPk, fieldNumber: 4)
    }
    try { if let v = self._pop {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgCreateFinalityProvider, rhs: Babylon_Btcstaking_V1_MsgCreateFinalityProvider) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.commission != rhs.commission {return false}
    if lhs.btcPk != rhs.btcPk {return false}
    if lhs._pop != rhs._pop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgCreateFinalityProviderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateFinalityProviderResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgCreateFinalityProviderResponse, rhs: Babylon_Btcstaking_V1_MsgCreateFinalityProviderResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgEditFinalityProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgEditFinalityProvider"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
    2: .standard(proto: "btc_pk"),
    3: .same(proto: "description"),
    4: .same(proto: "commission"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.btcPk) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.commission) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    if !self.btcPk.isEmpty {
      try visitor.visitSingularBytesField(value: self.btcPk, fieldNumber: 2)
    }
    try { if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.commission.isEmpty {
      try visitor.visitSingularStringField(value: self.commission, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgEditFinalityProvider, rhs: Babylon_Btcstaking_V1_MsgEditFinalityProvider) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.btcPk != rhs.btcPk {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.commission != rhs.commission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgEditFinalityProviderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgEditFinalityProviderResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgEditFinalityProviderResponse, rhs: Babylon_Btcstaking_V1_MsgEditFinalityProviderResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgCreateBTCDelegation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBTCDelegation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staker_addr"),
    2: .same(proto: "pop"),
    3: .standard(proto: "btc_pk"),
    4: .standard(proto: "fp_btc_pk_list"),
    5: .standard(proto: "staking_time"),
    6: .standard(proto: "staking_value"),
    7: .standard(proto: "staking_tx"),
    8: .standard(proto: "staking_tx_inclusion_proof"),
    9: .standard(proto: "slashing_tx"),
    10: .standard(proto: "delegator_slashing_sig"),
    11: .standard(proto: "unbonding_time"),
    12: .standard(proto: "unbonding_tx"),
    13: .standard(proto: "unbonding_value"),
    14: .standard(proto: "unbonding_slashing_tx"),
    15: .standard(proto: "delegator_unbonding_slashing_sig"),
  ]

  fileprivate class _StorageClass {
    var _stakerAddr: String = String()
    var _pop: Babylon_Btcstaking_V1_ProofOfPossessionBTC? = nil
    var _btcPk: Data = Data()
    var _fpBtcPkList: [Data] = []
    var _stakingTime: UInt32 = 0
    var _stakingValue: Int64 = 0
    var _stakingTx: Data = Data()
    var _stakingTxInclusionProof: Babylon_Btcstaking_V1_InclusionProof? = nil
    var _slashingTx: Data = Data()
    var _delegatorSlashingSig: Data = Data()
    var _unbondingTime: UInt32 = 0
    var _unbondingTx: Data = Data()
    var _unbondingValue: Int64 = 0
    var _unbondingSlashingTx: Data = Data()
    var _delegatorUnbondingSlashingSig: Data = Data()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _stakerAddr = source._stakerAddr
      _pop = source._pop
      _btcPk = source._btcPk
      _fpBtcPkList = source._fpBtcPkList
      _stakingTime = source._stakingTime
      _stakingValue = source._stakingValue
      _stakingTx = source._stakingTx
      _stakingTxInclusionProof = source._stakingTxInclusionProof
      _slashingTx = source._slashingTx
      _delegatorSlashingSig = source._delegatorSlashingSig
      _unbondingTime = source._unbondingTime
      _unbondingTx = source._unbondingTx
      _unbondingValue = source._unbondingValue
      _unbondingSlashingTx = source._unbondingSlashingTx
      _delegatorUnbondingSlashingSig = source._delegatorUnbondingSlashingSig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._stakerAddr) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._pop) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._btcPk) }()
        case 4: try { try decoder.decodeRepeatedBytesField(value: &_storage._fpBtcPkList) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._stakingTime) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._stakingValue) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._stakingTx) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._stakingTxInclusionProof) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._slashingTx) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._delegatorSlashingSig) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._unbondingTime) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._unbondingTx) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._unbondingValue) }()
        case 14: try { try decoder.decodeSingularBytesField(value: &_storage._unbondingSlashingTx) }()
        case 15: try { try decoder.decodeSingularBytesField(value: &_storage._delegatorUnbondingSlashingSig) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._stakerAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stakerAddr, fieldNumber: 1)
      }
      try { if let v = _storage._pop {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._btcPk.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._btcPk, fieldNumber: 3)
      }
      if !_storage._fpBtcPkList.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._fpBtcPkList, fieldNumber: 4)
      }
      if _storage._stakingTime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._stakingTime, fieldNumber: 5)
      }
      if _storage._stakingValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stakingValue, fieldNumber: 6)
      }
      if !_storage._stakingTx.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._stakingTx, fieldNumber: 7)
      }
      try { if let v = _storage._stakingTxInclusionProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._slashingTx.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._slashingTx, fieldNumber: 9)
      }
      if !_storage._delegatorSlashingSig.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._delegatorSlashingSig, fieldNumber: 10)
      }
      if _storage._unbondingTime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._unbondingTime, fieldNumber: 11)
      }
      if !_storage._unbondingTx.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._unbondingTx, fieldNumber: 12)
      }
      if _storage._unbondingValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unbondingValue, fieldNumber: 13)
      }
      if !_storage._unbondingSlashingTx.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._unbondingSlashingTx, fieldNumber: 14)
      }
      if !_storage._delegatorUnbondingSlashingSig.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._delegatorUnbondingSlashingSig, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgCreateBTCDelegation, rhs: Babylon_Btcstaking_V1_MsgCreateBTCDelegation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._stakerAddr != rhs_storage._stakerAddr {return false}
        if _storage._pop != rhs_storage._pop {return false}
        if _storage._btcPk != rhs_storage._btcPk {return false}
        if _storage._fpBtcPkList != rhs_storage._fpBtcPkList {return false}
        if _storage._stakingTime != rhs_storage._stakingTime {return false}
        if _storage._stakingValue != rhs_storage._stakingValue {return false}
        if _storage._stakingTx != rhs_storage._stakingTx {return false}
        if _storage._stakingTxInclusionProof != rhs_storage._stakingTxInclusionProof {return false}
        if _storage._slashingTx != rhs_storage._slashingTx {return false}
        if _storage._delegatorSlashingSig != rhs_storage._delegatorSlashingSig {return false}
        if _storage._unbondingTime != rhs_storage._unbondingTime {return false}
        if _storage._unbondingTx != rhs_storage._unbondingTx {return false}
        if _storage._unbondingValue != rhs_storage._unbondingValue {return false}
        if _storage._unbondingSlashingTx != rhs_storage._unbondingSlashingTx {return false}
        if _storage._delegatorUnbondingSlashingSig != rhs_storage._delegatorUnbondingSlashingSig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgCreateBTCDelegationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBTCDelegationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgCreateBTCDelegationResponse, rhs: Babylon_Btcstaking_V1_MsgCreateBTCDelegationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgAddBTCDelegationInclusionProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddBTCDelegationInclusionProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signer"),
    2: .standard(proto: "staking_tx_hash"),
    3: .standard(proto: "staking_tx_inclusion_proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stakingTxHash) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._stakingTxInclusionProof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 1)
    }
    if !self.stakingTxHash.isEmpty {
      try visitor.visitSingularStringField(value: self.stakingTxHash, fieldNumber: 2)
    }
    try { if let v = self._stakingTxInclusionProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgAddBTCDelegationInclusionProof, rhs: Babylon_Btcstaking_V1_MsgAddBTCDelegationInclusionProof) -> Bool {
    if lhs.signer != rhs.signer {return false}
    if lhs.stakingTxHash != rhs.stakingTxHash {return false}
    if lhs._stakingTxInclusionProof != rhs._stakingTxInclusionProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgAddBTCDelegationInclusionProofResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddBTCDelegationInclusionProofResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgAddBTCDelegationInclusionProofResponse, rhs: Babylon_Btcstaking_V1_MsgAddBTCDelegationInclusionProofResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgAddCovenantSigs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddCovenantSigs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signer"),
    2: .same(proto: "pk"),
    3: .standard(proto: "staking_tx_hash"),
    4: .standard(proto: "slashing_tx_sigs"),
    5: .standard(proto: "unbonding_tx_sig"),
    6: .standard(proto: "slashing_unbonding_tx_sigs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pk) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.stakingTxHash) }()
      case 4: try { try decoder.decodeRepeatedBytesField(value: &self.slashingTxSigs) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.unbondingTxSig) }()
      case 6: try { try decoder.decodeRepeatedBytesField(value: &self.slashingUnbondingTxSigs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 1)
    }
    if !self.pk.isEmpty {
      try visitor.visitSingularBytesField(value: self.pk, fieldNumber: 2)
    }
    if !self.stakingTxHash.isEmpty {
      try visitor.visitSingularStringField(value: self.stakingTxHash, fieldNumber: 3)
    }
    if !self.slashingTxSigs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.slashingTxSigs, fieldNumber: 4)
    }
    if !self.unbondingTxSig.isEmpty {
      try visitor.visitSingularBytesField(value: self.unbondingTxSig, fieldNumber: 5)
    }
    if !self.slashingUnbondingTxSigs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.slashingUnbondingTxSigs, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgAddCovenantSigs, rhs: Babylon_Btcstaking_V1_MsgAddCovenantSigs) -> Bool {
    if lhs.signer != rhs.signer {return false}
    if lhs.pk != rhs.pk {return false}
    if lhs.stakingTxHash != rhs.stakingTxHash {return false}
    if lhs.slashingTxSigs != rhs.slashingTxSigs {return false}
    if lhs.unbondingTxSig != rhs.unbondingTxSig {return false}
    if lhs.slashingUnbondingTxSigs != rhs.slashingUnbondingTxSigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgAddCovenantSigsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddCovenantSigsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgAddCovenantSigsResponse, rhs: Babylon_Btcstaking_V1_MsgAddCovenantSigsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgBTCUndelegate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBTCUndelegate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signer"),
    2: .standard(proto: "staking_tx_hash"),
    3: .standard(proto: "stake_spending_tx"),
    4: .standard(proto: "stake_spending_tx_inclusion_proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stakingTxHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.stakeSpendingTx) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._stakeSpendingTxInclusionProof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 1)
    }
    if !self.stakingTxHash.isEmpty {
      try visitor.visitSingularStringField(value: self.stakingTxHash, fieldNumber: 2)
    }
    if !self.stakeSpendingTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.stakeSpendingTx, fieldNumber: 3)
    }
    try { if let v = self._stakeSpendingTxInclusionProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgBTCUndelegate, rhs: Babylon_Btcstaking_V1_MsgBTCUndelegate) -> Bool {
    if lhs.signer != rhs.signer {return false}
    if lhs.stakingTxHash != rhs.stakingTxHash {return false}
    if lhs.stakeSpendingTx != rhs.stakeSpendingTx {return false}
    if lhs._stakeSpendingTxInclusionProof != rhs._stakeSpendingTxInclusionProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgBTCUndelegateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBTCUndelegateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgBTCUndelegateResponse, rhs: Babylon_Btcstaking_V1_MsgBTCUndelegateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgSelectiveSlashingEvidence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSelectiveSlashingEvidence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signer"),
    2: .standard(proto: "staking_tx_hash"),
    3: .standard(proto: "recovered_fp_btc_sk"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stakingTxHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.recoveredFpBtcSk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 1)
    }
    if !self.stakingTxHash.isEmpty {
      try visitor.visitSingularStringField(value: self.stakingTxHash, fieldNumber: 2)
    }
    if !self.recoveredFpBtcSk.isEmpty {
      try visitor.visitSingularBytesField(value: self.recoveredFpBtcSk, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgSelectiveSlashingEvidence, rhs: Babylon_Btcstaking_V1_MsgSelectiveSlashingEvidence) -> Bool {
    if lhs.signer != rhs.signer {return false}
    if lhs.stakingTxHash != rhs.stakingTxHash {return false}
    if lhs.recoveredFpBtcSk != rhs.recoveredFpBtcSk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgSelectiveSlashingEvidenceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSelectiveSlashingEvidenceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgSelectiveSlashingEvidenceResponse, rhs: Babylon_Btcstaking_V1_MsgSelectiveSlashingEvidenceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgUpdateParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgUpdateParams, rhs: Babylon_Btcstaking_V1_MsgUpdateParams) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_MsgUpdateParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParamsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_MsgUpdateParamsResponse, rhs: Babylon_Btcstaking_V1_MsgUpdateParamsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
