// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ixo/bonds/v1beta1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryBondsRequest is the request type for the Query/Bonds RPC method.
struct Ixo_Bonds_V1beta1_QueryBondsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBondsResponse is the response type for the Query/Bonds RPC method.
struct Ixo_Bonds_V1beta1_QueryBondsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bonds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBondsDetailedRequest is the request type for the Query/BondsDetailed RPC
/// method.
struct Ixo_Bonds_V1beta1_QueryBondsDetailedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBondsDetailedResponse is the response type for the Query/BondsDetailed
/// RPC method.
struct Ixo_Bonds_V1beta1_QueryBondsDetailedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondsDetailed: [Ixo_Bonds_V1beta1_BondDetails] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBondRequest is the request type for the Query/Bond RPC method.
struct Ixo_Bonds_V1beta1_QueryBondRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBondResponse is the response type for the Query/Bond RPC method.
struct Ixo_Bonds_V1beta1_QueryBondResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bond: Ixo_Bonds_V1beta1_Bond {
    get {return _bond ?? Ixo_Bonds_V1beta1_Bond()}
    set {_bond = newValue}
  }
  /// Returns true if `bond` has been explicitly set.
  var hasBond: Bool {return self._bond != nil}
  /// Clears the value of `bond`. Subsequent reads from it will return its default value.
  mutating func clearBond() {self._bond = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bond: Ixo_Bonds_V1beta1_Bond? = nil
}

/// QueryBatchRequest is the request type for the Query/Batch RPC method.
struct Ixo_Bonds_V1beta1_QueryBatchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBatchResponse is the response type for the Query/Batch RPC method.
struct Ixo_Bonds_V1beta1_QueryBatchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var batch: Ixo_Bonds_V1beta1_Batch {
    get {return _batch ?? Ixo_Bonds_V1beta1_Batch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  mutating func clearBatch() {self._batch = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _batch: Ixo_Bonds_V1beta1_Batch? = nil
}

/// QueryLastBatchRequest is the request type for the Query/LastBatch RPC method.
struct Ixo_Bonds_V1beta1_QueryLastBatchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryLastBatchResponse is the response type for the Query/LastBatch RPC
/// method.
struct Ixo_Bonds_V1beta1_QueryLastBatchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastBatch: Ixo_Bonds_V1beta1_Batch {
    get {return _lastBatch ?? Ixo_Bonds_V1beta1_Batch()}
    set {_lastBatch = newValue}
  }
  /// Returns true if `lastBatch` has been explicitly set.
  var hasLastBatch: Bool {return self._lastBatch != nil}
  /// Clears the value of `lastBatch`. Subsequent reads from it will return its default value.
  mutating func clearLastBatch() {self._lastBatch = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastBatch: Ixo_Bonds_V1beta1_Batch? = nil
}

/// QueryCurrentPriceRequest is the request type for the Query/CurrentPrice RPC
/// method.
struct Ixo_Bonds_V1beta1_QueryCurrentPriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCurrentPriceResponse is the response type for the Query/CurrentPrice RPC
/// method.
struct Ixo_Bonds_V1beta1_QueryCurrentPriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentPrice: [Cosmos_Base_V1beta1_DecCoin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCurrentReserveRequest is the request type for the Query/CurrentReserve
/// RPC method.
struct Ixo_Bonds_V1beta1_QueryCurrentReserveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCurrentReserveResponse is the response type for the Query/CurrentReserve
/// RPC method.
struct Ixo_Bonds_V1beta1_QueryCurrentReserveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentReserve: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAvailableReserveRequest is the request type for the
/// Query/AvailableReserve RPC method.
struct Ixo_Bonds_V1beta1_QueryAvailableReserveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAvailableReserveResponse is the response type for the
/// Query/AvailableReserve RPC method.
struct Ixo_Bonds_V1beta1_QueryAvailableReserveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var availableReserve: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCustomPriceRequest is the request type for the Query/CustomPrice RPC
/// method.
struct Ixo_Bonds_V1beta1_QueryCustomPriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var bondAmount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCustomPriceResponse is the response type for the Query/CustomPrice RPC
/// method.
struct Ixo_Bonds_V1beta1_QueryCustomPriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var price: [Cosmos_Base_V1beta1_DecCoin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCustomPriceRequest is the request type for the Query/BuyPrice RPC
/// method.
struct Ixo_Bonds_V1beta1_QueryBuyPriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var bondAmount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCustomPriceResponse is the response type for the Query/BuyPrice RPC
/// method.
struct Ixo_Bonds_V1beta1_QueryBuyPriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var adjustedSupply: Cosmos_Base_V1beta1_Coin {
    get {return _adjustedSupply ?? Cosmos_Base_V1beta1_Coin()}
    set {_adjustedSupply = newValue}
  }
  /// Returns true if `adjustedSupply` has been explicitly set.
  var hasAdjustedSupply: Bool {return self._adjustedSupply != nil}
  /// Clears the value of `adjustedSupply`. Subsequent reads from it will return its default value.
  mutating func clearAdjustedSupply() {self._adjustedSupply = nil}

  var prices: [Cosmos_Base_V1beta1_Coin] = []

  var txFees: [Cosmos_Base_V1beta1_Coin] = []

  var totalPrices: [Cosmos_Base_V1beta1_Coin] = []

  var totalFees: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _adjustedSupply: Cosmos_Base_V1beta1_Coin? = nil
}

/// QuerySellReturnRequest is the request type for the Query/SellReturn RPC
/// method.
struct Ixo_Bonds_V1beta1_QuerySellReturnRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var bondAmount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySellReturnResponse is the response type for the Query/SellReturn RPC
/// method.
struct Ixo_Bonds_V1beta1_QuerySellReturnResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var adjustedSupply: Cosmos_Base_V1beta1_Coin {
    get {return _adjustedSupply ?? Cosmos_Base_V1beta1_Coin()}
    set {_adjustedSupply = newValue}
  }
  /// Returns true if `adjustedSupply` has been explicitly set.
  var hasAdjustedSupply: Bool {return self._adjustedSupply != nil}
  /// Clears the value of `adjustedSupply`. Subsequent reads from it will return its default value.
  mutating func clearAdjustedSupply() {self._adjustedSupply = nil}

  var returns: [Cosmos_Base_V1beta1_Coin] = []

  var txFees: [Cosmos_Base_V1beta1_Coin] = []

  var exitFees: [Cosmos_Base_V1beta1_Coin] = []

  var totalReturns: [Cosmos_Base_V1beta1_Coin] = []

  var totalFees: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _adjustedSupply: Cosmos_Base_V1beta1_Coin? = nil
}

/// QuerySwapReturnRequest is the request type for the Query/SwapReturn RPC
/// method.
struct Ixo_Bonds_V1beta1_QuerySwapReturnRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var fromTokenWithAmount: String = String()

  var toToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySwapReturnResponse is the response type for the Query/SwapReturn RPC
/// method.
struct Ixo_Bonds_V1beta1_QuerySwapReturnResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalReturns: [Cosmos_Base_V1beta1_Coin] = []

  var totalFees: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAlphaMaximumsRequest is the request type for the Query/AlphaMaximums RPC
/// method.
struct Ixo_Bonds_V1beta1_QueryAlphaMaximumsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAlphaMaximumsResponse is the response type for the Query/AlphaMaximums
/// RPC method.
struct Ixo_Bonds_V1beta1_QueryAlphaMaximumsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maxSystemAlphaIncrease: String = String()

  var maxSystemAlpha: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryParamsRequest is the request type for the Query/Params RPC method.
struct Ixo_Bonds_V1beta1_QueryParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryParamsResponse is the response type for the Query/Params RPC method.
struct Ixo_Bonds_V1beta1_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Ixo_Bonds_V1beta1_Params {
    get {return _params ?? Ixo_Bonds_V1beta1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Ixo_Bonds_V1beta1_Params? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Ixo_Bonds_V1beta1_QueryBondsRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryBondsResponse: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryBondsDetailedRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryBondsDetailedResponse: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryBondRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryBondResponse: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryBatchRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryBatchResponse: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryLastBatchRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryLastBatchResponse: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryCurrentPriceRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryCurrentPriceResponse: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryCurrentReserveRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryCurrentReserveResponse: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryAvailableReserveRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryAvailableReserveResponse: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryCustomPriceRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryCustomPriceResponse: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryBuyPriceRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryBuyPriceResponse: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QuerySellReturnRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QuerySellReturnResponse: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QuerySwapReturnRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QuerySwapReturnResponse: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryAlphaMaximumsRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryAlphaMaximumsResponse: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryParamsRequest: @unchecked Sendable {}
extension Ixo_Bonds_V1beta1_QueryParamsResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ixo.bonds.v1beta1"

extension Ixo_Bonds_V1beta1_QueryBondsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBondsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryBondsRequest, rhs: Ixo_Bonds_V1beta1_QueryBondsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryBondsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBondsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bonds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.bonds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bonds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.bonds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryBondsResponse, rhs: Ixo_Bonds_V1beta1_QueryBondsResponse) -> Bool {
    if lhs.bonds != rhs.bonds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryBondsDetailedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBondsDetailedRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryBondsDetailedRequest, rhs: Ixo_Bonds_V1beta1_QueryBondsDetailedRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryBondsDetailedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBondsDetailedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bonds_detailed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.bondsDetailed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondsDetailed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bondsDetailed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryBondsDetailedResponse, rhs: Ixo_Bonds_V1beta1_QueryBondsDetailedResponse) -> Bool {
    if lhs.bondsDetailed != rhs.bondsDetailed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryBondRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBondRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryBondRequest, rhs: Ixo_Bonds_V1beta1_QueryBondRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryBondResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBondResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bond"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bond) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bond {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryBondResponse, rhs: Ixo_Bonds_V1beta1_QueryBondResponse) -> Bool {
    if lhs._bond != rhs._bond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryBatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBatchRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryBatchRequest, rhs: Ixo_Bonds_V1beta1_QueryBatchRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBatchResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryBatchResponse, rhs: Ixo_Bonds_V1beta1_QueryBatchResponse) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryLastBatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryLastBatchRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryLastBatchRequest, rhs: Ixo_Bonds_V1beta1_QueryLastBatchRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryLastBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryLastBatchResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_batch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lastBatch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lastBatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryLastBatchResponse, rhs: Ixo_Bonds_V1beta1_QueryLastBatchResponse) -> Bool {
    if lhs._lastBatch != rhs._lastBatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryCurrentPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCurrentPriceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryCurrentPriceRequest, rhs: Ixo_Bonds_V1beta1_QueryCurrentPriceRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryCurrentPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCurrentPriceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.currentPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currentPrice.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.currentPrice, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryCurrentPriceResponse, rhs: Ixo_Bonds_V1beta1_QueryCurrentPriceResponse) -> Bool {
    if lhs.currentPrice != rhs.currentPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryCurrentReserveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCurrentReserveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryCurrentReserveRequest, rhs: Ixo_Bonds_V1beta1_QueryCurrentReserveRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryCurrentReserveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCurrentReserveResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_reserve"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.currentReserve) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currentReserve.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.currentReserve, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryCurrentReserveResponse, rhs: Ixo_Bonds_V1beta1_QueryCurrentReserveResponse) -> Bool {
    if lhs.currentReserve != rhs.currentReserve {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryAvailableReserveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAvailableReserveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryAvailableReserveRequest, rhs: Ixo_Bonds_V1beta1_QueryAvailableReserveRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryAvailableReserveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAvailableReserveResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "available_reserve"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.availableReserve) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.availableReserve.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.availableReserve, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryAvailableReserveResponse, rhs: Ixo_Bonds_V1beta1_QueryAvailableReserveResponse) -> Bool {
    if lhs.availableReserve != rhs.availableReserve {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryCustomPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCustomPriceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .standard(proto: "bond_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bondAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    if !self.bondAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.bondAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryCustomPriceRequest, rhs: Ixo_Bonds_V1beta1_QueryCustomPriceRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.bondAmount != rhs.bondAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryCustomPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCustomPriceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.price) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.price, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryCustomPriceResponse, rhs: Ixo_Bonds_V1beta1_QueryCustomPriceResponse) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryBuyPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBuyPriceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .standard(proto: "bond_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bondAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    if !self.bondAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.bondAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryBuyPriceRequest, rhs: Ixo_Bonds_V1beta1_QueryBuyPriceRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.bondAmount != rhs.bondAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryBuyPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBuyPriceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "adjusted_supply"),
    2: .same(proto: "prices"),
    3: .standard(proto: "tx_fees"),
    4: .standard(proto: "total_prices"),
    5: .standard(proto: "total_fees"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._adjustedSupply) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.prices) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.txFees) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.totalPrices) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.totalFees) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._adjustedSupply {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.prices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.prices, fieldNumber: 2)
    }
    if !self.txFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txFees, fieldNumber: 3)
    }
    if !self.totalPrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalPrices, fieldNumber: 4)
    }
    if !self.totalFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalFees, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryBuyPriceResponse, rhs: Ixo_Bonds_V1beta1_QueryBuyPriceResponse) -> Bool {
    if lhs._adjustedSupply != rhs._adjustedSupply {return false}
    if lhs.prices != rhs.prices {return false}
    if lhs.txFees != rhs.txFees {return false}
    if lhs.totalPrices != rhs.totalPrices {return false}
    if lhs.totalFees != rhs.totalFees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QuerySellReturnRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySellReturnRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .standard(proto: "bond_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bondAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    if !self.bondAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.bondAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QuerySellReturnRequest, rhs: Ixo_Bonds_V1beta1_QuerySellReturnRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.bondAmount != rhs.bondAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QuerySellReturnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySellReturnResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "adjusted_supply"),
    2: .same(proto: "returns"),
    3: .standard(proto: "tx_fees"),
    4: .standard(proto: "exit_fees"),
    5: .standard(proto: "total_returns"),
    6: .standard(proto: "total_fees"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._adjustedSupply) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.returns) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.txFees) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.exitFees) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.totalReturns) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.totalFees) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._adjustedSupply {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.returns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.returns, fieldNumber: 2)
    }
    if !self.txFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txFees, fieldNumber: 3)
    }
    if !self.exitFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exitFees, fieldNumber: 4)
    }
    if !self.totalReturns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalReturns, fieldNumber: 5)
    }
    if !self.totalFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalFees, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QuerySellReturnResponse, rhs: Ixo_Bonds_V1beta1_QuerySellReturnResponse) -> Bool {
    if lhs._adjustedSupply != rhs._adjustedSupply {return false}
    if lhs.returns != rhs.returns {return false}
    if lhs.txFees != rhs.txFees {return false}
    if lhs.exitFees != rhs.exitFees {return false}
    if lhs.totalReturns != rhs.totalReturns {return false}
    if lhs.totalFees != rhs.totalFees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QuerySwapReturnRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySwapReturnRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .standard(proto: "from_token_with_amount"),
    3: .standard(proto: "to_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fromTokenWithAmount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.toToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    if !self.fromTokenWithAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.fromTokenWithAmount, fieldNumber: 2)
    }
    if !self.toToken.isEmpty {
      try visitor.visitSingularStringField(value: self.toToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QuerySwapReturnRequest, rhs: Ixo_Bonds_V1beta1_QuerySwapReturnRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.fromTokenWithAmount != rhs.fromTokenWithAmount {return false}
    if lhs.toToken != rhs.toToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QuerySwapReturnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySwapReturnResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_returns"),
    2: .standard(proto: "total_fees"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.totalReturns) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.totalFees) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.totalReturns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalReturns, fieldNumber: 1)
    }
    if !self.totalFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalFees, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QuerySwapReturnResponse, rhs: Ixo_Bonds_V1beta1_QuerySwapReturnResponse) -> Bool {
    if lhs.totalReturns != rhs.totalReturns {return false}
    if lhs.totalFees != rhs.totalFees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryAlphaMaximumsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAlphaMaximumsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryAlphaMaximumsRequest, rhs: Ixo_Bonds_V1beta1_QueryAlphaMaximumsRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryAlphaMaximumsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAlphaMaximumsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_system_alpha_increase"),
    2: .standard(proto: "max_system_alpha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.maxSystemAlphaIncrease) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.maxSystemAlpha) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.maxSystemAlphaIncrease.isEmpty {
      try visitor.visitSingularStringField(value: self.maxSystemAlphaIncrease, fieldNumber: 1)
    }
    if !self.maxSystemAlpha.isEmpty {
      try visitor.visitSingularStringField(value: self.maxSystemAlpha, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryAlphaMaximumsResponse, rhs: Ixo_Bonds_V1beta1_QueryAlphaMaximumsResponse) -> Bool {
    if lhs.maxSystemAlphaIncrease != rhs.maxSystemAlphaIncrease {return false}
    if lhs.maxSystemAlpha != rhs.maxSystemAlpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryParamsRequest, rhs: Ixo_Bonds_V1beta1_QueryParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Bonds_V1beta1_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Bonds_V1beta1_QueryParamsResponse, rhs: Ixo_Bonds_V1beta1_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
