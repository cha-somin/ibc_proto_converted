// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: zrchain/treasury/mpcsign.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// SignRequestStatus indicates the status of an MPC signature request.
/// A request starts as "pending", waiting to be picked up. Then it can move to
/// either "approved" or "rejected", depending on the decision of the MPC nodes.
enum Zrchain_Treasury_SignRequestStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// The request is missing the status field.
  case unspecified // = 0

  /// The request is waiting to be fulfilled. This is the initial state of a
  /// request.
  case pending // = 1

  /// The request is partially fulfilled - at least one more response from
  /// a different MPC party is needed to confirm it.
  case partial // = 2

  /// The request was fulfilled. This is a final state for a request.
  case fulfilled // = 3

  /// The request was rejected. This is a final state for a request.
  case rejected // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .pending
    case 2: self = .partial
    case 3: self = .fulfilled
    case 4: self = .rejected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .pending: return 1
    case .partial: return 2
    case .fulfilled: return 3
    case .rejected: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Zrchain_Treasury_SignRequestStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Zrchain_Treasury_SignRequestStatus] = [
    .unspecified,
    .pending,
    .partial,
    .fulfilled,
    .rejected,
  ]
}

#endif  // swift(>=4.2)

/// format of a sign request
struct Zrchain_Treasury_SignRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var creator: String = String()

  /// Deprecated
  var keyID: UInt64 = 0

  var keyType: Zrchain_Treasury_KeyType = .unspecified

  var dataForSigning: [Data] = []

  var status: Zrchain_Treasury_SignRequestStatus = .unspecified

  var signedData: [Zrchain_Treasury_SignedDataWithID] = []

  var keyringPartySignatures: [Data] = []

  var rejectReason: String = String()

  var metadata: SwiftProtobuf.Google_Protobuf_Any {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var parentReqID: UInt64 = 0

  var childReqIds: [UInt64] = []

  var cacheID: Data = Data()

  var keyIds: [UInt64] = []

  var mpcBtl: UInt64 = 0

  var fee: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// format of a signed data with an id value used to sort the signed data
struct Zrchain_Treasury_SignedDataWithID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signRequestID: UInt64 = 0

  var signedData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// format of a sign transaction request
struct Zrchain_Treasury_SignTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var creator: String = String()

  var keyID: UInt64 = 0

  var walletType: Zrchain_Treasury_WalletType = .unspecified

  var unsignedTransaction: Data = Data()

  var signRequestID: UInt64 = 0

  var noBroadcast: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// format of a sign request response
struct Zrchain_Treasury_SignReqResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var creator: String = String()

  var keyIds: [UInt64] = []

  var keyType: String = String()

  var dataForSigning: [Data] = []

  var status: String = String()

  var signedData: [Zrchain_Treasury_SignedDataWithID] = []

  var keyringPartySignatures: [Data] = []

  var rejectReason: String = String()

  var metadata: SwiftProtobuf.Google_Protobuf_Any {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var parentReqID: UInt64 = 0

  var childReqIds: [UInt64] = []

  var cacheID: Data = Data()

  var mpcBtl: UInt64 = 0

  var fee: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// format of a sign transaction request response
struct Zrchain_Treasury_SignTxReqResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var creator: String = String()

  var keyID: UInt64 = 0

  var walletType: String = String()

  var unsignedTransaction: Data = Data()

  var signRequestID: UInt64 = 0

  var noBroadcast: Bool = false

  var mpcBtl: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// format of a sign transaction request for an InterChain Account transaction
struct Zrchain_Treasury_ICATransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var creator: String = String()

  var keyID: UInt64 = 0

  var keyType: Zrchain_Treasury_KeyType = .unspecified

  var inputMsg: Data = Data()

  /// ibc.applications.interchain_accounts.v1.MsgSendTx input_msg = 5;
  var status: Zrchain_Treasury_SignRequestStatus = .unspecified

  var signedData: [Data] = []

  var keyringPartySignatures: [Data] = []

  var rejectReason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Zrchain_Treasury_SignRequestStatus: @unchecked Sendable {}
extension Zrchain_Treasury_SignRequest: @unchecked Sendable {}
extension Zrchain_Treasury_SignedDataWithID: @unchecked Sendable {}
extension Zrchain_Treasury_SignTransactionRequest: @unchecked Sendable {}
extension Zrchain_Treasury_SignReqResponse: @unchecked Sendable {}
extension Zrchain_Treasury_SignTxReqResponse: @unchecked Sendable {}
extension Zrchain_Treasury_ICATransactionRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "zrchain.treasury"

extension Zrchain_Treasury_SignRequestStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIGN_REQUEST_STATUS_UNSPECIFIED"),
    1: .same(proto: "SIGN_REQUEST_STATUS_PENDING"),
    2: .same(proto: "SIGN_REQUEST_STATUS_PARTIAL"),
    3: .same(proto: "SIGN_REQUEST_STATUS_FULFILLED"),
    4: .same(proto: "SIGN_REQUEST_STATUS_REJECTED"),
  ]
}

extension Zrchain_Treasury_SignRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "creator"),
    3: .standard(proto: "key_id"),
    4: .standard(proto: "key_type"),
    5: .standard(proto: "data_for_signing"),
    6: .same(proto: "status"),
    7: .standard(proto: "signed_data"),
    8: .standard(proto: "keyring_party_signatures"),
    9: .standard(proto: "reject_reason"),
    10: .same(proto: "metadata"),
    11: .standard(proto: "parent_req_id"),
    12: .standard(proto: "child_req_ids"),
    13: .standard(proto: "cache_id"),
    14: .standard(proto: "key_ids"),
    15: .standard(proto: "mpc_btl"),
    16: .same(proto: "fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.keyID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.keyType) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.dataForSigning) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.signedData) }()
      case 8: try { try decoder.decodeRepeatedBytesField(value: &self.keyringPartySignatures) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.rejectReason) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.parentReqID) }()
      case 12: try { try decoder.decodeRepeatedUInt64Field(value: &self.childReqIds) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self.cacheID) }()
      case 14: try { try decoder.decodeRepeatedUInt64Field(value: &self.keyIds) }()
      case 15: try { try decoder.decodeSingularUInt64Field(value: &self.mpcBtl) }()
      case 16: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 2)
    }
    if self.keyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.keyID, fieldNumber: 3)
    }
    if self.keyType != .unspecified {
      try visitor.visitSingularEnumField(value: self.keyType, fieldNumber: 4)
    }
    if !self.dataForSigning.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.dataForSigning, fieldNumber: 5)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 6)
    }
    if !self.signedData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signedData, fieldNumber: 7)
    }
    if !self.keyringPartySignatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.keyringPartySignatures, fieldNumber: 8)
    }
    if !self.rejectReason.isEmpty {
      try visitor.visitSingularStringField(value: self.rejectReason, fieldNumber: 9)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if self.parentReqID != 0 {
      try visitor.visitSingularUInt64Field(value: self.parentReqID, fieldNumber: 11)
    }
    if !self.childReqIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.childReqIds, fieldNumber: 12)
    }
    if !self.cacheID.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheID, fieldNumber: 13)
    }
    if !self.keyIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.keyIds, fieldNumber: 14)
    }
    if self.mpcBtl != 0 {
      try visitor.visitSingularUInt64Field(value: self.mpcBtl, fieldNumber: 15)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_SignRequest, rhs: Zrchain_Treasury_SignRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.keyType != rhs.keyType {return false}
    if lhs.dataForSigning != rhs.dataForSigning {return false}
    if lhs.status != rhs.status {return false}
    if lhs.signedData != rhs.signedData {return false}
    if lhs.keyringPartySignatures != rhs.keyringPartySignatures {return false}
    if lhs.rejectReason != rhs.rejectReason {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.parentReqID != rhs.parentReqID {return false}
    if lhs.childReqIds != rhs.childReqIds {return false}
    if lhs.cacheID != rhs.cacheID {return false}
    if lhs.keyIds != rhs.keyIds {return false}
    if lhs.mpcBtl != rhs.mpcBtl {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_SignedDataWithID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedDataWithID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sign_request_id"),
    2: .standard(proto: "signed_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.signRequestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signedData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.signRequestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.signRequestID, fieldNumber: 1)
    }
    if !self.signedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_SignedDataWithID, rhs: Zrchain_Treasury_SignedDataWithID) -> Bool {
    if lhs.signRequestID != rhs.signRequestID {return false}
    if lhs.signedData != rhs.signedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_SignTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignTransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "creator"),
    3: .standard(proto: "key_id"),
    4: .standard(proto: "wallet_type"),
    5: .standard(proto: "unsigned_transaction"),
    6: .standard(proto: "sign_request_id"),
    7: .standard(proto: "no_broadcast"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.keyID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.walletType) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.unsignedTransaction) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.signRequestID) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.noBroadcast) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 2)
    }
    if self.keyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.keyID, fieldNumber: 3)
    }
    if self.walletType != .unspecified {
      try visitor.visitSingularEnumField(value: self.walletType, fieldNumber: 4)
    }
    if !self.unsignedTransaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.unsignedTransaction, fieldNumber: 5)
    }
    if self.signRequestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.signRequestID, fieldNumber: 6)
    }
    if self.noBroadcast != false {
      try visitor.visitSingularBoolField(value: self.noBroadcast, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_SignTransactionRequest, rhs: Zrchain_Treasury_SignTransactionRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.walletType != rhs.walletType {return false}
    if lhs.unsignedTransaction != rhs.unsignedTransaction {return false}
    if lhs.signRequestID != rhs.signRequestID {return false}
    if lhs.noBroadcast != rhs.noBroadcast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_SignReqResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignReqResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "creator"),
    3: .standard(proto: "key_ids"),
    4: .standard(proto: "key_type"),
    5: .standard(proto: "data_for_signing"),
    6: .same(proto: "status"),
    7: .standard(proto: "signed_data"),
    8: .standard(proto: "keyring_party_signatures"),
    9: .standard(proto: "reject_reason"),
    10: .same(proto: "metadata"),
    11: .standard(proto: "parent_req_id"),
    12: .standard(proto: "child_req_ids"),
    13: .standard(proto: "cache_id"),
    14: .standard(proto: "mpc_btl"),
    15: .same(proto: "fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 3: try { try decoder.decodeRepeatedUInt64Field(value: &self.keyIds) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.keyType) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.dataForSigning) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.signedData) }()
      case 8: try { try decoder.decodeRepeatedBytesField(value: &self.keyringPartySignatures) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.rejectReason) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.parentReqID) }()
      case 12: try { try decoder.decodeRepeatedUInt64Field(value: &self.childReqIds) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self.cacheID) }()
      case 14: try { try decoder.decodeSingularUInt64Field(value: &self.mpcBtl) }()
      case 15: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 2)
    }
    if !self.keyIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.keyIds, fieldNumber: 3)
    }
    if !self.keyType.isEmpty {
      try visitor.visitSingularStringField(value: self.keyType, fieldNumber: 4)
    }
    if !self.dataForSigning.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.dataForSigning, fieldNumber: 5)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 6)
    }
    if !self.signedData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signedData, fieldNumber: 7)
    }
    if !self.keyringPartySignatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.keyringPartySignatures, fieldNumber: 8)
    }
    if !self.rejectReason.isEmpty {
      try visitor.visitSingularStringField(value: self.rejectReason, fieldNumber: 9)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if self.parentReqID != 0 {
      try visitor.visitSingularUInt64Field(value: self.parentReqID, fieldNumber: 11)
    }
    if !self.childReqIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.childReqIds, fieldNumber: 12)
    }
    if !self.cacheID.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheID, fieldNumber: 13)
    }
    if self.mpcBtl != 0 {
      try visitor.visitSingularUInt64Field(value: self.mpcBtl, fieldNumber: 14)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_SignReqResponse, rhs: Zrchain_Treasury_SignReqResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.keyIds != rhs.keyIds {return false}
    if lhs.keyType != rhs.keyType {return false}
    if lhs.dataForSigning != rhs.dataForSigning {return false}
    if lhs.status != rhs.status {return false}
    if lhs.signedData != rhs.signedData {return false}
    if lhs.keyringPartySignatures != rhs.keyringPartySignatures {return false}
    if lhs.rejectReason != rhs.rejectReason {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.parentReqID != rhs.parentReqID {return false}
    if lhs.childReqIds != rhs.childReqIds {return false}
    if lhs.cacheID != rhs.cacheID {return false}
    if lhs.mpcBtl != rhs.mpcBtl {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_SignTxReqResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignTxReqResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "creator"),
    3: .standard(proto: "key_id"),
    4: .standard(proto: "wallet_type"),
    5: .standard(proto: "unsigned_transaction"),
    6: .standard(proto: "sign_request_id"),
    7: .standard(proto: "no_broadcast"),
    8: .standard(proto: "mpc_btl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.keyID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.walletType) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.unsignedTransaction) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.signRequestID) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.noBroadcast) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.mpcBtl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 2)
    }
    if self.keyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.keyID, fieldNumber: 3)
    }
    if !self.walletType.isEmpty {
      try visitor.visitSingularStringField(value: self.walletType, fieldNumber: 4)
    }
    if !self.unsignedTransaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.unsignedTransaction, fieldNumber: 5)
    }
    if self.signRequestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.signRequestID, fieldNumber: 6)
    }
    if self.noBroadcast != false {
      try visitor.visitSingularBoolField(value: self.noBroadcast, fieldNumber: 7)
    }
    if self.mpcBtl != 0 {
      try visitor.visitSingularUInt64Field(value: self.mpcBtl, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_SignTxReqResponse, rhs: Zrchain_Treasury_SignTxReqResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.walletType != rhs.walletType {return false}
    if lhs.unsignedTransaction != rhs.unsignedTransaction {return false}
    if lhs.signRequestID != rhs.signRequestID {return false}
    if lhs.noBroadcast != rhs.noBroadcast {return false}
    if lhs.mpcBtl != rhs.mpcBtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_ICATransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ICATransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "creator"),
    3: .standard(proto: "key_id"),
    4: .standard(proto: "key_type"),
    5: .standard(proto: "input_msg"),
    6: .same(proto: "status"),
    7: .standard(proto: "signed_data"),
    8: .standard(proto: "keyring_party_signatures"),
    9: .standard(proto: "reject_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.keyID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.keyType) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.inputMsg) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 7: try { try decoder.decodeRepeatedBytesField(value: &self.signedData) }()
      case 8: try { try decoder.decodeRepeatedBytesField(value: &self.keyringPartySignatures) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.rejectReason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 2)
    }
    if self.keyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.keyID, fieldNumber: 3)
    }
    if self.keyType != .unspecified {
      try visitor.visitSingularEnumField(value: self.keyType, fieldNumber: 4)
    }
    if !self.inputMsg.isEmpty {
      try visitor.visitSingularBytesField(value: self.inputMsg, fieldNumber: 5)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 6)
    }
    if !self.signedData.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.signedData, fieldNumber: 7)
    }
    if !self.keyringPartySignatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.keyringPartySignatures, fieldNumber: 8)
    }
    if !self.rejectReason.isEmpty {
      try visitor.visitSingularStringField(value: self.rejectReason, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_ICATransactionRequest, rhs: Zrchain_Treasury_ICATransactionRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.keyType != rhs.keyType {return false}
    if lhs.inputMsg != rhs.inputMsg {return false}
    if lhs.status != rhs.status {return false}
    if lhs.signedData != rhs.signedData {return false}
    if lhs.keyringPartySignatures != rhs.keyringPartySignatures {return false}
    if lhs.rejectReason != rhs.rejectReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
