// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: injective/exchange/v1beta1/events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Injective_Exchange_V1beta1_EventBatchSpotExecution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var isBuy: Bool = false

  var executionType: Injective_Exchange_V1beta1_ExecutionType = .unspecifiedExecutionType

  var trades: [Injective_Exchange_V1beta1_TradeLog] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventBatchDerivativeExecution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var isBuy: Bool = false

  var isLiquidation: Bool = false

  /// nil for time expiry futures
  var cumulativeFunding: String = String()

  var executionType: Injective_Exchange_V1beta1_ExecutionType = .unspecifiedExecutionType

  var trades: [Injective_Exchange_V1beta1_DerivativeTradeLog] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventLostFundsFromLiquidation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var subaccountID: Data = Data()

  var lostFundsFromAvailableDuringPayout: String = String()

  var lostFundsFromOrderCancels: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventBatchDerivativePosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var positions: [Injective_Exchange_V1beta1_SubaccountPosition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventDerivativeMarketPaused {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var settlePrice: String = String()

  var totalMissingFunds: String = String()

  var missingFundsRate: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventMarketBeyondBankruptcy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var settlePrice: String = String()

  var missingMarketFunds: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventAllPositionsHaircut {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var settlePrice: String = String()

  var missingFundsRate: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventBinaryOptionsMarketUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var market: Injective_Exchange_V1beta1_BinaryOptionsMarket {
    get {return _market ?? Injective_Exchange_V1beta1_BinaryOptionsMarket()}
    set {_market = newValue}
  }
  /// Returns true if `market` has been explicitly set.
  var hasMarket: Bool {return self._market != nil}
  /// Clears the value of `market`. Subsequent reads from it will return its default value.
  mutating func clearMarket() {self._market = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _market: Injective_Exchange_V1beta1_BinaryOptionsMarket? = nil
}

struct Injective_Exchange_V1beta1_EventNewSpotOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var buyOrders: [Injective_Exchange_V1beta1_SpotLimitOrder] = []

  var sellOrders: [Injective_Exchange_V1beta1_SpotLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventNewDerivativeOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var buyOrders: [Injective_Exchange_V1beta1_DerivativeLimitOrder] = []

  var sellOrders: [Injective_Exchange_V1beta1_DerivativeLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventCancelSpotOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var order: Injective_Exchange_V1beta1_SpotLimitOrder {
    get {return _order ?? Injective_Exchange_V1beta1_SpotLimitOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_SpotLimitOrder? = nil
}

struct Injective_Exchange_V1beta1_EventSpotMarketUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var market: Injective_Exchange_V1beta1_SpotMarket {
    get {return _market ?? Injective_Exchange_V1beta1_SpotMarket()}
    set {_market = newValue}
  }
  /// Returns true if `market` has been explicitly set.
  var hasMarket: Bool {return self._market != nil}
  /// Clears the value of `market`. Subsequent reads from it will return its default value.
  mutating func clearMarket() {self._market = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _market: Injective_Exchange_V1beta1_SpotMarket? = nil
}

struct Injective_Exchange_V1beta1_EventPerpetualMarketUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var market: Injective_Exchange_V1beta1_DerivativeMarket {
    get {return _storage._market ?? Injective_Exchange_V1beta1_DerivativeMarket()}
    set {_uniqueStorage()._market = newValue}
  }
  /// Returns true if `market` has been explicitly set.
  var hasMarket: Bool {return _storage._market != nil}
  /// Clears the value of `market`. Subsequent reads from it will return its default value.
  mutating func clearMarket() {_uniqueStorage()._market = nil}

  var perpetualMarketInfo: Injective_Exchange_V1beta1_PerpetualMarketInfo {
    get {return _storage._perpetualMarketInfo ?? Injective_Exchange_V1beta1_PerpetualMarketInfo()}
    set {_uniqueStorage()._perpetualMarketInfo = newValue}
  }
  /// Returns true if `perpetualMarketInfo` has been explicitly set.
  var hasPerpetualMarketInfo: Bool {return _storage._perpetualMarketInfo != nil}
  /// Clears the value of `perpetualMarketInfo`. Subsequent reads from it will return its default value.
  mutating func clearPerpetualMarketInfo() {_uniqueStorage()._perpetualMarketInfo = nil}

  var funding: Injective_Exchange_V1beta1_PerpetualMarketFunding {
    get {return _storage._funding ?? Injective_Exchange_V1beta1_PerpetualMarketFunding()}
    set {_uniqueStorage()._funding = newValue}
  }
  /// Returns true if `funding` has been explicitly set.
  var hasFunding: Bool {return _storage._funding != nil}
  /// Clears the value of `funding`. Subsequent reads from it will return its default value.
  mutating func clearFunding() {_uniqueStorage()._funding = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_EventExpiryFuturesMarketUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var market: Injective_Exchange_V1beta1_DerivativeMarket {
    get {return _storage._market ?? Injective_Exchange_V1beta1_DerivativeMarket()}
    set {_uniqueStorage()._market = newValue}
  }
  /// Returns true if `market` has been explicitly set.
  var hasMarket: Bool {return _storage._market != nil}
  /// Clears the value of `market`. Subsequent reads from it will return its default value.
  mutating func clearMarket() {_uniqueStorage()._market = nil}

  var expiryFuturesMarketInfo: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo {
    get {return _storage._expiryFuturesMarketInfo ?? Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo()}
    set {_uniqueStorage()._expiryFuturesMarketInfo = newValue}
  }
  /// Returns true if `expiryFuturesMarketInfo` has been explicitly set.
  var hasExpiryFuturesMarketInfo: Bool {return _storage._expiryFuturesMarketInfo != nil}
  /// Clears the value of `expiryFuturesMarketInfo`. Subsequent reads from it will return its default value.
  mutating func clearExpiryFuturesMarketInfo() {_uniqueStorage()._expiryFuturesMarketInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_EventPerpetualMarketFundingUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var funding: Injective_Exchange_V1beta1_PerpetualMarketFunding {
    get {return _funding ?? Injective_Exchange_V1beta1_PerpetualMarketFunding()}
    set {_funding = newValue}
  }
  /// Returns true if `funding` has been explicitly set.
  var hasFunding: Bool {return self._funding != nil}
  /// Clears the value of `funding`. Subsequent reads from it will return its default value.
  mutating func clearFunding() {self._funding = nil}

  var isHourlyFunding: Bool = false

  var fundingRate: String = String()

  var markPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _funding: Injective_Exchange_V1beta1_PerpetualMarketFunding? = nil
}

struct Injective_Exchange_V1beta1_EventSubaccountDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var srcAddress: String = String()

  var subaccountID: Data = Data()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Injective_Exchange_V1beta1_EventSubaccountWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: Data = Data()

  var dstAddress: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Injective_Exchange_V1beta1_EventSubaccountBalanceTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var srcSubaccountID: String = String()

  var dstSubaccountID: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Injective_Exchange_V1beta1_EventBatchDepositUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var depositUpdates: [Injective_Exchange_V1beta1_DepositUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_DerivativeMarketOrderCancel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketOrder: Injective_Exchange_V1beta1_DerivativeMarketOrder {
    get {return _marketOrder ?? Injective_Exchange_V1beta1_DerivativeMarketOrder()}
    set {_marketOrder = newValue}
  }
  /// Returns true if `marketOrder` has been explicitly set.
  var hasMarketOrder: Bool {return self._marketOrder != nil}
  /// Clears the value of `marketOrder`. Subsequent reads from it will return its default value.
  mutating func clearMarketOrder() {self._marketOrder = nil}

  var cancelQuantity: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _marketOrder: Injective_Exchange_V1beta1_DerivativeMarketOrder? = nil
}

struct Injective_Exchange_V1beta1_EventCancelDerivativeOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String {
    get {return _storage._marketID}
    set {_uniqueStorage()._marketID = newValue}
  }

  var isLimitCancel: Bool {
    get {return _storage._isLimitCancel}
    set {_uniqueStorage()._isLimitCancel = newValue}
  }

  var limitOrder: Injective_Exchange_V1beta1_DerivativeLimitOrder {
    get {return _storage._limitOrder ?? Injective_Exchange_V1beta1_DerivativeLimitOrder()}
    set {_uniqueStorage()._limitOrder = newValue}
  }
  /// Returns true if `limitOrder` has been explicitly set.
  var hasLimitOrder: Bool {return _storage._limitOrder != nil}
  /// Clears the value of `limitOrder`. Subsequent reads from it will return its default value.
  mutating func clearLimitOrder() {_uniqueStorage()._limitOrder = nil}

  var marketOrderCancel: Injective_Exchange_V1beta1_DerivativeMarketOrderCancel {
    get {return _storage._marketOrderCancel ?? Injective_Exchange_V1beta1_DerivativeMarketOrderCancel()}
    set {_uniqueStorage()._marketOrderCancel = newValue}
  }
  /// Returns true if `marketOrderCancel` has been explicitly set.
  var hasMarketOrderCancel: Bool {return _storage._marketOrderCancel != nil}
  /// Clears the value of `marketOrderCancel`. Subsequent reads from it will return its default value.
  mutating func clearMarketOrderCancel() {_uniqueStorage()._marketOrderCancel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_EventFeeDiscountSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var schedule: Injective_Exchange_V1beta1_FeeDiscountSchedule {
    get {return _schedule ?? Injective_Exchange_V1beta1_FeeDiscountSchedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  mutating func clearSchedule() {self._schedule = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _schedule: Injective_Exchange_V1beta1_FeeDiscountSchedule? = nil
}

struct Injective_Exchange_V1beta1_EventTradingRewardCampaignUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var campaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo {
    get {return _campaignInfo ?? Injective_Exchange_V1beta1_TradingRewardCampaignInfo()}
    set {_campaignInfo = newValue}
  }
  /// Returns true if `campaignInfo` has been explicitly set.
  var hasCampaignInfo: Bool {return self._campaignInfo != nil}
  /// Clears the value of `campaignInfo`. Subsequent reads from it will return its default value.
  mutating func clearCampaignInfo() {self._campaignInfo = nil}

  var campaignRewardPools: [Injective_Exchange_V1beta1_CampaignRewardPool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _campaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo? = nil
}

struct Injective_Exchange_V1beta1_EventTradingRewardDistribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountRewards: [Injective_Exchange_V1beta1_AccountRewards] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventNewConditionalDerivativeOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var order: Injective_Exchange_V1beta1_DerivativeOrder {
    get {return _order ?? Injective_Exchange_V1beta1_DerivativeOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var hash: Data = Data()

  var isMarket: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_DerivativeOrder? = nil
}

struct Injective_Exchange_V1beta1_EventCancelConditionalDerivativeOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String {
    get {return _storage._marketID}
    set {_uniqueStorage()._marketID = newValue}
  }

  var isLimitCancel: Bool {
    get {return _storage._isLimitCancel}
    set {_uniqueStorage()._isLimitCancel = newValue}
  }

  var limitOrder: Injective_Exchange_V1beta1_DerivativeLimitOrder {
    get {return _storage._limitOrder ?? Injective_Exchange_V1beta1_DerivativeLimitOrder()}
    set {_uniqueStorage()._limitOrder = newValue}
  }
  /// Returns true if `limitOrder` has been explicitly set.
  var hasLimitOrder: Bool {return _storage._limitOrder != nil}
  /// Clears the value of `limitOrder`. Subsequent reads from it will return its default value.
  mutating func clearLimitOrder() {_uniqueStorage()._limitOrder = nil}

  var marketOrder: Injective_Exchange_V1beta1_DerivativeMarketOrder {
    get {return _storage._marketOrder ?? Injective_Exchange_V1beta1_DerivativeMarketOrder()}
    set {_uniqueStorage()._marketOrder = newValue}
  }
  /// Returns true if `marketOrder` has been explicitly set.
  var hasMarketOrder: Bool {return _storage._marketOrder != nil}
  /// Clears the value of `marketOrder`. Subsequent reads from it will return its default value.
  mutating func clearMarketOrder() {_uniqueStorage()._marketOrder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_EventConditionalDerivativeOrderTrigger {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: Data = Data()

  var isLimitTrigger: Bool = false

  var triggeredOrderHash: Data = Data()

  var placedOrderHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventOrderFail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: Data = Data()

  var hashes: [Data] = []

  var flags: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventAtomicMarketOrderFeeMultipliersUpdated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketFeeMultipliers: [Injective_Exchange_V1beta1_MarketFeeMultiplier] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventOrderbookUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var spotUpdates: [Injective_Exchange_V1beta1_OrderbookUpdate] = []

  var derivativeUpdates: [Injective_Exchange_V1beta1_OrderbookUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_OrderbookUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var seq: UInt64 = 0

  var orderbook: Injective_Exchange_V1beta1_Orderbook {
    get {return _orderbook ?? Injective_Exchange_V1beta1_Orderbook()}
    set {_orderbook = newValue}
  }
  /// Returns true if `orderbook` has been explicitly set.
  var hasOrderbook: Bool {return self._orderbook != nil}
  /// Clears the value of `orderbook`. Subsequent reads from it will return its default value.
  mutating func clearOrderbook() {self._orderbook = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _orderbook: Injective_Exchange_V1beta1_Orderbook? = nil
}

struct Injective_Exchange_V1beta1_Orderbook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: Data = Data()

  var buyLevels: [Injective_Exchange_V1beta1_Level] = []

  var sellLevels: [Injective_Exchange_V1beta1_Level] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Injective_Exchange_V1beta1_EventBatchSpotExecution: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventBatchDerivativeExecution: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventLostFundsFromLiquidation: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventBatchDerivativePosition: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventDerivativeMarketPaused: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventMarketBeyondBankruptcy: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventAllPositionsHaircut: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventBinaryOptionsMarketUpdate: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventNewSpotOrders: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventNewDerivativeOrders: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventCancelSpotOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventSpotMarketUpdate: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventPerpetualMarketUpdate: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventExpiryFuturesMarketUpdate: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventPerpetualMarketFundingUpdate: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventSubaccountDeposit: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventSubaccountWithdraw: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventSubaccountBalanceTransfer: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventBatchDepositUpdate: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_DerivativeMarketOrderCancel: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventCancelDerivativeOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventFeeDiscountSchedule: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventTradingRewardCampaignUpdate: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventTradingRewardDistribution: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventNewConditionalDerivativeOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventCancelConditionalDerivativeOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventConditionalDerivativeOrderTrigger: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventOrderFail: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventAtomicMarketOrderFeeMultipliersUpdated: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EventOrderbookUpdate: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_OrderbookUpdate: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_Orderbook: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "injective.exchange.v1beta1"

extension Injective_Exchange_V1beta1_EventBatchSpotExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBatchSpotExecution"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "is_buy"),
    3: .same(proto: "executionType"),
    4: .same(proto: "trades"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isBuy) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.executionType) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.trades) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.isBuy != false {
      try visitor.visitSingularBoolField(value: self.isBuy, fieldNumber: 2)
    }
    if self.executionType != .unspecifiedExecutionType {
      try visitor.visitSingularEnumField(value: self.executionType, fieldNumber: 3)
    }
    if !self.trades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trades, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventBatchSpotExecution, rhs: Injective_Exchange_V1beta1_EventBatchSpotExecution) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.isBuy != rhs.isBuy {return false}
    if lhs.executionType != rhs.executionType {return false}
    if lhs.trades != rhs.trades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventBatchDerivativeExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBatchDerivativeExecution"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "is_buy"),
    3: .standard(proto: "is_liquidation"),
    4: .standard(proto: "cumulative_funding"),
    5: .same(proto: "executionType"),
    6: .same(proto: "trades"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isBuy) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isLiquidation) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cumulativeFunding) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.executionType) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.trades) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.isBuy != false {
      try visitor.visitSingularBoolField(value: self.isBuy, fieldNumber: 2)
    }
    if self.isLiquidation != false {
      try visitor.visitSingularBoolField(value: self.isLiquidation, fieldNumber: 3)
    }
    if !self.cumulativeFunding.isEmpty {
      try visitor.visitSingularStringField(value: self.cumulativeFunding, fieldNumber: 4)
    }
    if self.executionType != .unspecifiedExecutionType {
      try visitor.visitSingularEnumField(value: self.executionType, fieldNumber: 5)
    }
    if !self.trades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trades, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventBatchDerivativeExecution, rhs: Injective_Exchange_V1beta1_EventBatchDerivativeExecution) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.isBuy != rhs.isBuy {return false}
    if lhs.isLiquidation != rhs.isLiquidation {return false}
    if lhs.cumulativeFunding != rhs.cumulativeFunding {return false}
    if lhs.executionType != rhs.executionType {return false}
    if lhs.trades != rhs.trades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventLostFundsFromLiquidation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventLostFundsFromLiquidation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "subaccount_id"),
    3: .standard(proto: "lost_funds_from_available_during_payout"),
    4: .standard(proto: "lost_funds_from_order_cancels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lostFundsFromAvailableDuringPayout) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.lostFundsFromOrderCancels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subaccountID, fieldNumber: 2)
    }
    if !self.lostFundsFromAvailableDuringPayout.isEmpty {
      try visitor.visitSingularStringField(value: self.lostFundsFromAvailableDuringPayout, fieldNumber: 3)
    }
    if !self.lostFundsFromOrderCancels.isEmpty {
      try visitor.visitSingularStringField(value: self.lostFundsFromOrderCancels, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventLostFundsFromLiquidation, rhs: Injective_Exchange_V1beta1_EventLostFundsFromLiquidation) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.lostFundsFromAvailableDuringPayout != rhs.lostFundsFromAvailableDuringPayout {return false}
    if lhs.lostFundsFromOrderCancels != rhs.lostFundsFromOrderCancels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventBatchDerivativePosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBatchDerivativePosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "positions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.positions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.positions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventBatchDerivativePosition, rhs: Injective_Exchange_V1beta1_EventBatchDerivativePosition) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.positions != rhs.positions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventDerivativeMarketPaused: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventDerivativeMarketPaused"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "settle_price"),
    3: .standard(proto: "total_missing_funds"),
    4: .standard(proto: "missing_funds_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.settlePrice) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.totalMissingFunds) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.missingFundsRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.settlePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.settlePrice, fieldNumber: 2)
    }
    if !self.totalMissingFunds.isEmpty {
      try visitor.visitSingularStringField(value: self.totalMissingFunds, fieldNumber: 3)
    }
    if !self.missingFundsRate.isEmpty {
      try visitor.visitSingularStringField(value: self.missingFundsRate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventDerivativeMarketPaused, rhs: Injective_Exchange_V1beta1_EventDerivativeMarketPaused) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.settlePrice != rhs.settlePrice {return false}
    if lhs.totalMissingFunds != rhs.totalMissingFunds {return false}
    if lhs.missingFundsRate != rhs.missingFundsRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventMarketBeyondBankruptcy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarketBeyondBankruptcy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "settle_price"),
    3: .standard(proto: "missing_market_funds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.settlePrice) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.missingMarketFunds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.settlePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.settlePrice, fieldNumber: 2)
    }
    if !self.missingMarketFunds.isEmpty {
      try visitor.visitSingularStringField(value: self.missingMarketFunds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventMarketBeyondBankruptcy, rhs: Injective_Exchange_V1beta1_EventMarketBeyondBankruptcy) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.settlePrice != rhs.settlePrice {return false}
    if lhs.missingMarketFunds != rhs.missingMarketFunds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventAllPositionsHaircut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventAllPositionsHaircut"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "settle_price"),
    3: .standard(proto: "missing_funds_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.settlePrice) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.missingFundsRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.settlePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.settlePrice, fieldNumber: 2)
    }
    if !self.missingFundsRate.isEmpty {
      try visitor.visitSingularStringField(value: self.missingFundsRate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventAllPositionsHaircut, rhs: Injective_Exchange_V1beta1_EventAllPositionsHaircut) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.settlePrice != rhs.settlePrice {return false}
    if lhs.missingFundsRate != rhs.missingFundsRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventBinaryOptionsMarketUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBinaryOptionsMarketUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "market"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._market) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._market {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventBinaryOptionsMarketUpdate, rhs: Injective_Exchange_V1beta1_EventBinaryOptionsMarketUpdate) -> Bool {
    if lhs._market != rhs._market {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventNewSpotOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventNewSpotOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "buy_orders"),
    3: .standard(proto: "sell_orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.buyOrders) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sellOrders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.buyOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buyOrders, fieldNumber: 2)
    }
    if !self.sellOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sellOrders, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventNewSpotOrders, rhs: Injective_Exchange_V1beta1_EventNewSpotOrders) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.buyOrders != rhs.buyOrders {return false}
    if lhs.sellOrders != rhs.sellOrders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventNewDerivativeOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventNewDerivativeOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "buy_orders"),
    3: .standard(proto: "sell_orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.buyOrders) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sellOrders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.buyOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buyOrders, fieldNumber: 2)
    }
    if !self.sellOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sellOrders, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventNewDerivativeOrders, rhs: Injective_Exchange_V1beta1_EventNewDerivativeOrders) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.buyOrders != rhs.buyOrders {return false}
    if lhs.sellOrders != rhs.sellOrders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventCancelSpotOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCancelSpotOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try { if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventCancelSpotOrder, rhs: Injective_Exchange_V1beta1_EventCancelSpotOrder) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventSpotMarketUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSpotMarketUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "market"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._market) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._market {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventSpotMarketUpdate, rhs: Injective_Exchange_V1beta1_EventSpotMarketUpdate) -> Bool {
    if lhs._market != rhs._market {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventPerpetualMarketUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventPerpetualMarketUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "market"),
    2: .standard(proto: "perpetual_market_info"),
    3: .same(proto: "funding"),
  ]

  fileprivate class _StorageClass {
    var _market: Injective_Exchange_V1beta1_DerivativeMarket? = nil
    var _perpetualMarketInfo: Injective_Exchange_V1beta1_PerpetualMarketInfo? = nil
    var _funding: Injective_Exchange_V1beta1_PerpetualMarketFunding? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _market = source._market
      _perpetualMarketInfo = source._perpetualMarketInfo
      _funding = source._funding
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._market) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._perpetualMarketInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._funding) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._market {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._perpetualMarketInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._funding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventPerpetualMarketUpdate, rhs: Injective_Exchange_V1beta1_EventPerpetualMarketUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._market != rhs_storage._market {return false}
        if _storage._perpetualMarketInfo != rhs_storage._perpetualMarketInfo {return false}
        if _storage._funding != rhs_storage._funding {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventExpiryFuturesMarketUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventExpiryFuturesMarketUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "market"),
    3: .standard(proto: "expiry_futures_market_info"),
  ]

  fileprivate class _StorageClass {
    var _market: Injective_Exchange_V1beta1_DerivativeMarket? = nil
    var _expiryFuturesMarketInfo: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _market = source._market
      _expiryFuturesMarketInfo = source._expiryFuturesMarketInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._market) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._expiryFuturesMarketInfo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._market {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._expiryFuturesMarketInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventExpiryFuturesMarketUpdate, rhs: Injective_Exchange_V1beta1_EventExpiryFuturesMarketUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._market != rhs_storage._market {return false}
        if _storage._expiryFuturesMarketInfo != rhs_storage._expiryFuturesMarketInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventPerpetualMarketFundingUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventPerpetualMarketFundingUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "funding"),
    3: .standard(proto: "is_hourly_funding"),
    4: .standard(proto: "funding_rate"),
    5: .standard(proto: "mark_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._funding) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isHourlyFunding) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fundingRate) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.markPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try { if let v = self._funding {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isHourlyFunding != false {
      try visitor.visitSingularBoolField(value: self.isHourlyFunding, fieldNumber: 3)
    }
    if !self.fundingRate.isEmpty {
      try visitor.visitSingularStringField(value: self.fundingRate, fieldNumber: 4)
    }
    if !self.markPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.markPrice, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventPerpetualMarketFundingUpdate, rhs: Injective_Exchange_V1beta1_EventPerpetualMarketFundingUpdate) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._funding != rhs._funding {return false}
    if lhs.isHourlyFunding != rhs.isHourlyFunding {return false}
    if lhs.fundingRate != rhs.fundingRate {return false}
    if lhs.markPrice != rhs.markPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventSubaccountDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSubaccountDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "src_address"),
    2: .standard(proto: "subaccount_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.srcAddress) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.srcAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.srcAddress, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subaccountID, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventSubaccountDeposit, rhs: Injective_Exchange_V1beta1_EventSubaccountDeposit) -> Bool {
    if lhs.srcAddress != rhs.srcAddress {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventSubaccountWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSubaccountWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "dst_address"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dstAddress) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.dstAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.dstAddress, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventSubaccountWithdraw, rhs: Injective_Exchange_V1beta1_EventSubaccountWithdraw) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.dstAddress != rhs.dstAddress {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventSubaccountBalanceTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSubaccountBalanceTransfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "src_subaccount_id"),
    2: .standard(proto: "dst_subaccount_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.srcSubaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dstSubaccountID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.srcSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.srcSubaccountID, fieldNumber: 1)
    }
    if !self.dstSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.dstSubaccountID, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventSubaccountBalanceTransfer, rhs: Injective_Exchange_V1beta1_EventSubaccountBalanceTransfer) -> Bool {
    if lhs.srcSubaccountID != rhs.srcSubaccountID {return false}
    if lhs.dstSubaccountID != rhs.dstSubaccountID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventBatchDepositUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBatchDepositUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deposit_updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.depositUpdates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.depositUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.depositUpdates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventBatchDepositUpdate, rhs: Injective_Exchange_V1beta1_EventBatchDepositUpdate) -> Bool {
    if lhs.depositUpdates != rhs.depositUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeMarketOrderCancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeMarketOrderCancel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_order"),
    2: .standard(proto: "cancel_quantity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._marketOrder) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cancelQuantity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._marketOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.cancelQuantity.isEmpty {
      try visitor.visitSingularStringField(value: self.cancelQuantity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeMarketOrderCancel, rhs: Injective_Exchange_V1beta1_DerivativeMarketOrderCancel) -> Bool {
    if lhs._marketOrder != rhs._marketOrder {return false}
    if lhs.cancelQuantity != rhs.cancelQuantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventCancelDerivativeOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCancelDerivativeOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "isLimitCancel"),
    3: .standard(proto: "limit_order"),
    4: .standard(proto: "market_order_cancel"),
  ]

  fileprivate class _StorageClass {
    var _marketID: String = String()
    var _isLimitCancel: Bool = false
    var _limitOrder: Injective_Exchange_V1beta1_DerivativeLimitOrder? = nil
    var _marketOrderCancel: Injective_Exchange_V1beta1_DerivativeMarketOrderCancel? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _marketID = source._marketID
      _isLimitCancel = source._isLimitCancel
      _limitOrder = source._limitOrder
      _marketOrderCancel = source._marketOrderCancel
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._marketID) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._isLimitCancel) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._limitOrder) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._marketOrderCancel) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._marketID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._marketID, fieldNumber: 1)
      }
      if _storage._isLimitCancel != false {
        try visitor.visitSingularBoolField(value: _storage._isLimitCancel, fieldNumber: 2)
      }
      try { if let v = _storage._limitOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._marketOrderCancel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventCancelDerivativeOrder, rhs: Injective_Exchange_V1beta1_EventCancelDerivativeOrder) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._marketID != rhs_storage._marketID {return false}
        if _storage._isLimitCancel != rhs_storage._isLimitCancel {return false}
        if _storage._limitOrder != rhs_storage._limitOrder {return false}
        if _storage._marketOrderCancel != rhs_storage._marketOrderCancel {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventFeeDiscountSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventFeeDiscountSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "schedule"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventFeeDiscountSchedule, rhs: Injective_Exchange_V1beta1_EventFeeDiscountSchedule) -> Bool {
    if lhs._schedule != rhs._schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventTradingRewardCampaignUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTradingRewardCampaignUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "campaign_info"),
    2: .standard(proto: "campaign_reward_pools"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._campaignInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.campaignRewardPools) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._campaignInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.campaignRewardPools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.campaignRewardPools, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventTradingRewardCampaignUpdate, rhs: Injective_Exchange_V1beta1_EventTradingRewardCampaignUpdate) -> Bool {
    if lhs._campaignInfo != rhs._campaignInfo {return false}
    if lhs.campaignRewardPools != rhs.campaignRewardPools {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventTradingRewardDistribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTradingRewardDistribution"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_rewards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accountRewards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountRewards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountRewards, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventTradingRewardDistribution, rhs: Injective_Exchange_V1beta1_EventTradingRewardDistribution) -> Bool {
    if lhs.accountRewards != rhs.accountRewards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventNewConditionalDerivativeOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventNewConditionalDerivativeOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "order"),
    3: .same(proto: "hash"),
    4: .standard(proto: "is_market"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isMarket) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try { if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 3)
    }
    if self.isMarket != false {
      try visitor.visitSingularBoolField(value: self.isMarket, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventNewConditionalDerivativeOrder, rhs: Injective_Exchange_V1beta1_EventNewConditionalDerivativeOrder) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._order != rhs._order {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.isMarket != rhs.isMarket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventCancelConditionalDerivativeOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCancelConditionalDerivativeOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "isLimitCancel"),
    3: .standard(proto: "limit_order"),
    4: .standard(proto: "market_order"),
  ]

  fileprivate class _StorageClass {
    var _marketID: String = String()
    var _isLimitCancel: Bool = false
    var _limitOrder: Injective_Exchange_V1beta1_DerivativeLimitOrder? = nil
    var _marketOrder: Injective_Exchange_V1beta1_DerivativeMarketOrder? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _marketID = source._marketID
      _isLimitCancel = source._isLimitCancel
      _limitOrder = source._limitOrder
      _marketOrder = source._marketOrder
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._marketID) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._isLimitCancel) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._limitOrder) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._marketOrder) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._marketID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._marketID, fieldNumber: 1)
      }
      if _storage._isLimitCancel != false {
        try visitor.visitSingularBoolField(value: _storage._isLimitCancel, fieldNumber: 2)
      }
      try { if let v = _storage._limitOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._marketOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventCancelConditionalDerivativeOrder, rhs: Injective_Exchange_V1beta1_EventCancelConditionalDerivativeOrder) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._marketID != rhs_storage._marketID {return false}
        if _storage._isLimitCancel != rhs_storage._isLimitCancel {return false}
        if _storage._limitOrder != rhs_storage._limitOrder {return false}
        if _storage._marketOrder != rhs_storage._marketOrder {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventConditionalDerivativeOrderTrigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventConditionalDerivativeOrderTrigger"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "isLimitTrigger"),
    3: .standard(proto: "triggered_order_hash"),
    4: .standard(proto: "placed_order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isLimitTrigger) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.triggeredOrderHash) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.placedOrderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularBytesField(value: self.marketID, fieldNumber: 1)
    }
    if self.isLimitTrigger != false {
      try visitor.visitSingularBoolField(value: self.isLimitTrigger, fieldNumber: 2)
    }
    if !self.triggeredOrderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.triggeredOrderHash, fieldNumber: 3)
    }
    if !self.placedOrderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.placedOrderHash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventConditionalDerivativeOrderTrigger, rhs: Injective_Exchange_V1beta1_EventConditionalDerivativeOrderTrigger) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.isLimitTrigger != rhs.isLimitTrigger {return false}
    if lhs.triggeredOrderHash != rhs.triggeredOrderHash {return false}
    if lhs.placedOrderHash != rhs.placedOrderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventOrderFail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventOrderFail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "hashes"),
    3: .same(proto: "flags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.account) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.hashes) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.flags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularBytesField(value: self.account, fieldNumber: 1)
    }
    if !self.hashes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.hashes, fieldNumber: 2)
    }
    if !self.flags.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.flags, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventOrderFail, rhs: Injective_Exchange_V1beta1_EventOrderFail) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.hashes != rhs.hashes {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventAtomicMarketOrderFeeMultipliersUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventAtomicMarketOrderFeeMultipliersUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_fee_multipliers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.marketFeeMultipliers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketFeeMultipliers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.marketFeeMultipliers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventAtomicMarketOrderFeeMultipliersUpdated, rhs: Injective_Exchange_V1beta1_EventAtomicMarketOrderFeeMultipliersUpdated) -> Bool {
    if lhs.marketFeeMultipliers != rhs.marketFeeMultipliers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventOrderbookUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventOrderbookUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "spot_updates"),
    2: .standard(proto: "derivative_updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.spotUpdates) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.derivativeUpdates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spotUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spotUpdates, fieldNumber: 1)
    }
    if !self.derivativeUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.derivativeUpdates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventOrderbookUpdate, rhs: Injective_Exchange_V1beta1_EventOrderbookUpdate) -> Bool {
    if lhs.spotUpdates != rhs.spotUpdates {return false}
    if lhs.derivativeUpdates != rhs.derivativeUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_OrderbookUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderbookUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seq"),
    2: .same(proto: "orderbook"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._orderbook) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt64Field(value: self.seq, fieldNumber: 1)
    }
    try { if let v = self._orderbook {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_OrderbookUpdate, rhs: Injective_Exchange_V1beta1_OrderbookUpdate) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs._orderbook != rhs._orderbook {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_Orderbook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Orderbook"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "buy_levels"),
    3: .standard(proto: "sell_levels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.marketID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.buyLevels) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sellLevels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularBytesField(value: self.marketID, fieldNumber: 1)
    }
    if !self.buyLevels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buyLevels, fieldNumber: 2)
    }
    if !self.sellLevels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sellLevels, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_Orderbook, rhs: Injective_Exchange_V1beta1_Orderbook) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.buyLevels != rhs.buyLevels {return false}
    if lhs.sellLevels != rhs.sellLevels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
