// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: axelar/evm/v1beta1/types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Axelar_Evm_V1beta1_Status: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// these enum values are used for bitwise operations, therefore they need to
  /// be powers of 2
  case unspecified // = 0
  case initialized // = 1
  case pending // = 2
  case confirmed // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .initialized
    case 2: self = .pending
    case 4: self = .confirmed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .initialized: return 1
    case .pending: return 2
    case .confirmed: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Axelar_Evm_V1beta1_Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Axelar_Evm_V1beta1_Status] = [
    .unspecified,
    .initialized,
    .pending,
    .confirmed,
  ]
}

#endif  // swift(>=4.2)

enum Axelar_Evm_V1beta1_CommandType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case mintToken // = 1
  case deployToken // = 2
  case burnToken // = 3
  case transferOperatorship // = 4
  case approveContractCallWithMint // = 5
  case approveContractCall // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .mintToken
    case 2: self = .deployToken
    case 3: self = .burnToken
    case 4: self = .transferOperatorship
    case 5: self = .approveContractCallWithMint
    case 6: self = .approveContractCall
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .mintToken: return 1
    case .deployToken: return 2
    case .burnToken: return 3
    case .transferOperatorship: return 4
    case .approveContractCallWithMint: return 5
    case .approveContractCall: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Axelar_Evm_V1beta1_CommandType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Axelar_Evm_V1beta1_CommandType] = [
    .unspecified,
    .mintToken,
    .deployToken,
    .burnToken,
    .transferOperatorship,
    .approveContractCallWithMint,
    .approveContractCall,
  ]
}

#endif  // swift(>=4.2)

enum Axelar_Evm_V1beta1_BatchedCommandsStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case signing // = 1
  case aborted // = 2
  case signed // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .signing
    case 2: self = .aborted
    case 3: self = .signed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .signing: return 1
    case .aborted: return 2
    case .signed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Axelar_Evm_V1beta1_BatchedCommandsStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Axelar_Evm_V1beta1_BatchedCommandsStatus] = [
    .unspecified,
    .signing,
    .aborted,
    .signed,
  ]
}

#endif  // swift(>=4.2)

enum Axelar_Evm_V1beta1_SigType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case tx // = 1
  case command // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .tx
    case 2: self = .command
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .tx: return 1
    case .command: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Axelar_Evm_V1beta1_SigType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Axelar_Evm_V1beta1_SigType] = [
    .unspecified,
    .tx,
    .command,
  ]
}

#endif  // swift(>=4.2)

enum Axelar_Evm_V1beta1_DepositStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case pending // = 1
  case confirmed // = 2
  case burned // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .pending
    case 2: self = .confirmed
    case 3: self = .burned
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .pending: return 1
    case .confirmed: return 2
    case .burned: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Axelar_Evm_V1beta1_DepositStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Axelar_Evm_V1beta1_DepositStatus] = [
    .unspecified,
    .pending,
    .confirmed,
    .burned,
  ]
}

#endif  // swift(>=4.2)

struct Axelar_Evm_V1beta1_VoteEvents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var events: [Axelar_Evm_V1beta1_Event] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var txID: Data = Data()

  var index: UInt64 = 0

  var status: Axelar_Evm_V1beta1_Event.Status = .unspecified

  var event: Axelar_Evm_V1beta1_Event.OneOf_Event? = nil

  var tokenSent: Axelar_Evm_V1beta1_EventTokenSent {
    get {
      if case .tokenSent(let v)? = event {return v}
      return Axelar_Evm_V1beta1_EventTokenSent()
    }
    set {event = .tokenSent(newValue)}
  }

  var contractCall: Axelar_Evm_V1beta1_EventContractCall {
    get {
      if case .contractCall(let v)? = event {return v}
      return Axelar_Evm_V1beta1_EventContractCall()
    }
    set {event = .contractCall(newValue)}
  }

  var contractCallWithToken: Axelar_Evm_V1beta1_EventContractCallWithToken {
    get {
      if case .contractCallWithToken(let v)? = event {return v}
      return Axelar_Evm_V1beta1_EventContractCallWithToken()
    }
    set {event = .contractCallWithToken(newValue)}
  }

  var transfer: Axelar_Evm_V1beta1_EventTransfer {
    get {
      if case .transfer(let v)? = event {return v}
      return Axelar_Evm_V1beta1_EventTransfer()
    }
    set {event = .transfer(newValue)}
  }

  var tokenDeployed: Axelar_Evm_V1beta1_EventTokenDeployed {
    get {
      if case .tokenDeployed(let v)? = event {return v}
      return Axelar_Evm_V1beta1_EventTokenDeployed()
    }
    set {event = .tokenDeployed(newValue)}
  }

  var multisigOwnershipTransferred: Axelar_Evm_V1beta1_EventMultisigOwnershipTransferred {
    get {
      if case .multisigOwnershipTransferred(let v)? = event {return v}
      return Axelar_Evm_V1beta1_EventMultisigOwnershipTransferred()
    }
    set {event = .multisigOwnershipTransferred(newValue)}
  }

  var multisigOperatorshipTransferred: Axelar_Evm_V1beta1_EventMultisigOperatorshipTransferred {
    get {
      if case .multisigOperatorshipTransferred(let v)? = event {return v}
      return Axelar_Evm_V1beta1_EventMultisigOperatorshipTransferred()
    }
    set {event = .multisigOperatorshipTransferred(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable {
    case tokenSent(Axelar_Evm_V1beta1_EventTokenSent)
    case contractCall(Axelar_Evm_V1beta1_EventContractCall)
    case contractCallWithToken(Axelar_Evm_V1beta1_EventContractCallWithToken)
    case transfer(Axelar_Evm_V1beta1_EventTransfer)
    case tokenDeployed(Axelar_Evm_V1beta1_EventTokenDeployed)
    case multisigOwnershipTransferred(Axelar_Evm_V1beta1_EventMultisigOwnershipTransferred)
    case multisigOperatorshipTransferred(Axelar_Evm_V1beta1_EventMultisigOperatorshipTransferred)

  #if !swift(>=4.1)
    static func ==(lhs: Axelar_Evm_V1beta1_Event.OneOf_Event, rhs: Axelar_Evm_V1beta1_Event.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenSent, .tokenSent): return {
        guard case .tokenSent(let l) = lhs, case .tokenSent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contractCall, .contractCall): return {
        guard case .contractCall(let l) = lhs, case .contractCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contractCallWithToken, .contractCallWithToken): return {
        guard case .contractCallWithToken(let l) = lhs, case .contractCallWithToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transfer, .transfer): return {
        guard case .transfer(let l) = lhs, case .transfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenDeployed, .tokenDeployed): return {
        guard case .tokenDeployed(let l) = lhs, case .tokenDeployed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multisigOwnershipTransferred, .multisigOwnershipTransferred): return {
        guard case .multisigOwnershipTransferred(let l) = lhs, case .multisigOwnershipTransferred(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multisigOperatorshipTransferred, .multisigOperatorshipTransferred): return {
        guard case .multisigOperatorshipTransferred(let l) = lhs, case .multisigOperatorshipTransferred(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case confirmed // = 1
    case completed // = 2
    case failed // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .confirmed
      case 2: self = .completed
      case 3: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .confirmed: return 1
      case .completed: return 2
      case .failed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Axelar_Evm_V1beta1_Event.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Axelar_Evm_V1beta1_Event.Status] = [
    .unspecified,
    .confirmed,
    .completed,
    .failed,
  ]
}

#endif  // swift(>=4.2)

struct Axelar_Evm_V1beta1_EventTokenSent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: Data = Data()

  var destinationChain: String = String()

  var destinationAddress: String = String()

  var symbol: String = String()

  var amount: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_EventContractCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: Data = Data()

  var destinationChain: String = String()

  var contractAddress: String = String()

  var payloadHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_EventContractCallWithToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: Data = Data()

  var destinationChain: String = String()

  var contractAddress: String = String()

  var payloadHash: Data = Data()

  var symbol: String = String()

  var amount: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_EventTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var to: Data = Data()

  var amount: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_EventTokenDeployed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var symbol: String = String()

  var tokenAddress: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_EventMultisigOwnershipTransferred {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var preOwners: [Data] = []

  var prevThreshold: Data = Data()

  var newOwners: [Data] = []

  var newThreshold: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_EventMultisigOperatorshipTransferred {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var newOperators: [Data] = []

  var newThreshold: Data = Data()

  var newWeights: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NetworkInfo describes information about a network
struct Axelar_Evm_V1beta1_NetworkInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var id: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BurnerInfo describes information required to burn token at an burner address
/// that is deposited by an user
struct Axelar_Evm_V1beta1_BurnerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var burnerAddress: Data = Data()

  var tokenAddress: Data = Data()

  var destinationChain: String = String()

  var symbol: String = String()

  var asset: String = String()

  var salt: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ERC20Deposit contains information for an ERC20 deposit
struct Axelar_Evm_V1beta1_ERC20Deposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: Data = Data()

  var amount: Data = Data()

  var asset: String = String()

  var destinationChain: String = String()

  var burnerAddress: Data = Data()

  var logIndex: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ERC20TokenMetadata describes information about an ERC20 token
struct Axelar_Evm_V1beta1_ERC20TokenMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var asset: String = String()

  var chainID: Data = Data()

  var details: Axelar_Evm_V1beta1_TokenDetails {
    get {return _details ?? Axelar_Evm_V1beta1_TokenDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  mutating func clearDetails() {self._details = nil}

  var tokenAddress: String = String()

  var txHash: String = String()

  var status: Axelar_Evm_V1beta1_Status = .unspecified

  var isExternal: Bool = false

  var burnerCode: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _details: Axelar_Evm_V1beta1_TokenDetails? = nil
}

struct Axelar_Evm_V1beta1_TransactionMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rawTx: Data = Data()

  var pubKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var command: String = String()

  var params: Data = Data()

  var keyID: String = String()

  var maxGasCost: UInt32 = 0

  var type: Axelar_Evm_V1beta1_CommandType = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_CommandBatchMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data = Data()

  var commandIds: [Data] = []

  var data: Data = Data()

  var sigHash: Data = Data()

  var status: Axelar_Evm_V1beta1_BatchedCommandsStatus = .unspecified

  var keyID: String = String()

  var prevBatchedCommandsID: Data = Data()

  var signature: SwiftProtobuf.Google_Protobuf_Any {
    get {return _signature ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  mutating func clearSignature() {self._signature = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signature: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// SigMetadata stores necessary information for external apps to map signature
/// results to evm relay transaction types
struct Axelar_Evm_V1beta1_SigMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Axelar_Evm_V1beta1_SigType = .unspecified

  var chain: String = String()

  var commandBatchID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TransferKey contains information for a transfer operatorship
struct Axelar_Evm_V1beta1_TransferKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: Data = Data()

  var nextKeyID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_Asset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_TokenDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenName: String = String()

  var symbol: String = String()

  var decimals: UInt32 = 0

  var capacity: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_Gateway {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_PollMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var txID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Axelar_Evm_V1beta1_Status: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_CommandType: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_BatchedCommandsStatus: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_SigType: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_DepositStatus: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_VoteEvents: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_Event: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_Event.OneOf_Event: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_Event.Status: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_EventTokenSent: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_EventContractCall: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_EventContractCallWithToken: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_EventTransfer: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_EventTokenDeployed: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_EventMultisigOwnershipTransferred: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_EventMultisigOperatorshipTransferred: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_NetworkInfo: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_BurnerInfo: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_ERC20Deposit: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_ERC20TokenMetadata: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_TransactionMetadata: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_Command: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_CommandBatchMetadata: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_SigMetadata: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_TransferKey: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_Asset: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_TokenDetails: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_Gateway: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_PollMetadata: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "axelar.evm.v1beta1"

extension Axelar_Evm_V1beta1_Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "STATUS_INITIALIZED"),
    2: .same(proto: "STATUS_PENDING"),
    4: .same(proto: "STATUS_CONFIRMED"),
  ]
}

extension Axelar_Evm_V1beta1_CommandType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMAND_TYPE_UNSPECIFIED"),
    1: .same(proto: "COMMAND_TYPE_MINT_TOKEN"),
    2: .same(proto: "COMMAND_TYPE_DEPLOY_TOKEN"),
    3: .same(proto: "COMMAND_TYPE_BURN_TOKEN"),
    4: .same(proto: "COMMAND_TYPE_TRANSFER_OPERATORSHIP"),
    5: .same(proto: "COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT"),
    6: .same(proto: "COMMAND_TYPE_APPROVE_CONTRACT_CALL"),
  ]
}

extension Axelar_Evm_V1beta1_BatchedCommandsStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BATCHED_COMMANDS_STATUS_UNSPECIFIED"),
    1: .same(proto: "BATCHED_COMMANDS_STATUS_SIGNING"),
    2: .same(proto: "BATCHED_COMMANDS_STATUS_ABORTED"),
    3: .same(proto: "BATCHED_COMMANDS_STATUS_SIGNED"),
  ]
}

extension Axelar_Evm_V1beta1_SigType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIG_TYPE_UNSPECIFIED"),
    1: .same(proto: "SIG_TYPE_TX"),
    2: .same(proto: "SIG_TYPE_COMMAND"),
  ]
}

extension Axelar_Evm_V1beta1_DepositStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEPOSIT_STATUS_UNSPECIFIED"),
    1: .same(proto: "DEPOSIT_STATUS_PENDING"),
    2: .same(proto: "DEPOSIT_STATUS_CONFIRMED"),
    3: .same(proto: "DEPOSIT_STATUS_BURNED"),
  ]
}

extension Axelar_Evm_V1beta1_VoteEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VoteEvents"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .same(proto: "events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_VoteEvents, rhs: Axelar_Evm_V1beta1_VoteEvents) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "tx_id"),
    3: .same(proto: "index"),
    4: .same(proto: "status"),
    5: .standard(proto: "token_sent"),
    6: .standard(proto: "contract_call"),
    7: .standard(proto: "contract_call_with_token"),
    8: .same(proto: "transfer"),
    9: .standard(proto: "token_deployed"),
    10: .standard(proto: "multisig_ownership_transferred"),
    11: .standard(proto: "multisig_operatorship_transferred"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try {
        var v: Axelar_Evm_V1beta1_EventTokenSent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .tokenSent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .tokenSent(v)
        }
      }()
      case 6: try {
        var v: Axelar_Evm_V1beta1_EventContractCall?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .contractCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .contractCall(v)
        }
      }()
      case 7: try {
        var v: Axelar_Evm_V1beta1_EventContractCallWithToken?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .contractCallWithToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .contractCallWithToken(v)
        }
      }()
      case 8: try {
        var v: Axelar_Evm_V1beta1_EventTransfer?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .transfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .transfer(v)
        }
      }()
      case 9: try {
        var v: Axelar_Evm_V1beta1_EventTokenDeployed?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .tokenDeployed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .tokenDeployed(v)
        }
      }()
      case 10: try {
        var v: Axelar_Evm_V1beta1_EventMultisigOwnershipTransferred?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .multisigOwnershipTransferred(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .multisigOwnershipTransferred(v)
        }
      }()
      case 11: try {
        var v: Axelar_Evm_V1beta1_EventMultisigOperatorshipTransferred?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .multisigOperatorshipTransferred(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .multisigOperatorshipTransferred(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 3)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    switch self.event {
    case .tokenSent?: try {
      guard case .tokenSent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .contractCall?: try {
      guard case .contractCall(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .contractCallWithToken?: try {
      guard case .contractCallWithToken(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .transfer?: try {
      guard case .transfer(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .tokenDeployed?: try {
      guard case .tokenDeployed(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .multisigOwnershipTransferred?: try {
      guard case .multisigOwnershipTransferred(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .multisigOperatorshipTransferred?: try {
      guard case .multisigOperatorshipTransferred(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_Event, rhs: Axelar_Evm_V1beta1_Event) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.txID != rhs.txID {return false}
    if lhs.index != rhs.index {return false}
    if lhs.status != rhs.status {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_Event.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "STATUS_CONFIRMED"),
    2: .same(proto: "STATUS_COMPLETED"),
    3: .same(proto: "STATUS_FAILED"),
  ]
}

extension Axelar_Evm_V1beta1_EventTokenSent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTokenSent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "destination_chain"),
    3: .standard(proto: "destination_address"),
    4: .same(proto: "symbol"),
    5: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.destinationChain) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularBytesField(value: self.sender, fieldNumber: 1)
    }
    if !self.destinationChain.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationChain, fieldNumber: 2)
    }
    if !self.destinationAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationAddress, fieldNumber: 3)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 4)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularBytesField(value: self.amount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_EventTokenSent, rhs: Axelar_Evm_V1beta1_EventTokenSent) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.destinationChain != rhs.destinationChain {return false}
    if lhs.destinationAddress != rhs.destinationAddress {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_EventContractCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventContractCall"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "destination_chain"),
    3: .standard(proto: "contract_address"),
    4: .standard(proto: "payload_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.destinationChain) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.payloadHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularBytesField(value: self.sender, fieldNumber: 1)
    }
    if !self.destinationChain.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationChain, fieldNumber: 2)
    }
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 3)
    }
    if !self.payloadHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.payloadHash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_EventContractCall, rhs: Axelar_Evm_V1beta1_EventContractCall) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.destinationChain != rhs.destinationChain {return false}
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.payloadHash != rhs.payloadHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_EventContractCallWithToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventContractCallWithToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "destination_chain"),
    3: .standard(proto: "contract_address"),
    4: .standard(proto: "payload_hash"),
    5: .same(proto: "symbol"),
    6: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.destinationChain) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.payloadHash) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularBytesField(value: self.sender, fieldNumber: 1)
    }
    if !self.destinationChain.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationChain, fieldNumber: 2)
    }
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 3)
    }
    if !self.payloadHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.payloadHash, fieldNumber: 4)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 5)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularBytesField(value: self.amount, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_EventContractCallWithToken, rhs: Axelar_Evm_V1beta1_EventContractCallWithToken) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.destinationChain != rhs.destinationChain {return false}
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.payloadHash != rhs.payloadHash {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_EventTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTransfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.to) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.to.isEmpty {
      try visitor.visitSingularBytesField(value: self.to, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularBytesField(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_EventTransfer, rhs: Axelar_Evm_V1beta1_EventTransfer) -> Bool {
    if lhs.to != rhs.to {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_EventTokenDeployed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTokenDeployed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbol"),
    2: .standard(proto: "token_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.tokenAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 1)
    }
    if !self.tokenAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_EventTokenDeployed, rhs: Axelar_Evm_V1beta1_EventTokenDeployed) -> Bool {
    if lhs.symbol != rhs.symbol {return false}
    if lhs.tokenAddress != rhs.tokenAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_EventMultisigOwnershipTransferred: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMultisigOwnershipTransferred"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pre_owners"),
    2: .standard(proto: "prev_threshold"),
    3: .standard(proto: "new_owners"),
    4: .standard(proto: "new_threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.preOwners) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.prevThreshold) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.newOwners) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.newThreshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.preOwners.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.preOwners, fieldNumber: 1)
    }
    if !self.prevThreshold.isEmpty {
      try visitor.visitSingularBytesField(value: self.prevThreshold, fieldNumber: 2)
    }
    if !self.newOwners.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.newOwners, fieldNumber: 3)
    }
    if !self.newThreshold.isEmpty {
      try visitor.visitSingularBytesField(value: self.newThreshold, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_EventMultisigOwnershipTransferred, rhs: Axelar_Evm_V1beta1_EventMultisigOwnershipTransferred) -> Bool {
    if lhs.preOwners != rhs.preOwners {return false}
    if lhs.prevThreshold != rhs.prevThreshold {return false}
    if lhs.newOwners != rhs.newOwners {return false}
    if lhs.newThreshold != rhs.newThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_EventMultisigOperatorshipTransferred: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMultisigOperatorshipTransferred"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "new_operators"),
    4: .standard(proto: "new_threshold"),
    5: .standard(proto: "new_weights"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.newOperators) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.newThreshold) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.newWeights) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newOperators.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.newOperators, fieldNumber: 3)
    }
    if !self.newThreshold.isEmpty {
      try visitor.visitSingularBytesField(value: self.newThreshold, fieldNumber: 4)
    }
    if !self.newWeights.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.newWeights, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_EventMultisigOperatorshipTransferred, rhs: Axelar_Evm_V1beta1_EventMultisigOperatorshipTransferred) -> Bool {
    if lhs.newOperators != rhs.newOperators {return false}
    if lhs.newThreshold != rhs.newThreshold {return false}
    if lhs.newWeights != rhs.newWeights {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_NetworkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_NetworkInfo, rhs: Axelar_Evm_V1beta1_NetworkInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_BurnerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BurnerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "burner_address"),
    2: .standard(proto: "token_address"),
    3: .standard(proto: "destination_chain"),
    4: .same(proto: "symbol"),
    5: .same(proto: "asset"),
    6: .same(proto: "salt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.burnerAddress) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.tokenAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationChain) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.asset) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.salt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.burnerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.burnerAddress, fieldNumber: 1)
    }
    if !self.tokenAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenAddress, fieldNumber: 2)
    }
    if !self.destinationChain.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationChain, fieldNumber: 3)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 4)
    }
    if !self.asset.isEmpty {
      try visitor.visitSingularStringField(value: self.asset, fieldNumber: 5)
    }
    if !self.salt.isEmpty {
      try visitor.visitSingularBytesField(value: self.salt, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_BurnerInfo, rhs: Axelar_Evm_V1beta1_BurnerInfo) -> Bool {
    if lhs.burnerAddress != rhs.burnerAddress {return false}
    if lhs.tokenAddress != rhs.tokenAddress {return false}
    if lhs.destinationChain != rhs.destinationChain {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.asset != rhs.asset {return false}
    if lhs.salt != rhs.salt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_ERC20Deposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ERC20Deposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .same(proto: "amount"),
    3: .same(proto: "asset"),
    4: .standard(proto: "destination_chain"),
    5: .standard(proto: "burner_address"),
    6: .standard(proto: "log_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asset) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.destinationChain) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.burnerAddress) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.logIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularBytesField(value: self.amount, fieldNumber: 2)
    }
    if !self.asset.isEmpty {
      try visitor.visitSingularStringField(value: self.asset, fieldNumber: 3)
    }
    if !self.destinationChain.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationChain, fieldNumber: 4)
    }
    if !self.burnerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.burnerAddress, fieldNumber: 5)
    }
    if self.logIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.logIndex, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_ERC20Deposit, rhs: Axelar_Evm_V1beta1_ERC20Deposit) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.asset != rhs.asset {return false}
    if lhs.destinationChain != rhs.destinationChain {return false}
    if lhs.burnerAddress != rhs.burnerAddress {return false}
    if lhs.logIndex != rhs.logIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_ERC20TokenMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ERC20TokenMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asset"),
    2: .standard(proto: "chain_id"),
    3: .same(proto: "details"),
    4: .standard(proto: "token_address"),
    5: .standard(proto: "tx_hash"),
    7: .same(proto: "status"),
    8: .standard(proto: "is_external"),
    9: .standard(proto: "burner_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.asset) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.chainID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tokenAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.txHash) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isExternal) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.burnerCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.asset.isEmpty {
      try visitor.visitSingularStringField(value: self.asset, fieldNumber: 1)
    }
    if !self.chainID.isEmpty {
      try visitor.visitSingularBytesField(value: self.chainID, fieldNumber: 2)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.tokenAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenAddress, fieldNumber: 4)
    }
    if !self.txHash.isEmpty {
      try visitor.visitSingularStringField(value: self.txHash, fieldNumber: 5)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    if self.isExternal != false {
      try visitor.visitSingularBoolField(value: self.isExternal, fieldNumber: 8)
    }
    if !self.burnerCode.isEmpty {
      try visitor.visitSingularBytesField(value: self.burnerCode, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_ERC20TokenMetadata, rhs: Axelar_Evm_V1beta1_ERC20TokenMetadata) -> Bool {
    if lhs.asset != rhs.asset {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs._details != rhs._details {return false}
    if lhs.tokenAddress != rhs.tokenAddress {return false}
    if lhs.txHash != rhs.txHash {return false}
    if lhs.status != rhs.status {return false}
    if lhs.isExternal != rhs.isExternal {return false}
    if lhs.burnerCode != rhs.burnerCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_TransactionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_tx"),
    2: .standard(proto: "pub_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rawTx) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pubKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawTx, fieldNumber: 1)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_TransactionMetadata, rhs: Axelar_Evm_V1beta1_TransactionMetadata) -> Bool {
    if lhs.rawTx != rhs.rawTx {return false}
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Command"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "command"),
    3: .same(proto: "params"),
    4: .standard(proto: "key_id"),
    5: .standard(proto: "max_gas_cost"),
    6: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.params) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.maxGasCost) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 2)
    }
    if !self.params.isEmpty {
      try visitor.visitSingularBytesField(value: self.params, fieldNumber: 3)
    }
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 4)
    }
    if self.maxGasCost != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxGasCost, fieldNumber: 5)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_Command, rhs: Axelar_Evm_V1beta1_Command) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.command != rhs.command {return false}
    if lhs.params != rhs.params {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.maxGasCost != rhs.maxGasCost {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_CommandBatchMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandBatchMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "command_ids"),
    3: .same(proto: "data"),
    4: .standard(proto: "sig_hash"),
    5: .same(proto: "status"),
    6: .standard(proto: "key_id"),
    7: .standard(proto: "prev_batched_commands_id"),
    8: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.commandIds) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.sigHash) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.prevBatchedCommandsID) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.commandIds.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.commandIds, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    if !self.sigHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.sigHash, fieldNumber: 4)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 6)
    }
    if !self.prevBatchedCommandsID.isEmpty {
      try visitor.visitSingularBytesField(value: self.prevBatchedCommandsID, fieldNumber: 7)
    }
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_CommandBatchMetadata, rhs: Axelar_Evm_V1beta1_CommandBatchMetadata) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.commandIds != rhs.commandIds {return false}
    if lhs.data != rhs.data {return false}
    if lhs.sigHash != rhs.sigHash {return false}
    if lhs.status != rhs.status {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.prevBatchedCommandsID != rhs.prevBatchedCommandsID {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_SigMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SigMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "chain"),
    3: .standard(proto: "command_batch_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.commandBatchID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 2)
    }
    if !self.commandBatchID.isEmpty {
      try visitor.visitSingularBytesField(value: self.commandBatchID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_SigMetadata, rhs: Axelar_Evm_V1beta1_SigMetadata) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.commandBatchID != rhs.commandBatchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_TransferKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransferKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    3: .standard(proto: "next_key_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nextKeyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 1)
    }
    if !self.nextKeyID.isEmpty {
      try visitor.visitSingularStringField(value: self.nextKeyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_TransferKey, rhs: Axelar_Evm_V1beta1_TransferKey) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.nextKeyID != rhs.nextKeyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_Asset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Asset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_Asset, rhs: Axelar_Evm_V1beta1_Asset) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_TokenDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_name"),
    2: .same(proto: "symbol"),
    3: .same(proto: "decimals"),
    4: .same(proto: "capacity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.decimals) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.capacity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenName.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenName, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if self.decimals != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimals, fieldNumber: 3)
    }
    if !self.capacity.isEmpty {
      try visitor.visitSingularBytesField(value: self.capacity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_TokenDetails, rhs: Axelar_Evm_V1beta1_TokenDetails) -> Bool {
    if lhs.tokenName != rhs.tokenName {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.capacity != rhs.capacity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_Gateway: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Gateway"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_Gateway, rhs: Axelar_Evm_V1beta1_Gateway) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_PollMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PollMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "tx_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_PollMetadata, rhs: Axelar_Evm_V1beta1_PollMetadata) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.txID != rhs.txID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
