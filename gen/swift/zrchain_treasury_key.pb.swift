// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: zrchain/treasury/key.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// KeyRequestStatus indicates the status of a key request.
/// A request starts as "pending", waiting to be picked up. Then it can move to
/// either "approved" or "rejected", depending on the decision of the MPC nodes.
enum Zrchain_Treasury_KeyRequestStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// The request is missing the status field.
  case unspecified // = 0

  /// The request is waiting to be fulfilled. This is the initial state of a
  /// request.
  case pending // = 1

  /// The request is partially fulfilled - at least one more response from
  /// a different MPC party is needed to confirm it.
  case partial // = 2

  /// The request was fulfilled. This is a final state for a request.
  case fulfilled // = 3

  /// The request was rejected. This is a final state for a request.
  case rejected // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .pending
    case 2: self = .partial
    case 3: self = .fulfilled
    case 4: self = .rejected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .pending: return 1
    case .partial: return 2
    case .fulfilled: return 3
    case .rejected: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Zrchain_Treasury_KeyRequestStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Zrchain_Treasury_KeyRequestStatus] = [
    .unspecified,
    .pending,
    .partial,
    .fulfilled,
    .rejected,
  ]
}

#endif  // swift(>=4.2)

/// KeyType indicates what crypto key algo will be used by this key (e.g. ECDSA
/// with secp256k1 curve). Its public key will be one of the specified type.
enum Zrchain_Treasury_KeyType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// The key type is missing.
  case unspecified // = 0

  /// The key is an ECDSA secp256k1 key.
  case ecdsaSecp256K1 // = 1

  /// The key is an EdDSA Ed25519 key.
  case eddsaEd25519 // = 2

  /// Standard Bitcoin Keys
  case bitcoinSecp256K1 // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .ecdsaSecp256K1
    case 2: self = .eddsaEd25519
    case 3: self = .bitcoinSecp256K1
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .ecdsaSecp256K1: return 1
    case .eddsaEd25519: return 2
    case .bitcoinSecp256K1: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Zrchain_Treasury_KeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Zrchain_Treasury_KeyType] = [
    .unspecified,
    .ecdsaSecp256K1,
    .eddsaEd25519,
    .bitcoinSecp256K1,
  ]
}

#endif  // swift(>=4.2)

/// format of a key request
struct Zrchain_Treasury_KeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var creator: String = String()

  var workspaceAddr: String = String()

  var keyringAddr: String = String()

  var keyType: Zrchain_Treasury_KeyType = .unspecified

  var status: Zrchain_Treasury_KeyRequestStatus = .unspecified

  var keyringPartySignatures: [Data] = []

  var rejectReason: String = String()

  var index: UInt64 = 0

  var signPolicyID: UInt64 = 0

  /// Optional
  var zenbtcMetadata: Zrchain_Treasury_ZenBTCMetadata {
    get {return _zenbtcMetadata ?? Zrchain_Treasury_ZenBTCMetadata()}
    set {_zenbtcMetadata = newValue}
  }
  /// Returns true if `zenbtcMetadata` has been explicitly set.
  var hasZenbtcMetadata: Bool {return self._zenbtcMetadata != nil}
  /// Clears the value of `zenbtcMetadata`. Subsequent reads from it will return its default value.
  mutating func clearZenbtcMetadata() {self._zenbtcMetadata = nil}

  var mpcBtl: UInt64 = 0

  var fee: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _zenbtcMetadata: Zrchain_Treasury_ZenBTCMetadata? = nil
}

/// format of a key request response
struct Zrchain_Treasury_KeyReqResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var creator: String = String()

  var workspaceAddr: String = String()

  var keyringAddr: String = String()

  var keyType: String = String()

  var status: String = String()

  var keyringPartySignatures: [Data] = []

  var rejectReason: String = String()

  var index: UInt64 = 0

  var signPolicyID: UInt64 = 0

  /// Optional
  var zenbtcMetadata: Zrchain_Treasury_ZenBTCMetadata {
    get {return _zenbtcMetadata ?? Zrchain_Treasury_ZenBTCMetadata()}
    set {_zenbtcMetadata = newValue}
  }
  /// Returns true if `zenbtcMetadata` has been explicitly set.
  var hasZenbtcMetadata: Bool {return self._zenbtcMetadata != nil}
  /// Clears the value of `zenbtcMetadata`. Subsequent reads from it will return its default value.
  mutating func clearZenbtcMetadata() {self._zenbtcMetadata = nil}

  var mpcBtl: UInt64 = 0

  var fee: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _zenbtcMetadata: Zrchain_Treasury_ZenBTCMetadata? = nil
}

/// format of a key
struct Zrchain_Treasury_Key {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var workspaceAddr: String = String()

  var keyringAddr: String = String()

  var type: Zrchain_Treasury_KeyType = .unspecified

  var publicKey: Data = Data()

  var index: UInt64 = 0

  var signPolicyID: UInt64 = 0

  /// Optional
  var zenbtcMetadata: Zrchain_Treasury_ZenBTCMetadata {
    get {return _zenbtcMetadata ?? Zrchain_Treasury_ZenBTCMetadata()}
    set {_zenbtcMetadata = newValue}
  }
  /// Returns true if `zenbtcMetadata` has been explicitly set.
  var hasZenbtcMetadata: Bool {return self._zenbtcMetadata != nil}
  /// Clears the value of `zenbtcMetadata`. Subsequent reads from it will return its default value.
  mutating func clearZenbtcMetadata() {self._zenbtcMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _zenbtcMetadata: Zrchain_Treasury_ZenBTCMetadata? = nil
}

/// format of a key response
struct Zrchain_Treasury_KeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var workspaceAddr: String = String()

  var keyringAddr: String = String()

  var type: String = String()

  var publicKey: Data = Data()

  var index: UInt64 = 0

  var signPolicyID: UInt64 = 0

  /// Optional
  var zenbtcMetadata: Zrchain_Treasury_ZenBTCMetadata {
    get {return _zenbtcMetadata ?? Zrchain_Treasury_ZenBTCMetadata()}
    set {_zenbtcMetadata = newValue}
  }
  /// Returns true if `zenbtcMetadata` has been explicitly set.
  var hasZenbtcMetadata: Bool {return self._zenbtcMetadata != nil}
  /// Clears the value of `zenbtcMetadata`. Subsequent reads from it will return its default value.
  mutating func clearZenbtcMetadata() {self._zenbtcMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _zenbtcMetadata: Zrchain_Treasury_ZenBTCMetadata? = nil
}

/// ZenBTCMetadata is the metadata for a key on the zenBTC keyring.
struct Zrchain_Treasury_ZenBTCMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recipientAddr: String = String()

  var chainType: Zrchain_Treasury_WalletType = .unspecified

  var chainID: UInt64 = 0

  var returnAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Zrchain_Treasury_KeyRequestStatus: @unchecked Sendable {}
extension Zrchain_Treasury_KeyType: @unchecked Sendable {}
extension Zrchain_Treasury_KeyRequest: @unchecked Sendable {}
extension Zrchain_Treasury_KeyReqResponse: @unchecked Sendable {}
extension Zrchain_Treasury_Key: @unchecked Sendable {}
extension Zrchain_Treasury_KeyResponse: @unchecked Sendable {}
extension Zrchain_Treasury_ZenBTCMetadata: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "zrchain.treasury"

extension Zrchain_Treasury_KeyRequestStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_REQUEST_STATUS_UNSPECIFIED"),
    1: .same(proto: "KEY_REQUEST_STATUS_PENDING"),
    2: .same(proto: "KEY_REQUEST_STATUS_PARTIAL"),
    3: .same(proto: "KEY_REQUEST_STATUS_FULFILLED"),
    4: .same(proto: "KEY_REQUEST_STATUS_REJECTED"),
  ]
}

extension Zrchain_Treasury_KeyType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_TYPE_UNSPECIFIED"),
    1: .same(proto: "KEY_TYPE_ECDSA_SECP256K1"),
    2: .same(proto: "KEY_TYPE_EDDSA_ED25519"),
    3: .same(proto: "KEY_TYPE_BITCOIN_SECP256K1"),
  ]
}

extension Zrchain_Treasury_KeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "creator"),
    3: .standard(proto: "workspace_addr"),
    4: .standard(proto: "keyring_addr"),
    5: .standard(proto: "key_type"),
    6: .same(proto: "status"),
    7: .standard(proto: "keyring_party_signatures"),
    8: .standard(proto: "reject_reason"),
    9: .same(proto: "index"),
    10: .standard(proto: "sign_policy_id"),
    11: .standard(proto: "zenbtc_metadata"),
    12: .standard(proto: "mpc_btl"),
    13: .same(proto: "fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workspaceAddr) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.keyringAddr) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.keyType) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 7: try { try decoder.decodeRepeatedBytesField(value: &self.keyringPartySignatures) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.rejectReason) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.signPolicyID) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._zenbtcMetadata) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self.mpcBtl) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 2)
    }
    if !self.workspaceAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceAddr, fieldNumber: 3)
    }
    if !self.keyringAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.keyringAddr, fieldNumber: 4)
    }
    if self.keyType != .unspecified {
      try visitor.visitSingularEnumField(value: self.keyType, fieldNumber: 5)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 6)
    }
    if !self.keyringPartySignatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.keyringPartySignatures, fieldNumber: 7)
    }
    if !self.rejectReason.isEmpty {
      try visitor.visitSingularStringField(value: self.rejectReason, fieldNumber: 8)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 9)
    }
    if self.signPolicyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.signPolicyID, fieldNumber: 10)
    }
    try { if let v = self._zenbtcMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if self.mpcBtl != 0 {
      try visitor.visitSingularUInt64Field(value: self.mpcBtl, fieldNumber: 12)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_KeyRequest, rhs: Zrchain_Treasury_KeyRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.workspaceAddr != rhs.workspaceAddr {return false}
    if lhs.keyringAddr != rhs.keyringAddr {return false}
    if lhs.keyType != rhs.keyType {return false}
    if lhs.status != rhs.status {return false}
    if lhs.keyringPartySignatures != rhs.keyringPartySignatures {return false}
    if lhs.rejectReason != rhs.rejectReason {return false}
    if lhs.index != rhs.index {return false}
    if lhs.signPolicyID != rhs.signPolicyID {return false}
    if lhs._zenbtcMetadata != rhs._zenbtcMetadata {return false}
    if lhs.mpcBtl != rhs.mpcBtl {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_KeyReqResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyReqResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "creator"),
    3: .standard(proto: "workspace_addr"),
    4: .standard(proto: "keyring_addr"),
    5: .standard(proto: "key_type"),
    6: .same(proto: "status"),
    7: .standard(proto: "keyring_party_signatures"),
    8: .standard(proto: "reject_reason"),
    9: .same(proto: "index"),
    10: .standard(proto: "sign_policy_id"),
    11: .standard(proto: "zenbtc_metadata"),
    12: .standard(proto: "mpc_btl"),
    13: .same(proto: "fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workspaceAddr) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.keyringAddr) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.keyType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 7: try { try decoder.decodeRepeatedBytesField(value: &self.keyringPartySignatures) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.rejectReason) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.signPolicyID) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._zenbtcMetadata) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self.mpcBtl) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 2)
    }
    if !self.workspaceAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceAddr, fieldNumber: 3)
    }
    if !self.keyringAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.keyringAddr, fieldNumber: 4)
    }
    if !self.keyType.isEmpty {
      try visitor.visitSingularStringField(value: self.keyType, fieldNumber: 5)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 6)
    }
    if !self.keyringPartySignatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.keyringPartySignatures, fieldNumber: 7)
    }
    if !self.rejectReason.isEmpty {
      try visitor.visitSingularStringField(value: self.rejectReason, fieldNumber: 8)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 9)
    }
    if self.signPolicyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.signPolicyID, fieldNumber: 10)
    }
    try { if let v = self._zenbtcMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if self.mpcBtl != 0 {
      try visitor.visitSingularUInt64Field(value: self.mpcBtl, fieldNumber: 12)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_KeyReqResponse, rhs: Zrchain_Treasury_KeyReqResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.workspaceAddr != rhs.workspaceAddr {return false}
    if lhs.keyringAddr != rhs.keyringAddr {return false}
    if lhs.keyType != rhs.keyType {return false}
    if lhs.status != rhs.status {return false}
    if lhs.keyringPartySignatures != rhs.keyringPartySignatures {return false}
    if lhs.rejectReason != rhs.rejectReason {return false}
    if lhs.index != rhs.index {return false}
    if lhs.signPolicyID != rhs.signPolicyID {return false}
    if lhs._zenbtcMetadata != rhs._zenbtcMetadata {return false}
    if lhs.mpcBtl != rhs.mpcBtl {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Key"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "workspace_addr"),
    3: .standard(proto: "keyring_addr"),
    4: .same(proto: "type"),
    5: .standard(proto: "public_key"),
    9: .same(proto: "index"),
    10: .standard(proto: "sign_policy_id"),
    11: .standard(proto: "zenbtc_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workspaceAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyringAddr) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.signPolicyID) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._zenbtcMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.workspaceAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceAddr, fieldNumber: 2)
    }
    if !self.keyringAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.keyringAddr, fieldNumber: 3)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 5)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 9)
    }
    if self.signPolicyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.signPolicyID, fieldNumber: 10)
    }
    try { if let v = self._zenbtcMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_Key, rhs: Zrchain_Treasury_Key) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.workspaceAddr != rhs.workspaceAddr {return false}
    if lhs.keyringAddr != rhs.keyringAddr {return false}
    if lhs.type != rhs.type {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.index != rhs.index {return false}
    if lhs.signPolicyID != rhs.signPolicyID {return false}
    if lhs._zenbtcMetadata != rhs._zenbtcMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_KeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "workspace_addr"),
    3: .standard(proto: "keyring_addr"),
    4: .same(proto: "type"),
    5: .standard(proto: "public_key"),
    9: .same(proto: "index"),
    10: .standard(proto: "sign_policy_id"),
    11: .standard(proto: "zenbtc_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workspaceAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyringAddr) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.signPolicyID) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._zenbtcMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.workspaceAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceAddr, fieldNumber: 2)
    }
    if !self.keyringAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.keyringAddr, fieldNumber: 3)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 4)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 5)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 9)
    }
    if self.signPolicyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.signPolicyID, fieldNumber: 10)
    }
    try { if let v = self._zenbtcMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_KeyResponse, rhs: Zrchain_Treasury_KeyResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.workspaceAddr != rhs.workspaceAddr {return false}
    if lhs.keyringAddr != rhs.keyringAddr {return false}
    if lhs.type != rhs.type {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.index != rhs.index {return false}
    if lhs.signPolicyID != rhs.signPolicyID {return false}
    if lhs._zenbtcMetadata != rhs._zenbtcMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_ZenBTCMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZenBTCMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "recipient_addr"),
    2: .standard(proto: "chain_type"),
    3: .standard(proto: "chain_id"),
    4: .standard(proto: "return_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recipientAddr) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.chainType) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.chainID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.returnAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recipientAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.recipientAddr, fieldNumber: 1)
    }
    if self.chainType != .unspecified {
      try visitor.visitSingularEnumField(value: self.chainType, fieldNumber: 2)
    }
    if self.chainID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chainID, fieldNumber: 3)
    }
    if !self.returnAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.returnAddress, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_ZenBTCMetadata, rhs: Zrchain_Treasury_ZenBTCMetadata) -> Bool {
    if lhs.recipientAddr != rhs.recipientAddr {return false}
    if lhs.chainType != rhs.chainType {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.returnAddress != rhs.returnAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
