// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: injective/exchange/v1beta1/genesis.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// GenesisState defines the exchange module's genesis state.
struct Injective_Exchange_V1beta1_GenesisState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// params defines all the parameters of related to exchange.
  var params: Injective_Exchange_V1beta1_Params {
    get {return _storage._params ?? Injective_Exchange_V1beta1_Params()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {_uniqueStorage()._params = nil}

  /// spot_markets is an array containing the genesis trade pairs
  var spotMarkets: [Injective_Exchange_V1beta1_SpotMarket] {
    get {return _storage._spotMarkets}
    set {_uniqueStorage()._spotMarkets = newValue}
  }

  /// derivative_markets is an array containing the genesis derivative markets
  var derivativeMarkets: [Injective_Exchange_V1beta1_DerivativeMarket] {
    get {return _storage._derivativeMarkets}
    set {_uniqueStorage()._derivativeMarkets = newValue}
  }

  /// spot_orderbook defines the spot exchange limit orderbook active at genesis.
  var spotOrderbook: [Injective_Exchange_V1beta1_SpotOrderBook] {
    get {return _storage._spotOrderbook}
    set {_uniqueStorage()._spotOrderbook = newValue}
  }

  /// derivative_orderbook defines the derivative exchange limit orderbook active
  /// at genesis.
  var derivativeOrderbook: [Injective_Exchange_V1beta1_DerivativeOrderBook] {
    get {return _storage._derivativeOrderbook}
    set {_uniqueStorage()._derivativeOrderbook = newValue}
  }

  /// balances defines the exchange users balances active at genesis.
  var balances: [Injective_Exchange_V1beta1_Balance] {
    get {return _storage._balances}
    set {_uniqueStorage()._balances = newValue}
  }

  /// positions defines the exchange derivative positions at genesis
  var positions: [Injective_Exchange_V1beta1_DerivativePosition] {
    get {return _storage._positions}
    set {_uniqueStorage()._positions = newValue}
  }

  /// subaccount_trade_nonces defines the subaccount trade nonces for the
  /// subaccounts at genesis
  var subaccountTradeNonces: [Injective_Exchange_V1beta1_SubaccountNonce] {
    get {return _storage._subaccountTradeNonces}
    set {_uniqueStorage()._subaccountTradeNonces = newValue}
  }

  /// expiry_futures_market_info defines the market info for the expiry futures
  /// markets at genesis
  var expiryFuturesMarketInfoState: [Injective_Exchange_V1beta1_ExpiryFuturesMarketInfoState] {
    get {return _storage._expiryFuturesMarketInfoState}
    set {_uniqueStorage()._expiryFuturesMarketInfoState = newValue}
  }

  /// perpetual_market_info defines the market info for the perpetual derivative
  /// markets at genesis
  var perpetualMarketInfo: [Injective_Exchange_V1beta1_PerpetualMarketInfo] {
    get {return _storage._perpetualMarketInfo}
    set {_uniqueStorage()._perpetualMarketInfo = newValue}
  }

  /// perpetual_market_funding_state defines the funding state for the perpetual
  /// derivative markets at genesis
  var perpetualMarketFundingState: [Injective_Exchange_V1beta1_PerpetualMarketFundingState] {
    get {return _storage._perpetualMarketFundingState}
    set {_uniqueStorage()._perpetualMarketFundingState = newValue}
  }

  /// derivative_market_settlement_scheduled defines the scheduled markets for
  /// settlement at genesis
  var derivativeMarketSettlementScheduled: [Injective_Exchange_V1beta1_DerivativeMarketSettlementInfo] {
    get {return _storage._derivativeMarketSettlementScheduled}
    set {_uniqueStorage()._derivativeMarketSettlementScheduled = newValue}
  }

  /// sets spot markets as enabled
  var isSpotExchangeEnabled: Bool {
    get {return _storage._isSpotExchangeEnabled}
    set {_uniqueStorage()._isSpotExchangeEnabled = newValue}
  }

  /// sets derivative markets as enabled
  var isDerivativesExchangeEnabled: Bool {
    get {return _storage._isDerivativesExchangeEnabled}
    set {_uniqueStorage()._isDerivativesExchangeEnabled = newValue}
  }

  /// the current trading reward campaign info
  var tradingRewardCampaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo {
    get {return _storage._tradingRewardCampaignInfo ?? Injective_Exchange_V1beta1_TradingRewardCampaignInfo()}
    set {_uniqueStorage()._tradingRewardCampaignInfo = newValue}
  }
  /// Returns true if `tradingRewardCampaignInfo` has been explicitly set.
  var hasTradingRewardCampaignInfo: Bool {return _storage._tradingRewardCampaignInfo != nil}
  /// Clears the value of `tradingRewardCampaignInfo`. Subsequent reads from it will return its default value.
  mutating func clearTradingRewardCampaignInfo() {_uniqueStorage()._tradingRewardCampaignInfo = nil}

  /// the current and upcoming trading reward campaign pools
  var tradingRewardPoolCampaignSchedule: [Injective_Exchange_V1beta1_CampaignRewardPool] {
    get {return _storage._tradingRewardPoolCampaignSchedule}
    set {_uniqueStorage()._tradingRewardPoolCampaignSchedule = newValue}
  }

  /// the current trading reward account points
  var tradingRewardCampaignAccountPoints: [Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints] {
    get {return _storage._tradingRewardCampaignAccountPoints}
    set {_uniqueStorage()._tradingRewardCampaignAccountPoints = newValue}
  }

  /// the fee discount schedule
  var feeDiscountSchedule: Injective_Exchange_V1beta1_FeeDiscountSchedule {
    get {return _storage._feeDiscountSchedule ?? Injective_Exchange_V1beta1_FeeDiscountSchedule()}
    set {_uniqueStorage()._feeDiscountSchedule = newValue}
  }
  /// Returns true if `feeDiscountSchedule` has been explicitly set.
  var hasFeeDiscountSchedule: Bool {return _storage._feeDiscountSchedule != nil}
  /// Clears the value of `feeDiscountSchedule`. Subsequent reads from it will return its default value.
  mutating func clearFeeDiscountSchedule() {_uniqueStorage()._feeDiscountSchedule = nil}

  /// the cached fee discount account tiers with TTL
  var feeDiscountAccountTierTtl: [Injective_Exchange_V1beta1_FeeDiscountAccountTierTTL] {
    get {return _storage._feeDiscountAccountTierTtl}
    set {_uniqueStorage()._feeDiscountAccountTierTtl = newValue}
  }

  /// the fee discount paid by accounts in all buckets
  var feeDiscountBucketVolumeAccounts: [Injective_Exchange_V1beta1_FeeDiscountBucketVolumeAccounts] {
    get {return _storage._feeDiscountBucketVolumeAccounts}
    set {_uniqueStorage()._feeDiscountBucketVolumeAccounts = newValue}
  }

  /// sets the first fee cycle as finished
  var isFirstFeeCycleFinished: Bool {
    get {return _storage._isFirstFeeCycleFinished}
    set {_uniqueStorage()._isFirstFeeCycleFinished = newValue}
  }

  /// the current and upcoming trading reward campaign pending pools
  var pendingTradingRewardPoolCampaignSchedule: [Injective_Exchange_V1beta1_CampaignRewardPool] {
    get {return _storage._pendingTradingRewardPoolCampaignSchedule}
    set {_uniqueStorage()._pendingTradingRewardPoolCampaignSchedule = newValue}
  }

  /// the pending trading reward account points
  var pendingTradingRewardCampaignAccountPoints: [Injective_Exchange_V1beta1_TradingRewardCampaignAccountPendingPoints] {
    get {return _storage._pendingTradingRewardCampaignAccountPoints}
    set {_uniqueStorage()._pendingTradingRewardCampaignAccountPoints = newValue}
  }

  /// the addresses opting out of trading rewards
  var rewardsOptOutAddresses: [String] {
    get {return _storage._rewardsOptOutAddresses}
    set {_uniqueStorage()._rewardsOptOutAddresses = newValue}
  }

  var historicalTradeRecords: [Injective_Exchange_V1beta1_TradeRecords] {
    get {return _storage._historicalTradeRecords}
    set {_uniqueStorage()._historicalTradeRecords = newValue}
  }

  /// binary_options_markets is an array containing the genesis binary options
  /// markets
  var binaryOptionsMarkets: [Injective_Exchange_V1beta1_BinaryOptionsMarket] {
    get {return _storage._binaryOptionsMarkets}
    set {_uniqueStorage()._binaryOptionsMarkets = newValue}
  }

  /// binary_options_markets_scheduled_for_settlement contains the marketIDs of
  /// binary options markets scheduled for next-block settlement
  var binaryOptionsMarketIdsScheduledForSettlement: [String] {
    get {return _storage._binaryOptionsMarketIdsScheduledForSettlement}
    set {_uniqueStorage()._binaryOptionsMarketIdsScheduledForSettlement = newValue}
  }

  /// spot_market_ids_scheduled_to_force_close defines the scheduled markets for
  /// forced closings at genesis
  var spotMarketIdsScheduledToForceClose: [String] {
    get {return _storage._spotMarketIdsScheduledToForceClose}
    set {_uniqueStorage()._spotMarketIdsScheduledToForceClose = newValue}
  }

  /// denom_decimals defines the denom decimals for the exchange.
  var denomDecimals: [Injective_Exchange_V1beta1_DenomDecimals] {
    get {return _storage._denomDecimals}
    set {_uniqueStorage()._denomDecimals = newValue}
  }

  /// conditional_derivative_orderbook contains conditional orderbooks for all
  /// markets (both lmit and market conditional orders)
  var conditionalDerivativeOrderbooks: [Injective_Exchange_V1beta1_ConditionalDerivativeOrderBook] {
    get {return _storage._conditionalDerivativeOrderbooks}
    set {_uniqueStorage()._conditionalDerivativeOrderbooks = newValue}
  }

  /// market_fee_multipliers contains any non-default atomic order fee
  /// multipliers
  var marketFeeMultipliers: [Injective_Exchange_V1beta1_MarketFeeMultiplier] {
    get {return _storage._marketFeeMultipliers}
    set {_uniqueStorage()._marketFeeMultipliers = newValue}
  }

  var orderbookSequences: [Injective_Exchange_V1beta1_OrderbookSequence] {
    get {return _storage._orderbookSequences}
    set {_uniqueStorage()._orderbookSequences = newValue}
  }

  var subaccountVolumes: [Injective_Exchange_V1beta1_AggregateSubaccountVolumeRecord] {
    get {return _storage._subaccountVolumes}
    set {_uniqueStorage()._subaccountVolumes = newValue}
  }

  var marketVolumes: [Injective_Exchange_V1beta1_MarketVolume] {
    get {return _storage._marketVolumes}
    set {_uniqueStorage()._marketVolumes = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_OrderbookSequence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequence: UInt64 = 0

  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_FeeDiscountAccountTierTTL {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: String = String()

  var tierTtl: Injective_Exchange_V1beta1_FeeDiscountTierTTL {
    get {return _tierTtl ?? Injective_Exchange_V1beta1_FeeDiscountTierTTL()}
    set {_tierTtl = newValue}
  }
  /// Returns true if `tierTtl` has been explicitly set.
  var hasTierTtl: Bool {return self._tierTtl != nil}
  /// Clears the value of `tierTtl`. Subsequent reads from it will return its default value.
  mutating func clearTierTtl() {self._tierTtl = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tierTtl: Injective_Exchange_V1beta1_FeeDiscountTierTTL? = nil
}

struct Injective_Exchange_V1beta1_FeeDiscountBucketVolumeAccounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bucketStartTimestamp: Int64 = 0

  var accountVolume: [Injective_Exchange_V1beta1_AccountVolume] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_AccountVolume {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: String = String()

  var volume: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: String = String()

  var points: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradingRewardCampaignAccountPendingPoints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rewardPoolStartTimestamp: Int64 = 0

  var accountPoints: [Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Spot Exchange Limit Orderbook
struct Injective_Exchange_V1beta1_SpotOrderBook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var isBuySide: Bool = false

  var orders: [Injective_Exchange_V1beta1_SpotLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Derivative Exchange Limit Orderbook
struct Injective_Exchange_V1beta1_DerivativeOrderBook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var isBuySide: Bool = false

  var orders: [Injective_Exchange_V1beta1_DerivativeLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Orderbook containing limit & market conditional orders
struct Injective_Exchange_V1beta1_ConditionalDerivativeOrderBook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var limitBuyOrders: [Injective_Exchange_V1beta1_DerivativeLimitOrder] = []

  var marketBuyOrders: [Injective_Exchange_V1beta1_DerivativeMarketOrder] = []

  var limitSellOrders: [Injective_Exchange_V1beta1_DerivativeLimitOrder] = []

  var marketSellOrders: [Injective_Exchange_V1beta1_DerivativeMarketOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_Balance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var denom: String = String()

  var deposits: Injective_Exchange_V1beta1_Deposit {
    get {return _deposits ?? Injective_Exchange_V1beta1_Deposit()}
    set {_deposits = newValue}
  }
  /// Returns true if `deposits` has been explicitly set.
  var hasDeposits: Bool {return self._deposits != nil}
  /// Clears the value of `deposits`. Subsequent reads from it will return its default value.
  mutating func clearDeposits() {self._deposits = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deposits: Injective_Exchange_V1beta1_Deposit? = nil
}

struct Injective_Exchange_V1beta1_DerivativePosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var marketID: String = String()

  var position: Injective_Exchange_V1beta1_Position {
    get {return _position ?? Injective_Exchange_V1beta1_Position()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: Injective_Exchange_V1beta1_Position? = nil
}

struct Injective_Exchange_V1beta1_SubaccountNonce {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var subaccountTradeNonce: Injective_Exchange_V1beta1_SubaccountTradeNonce {
    get {return _subaccountTradeNonce ?? Injective_Exchange_V1beta1_SubaccountTradeNonce()}
    set {_subaccountTradeNonce = newValue}
  }
  /// Returns true if `subaccountTradeNonce` has been explicitly set.
  var hasSubaccountTradeNonce: Bool {return self._subaccountTradeNonce != nil}
  /// Clears the value of `subaccountTradeNonce`. Subsequent reads from it will return its default value.
  mutating func clearSubaccountTradeNonce() {self._subaccountTradeNonce = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _subaccountTradeNonce: Injective_Exchange_V1beta1_SubaccountTradeNonce? = nil
}

struct Injective_Exchange_V1beta1_ExpiryFuturesMarketInfoState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var marketInfo: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo {
    get {return _marketInfo ?? Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo()}
    set {_marketInfo = newValue}
  }
  /// Returns true if `marketInfo` has been explicitly set.
  var hasMarketInfo: Bool {return self._marketInfo != nil}
  /// Clears the value of `marketInfo`. Subsequent reads from it will return its default value.
  mutating func clearMarketInfo() {self._marketInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _marketInfo: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo? = nil
}

struct Injective_Exchange_V1beta1_PerpetualMarketFundingState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var funding: Injective_Exchange_V1beta1_PerpetualMarketFunding {
    get {return _funding ?? Injective_Exchange_V1beta1_PerpetualMarketFunding()}
    set {_funding = newValue}
  }
  /// Returns true if `funding` has been explicitly set.
  var hasFunding: Bool {return self._funding != nil}
  /// Clears the value of `funding`. Subsequent reads from it will return its default value.
  mutating func clearFunding() {self._funding = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _funding: Injective_Exchange_V1beta1_PerpetualMarketFunding? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Injective_Exchange_V1beta1_GenesisState: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_OrderbookSequence: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_FeeDiscountAccountTierTTL: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_FeeDiscountBucketVolumeAccounts: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_AccountVolume: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TradingRewardCampaignAccountPendingPoints: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SpotOrderBook: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_DerivativeOrderBook: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_ConditionalDerivativeOrderBook: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_Balance: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_DerivativePosition: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SubaccountNonce: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_ExpiryFuturesMarketInfoState: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_PerpetualMarketFundingState: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "injective.exchange.v1beta1"

extension Injective_Exchange_V1beta1_GenesisState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .standard(proto: "spot_markets"),
    3: .standard(proto: "derivative_markets"),
    4: .standard(proto: "spot_orderbook"),
    5: .standard(proto: "derivative_orderbook"),
    6: .same(proto: "balances"),
    7: .same(proto: "positions"),
    8: .standard(proto: "subaccount_trade_nonces"),
    9: .standard(proto: "expiry_futures_market_info_state"),
    10: .standard(proto: "perpetual_market_info"),
    11: .standard(proto: "perpetual_market_funding_state"),
    12: .standard(proto: "derivative_market_settlement_scheduled"),
    13: .standard(proto: "is_spot_exchange_enabled"),
    14: .standard(proto: "is_derivatives_exchange_enabled"),
    15: .standard(proto: "trading_reward_campaign_info"),
    16: .standard(proto: "trading_reward_pool_campaign_schedule"),
    17: .standard(proto: "trading_reward_campaign_account_points"),
    18: .standard(proto: "fee_discount_schedule"),
    19: .standard(proto: "fee_discount_account_tier_ttl"),
    20: .standard(proto: "fee_discount_bucket_volume_accounts"),
    21: .standard(proto: "is_first_fee_cycle_finished"),
    22: .standard(proto: "pending_trading_reward_pool_campaign_schedule"),
    23: .standard(proto: "pending_trading_reward_campaign_account_points"),
    24: .standard(proto: "rewards_opt_out_addresses"),
    25: .standard(proto: "historical_trade_records"),
    26: .standard(proto: "binary_options_markets"),
    27: .standard(proto: "binary_options_market_ids_scheduled_for_settlement"),
    28: .standard(proto: "spot_market_ids_scheduled_to_force_close"),
    29: .standard(proto: "denom_decimals"),
    30: .standard(proto: "conditional_derivative_orderbooks"),
    31: .standard(proto: "market_fee_multipliers"),
    32: .standard(proto: "orderbook_sequences"),
    33: .standard(proto: "subaccount_volumes"),
    34: .standard(proto: "market_volumes"),
  ]

  fileprivate class _StorageClass {
    var _params: Injective_Exchange_V1beta1_Params? = nil
    var _spotMarkets: [Injective_Exchange_V1beta1_SpotMarket] = []
    var _derivativeMarkets: [Injective_Exchange_V1beta1_DerivativeMarket] = []
    var _spotOrderbook: [Injective_Exchange_V1beta1_SpotOrderBook] = []
    var _derivativeOrderbook: [Injective_Exchange_V1beta1_DerivativeOrderBook] = []
    var _balances: [Injective_Exchange_V1beta1_Balance] = []
    var _positions: [Injective_Exchange_V1beta1_DerivativePosition] = []
    var _subaccountTradeNonces: [Injective_Exchange_V1beta1_SubaccountNonce] = []
    var _expiryFuturesMarketInfoState: [Injective_Exchange_V1beta1_ExpiryFuturesMarketInfoState] = []
    var _perpetualMarketInfo: [Injective_Exchange_V1beta1_PerpetualMarketInfo] = []
    var _perpetualMarketFundingState: [Injective_Exchange_V1beta1_PerpetualMarketFundingState] = []
    var _derivativeMarketSettlementScheduled: [Injective_Exchange_V1beta1_DerivativeMarketSettlementInfo] = []
    var _isSpotExchangeEnabled: Bool = false
    var _isDerivativesExchangeEnabled: Bool = false
    var _tradingRewardCampaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo? = nil
    var _tradingRewardPoolCampaignSchedule: [Injective_Exchange_V1beta1_CampaignRewardPool] = []
    var _tradingRewardCampaignAccountPoints: [Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints] = []
    var _feeDiscountSchedule: Injective_Exchange_V1beta1_FeeDiscountSchedule? = nil
    var _feeDiscountAccountTierTtl: [Injective_Exchange_V1beta1_FeeDiscountAccountTierTTL] = []
    var _feeDiscountBucketVolumeAccounts: [Injective_Exchange_V1beta1_FeeDiscountBucketVolumeAccounts] = []
    var _isFirstFeeCycleFinished: Bool = false
    var _pendingTradingRewardPoolCampaignSchedule: [Injective_Exchange_V1beta1_CampaignRewardPool] = []
    var _pendingTradingRewardCampaignAccountPoints: [Injective_Exchange_V1beta1_TradingRewardCampaignAccountPendingPoints] = []
    var _rewardsOptOutAddresses: [String] = []
    var _historicalTradeRecords: [Injective_Exchange_V1beta1_TradeRecords] = []
    var _binaryOptionsMarkets: [Injective_Exchange_V1beta1_BinaryOptionsMarket] = []
    var _binaryOptionsMarketIdsScheduledForSettlement: [String] = []
    var _spotMarketIdsScheduledToForceClose: [String] = []
    var _denomDecimals: [Injective_Exchange_V1beta1_DenomDecimals] = []
    var _conditionalDerivativeOrderbooks: [Injective_Exchange_V1beta1_ConditionalDerivativeOrderBook] = []
    var _marketFeeMultipliers: [Injective_Exchange_V1beta1_MarketFeeMultiplier] = []
    var _orderbookSequences: [Injective_Exchange_V1beta1_OrderbookSequence] = []
    var _subaccountVolumes: [Injective_Exchange_V1beta1_AggregateSubaccountVolumeRecord] = []
    var _marketVolumes: [Injective_Exchange_V1beta1_MarketVolume] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _params = source._params
      _spotMarkets = source._spotMarkets
      _derivativeMarkets = source._derivativeMarkets
      _spotOrderbook = source._spotOrderbook
      _derivativeOrderbook = source._derivativeOrderbook
      _balances = source._balances
      _positions = source._positions
      _subaccountTradeNonces = source._subaccountTradeNonces
      _expiryFuturesMarketInfoState = source._expiryFuturesMarketInfoState
      _perpetualMarketInfo = source._perpetualMarketInfo
      _perpetualMarketFundingState = source._perpetualMarketFundingState
      _derivativeMarketSettlementScheduled = source._derivativeMarketSettlementScheduled
      _isSpotExchangeEnabled = source._isSpotExchangeEnabled
      _isDerivativesExchangeEnabled = source._isDerivativesExchangeEnabled
      _tradingRewardCampaignInfo = source._tradingRewardCampaignInfo
      _tradingRewardPoolCampaignSchedule = source._tradingRewardPoolCampaignSchedule
      _tradingRewardCampaignAccountPoints = source._tradingRewardCampaignAccountPoints
      _feeDiscountSchedule = source._feeDiscountSchedule
      _feeDiscountAccountTierTtl = source._feeDiscountAccountTierTtl
      _feeDiscountBucketVolumeAccounts = source._feeDiscountBucketVolumeAccounts
      _isFirstFeeCycleFinished = source._isFirstFeeCycleFinished
      _pendingTradingRewardPoolCampaignSchedule = source._pendingTradingRewardPoolCampaignSchedule
      _pendingTradingRewardCampaignAccountPoints = source._pendingTradingRewardCampaignAccountPoints
      _rewardsOptOutAddresses = source._rewardsOptOutAddresses
      _historicalTradeRecords = source._historicalTradeRecords
      _binaryOptionsMarkets = source._binaryOptionsMarkets
      _binaryOptionsMarketIdsScheduledForSettlement = source._binaryOptionsMarketIdsScheduledForSettlement
      _spotMarketIdsScheduledToForceClose = source._spotMarketIdsScheduledToForceClose
      _denomDecimals = source._denomDecimals
      _conditionalDerivativeOrderbooks = source._conditionalDerivativeOrderbooks
      _marketFeeMultipliers = source._marketFeeMultipliers
      _orderbookSequences = source._orderbookSequences
      _subaccountVolumes = source._subaccountVolumes
      _marketVolumes = source._marketVolumes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._spotMarkets) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._derivativeMarkets) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._spotOrderbook) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._derivativeOrderbook) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._balances) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._positions) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._subaccountTradeNonces) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._expiryFuturesMarketInfoState) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._perpetualMarketInfo) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._perpetualMarketFundingState) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._derivativeMarketSettlementScheduled) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._isSpotExchangeEnabled) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._isDerivativesExchangeEnabled) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._tradingRewardCampaignInfo) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._tradingRewardPoolCampaignSchedule) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._tradingRewardCampaignAccountPoints) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._feeDiscountSchedule) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._feeDiscountAccountTierTtl) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._feeDiscountBucketVolumeAccounts) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._isFirstFeeCycleFinished) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._pendingTradingRewardPoolCampaignSchedule) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._pendingTradingRewardCampaignAccountPoints) }()
        case 24: try { try decoder.decodeRepeatedStringField(value: &_storage._rewardsOptOutAddresses) }()
        case 25: try { try decoder.decodeRepeatedMessageField(value: &_storage._historicalTradeRecords) }()
        case 26: try { try decoder.decodeRepeatedMessageField(value: &_storage._binaryOptionsMarkets) }()
        case 27: try { try decoder.decodeRepeatedStringField(value: &_storage._binaryOptionsMarketIdsScheduledForSettlement) }()
        case 28: try { try decoder.decodeRepeatedStringField(value: &_storage._spotMarketIdsScheduledToForceClose) }()
        case 29: try { try decoder.decodeRepeatedMessageField(value: &_storage._denomDecimals) }()
        case 30: try { try decoder.decodeRepeatedMessageField(value: &_storage._conditionalDerivativeOrderbooks) }()
        case 31: try { try decoder.decodeRepeatedMessageField(value: &_storage._marketFeeMultipliers) }()
        case 32: try { try decoder.decodeRepeatedMessageField(value: &_storage._orderbookSequences) }()
        case 33: try { try decoder.decodeRepeatedMessageField(value: &_storage._subaccountVolumes) }()
        case 34: try { try decoder.decodeRepeatedMessageField(value: &_storage._marketVolumes) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._spotMarkets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._spotMarkets, fieldNumber: 2)
      }
      if !_storage._derivativeMarkets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._derivativeMarkets, fieldNumber: 3)
      }
      if !_storage._spotOrderbook.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._spotOrderbook, fieldNumber: 4)
      }
      if !_storage._derivativeOrderbook.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._derivativeOrderbook, fieldNumber: 5)
      }
      if !_storage._balances.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._balances, fieldNumber: 6)
      }
      if !_storage._positions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._positions, fieldNumber: 7)
      }
      if !_storage._subaccountTradeNonces.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._subaccountTradeNonces, fieldNumber: 8)
      }
      if !_storage._expiryFuturesMarketInfoState.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._expiryFuturesMarketInfoState, fieldNumber: 9)
      }
      if !_storage._perpetualMarketInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._perpetualMarketInfo, fieldNumber: 10)
      }
      if !_storage._perpetualMarketFundingState.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._perpetualMarketFundingState, fieldNumber: 11)
      }
      if !_storage._derivativeMarketSettlementScheduled.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._derivativeMarketSettlementScheduled, fieldNumber: 12)
      }
      if _storage._isSpotExchangeEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._isSpotExchangeEnabled, fieldNumber: 13)
      }
      if _storage._isDerivativesExchangeEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._isDerivativesExchangeEnabled, fieldNumber: 14)
      }
      try { if let v = _storage._tradingRewardCampaignInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._tradingRewardPoolCampaignSchedule.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tradingRewardPoolCampaignSchedule, fieldNumber: 16)
      }
      if !_storage._tradingRewardCampaignAccountPoints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tradingRewardCampaignAccountPoints, fieldNumber: 17)
      }
      try { if let v = _storage._feeDiscountSchedule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if !_storage._feeDiscountAccountTierTtl.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._feeDiscountAccountTierTtl, fieldNumber: 19)
      }
      if !_storage._feeDiscountBucketVolumeAccounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._feeDiscountBucketVolumeAccounts, fieldNumber: 20)
      }
      if _storage._isFirstFeeCycleFinished != false {
        try visitor.visitSingularBoolField(value: _storage._isFirstFeeCycleFinished, fieldNumber: 21)
      }
      if !_storage._pendingTradingRewardPoolCampaignSchedule.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingTradingRewardPoolCampaignSchedule, fieldNumber: 22)
      }
      if !_storage._pendingTradingRewardCampaignAccountPoints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingTradingRewardCampaignAccountPoints, fieldNumber: 23)
      }
      if !_storage._rewardsOptOutAddresses.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._rewardsOptOutAddresses, fieldNumber: 24)
      }
      if !_storage._historicalTradeRecords.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._historicalTradeRecords, fieldNumber: 25)
      }
      if !_storage._binaryOptionsMarkets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._binaryOptionsMarkets, fieldNumber: 26)
      }
      if !_storage._binaryOptionsMarketIdsScheduledForSettlement.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._binaryOptionsMarketIdsScheduledForSettlement, fieldNumber: 27)
      }
      if !_storage._spotMarketIdsScheduledToForceClose.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._spotMarketIdsScheduledToForceClose, fieldNumber: 28)
      }
      if !_storage._denomDecimals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._denomDecimals, fieldNumber: 29)
      }
      if !_storage._conditionalDerivativeOrderbooks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._conditionalDerivativeOrderbooks, fieldNumber: 30)
      }
      if !_storage._marketFeeMultipliers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._marketFeeMultipliers, fieldNumber: 31)
      }
      if !_storage._orderbookSequences.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._orderbookSequences, fieldNumber: 32)
      }
      if !_storage._subaccountVolumes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._subaccountVolumes, fieldNumber: 33)
      }
      if !_storage._marketVolumes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._marketVolumes, fieldNumber: 34)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_GenesisState, rhs: Injective_Exchange_V1beta1_GenesisState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._params != rhs_storage._params {return false}
        if _storage._spotMarkets != rhs_storage._spotMarkets {return false}
        if _storage._derivativeMarkets != rhs_storage._derivativeMarkets {return false}
        if _storage._spotOrderbook != rhs_storage._spotOrderbook {return false}
        if _storage._derivativeOrderbook != rhs_storage._derivativeOrderbook {return false}
        if _storage._balances != rhs_storage._balances {return false}
        if _storage._positions != rhs_storage._positions {return false}
        if _storage._subaccountTradeNonces != rhs_storage._subaccountTradeNonces {return false}
        if _storage._expiryFuturesMarketInfoState != rhs_storage._expiryFuturesMarketInfoState {return false}
        if _storage._perpetualMarketInfo != rhs_storage._perpetualMarketInfo {return false}
        if _storage._perpetualMarketFundingState != rhs_storage._perpetualMarketFundingState {return false}
        if _storage._derivativeMarketSettlementScheduled != rhs_storage._derivativeMarketSettlementScheduled {return false}
        if _storage._isSpotExchangeEnabled != rhs_storage._isSpotExchangeEnabled {return false}
        if _storage._isDerivativesExchangeEnabled != rhs_storage._isDerivativesExchangeEnabled {return false}
        if _storage._tradingRewardCampaignInfo != rhs_storage._tradingRewardCampaignInfo {return false}
        if _storage._tradingRewardPoolCampaignSchedule != rhs_storage._tradingRewardPoolCampaignSchedule {return false}
        if _storage._tradingRewardCampaignAccountPoints != rhs_storage._tradingRewardCampaignAccountPoints {return false}
        if _storage._feeDiscountSchedule != rhs_storage._feeDiscountSchedule {return false}
        if _storage._feeDiscountAccountTierTtl != rhs_storage._feeDiscountAccountTierTtl {return false}
        if _storage._feeDiscountBucketVolumeAccounts != rhs_storage._feeDiscountBucketVolumeAccounts {return false}
        if _storage._isFirstFeeCycleFinished != rhs_storage._isFirstFeeCycleFinished {return false}
        if _storage._pendingTradingRewardPoolCampaignSchedule != rhs_storage._pendingTradingRewardPoolCampaignSchedule {return false}
        if _storage._pendingTradingRewardCampaignAccountPoints != rhs_storage._pendingTradingRewardCampaignAccountPoints {return false}
        if _storage._rewardsOptOutAddresses != rhs_storage._rewardsOptOutAddresses {return false}
        if _storage._historicalTradeRecords != rhs_storage._historicalTradeRecords {return false}
        if _storage._binaryOptionsMarkets != rhs_storage._binaryOptionsMarkets {return false}
        if _storage._binaryOptionsMarketIdsScheduledForSettlement != rhs_storage._binaryOptionsMarketIdsScheduledForSettlement {return false}
        if _storage._spotMarketIdsScheduledToForceClose != rhs_storage._spotMarketIdsScheduledToForceClose {return false}
        if _storage._denomDecimals != rhs_storage._denomDecimals {return false}
        if _storage._conditionalDerivativeOrderbooks != rhs_storage._conditionalDerivativeOrderbooks {return false}
        if _storage._marketFeeMultipliers != rhs_storage._marketFeeMultipliers {return false}
        if _storage._orderbookSequences != rhs_storage._orderbookSequences {return false}
        if _storage._subaccountVolumes != rhs_storage._subaccountVolumes {return false}
        if _storage._marketVolumes != rhs_storage._marketVolumes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_OrderbookSequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderbookSequence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sequence"),
    2: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_OrderbookSequence, rhs: Injective_Exchange_V1beta1_OrderbookSequence) -> Bool {
    if lhs.sequence != rhs.sequence {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FeeDiscountAccountTierTTL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeDiscountAccountTierTTL"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "tier_ttl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tierTtl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    try { if let v = self._tierTtl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FeeDiscountAccountTierTTL, rhs: Injective_Exchange_V1beta1_FeeDiscountAccountTierTTL) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs._tierTtl != rhs._tierTtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FeeDiscountBucketVolumeAccounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeDiscountBucketVolumeAccounts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bucket_start_timestamp"),
    2: .standard(proto: "account_volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.bucketStartTimestamp) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.accountVolume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bucketStartTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketStartTimestamp, fieldNumber: 1)
    }
    if !self.accountVolume.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountVolume, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FeeDiscountBucketVolumeAccounts, rhs: Injective_Exchange_V1beta1_FeeDiscountBucketVolumeAccounts) -> Bool {
    if lhs.bucketStartTimestamp != rhs.bucketStartTimestamp {return false}
    if lhs.accountVolume != rhs.accountVolume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_AccountVolume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountVolume"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.volume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.volume.isEmpty {
      try visitor.visitSingularStringField(value: self.volume, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_AccountVolume, rhs: Injective_Exchange_V1beta1_AccountVolume) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingRewardCampaignAccountPoints"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.points) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.points.isEmpty {
      try visitor.visitSingularStringField(value: self.points, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints, rhs: Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradingRewardCampaignAccountPendingPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingRewardCampaignAccountPendingPoints"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reward_pool_start_timestamp"),
    2: .standard(proto: "account_points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.rewardPoolStartTimestamp) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.accountPoints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rewardPoolStartTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.rewardPoolStartTimestamp, fieldNumber: 1)
    }
    if !self.accountPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountPoints, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradingRewardCampaignAccountPendingPoints, rhs: Injective_Exchange_V1beta1_TradingRewardCampaignAccountPendingPoints) -> Bool {
    if lhs.rewardPoolStartTimestamp != rhs.rewardPoolStartTimestamp {return false}
    if lhs.accountPoints != rhs.accountPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotOrderBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotOrderBook"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "isBuySide"),
    3: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isBuySide) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.isBuySide != false {
      try visitor.visitSingularBoolField(value: self.isBuySide, fieldNumber: 2)
    }
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotOrderBook, rhs: Injective_Exchange_V1beta1_SpotOrderBook) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.isBuySide != rhs.isBuySide {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeOrderBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeOrderBook"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "isBuySide"),
    3: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isBuySide) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.isBuySide != false {
      try visitor.visitSingularBoolField(value: self.isBuySide, fieldNumber: 2)
    }
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeOrderBook, rhs: Injective_Exchange_V1beta1_DerivativeOrderBook) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.isBuySide != rhs.isBuySide {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_ConditionalDerivativeOrderBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConditionalDerivativeOrderBook"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "limit_buy_orders"),
    3: .standard(proto: "market_buy_orders"),
    4: .standard(proto: "limit_sell_orders"),
    5: .standard(proto: "market_sell_orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.limitBuyOrders) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.marketBuyOrders) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.limitSellOrders) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.marketSellOrders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.limitBuyOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.limitBuyOrders, fieldNumber: 2)
    }
    if !self.marketBuyOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.marketBuyOrders, fieldNumber: 3)
    }
    if !self.limitSellOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.limitSellOrders, fieldNumber: 4)
    }
    if !self.marketSellOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.marketSellOrders, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_ConditionalDerivativeOrderBook, rhs: Injective_Exchange_V1beta1_ConditionalDerivativeOrderBook) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.limitBuyOrders != rhs.limitBuyOrders {return false}
    if lhs.marketBuyOrders != rhs.marketBuyOrders {return false}
    if lhs.limitSellOrders != rhs.limitSellOrders {return false}
    if lhs.marketSellOrders != rhs.marketSellOrders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_Balance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Balance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .same(proto: "denom"),
    3: .same(proto: "deposits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._deposits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    try { if let v = self._deposits {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_Balance, rhs: Injective_Exchange_V1beta1_Balance) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs._deposits != rhs._deposits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativePosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativePosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "market_id"),
    3: .same(proto: "position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativePosition, rhs: Injective_Exchange_V1beta1_DerivativePosition) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountNonce: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountNonce"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "subaccount_trade_nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._subaccountTradeNonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    try { if let v = self._subaccountTradeNonce {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountNonce, rhs: Injective_Exchange_V1beta1_SubaccountNonce) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs._subaccountTradeNonce != rhs._subaccountTradeNonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_ExpiryFuturesMarketInfoState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpiryFuturesMarketInfoState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "market_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._marketInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try { if let v = self._marketInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfoState, rhs: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfoState) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._marketInfo != rhs._marketInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PerpetualMarketFundingState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PerpetualMarketFundingState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "funding"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._funding) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try { if let v = self._funding {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PerpetualMarketFundingState, rhs: Injective_Exchange_V1beta1_PerpetualMarketFundingState) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._funding != rhs._funding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
