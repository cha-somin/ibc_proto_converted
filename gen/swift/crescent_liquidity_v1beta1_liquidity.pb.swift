// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: crescent/liquidity/v1beta1/liquidity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// PoolType enumerates pool types.
enum Crescent_Liquidity_V1beta1_PoolType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// POOL_TYPE_UNSPECIFIED specifies unknown pool type
  case unspecified // = 0

  /// POOL_TYPE_BASIC specifies the basic pool type
  case basic // = 1

  /// POOL_TYPE_RANGED specifies the ranged pool type
  case ranged // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .basic
    case 2: self = .ranged
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .basic: return 1
    case .ranged: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Crescent_Liquidity_V1beta1_PoolType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Crescent_Liquidity_V1beta1_PoolType] = [
    .unspecified,
    .basic,
    .ranged,
  ]
}

#endif  // swift(>=4.2)

/// OrderType enumerates order types.
enum Crescent_Liquidity_V1beta1_OrderType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// ORDER_TYPE_UNSPECIFIED specifies unknown order type.
  case unspecified // = 0

  /// ORDER_TYPE_LIMIT specifies limit order type.
  case limit // = 1

  /// ORDER_TYPE_MARKET specifies market order type.
  case market // = 2

  /// ORDER_TYPE_MM specifies MM(market making) order type.
  case mm // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .limit
    case 2: self = .market
    case 3: self = .mm
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .limit: return 1
    case .market: return 2
    case .mm: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Crescent_Liquidity_V1beta1_OrderType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Crescent_Liquidity_V1beta1_OrderType] = [
    .unspecified,
    .limit,
    .market,
    .mm,
  ]
}

#endif  // swift(>=4.2)

/// OrderDirection enumerates order directions.
enum Crescent_Liquidity_V1beta1_OrderDirection: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// ORDER_DIRECTION_UNSPECIFIED specifies unknown order direction
  case unspecified // = 0

  /// ORDER_DIRECTION_BUY specifies buy(swap quote coin to base coin) order direction
  case buy // = 1

  /// ORDER_DIRECTION_SELL specifies sell(swap base coin to quote coin) order direction
  case sell // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .buy
    case 2: self = .sell
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .buy: return 1
    case .sell: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Crescent_Liquidity_V1beta1_OrderDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Crescent_Liquidity_V1beta1_OrderDirection] = [
    .unspecified,
    .buy,
    .sell,
  ]
}

#endif  // swift(>=4.2)

/// RequestStatus enumerates request statuses.
enum Crescent_Liquidity_V1beta1_RequestStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// REQUEST_STATUS_UNSPECIFIED specifies unknown request status
  case unspecified // = 0

  /// REQUEST_STATUS_NOT_EXECUTED indicates the request is not executed yet
  case notExecuted // = 1

  /// REQUEST_STATUS_SUCCEEDED indicates the request has been succeeded
  case succeeded // = 2

  /// REQUEST_STATUS_FAILED indicates the request is failed
  case failed // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notExecuted
    case 2: self = .succeeded
    case 3: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notExecuted: return 1
    case .succeeded: return 2
    case .failed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Crescent_Liquidity_V1beta1_RequestStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Crescent_Liquidity_V1beta1_RequestStatus] = [
    .unspecified,
    .notExecuted,
    .succeeded,
    .failed,
  ]
}

#endif  // swift(>=4.2)

/// OrderStatus enumerates order statuses.
enum Crescent_Liquidity_V1beta1_OrderStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// ORDER_STATUS_UNSPECIFIED specifies unknown order status
  case unspecified // = 0

  /// ORDER_STATUS_NOT_EXECUTED indicates the order has not been executed yet
  case notExecuted // = 1

  /// ORDER_STATUS_NOT_MATCHED indicates the order has been executed but has no match
  case notMatched // = 2

  /// ORDER_STATUS_PARTIALLY_MATCHED indicates the order has been partially matched
  case partiallyMatched // = 3

  /// ORDER_STATUS_COMPLETED indicates the order has been fully matched and completed
  case completed // = 4

  /// ORDER_STATUS_CANCELED indicates the order has been canceled
  case canceled // = 5

  /// ORDER_STATUS_EXPIRED indicates the order has been expired
  case expired // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notExecuted
    case 2: self = .notMatched
    case 3: self = .partiallyMatched
    case 4: self = .completed
    case 5: self = .canceled
    case 6: self = .expired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notExecuted: return 1
    case .notMatched: return 2
    case .partiallyMatched: return 3
    case .completed: return 4
    case .canceled: return 5
    case .expired: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Crescent_Liquidity_V1beta1_OrderStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Crescent_Liquidity_V1beta1_OrderStatus] = [
    .unspecified,
    .notExecuted,
    .notMatched,
    .partiallyMatched,
    .completed,
    .canceled,
    .expired,
  ]
}

#endif  // swift(>=4.2)

/// Params defines the parameters for the liquidity module.
struct Crescent_Liquidity_V1beta1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var batchSize: UInt32 {
    get {return _storage._batchSize}
    set {_uniqueStorage()._batchSize = newValue}
  }

  var tickPrecision: UInt32 {
    get {return _storage._tickPrecision}
    set {_uniqueStorage()._tickPrecision = newValue}
  }

  var feeCollectorAddress: String {
    get {return _storage._feeCollectorAddress}
    set {_uniqueStorage()._feeCollectorAddress = newValue}
  }

  var dustCollectorAddress: String {
    get {return _storage._dustCollectorAddress}
    set {_uniqueStorage()._dustCollectorAddress = newValue}
  }

  var minInitialPoolCoinSupply: String {
    get {return _storage._minInitialPoolCoinSupply}
    set {_uniqueStorage()._minInitialPoolCoinSupply = newValue}
  }

  var pairCreationFee: [Cosmos_Base_V1beta1_Coin] {
    get {return _storage._pairCreationFee}
    set {_uniqueStorage()._pairCreationFee = newValue}
  }

  var poolCreationFee: [Cosmos_Base_V1beta1_Coin] {
    get {return _storage._poolCreationFee}
    set {_uniqueStorage()._poolCreationFee = newValue}
  }

  var minInitialDepositAmount: String {
    get {return _storage._minInitialDepositAmount}
    set {_uniqueStorage()._minInitialDepositAmount = newValue}
  }

  var maxPriceLimitRatio: String {
    get {return _storage._maxPriceLimitRatio}
    set {_uniqueStorage()._maxPriceLimitRatio = newValue}
  }

  var maxNumMarketMakingOrderTicks: UInt32 {
    get {return _storage._maxNumMarketMakingOrderTicks}
    set {_uniqueStorage()._maxNumMarketMakingOrderTicks = newValue}
  }

  var maxNumMarketMakingOrdersPerPair: UInt32 {
    get {return _storage._maxNumMarketMakingOrdersPerPair}
    set {_uniqueStorage()._maxNumMarketMakingOrdersPerPair = newValue}
  }

  var maxOrderLifespan: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._maxOrderLifespan ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._maxOrderLifespan = newValue}
  }
  /// Returns true if `maxOrderLifespan` has been explicitly set.
  var hasMaxOrderLifespan: Bool {return _storage._maxOrderLifespan != nil}
  /// Clears the value of `maxOrderLifespan`. Subsequent reads from it will return its default value.
  mutating func clearMaxOrderLifespan() {_uniqueStorage()._maxOrderLifespan = nil}

  var swapFeeRate: String {
    get {return _storage._swapFeeRate}
    set {_uniqueStorage()._swapFeeRate = newValue}
  }

  var withdrawFeeRate: String {
    get {return _storage._withdrawFeeRate}
    set {_uniqueStorage()._withdrawFeeRate = newValue}
  }

  var depositExtraGas: UInt64 {
    get {return _storage._depositExtraGas}
    set {_uniqueStorage()._depositExtraGas = newValue}
  }

  var withdrawExtraGas: UInt64 {
    get {return _storage._withdrawExtraGas}
    set {_uniqueStorage()._withdrawExtraGas = newValue}
  }

  var orderExtraGas: UInt64 {
    get {return _storage._orderExtraGas}
    set {_uniqueStorage()._orderExtraGas = newValue}
  }

  var maxNumActivePoolsPerPair: UInt32 {
    get {return _storage._maxNumActivePoolsPerPair}
    set {_uniqueStorage()._maxNumActivePoolsPerPair = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Pair defines a coin pair.
struct Crescent_Liquidity_V1beta1_Pair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var baseCoinDenom: String = String()

  var quoteCoinDenom: String = String()

  var escrowAddress: String = String()

  var lastOrderID: UInt64 = 0

  var lastPrice: String = String()

  var currentBatchID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Pool defines generic liquidity pool object which can be either a basic pool or a
/// ranged pool.
struct Crescent_Liquidity_V1beta1_Pool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Crescent_Liquidity_V1beta1_PoolType = .unspecified

  var id: UInt64 = 0

  var pairID: UInt64 = 0

  var creator: String = String()

  var reserveAddress: String = String()

  var poolCoinDenom: String = String()

  var minPrice: String = String()

  var maxPrice: String = String()

  var lastDepositRequestID: UInt64 = 0

  var lastWithdrawRequestID: UInt64 = 0

  var disabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DepositRequest defines a deposit request.
struct Crescent_Liquidity_V1beta1_DepositRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id specifies the id for the request
  var id: UInt64 = 0

  /// pool_id specifies the pool id
  var poolID: UInt64 = 0

  /// msg_height specifies the block height when the request is stored for the batch execution
  var msgHeight: Int64 = 0

  /// depositor specifies the bech32-encoded address that makes a deposit to the pool
  var depositor: String = String()

  /// deposit_coins specifies the amount of coins to deposit.
  var depositCoins: [Cosmos_Base_V1beta1_Coin] = []

  /// accepted_coins specifies the amount of coins that are accepted.
  var acceptedCoins: [Cosmos_Base_V1beta1_Coin] = []

  var mintedPoolCoin: Cosmos_Base_V1beta1_Coin {
    get {return _mintedPoolCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_mintedPoolCoin = newValue}
  }
  /// Returns true if `mintedPoolCoin` has been explicitly set.
  var hasMintedPoolCoin: Bool {return self._mintedPoolCoin != nil}
  /// Clears the value of `mintedPoolCoin`. Subsequent reads from it will return its default value.
  mutating func clearMintedPoolCoin() {self._mintedPoolCoin = nil}

  var status: Crescent_Liquidity_V1beta1_RequestStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mintedPoolCoin: Cosmos_Base_V1beta1_Coin? = nil
}

/// WithdrawRequest defines a withdraw request.
struct Crescent_Liquidity_V1beta1_WithdrawRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id specifies the id for the request
  var id: UInt64 = 0

  /// pool_id specifies the pool id
  var poolID: UInt64 = 0

  /// msg_height specifies the block height when the request is stored for the batch execution
  var msgHeight: Int64 = 0

  /// withdrawer specifies the bech32-encoded address that withdraws pool coin from the pool
  var withdrawer: String = String()

  /// pool_coin specifies the pool coin that is a proof of liquidity provider for the pool
  var poolCoin: Cosmos_Base_V1beta1_Coin {
    get {return _poolCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_poolCoin = newValue}
  }
  /// Returns true if `poolCoin` has been explicitly set.
  var hasPoolCoin: Bool {return self._poolCoin != nil}
  /// Clears the value of `poolCoin`. Subsequent reads from it will return its default value.
  mutating func clearPoolCoin() {self._poolCoin = nil}

  /// withdrawn_coins specifies the amount of coins that are withdrawn.
  var withdrawnCoins: [Cosmos_Base_V1beta1_Coin] = []

  var status: Crescent_Liquidity_V1beta1_RequestStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _poolCoin: Cosmos_Base_V1beta1_Coin? = nil
}

/// Order defines an order.
struct Crescent_Liquidity_V1beta1_Order {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// type specifies the typo of the order
  var type: Crescent_Liquidity_V1beta1_OrderType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// id specifies the id of the order
  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// pair_id specifies the pair id
  var pairID: UInt64 {
    get {return _storage._pairID}
    set {_uniqueStorage()._pairID = newValue}
  }

  /// msg_height specifies the block height when the order is stored for the batch execution
  var msgHeight: Int64 {
    get {return _storage._msgHeight}
    set {_uniqueStorage()._msgHeight = newValue}
  }

  /// orderer specifies the bech32-encoded address that makes an order
  var orderer: String {
    get {return _storage._orderer}
    set {_uniqueStorage()._orderer = newValue}
  }

  /// direction specifies the order direction; either buy or sell
  var direction: Crescent_Liquidity_V1beta1_OrderDirection {
    get {return _storage._direction}
    set {_uniqueStorage()._direction = newValue}
  }

  var offerCoin: Cosmos_Base_V1beta1_Coin {
    get {return _storage._offerCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._offerCoin = newValue}
  }
  /// Returns true if `offerCoin` has been explicitly set.
  var hasOfferCoin: Bool {return _storage._offerCoin != nil}
  /// Clears the value of `offerCoin`. Subsequent reads from it will return its default value.
  mutating func clearOfferCoin() {_uniqueStorage()._offerCoin = nil}

  /// remaining_offer_coin specifies the remaining offer coin
  var remainingOfferCoin: Cosmos_Base_V1beta1_Coin {
    get {return _storage._remainingOfferCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._remainingOfferCoin = newValue}
  }
  /// Returns true if `remainingOfferCoin` has been explicitly set.
  var hasRemainingOfferCoin: Bool {return _storage._remainingOfferCoin != nil}
  /// Clears the value of `remainingOfferCoin`. Subsequent reads from it will return its default value.
  mutating func clearRemainingOfferCoin() {_uniqueStorage()._remainingOfferCoin = nil}

  /// received_coin specifies the received coin after the swap
  var receivedCoin: Cosmos_Base_V1beta1_Coin {
    get {return _storage._receivedCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._receivedCoin = newValue}
  }
  /// Returns true if `receivedCoin` has been explicitly set.
  var hasReceivedCoin: Bool {return _storage._receivedCoin != nil}
  /// Clears the value of `receivedCoin`. Subsequent reads from it will return its default value.
  mutating func clearReceivedCoin() {_uniqueStorage()._receivedCoin = nil}

  /// price specifies the price that an orderer is willing to swap
  var price: String {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  var amount: String {
    get {return _storage._amount}
    set {_uniqueStorage()._amount = newValue}
  }

  var openAmount: String {
    get {return _storage._openAmount}
    set {_uniqueStorage()._openAmount = newValue}
  }

  /// batch_id specifies the pair's batch id when the request is stored
  var batchID: UInt64 {
    get {return _storage._batchID}
    set {_uniqueStorage()._batchID = newValue}
  }

  var expireAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expireAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expireAt = newValue}
  }
  /// Returns true if `expireAt` has been explicitly set.
  var hasExpireAt: Bool {return _storage._expireAt != nil}
  /// Clears the value of `expireAt`. Subsequent reads from it will return its default value.
  mutating func clearExpireAt() {_uniqueStorage()._expireAt = nil}

  var status: Crescent_Liquidity_V1beta1_OrderStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Crescent_Liquidity_V1beta1_PoolType: @unchecked Sendable {}
extension Crescent_Liquidity_V1beta1_OrderType: @unchecked Sendable {}
extension Crescent_Liquidity_V1beta1_OrderDirection: @unchecked Sendable {}
extension Crescent_Liquidity_V1beta1_RequestStatus: @unchecked Sendable {}
extension Crescent_Liquidity_V1beta1_OrderStatus: @unchecked Sendable {}
extension Crescent_Liquidity_V1beta1_Params: @unchecked Sendable {}
extension Crescent_Liquidity_V1beta1_Pair: @unchecked Sendable {}
extension Crescent_Liquidity_V1beta1_Pool: @unchecked Sendable {}
extension Crescent_Liquidity_V1beta1_DepositRequest: @unchecked Sendable {}
extension Crescent_Liquidity_V1beta1_WithdrawRequest: @unchecked Sendable {}
extension Crescent_Liquidity_V1beta1_Order: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "crescent.liquidity.v1beta1"

extension Crescent_Liquidity_V1beta1_PoolType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POOL_TYPE_UNSPECIFIED"),
    1: .same(proto: "POOL_TYPE_BASIC"),
    2: .same(proto: "POOL_TYPE_RANGED"),
  ]
}

extension Crescent_Liquidity_V1beta1_OrderType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_TYPE_UNSPECIFIED"),
    1: .same(proto: "ORDER_TYPE_LIMIT"),
    2: .same(proto: "ORDER_TYPE_MARKET"),
    3: .same(proto: "ORDER_TYPE_MM"),
  ]
}

extension Crescent_Liquidity_V1beta1_OrderDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_DIRECTION_UNSPECIFIED"),
    1: .same(proto: "ORDER_DIRECTION_BUY"),
    2: .same(proto: "ORDER_DIRECTION_SELL"),
  ]
}

extension Crescent_Liquidity_V1beta1_RequestStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUEST_STATUS_UNSPECIFIED"),
    1: .same(proto: "REQUEST_STATUS_NOT_EXECUTED"),
    2: .same(proto: "REQUEST_STATUS_SUCCEEDED"),
    3: .same(proto: "REQUEST_STATUS_FAILED"),
  ]
}

extension Crescent_Liquidity_V1beta1_OrderStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_STATUS_UNSPECIFIED"),
    1: .same(proto: "ORDER_STATUS_NOT_EXECUTED"),
    2: .same(proto: "ORDER_STATUS_NOT_MATCHED"),
    3: .same(proto: "ORDER_STATUS_PARTIALLY_MATCHED"),
    4: .same(proto: "ORDER_STATUS_COMPLETED"),
    5: .same(proto: "ORDER_STATUS_CANCELED"),
    6: .same(proto: "ORDER_STATUS_EXPIRED"),
  ]
}

extension Crescent_Liquidity_V1beta1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_size"),
    2: .standard(proto: "tick_precision"),
    3: .standard(proto: "fee_collector_address"),
    4: .standard(proto: "dust_collector_address"),
    5: .standard(proto: "min_initial_pool_coin_supply"),
    6: .standard(proto: "pair_creation_fee"),
    7: .standard(proto: "pool_creation_fee"),
    8: .standard(proto: "min_initial_deposit_amount"),
    9: .standard(proto: "max_price_limit_ratio"),
    10: .standard(proto: "max_num_market_making_order_ticks"),
    11: .standard(proto: "max_num_market_making_orders_per_pair"),
    12: .standard(proto: "max_order_lifespan"),
    13: .standard(proto: "swap_fee_rate"),
    14: .standard(proto: "withdraw_fee_rate"),
    15: .standard(proto: "deposit_extra_gas"),
    16: .standard(proto: "withdraw_extra_gas"),
    17: .standard(proto: "order_extra_gas"),
    18: .standard(proto: "max_num_active_pools_per_pair"),
  ]

  fileprivate class _StorageClass {
    var _batchSize: UInt32 = 0
    var _tickPrecision: UInt32 = 0
    var _feeCollectorAddress: String = String()
    var _dustCollectorAddress: String = String()
    var _minInitialPoolCoinSupply: String = String()
    var _pairCreationFee: [Cosmos_Base_V1beta1_Coin] = []
    var _poolCreationFee: [Cosmos_Base_V1beta1_Coin] = []
    var _minInitialDepositAmount: String = String()
    var _maxPriceLimitRatio: String = String()
    var _maxNumMarketMakingOrderTicks: UInt32 = 0
    var _maxNumMarketMakingOrdersPerPair: UInt32 = 0
    var _maxOrderLifespan: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _swapFeeRate: String = String()
    var _withdrawFeeRate: String = String()
    var _depositExtraGas: UInt64 = 0
    var _withdrawExtraGas: UInt64 = 0
    var _orderExtraGas: UInt64 = 0
    var _maxNumActivePoolsPerPair: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _batchSize = source._batchSize
      _tickPrecision = source._tickPrecision
      _feeCollectorAddress = source._feeCollectorAddress
      _dustCollectorAddress = source._dustCollectorAddress
      _minInitialPoolCoinSupply = source._minInitialPoolCoinSupply
      _pairCreationFee = source._pairCreationFee
      _poolCreationFee = source._poolCreationFee
      _minInitialDepositAmount = source._minInitialDepositAmount
      _maxPriceLimitRatio = source._maxPriceLimitRatio
      _maxNumMarketMakingOrderTicks = source._maxNumMarketMakingOrderTicks
      _maxNumMarketMakingOrdersPerPair = source._maxNumMarketMakingOrdersPerPair
      _maxOrderLifespan = source._maxOrderLifespan
      _swapFeeRate = source._swapFeeRate
      _withdrawFeeRate = source._withdrawFeeRate
      _depositExtraGas = source._depositExtraGas
      _withdrawExtraGas = source._withdrawExtraGas
      _orderExtraGas = source._orderExtraGas
      _maxNumActivePoolsPerPair = source._maxNumActivePoolsPerPair
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._batchSize) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._tickPrecision) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._feeCollectorAddress) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._dustCollectorAddress) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._minInitialPoolCoinSupply) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._pairCreationFee) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._poolCreationFee) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._minInitialDepositAmount) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._maxPriceLimitRatio) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxNumMarketMakingOrderTicks) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxNumMarketMakingOrdersPerPair) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._maxOrderLifespan) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._swapFeeRate) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._withdrawFeeRate) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._depositExtraGas) }()
        case 16: try { try decoder.decodeSingularUInt64Field(value: &_storage._withdrawExtraGas) }()
        case 17: try { try decoder.decodeSingularUInt64Field(value: &_storage._orderExtraGas) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxNumActivePoolsPerPair) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._batchSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._batchSize, fieldNumber: 1)
      }
      if _storage._tickPrecision != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._tickPrecision, fieldNumber: 2)
      }
      if !_storage._feeCollectorAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._feeCollectorAddress, fieldNumber: 3)
      }
      if !_storage._dustCollectorAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dustCollectorAddress, fieldNumber: 4)
      }
      if !_storage._minInitialPoolCoinSupply.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minInitialPoolCoinSupply, fieldNumber: 5)
      }
      if !_storage._pairCreationFee.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pairCreationFee, fieldNumber: 6)
      }
      if !_storage._poolCreationFee.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._poolCreationFee, fieldNumber: 7)
      }
      if !_storage._minInitialDepositAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minInitialDepositAmount, fieldNumber: 8)
      }
      if !_storage._maxPriceLimitRatio.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxPriceLimitRatio, fieldNumber: 9)
      }
      if _storage._maxNumMarketMakingOrderTicks != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxNumMarketMakingOrderTicks, fieldNumber: 10)
      }
      if _storage._maxNumMarketMakingOrdersPerPair != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxNumMarketMakingOrdersPerPair, fieldNumber: 11)
      }
      try { if let v = _storage._maxOrderLifespan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._swapFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._swapFeeRate, fieldNumber: 13)
      }
      if !_storage._withdrawFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._withdrawFeeRate, fieldNumber: 14)
      }
      if _storage._depositExtraGas != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._depositExtraGas, fieldNumber: 15)
      }
      if _storage._withdrawExtraGas != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._withdrawExtraGas, fieldNumber: 16)
      }
      if _storage._orderExtraGas != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._orderExtraGas, fieldNumber: 17)
      }
      if _storage._maxNumActivePoolsPerPair != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxNumActivePoolsPerPair, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Crescent_Liquidity_V1beta1_Params, rhs: Crescent_Liquidity_V1beta1_Params) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._batchSize != rhs_storage._batchSize {return false}
        if _storage._tickPrecision != rhs_storage._tickPrecision {return false}
        if _storage._feeCollectorAddress != rhs_storage._feeCollectorAddress {return false}
        if _storage._dustCollectorAddress != rhs_storage._dustCollectorAddress {return false}
        if _storage._minInitialPoolCoinSupply != rhs_storage._minInitialPoolCoinSupply {return false}
        if _storage._pairCreationFee != rhs_storage._pairCreationFee {return false}
        if _storage._poolCreationFee != rhs_storage._poolCreationFee {return false}
        if _storage._minInitialDepositAmount != rhs_storage._minInitialDepositAmount {return false}
        if _storage._maxPriceLimitRatio != rhs_storage._maxPriceLimitRatio {return false}
        if _storage._maxNumMarketMakingOrderTicks != rhs_storage._maxNumMarketMakingOrderTicks {return false}
        if _storage._maxNumMarketMakingOrdersPerPair != rhs_storage._maxNumMarketMakingOrdersPerPair {return false}
        if _storage._maxOrderLifespan != rhs_storage._maxOrderLifespan {return false}
        if _storage._swapFeeRate != rhs_storage._swapFeeRate {return false}
        if _storage._withdrawFeeRate != rhs_storage._withdrawFeeRate {return false}
        if _storage._depositExtraGas != rhs_storage._depositExtraGas {return false}
        if _storage._withdrawExtraGas != rhs_storage._withdrawExtraGas {return false}
        if _storage._orderExtraGas != rhs_storage._orderExtraGas {return false}
        if _storage._maxNumActivePoolsPerPair != rhs_storage._maxNumActivePoolsPerPair {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Crescent_Liquidity_V1beta1_Pair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "base_coin_denom"),
    3: .standard(proto: "quote_coin_denom"),
    4: .standard(proto: "escrow_address"),
    5: .standard(proto: "last_order_id"),
    6: .standard(proto: "last_price"),
    7: .standard(proto: "current_batch_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.baseCoinDenom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quoteCoinDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.escrowAddress) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.lastOrderID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.lastPrice) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.currentBatchID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.baseCoinDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.baseCoinDenom, fieldNumber: 2)
    }
    if !self.quoteCoinDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteCoinDenom, fieldNumber: 3)
    }
    if !self.escrowAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.escrowAddress, fieldNumber: 4)
    }
    if self.lastOrderID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastOrderID, fieldNumber: 5)
    }
    if !self.lastPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.lastPrice, fieldNumber: 6)
    }
    if self.currentBatchID != 0 {
      try visitor.visitSingularUInt64Field(value: self.currentBatchID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Crescent_Liquidity_V1beta1_Pair, rhs: Crescent_Liquidity_V1beta1_Pair) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.baseCoinDenom != rhs.baseCoinDenom {return false}
    if lhs.quoteCoinDenom != rhs.quoteCoinDenom {return false}
    if lhs.escrowAddress != rhs.escrowAddress {return false}
    if lhs.lastOrderID != rhs.lastOrderID {return false}
    if lhs.lastPrice != rhs.lastPrice {return false}
    if lhs.currentBatchID != rhs.currentBatchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Crescent_Liquidity_V1beta1_Pool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .standard(proto: "pair_id"),
    4: .same(proto: "creator"),
    5: .standard(proto: "reserve_address"),
    6: .standard(proto: "pool_coin_denom"),
    7: .standard(proto: "min_price"),
    8: .standard(proto: "max_price"),
    9: .standard(proto: "last_deposit_request_id"),
    10: .standard(proto: "last_withdraw_request_id"),
    11: .same(proto: "disabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.pairID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.reserveAddress) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.poolCoinDenom) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.minPrice) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.maxPrice) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.lastDepositRequestID) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.lastWithdrawRequestID) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    if self.pairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pairID, fieldNumber: 3)
    }
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 4)
    }
    if !self.reserveAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.reserveAddress, fieldNumber: 5)
    }
    if !self.poolCoinDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.poolCoinDenom, fieldNumber: 6)
    }
    if !self.minPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.minPrice, fieldNumber: 7)
    }
    if !self.maxPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.maxPrice, fieldNumber: 8)
    }
    if self.lastDepositRequestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastDepositRequestID, fieldNumber: 9)
    }
    if self.lastWithdrawRequestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastWithdrawRequestID, fieldNumber: 10)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Crescent_Liquidity_V1beta1_Pool, rhs: Crescent_Liquidity_V1beta1_Pool) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.pairID != rhs.pairID {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.reserveAddress != rhs.reserveAddress {return false}
    if lhs.poolCoinDenom != rhs.poolCoinDenom {return false}
    if lhs.minPrice != rhs.minPrice {return false}
    if lhs.maxPrice != rhs.maxPrice {return false}
    if lhs.lastDepositRequestID != rhs.lastDepositRequestID {return false}
    if lhs.lastWithdrawRequestID != rhs.lastWithdrawRequestID {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Crescent_Liquidity_V1beta1_DepositRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DepositRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pool_id"),
    3: .standard(proto: "msg_height"),
    4: .same(proto: "depositor"),
    5: .standard(proto: "deposit_coins"),
    6: .standard(proto: "accepted_coins"),
    7: .standard(proto: "minted_pool_coin"),
    8: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.msgHeight) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.depositor) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.depositCoins) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.acceptedCoins) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._mintedPoolCoin) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 2)
    }
    if self.msgHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.msgHeight, fieldNumber: 3)
    }
    if !self.depositor.isEmpty {
      try visitor.visitSingularStringField(value: self.depositor, fieldNumber: 4)
    }
    if !self.depositCoins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.depositCoins, fieldNumber: 5)
    }
    if !self.acceptedCoins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.acceptedCoins, fieldNumber: 6)
    }
    try { if let v = self._mintedPoolCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Crescent_Liquidity_V1beta1_DepositRequest, rhs: Crescent_Liquidity_V1beta1_DepositRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs.msgHeight != rhs.msgHeight {return false}
    if lhs.depositor != rhs.depositor {return false}
    if lhs.depositCoins != rhs.depositCoins {return false}
    if lhs.acceptedCoins != rhs.acceptedCoins {return false}
    if lhs._mintedPoolCoin != rhs._mintedPoolCoin {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Crescent_Liquidity_V1beta1_WithdrawRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WithdrawRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pool_id"),
    3: .standard(proto: "msg_height"),
    4: .same(proto: "withdrawer"),
    5: .standard(proto: "pool_coin"),
    6: .standard(proto: "withdrawn_coins"),
    7: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.msgHeight) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.withdrawer) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._poolCoin) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.withdrawnCoins) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 2)
    }
    if self.msgHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.msgHeight, fieldNumber: 3)
    }
    if !self.withdrawer.isEmpty {
      try visitor.visitSingularStringField(value: self.withdrawer, fieldNumber: 4)
    }
    try { if let v = self._poolCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.withdrawnCoins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.withdrawnCoins, fieldNumber: 6)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Crescent_Liquidity_V1beta1_WithdrawRequest, rhs: Crescent_Liquidity_V1beta1_WithdrawRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs.msgHeight != rhs.msgHeight {return false}
    if lhs.withdrawer != rhs.withdrawer {return false}
    if lhs._poolCoin != rhs._poolCoin {return false}
    if lhs.withdrawnCoins != rhs.withdrawnCoins {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Crescent_Liquidity_V1beta1_Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Order"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .standard(proto: "pair_id"),
    4: .standard(proto: "msg_height"),
    5: .same(proto: "orderer"),
    6: .same(proto: "direction"),
    7: .standard(proto: "offer_coin"),
    8: .standard(proto: "remaining_offer_coin"),
    9: .standard(proto: "received_coin"),
    10: .same(proto: "price"),
    11: .same(proto: "amount"),
    12: .standard(proto: "open_amount"),
    13: .standard(proto: "batch_id"),
    14: .standard(proto: "expire_at"),
    15: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _type: Crescent_Liquidity_V1beta1_OrderType = .unspecified
    var _id: UInt64 = 0
    var _pairID: UInt64 = 0
    var _msgHeight: Int64 = 0
    var _orderer: String = String()
    var _direction: Crescent_Liquidity_V1beta1_OrderDirection = .unspecified
    var _offerCoin: Cosmos_Base_V1beta1_Coin? = nil
    var _remainingOfferCoin: Cosmos_Base_V1beta1_Coin? = nil
    var _receivedCoin: Cosmos_Base_V1beta1_Coin? = nil
    var _price: String = String()
    var _amount: String = String()
    var _openAmount: String = String()
    var _batchID: UInt64 = 0
    var _expireAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _status: Crescent_Liquidity_V1beta1_OrderStatus = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _id = source._id
      _pairID = source._pairID
      _msgHeight = source._msgHeight
      _orderer = source._orderer
      _direction = source._direction
      _offerCoin = source._offerCoin
      _remainingOfferCoin = source._remainingOfferCoin
      _receivedCoin = source._receivedCoin
      _price = source._price
      _amount = source._amount
      _openAmount = source._openAmount
      _batchID = source._batchID
      _expireAt = source._expireAt
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._pairID) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._msgHeight) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._orderer) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._direction) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._offerCoin) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._remainingOfferCoin) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._receivedCoin) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._price) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._amount) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._openAmount) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._batchID) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._expireAt) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 2)
      }
      if _storage._pairID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._pairID, fieldNumber: 3)
      }
      if _storage._msgHeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._msgHeight, fieldNumber: 4)
      }
      if !_storage._orderer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._orderer, fieldNumber: 5)
      }
      if _storage._direction != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._direction, fieldNumber: 6)
      }
      try { if let v = _storage._offerCoin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._remainingOfferCoin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._receivedCoin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._price.isEmpty {
        try visitor.visitSingularStringField(value: _storage._price, fieldNumber: 10)
      }
      if !_storage._amount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._amount, fieldNumber: 11)
      }
      if !_storage._openAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._openAmount, fieldNumber: 12)
      }
      if _storage._batchID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._batchID, fieldNumber: 13)
      }
      try { if let v = _storage._expireAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Crescent_Liquidity_V1beta1_Order, rhs: Crescent_Liquidity_V1beta1_Order) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._pairID != rhs_storage._pairID {return false}
        if _storage._msgHeight != rhs_storage._msgHeight {return false}
        if _storage._orderer != rhs_storage._orderer {return false}
        if _storage._direction != rhs_storage._direction {return false}
        if _storage._offerCoin != rhs_storage._offerCoin {return false}
        if _storage._remainingOfferCoin != rhs_storage._remainingOfferCoin {return false}
        if _storage._receivedCoin != rhs_storage._receivedCoin {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._openAmount != rhs_storage._openAmount {return false}
        if _storage._batchID != rhs_storage._batchID {return false}
        if _storage._expireAt != rhs_storage._expireAt {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
