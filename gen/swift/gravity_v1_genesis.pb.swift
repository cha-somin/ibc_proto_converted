// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: gravity/v1/genesis.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The slashing fractions for the various gravity related slashing conditions. The first three
/// refer to not submitting a particular message, the third for submitting a different claim
/// for the same Ethereum event
///
/// unbond_slashing_valsets_window
///
/// The unbond slashing valsets window is used to determine how many blocks after starting to unbond
/// a validator needs to continue signing blocks. The goal of this paramater is that when a validator leaves
/// the set, if their leaving creates enough change in the validator set to justify an update they will sign
/// a validator set update for the Ethereum bridge that does not include themselves. Allowing us to remove them
/// from the Ethereum bridge and replace them with the new set gracefully.
///
/// valset_reward
///
/// These parameters allow for the bridge oracle to resolve a fork on the Ethereum chain without halting
/// the chain. Once set reset bridge state will roll back events to the nonce provided in reset_bridge_nonce
/// if and only if those events have not yet been observed (executed on the Cosmos chain). This allows for easy
/// handling of cases where for example an Ethereum hardfork has occured and more than 1/3 of the vlaidtor set
/// disagrees with the rest. Normally this would require a chain halt, manual genesis editing and restar to resolve
/// with this feature a governance proposal can be used instead
///
/// bridge_active
///
/// This boolean flag can be used by governance to temporarily halt the bridge due to a vulnerability or other issue
/// In this context halting the bridge means prevent the execution of any oracle events from Ethereum and preventing
/// the creation of new batches that may be relayed to Ethereum.
/// This does not prevent the creation of validator sets
/// or slashing for not submitting validator set signatures as either of these might allow key signers to leave the validator
/// set and steal funds on Ethereum without consequence.
/// The practical outcome of this flag being set to 'false' is that deposits from Ethereum will not show up and withdraws from
/// Cosmos will not execute on Ethereum.
///
/// min_chain_fee_basis_points
///
/// The minimum SendToEth `chain_fee` amount, in terms of basis points. e.g. 10% fee = 1000, and 0.02% fee = 2
struct Gravity_V1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gravityID: String {
    get {return _storage._gravityID}
    set {_uniqueStorage()._gravityID = newValue}
  }

  var contractSourceHash: String {
    get {return _storage._contractSourceHash}
    set {_uniqueStorage()._contractSourceHash = newValue}
  }

  var bridgeEthereumAddress: String {
    get {return _storage._bridgeEthereumAddress}
    set {_uniqueStorage()._bridgeEthereumAddress = newValue}
  }

  var bridgeChainID: UInt64 {
    get {return _storage._bridgeChainID}
    set {_uniqueStorage()._bridgeChainID = newValue}
  }

  var signedValsetsWindow: UInt64 {
    get {return _storage._signedValsetsWindow}
    set {_uniqueStorage()._signedValsetsWindow = newValue}
  }

  var signedBatchesWindow: UInt64 {
    get {return _storage._signedBatchesWindow}
    set {_uniqueStorage()._signedBatchesWindow = newValue}
  }

  var signedLogicCallsWindow: UInt64 {
    get {return _storage._signedLogicCallsWindow}
    set {_uniqueStorage()._signedLogicCallsWindow = newValue}
  }

  var targetBatchTimeout: UInt64 {
    get {return _storage._targetBatchTimeout}
    set {_uniqueStorage()._targetBatchTimeout = newValue}
  }

  var averageBlockTime: UInt64 {
    get {return _storage._averageBlockTime}
    set {_uniqueStorage()._averageBlockTime = newValue}
  }

  var averageEthereumBlockTime: UInt64 {
    get {return _storage._averageEthereumBlockTime}
    set {_uniqueStorage()._averageEthereumBlockTime = newValue}
  }

  var slashFractionValset: Data {
    get {return _storage._slashFractionValset}
    set {_uniqueStorage()._slashFractionValset = newValue}
  }

  var slashFractionBatch: Data {
    get {return _storage._slashFractionBatch}
    set {_uniqueStorage()._slashFractionBatch = newValue}
  }

  var slashFractionLogicCall: Data {
    get {return _storage._slashFractionLogicCall}
    set {_uniqueStorage()._slashFractionLogicCall = newValue}
  }

  var unbondSlashingValsetsWindow: UInt64 {
    get {return _storage._unbondSlashingValsetsWindow}
    set {_uniqueStorage()._unbondSlashingValsetsWindow = newValue}
  }

  var slashFractionBadEthSignature: Data {
    get {return _storage._slashFractionBadEthSignature}
    set {_uniqueStorage()._slashFractionBadEthSignature = newValue}
  }

  var valsetReward: Cosmos_Base_V1beta1_Coin {
    get {return _storage._valsetReward ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._valsetReward = newValue}
  }
  /// Returns true if `valsetReward` has been explicitly set.
  var hasValsetReward: Bool {return _storage._valsetReward != nil}
  /// Clears the value of `valsetReward`. Subsequent reads from it will return its default value.
  mutating func clearValsetReward() {_uniqueStorage()._valsetReward = nil}

  var bridgeActive: Bool {
    get {return _storage._bridgeActive}
    set {_uniqueStorage()._bridgeActive = newValue}
  }

  /// addresses on this blacklist are forbidden from depositing or withdrawing
  /// from Ethereum to the bridge
  var ethereumBlacklist: [String] {
    get {return _storage._ethereumBlacklist}
    set {_uniqueStorage()._ethereumBlacklist = newValue}
  }

  var minChainFeeBasisPoints: UInt64 {
    get {return _storage._minChainFeeBasisPoints}
    set {_uniqueStorage()._minChainFeeBasisPoints = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GenesisState struct, containing all persistant data required by the Gravity module
struct Gravity_V1_GenesisState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Gravity_V1_Params {
    get {return _storage._params ?? Gravity_V1_Params()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {_uniqueStorage()._params = nil}

  var gravityNonces: Gravity_V1_GravityNonces {
    get {return _storage._gravityNonces ?? Gravity_V1_GravityNonces()}
    set {_uniqueStorage()._gravityNonces = newValue}
  }
  /// Returns true if `gravityNonces` has been explicitly set.
  var hasGravityNonces: Bool {return _storage._gravityNonces != nil}
  /// Clears the value of `gravityNonces`. Subsequent reads from it will return its default value.
  mutating func clearGravityNonces() {_uniqueStorage()._gravityNonces = nil}

  var valsets: [Gravity_V1_Valset] {
    get {return _storage._valsets}
    set {_uniqueStorage()._valsets = newValue}
  }

  var valsetConfirms: [Gravity_V1_MsgValsetConfirm] {
    get {return _storage._valsetConfirms}
    set {_uniqueStorage()._valsetConfirms = newValue}
  }

  var batches: [Gravity_V1_OutgoingTxBatch] {
    get {return _storage._batches}
    set {_uniqueStorage()._batches = newValue}
  }

  var batchConfirms: [Gravity_V1_MsgConfirmBatch] {
    get {return _storage._batchConfirms}
    set {_uniqueStorage()._batchConfirms = newValue}
  }

  var logicCalls: [Gravity_V1_OutgoingLogicCall] {
    get {return _storage._logicCalls}
    set {_uniqueStorage()._logicCalls = newValue}
  }

  var logicCallConfirms: [Gravity_V1_MsgConfirmLogicCall] {
    get {return _storage._logicCallConfirms}
    set {_uniqueStorage()._logicCallConfirms = newValue}
  }

  var attestations: [Gravity_V1_Attestation] {
    get {return _storage._attestations}
    set {_uniqueStorage()._attestations = newValue}
  }

  var delegateKeys: [Gravity_V1_MsgSetOrchestratorAddress] {
    get {return _storage._delegateKeys}
    set {_uniqueStorage()._delegateKeys = newValue}
  }

  var erc20ToDenoms: [Gravity_V1_ERC20ToDenom] {
    get {return _storage._erc20ToDenoms}
    set {_uniqueStorage()._erc20ToDenoms = newValue}
  }

  var unbatchedTransfers: [Gravity_V1_OutgoingTransferTx] {
    get {return _storage._unbatchedTransfers}
    set {_uniqueStorage()._unbatchedTransfers = newValue}
  }

  var pendingIbcAutoForwards: [Gravity_V1_PendingIbcAutoForward] {
    get {return _storage._pendingIbcAutoForwards}
    set {_uniqueStorage()._pendingIbcAutoForwards = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GravityCounters contains the many noces and counters required to maintain the bridge state in the genesis
struct Gravity_V1_GravityNonces {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the nonce of the last generated validator set
  var latestValsetNonce: UInt64 = 0

  /// the last observed Gravity.sol contract event nonce
  var lastObservedNonce: UInt64 = 0

  /// the last valset nonce we have slashed, to prevent double slashing
  var lastSlashedValsetNonce: UInt64 = 0

  /// the last batch Cosmos chain block that batch slashing has completed for
  /// there is an individual batch nonce for each token type so this removes
  /// the need to store them all
  var lastSlashedBatchBlock: UInt64 = 0

  /// the last cosmos block that logic call slashing has completed for
  var lastSlashedLogicCallBlock: UInt64 = 0

  /// the last transaction id from the Gravity TX pool, this prevents ID
  /// duplication during chain upgrades
  var lastTxPoolID: UInt64 = 0

  /// the last batch id from the Gravity batch pool, this prevents ID duplication
  /// during chain upgrades
  var lastBatchID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Gravity_V1_Params: @unchecked Sendable {}
extension Gravity_V1_GenesisState: @unchecked Sendable {}
extension Gravity_V1_GravityNonces: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "gravity.v1"

extension Gravity_V1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gravity_id"),
    2: .standard(proto: "contract_source_hash"),
    4: .standard(proto: "bridge_ethereum_address"),
    5: .standard(proto: "bridge_chain_id"),
    6: .standard(proto: "signed_valsets_window"),
    7: .standard(proto: "signed_batches_window"),
    8: .standard(proto: "signed_logic_calls_window"),
    9: .standard(proto: "target_batch_timeout"),
    10: .standard(proto: "average_block_time"),
    11: .standard(proto: "average_ethereum_block_time"),
    12: .standard(proto: "slash_fraction_valset"),
    13: .standard(proto: "slash_fraction_batch"),
    14: .standard(proto: "slash_fraction_logic_call"),
    15: .standard(proto: "unbond_slashing_valsets_window"),
    16: .standard(proto: "slash_fraction_bad_eth_signature"),
    17: .standard(proto: "valset_reward"),
    18: .standard(proto: "bridge_active"),
    19: .standard(proto: "ethereum_blacklist"),
    20: .standard(proto: "min_chain_fee_basis_points"),
  ]

  fileprivate class _StorageClass {
    var _gravityID: String = String()
    var _contractSourceHash: String = String()
    var _bridgeEthereumAddress: String = String()
    var _bridgeChainID: UInt64 = 0
    var _signedValsetsWindow: UInt64 = 0
    var _signedBatchesWindow: UInt64 = 0
    var _signedLogicCallsWindow: UInt64 = 0
    var _targetBatchTimeout: UInt64 = 0
    var _averageBlockTime: UInt64 = 0
    var _averageEthereumBlockTime: UInt64 = 0
    var _slashFractionValset: Data = Data()
    var _slashFractionBatch: Data = Data()
    var _slashFractionLogicCall: Data = Data()
    var _unbondSlashingValsetsWindow: UInt64 = 0
    var _slashFractionBadEthSignature: Data = Data()
    var _valsetReward: Cosmos_Base_V1beta1_Coin? = nil
    var _bridgeActive: Bool = false
    var _ethereumBlacklist: [String] = []
    var _minChainFeeBasisPoints: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gravityID = source._gravityID
      _contractSourceHash = source._contractSourceHash
      _bridgeEthereumAddress = source._bridgeEthereumAddress
      _bridgeChainID = source._bridgeChainID
      _signedValsetsWindow = source._signedValsetsWindow
      _signedBatchesWindow = source._signedBatchesWindow
      _signedLogicCallsWindow = source._signedLogicCallsWindow
      _targetBatchTimeout = source._targetBatchTimeout
      _averageBlockTime = source._averageBlockTime
      _averageEthereumBlockTime = source._averageEthereumBlockTime
      _slashFractionValset = source._slashFractionValset
      _slashFractionBatch = source._slashFractionBatch
      _slashFractionLogicCall = source._slashFractionLogicCall
      _unbondSlashingValsetsWindow = source._unbondSlashingValsetsWindow
      _slashFractionBadEthSignature = source._slashFractionBadEthSignature
      _valsetReward = source._valsetReward
      _bridgeActive = source._bridgeActive
      _ethereumBlacklist = source._ethereumBlacklist
      _minChainFeeBasisPoints = source._minChainFeeBasisPoints
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._gravityID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._contractSourceHash) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._bridgeEthereumAddress) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._bridgeChainID) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._signedValsetsWindow) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._signedBatchesWindow) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._signedLogicCallsWindow) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._targetBatchTimeout) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._averageBlockTime) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._averageEthereumBlockTime) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._slashFractionValset) }()
        case 13: try { try decoder.decodeSingularBytesField(value: &_storage._slashFractionBatch) }()
        case 14: try { try decoder.decodeSingularBytesField(value: &_storage._slashFractionLogicCall) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._unbondSlashingValsetsWindow) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._slashFractionBadEthSignature) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._valsetReward) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._bridgeActive) }()
        case 19: try { try decoder.decodeRepeatedStringField(value: &_storage._ethereumBlacklist) }()
        case 20: try { try decoder.decodeSingularUInt64Field(value: &_storage._minChainFeeBasisPoints) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._gravityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gravityID, fieldNumber: 1)
      }
      if !_storage._contractSourceHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contractSourceHash, fieldNumber: 2)
      }
      if !_storage._bridgeEthereumAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bridgeEthereumAddress, fieldNumber: 4)
      }
      if _storage._bridgeChainID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._bridgeChainID, fieldNumber: 5)
      }
      if _storage._signedValsetsWindow != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._signedValsetsWindow, fieldNumber: 6)
      }
      if _storage._signedBatchesWindow != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._signedBatchesWindow, fieldNumber: 7)
      }
      if _storage._signedLogicCallsWindow != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._signedLogicCallsWindow, fieldNumber: 8)
      }
      if _storage._targetBatchTimeout != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._targetBatchTimeout, fieldNumber: 9)
      }
      if _storage._averageBlockTime != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._averageBlockTime, fieldNumber: 10)
      }
      if _storage._averageEthereumBlockTime != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._averageEthereumBlockTime, fieldNumber: 11)
      }
      if !_storage._slashFractionValset.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._slashFractionValset, fieldNumber: 12)
      }
      if !_storage._slashFractionBatch.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._slashFractionBatch, fieldNumber: 13)
      }
      if !_storage._slashFractionLogicCall.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._slashFractionLogicCall, fieldNumber: 14)
      }
      if _storage._unbondSlashingValsetsWindow != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._unbondSlashingValsetsWindow, fieldNumber: 15)
      }
      if !_storage._slashFractionBadEthSignature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._slashFractionBadEthSignature, fieldNumber: 16)
      }
      try { if let v = _storage._valsetReward {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if _storage._bridgeActive != false {
        try visitor.visitSingularBoolField(value: _storage._bridgeActive, fieldNumber: 18)
      }
      if !_storage._ethereumBlacklist.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._ethereumBlacklist, fieldNumber: 19)
      }
      if _storage._minChainFeeBasisPoints != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._minChainFeeBasisPoints, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_Params, rhs: Gravity_V1_Params) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gravityID != rhs_storage._gravityID {return false}
        if _storage._contractSourceHash != rhs_storage._contractSourceHash {return false}
        if _storage._bridgeEthereumAddress != rhs_storage._bridgeEthereumAddress {return false}
        if _storage._bridgeChainID != rhs_storage._bridgeChainID {return false}
        if _storage._signedValsetsWindow != rhs_storage._signedValsetsWindow {return false}
        if _storage._signedBatchesWindow != rhs_storage._signedBatchesWindow {return false}
        if _storage._signedLogicCallsWindow != rhs_storage._signedLogicCallsWindow {return false}
        if _storage._targetBatchTimeout != rhs_storage._targetBatchTimeout {return false}
        if _storage._averageBlockTime != rhs_storage._averageBlockTime {return false}
        if _storage._averageEthereumBlockTime != rhs_storage._averageEthereumBlockTime {return false}
        if _storage._slashFractionValset != rhs_storage._slashFractionValset {return false}
        if _storage._slashFractionBatch != rhs_storage._slashFractionBatch {return false}
        if _storage._slashFractionLogicCall != rhs_storage._slashFractionLogicCall {return false}
        if _storage._unbondSlashingValsetsWindow != rhs_storage._unbondSlashingValsetsWindow {return false}
        if _storage._slashFractionBadEthSignature != rhs_storage._slashFractionBadEthSignature {return false}
        if _storage._valsetReward != rhs_storage._valsetReward {return false}
        if _storage._bridgeActive != rhs_storage._bridgeActive {return false}
        if _storage._ethereumBlacklist != rhs_storage._ethereumBlacklist {return false}
        if _storage._minChainFeeBasisPoints != rhs_storage._minChainFeeBasisPoints {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_GenesisState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .standard(proto: "gravity_nonces"),
    3: .same(proto: "valsets"),
    4: .standard(proto: "valset_confirms"),
    5: .same(proto: "batches"),
    6: .standard(proto: "batch_confirms"),
    7: .standard(proto: "logic_calls"),
    8: .standard(proto: "logic_call_confirms"),
    9: .same(proto: "attestations"),
    10: .standard(proto: "delegate_keys"),
    11: .standard(proto: "erc20_to_denoms"),
    12: .standard(proto: "unbatched_transfers"),
    13: .standard(proto: "pending_ibc_auto_forwards"),
  ]

  fileprivate class _StorageClass {
    var _params: Gravity_V1_Params? = nil
    var _gravityNonces: Gravity_V1_GravityNonces? = nil
    var _valsets: [Gravity_V1_Valset] = []
    var _valsetConfirms: [Gravity_V1_MsgValsetConfirm] = []
    var _batches: [Gravity_V1_OutgoingTxBatch] = []
    var _batchConfirms: [Gravity_V1_MsgConfirmBatch] = []
    var _logicCalls: [Gravity_V1_OutgoingLogicCall] = []
    var _logicCallConfirms: [Gravity_V1_MsgConfirmLogicCall] = []
    var _attestations: [Gravity_V1_Attestation] = []
    var _delegateKeys: [Gravity_V1_MsgSetOrchestratorAddress] = []
    var _erc20ToDenoms: [Gravity_V1_ERC20ToDenom] = []
    var _unbatchedTransfers: [Gravity_V1_OutgoingTransferTx] = []
    var _pendingIbcAutoForwards: [Gravity_V1_PendingIbcAutoForward] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _params = source._params
      _gravityNonces = source._gravityNonces
      _valsets = source._valsets
      _valsetConfirms = source._valsetConfirms
      _batches = source._batches
      _batchConfirms = source._batchConfirms
      _logicCalls = source._logicCalls
      _logicCallConfirms = source._logicCallConfirms
      _attestations = source._attestations
      _delegateKeys = source._delegateKeys
      _erc20ToDenoms = source._erc20ToDenoms
      _unbatchedTransfers = source._unbatchedTransfers
      _pendingIbcAutoForwards = source._pendingIbcAutoForwards
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._gravityNonces) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._valsets) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._valsetConfirms) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._batches) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._batchConfirms) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._logicCalls) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._logicCallConfirms) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._attestations) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._delegateKeys) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._erc20ToDenoms) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._unbatchedTransfers) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._pendingIbcAutoForwards) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._gravityNonces {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._valsets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._valsets, fieldNumber: 3)
      }
      if !_storage._valsetConfirms.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._valsetConfirms, fieldNumber: 4)
      }
      if !_storage._batches.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._batches, fieldNumber: 5)
      }
      if !_storage._batchConfirms.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._batchConfirms, fieldNumber: 6)
      }
      if !_storage._logicCalls.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._logicCalls, fieldNumber: 7)
      }
      if !_storage._logicCallConfirms.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._logicCallConfirms, fieldNumber: 8)
      }
      if !_storage._attestations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._attestations, fieldNumber: 9)
      }
      if !_storage._delegateKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._delegateKeys, fieldNumber: 10)
      }
      if !_storage._erc20ToDenoms.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._erc20ToDenoms, fieldNumber: 11)
      }
      if !_storage._unbatchedTransfers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._unbatchedTransfers, fieldNumber: 12)
      }
      if !_storage._pendingIbcAutoForwards.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingIbcAutoForwards, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_GenesisState, rhs: Gravity_V1_GenesisState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._params != rhs_storage._params {return false}
        if _storage._gravityNonces != rhs_storage._gravityNonces {return false}
        if _storage._valsets != rhs_storage._valsets {return false}
        if _storage._valsetConfirms != rhs_storage._valsetConfirms {return false}
        if _storage._batches != rhs_storage._batches {return false}
        if _storage._batchConfirms != rhs_storage._batchConfirms {return false}
        if _storage._logicCalls != rhs_storage._logicCalls {return false}
        if _storage._logicCallConfirms != rhs_storage._logicCallConfirms {return false}
        if _storage._attestations != rhs_storage._attestations {return false}
        if _storage._delegateKeys != rhs_storage._delegateKeys {return false}
        if _storage._erc20ToDenoms != rhs_storage._erc20ToDenoms {return false}
        if _storage._unbatchedTransfers != rhs_storage._unbatchedTransfers {return false}
        if _storage._pendingIbcAutoForwards != rhs_storage._pendingIbcAutoForwards {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_GravityNonces: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GravityNonces"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "latest_valset_nonce"),
    2: .standard(proto: "last_observed_nonce"),
    3: .standard(proto: "last_slashed_valset_nonce"),
    4: .standard(proto: "last_slashed_batch_block"),
    5: .standard(proto: "last_slashed_logic_call_block"),
    6: .standard(proto: "last_tx_pool_id"),
    7: .standard(proto: "last_batch_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.latestValsetNonce) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.lastObservedNonce) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.lastSlashedValsetNonce) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.lastSlashedBatchBlock) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.lastSlashedLogicCallBlock) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.lastTxPoolID) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.lastBatchID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latestValsetNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.latestValsetNonce, fieldNumber: 1)
    }
    if self.lastObservedNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastObservedNonce, fieldNumber: 2)
    }
    if self.lastSlashedValsetNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastSlashedValsetNonce, fieldNumber: 3)
    }
    if self.lastSlashedBatchBlock != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastSlashedBatchBlock, fieldNumber: 4)
    }
    if self.lastSlashedLogicCallBlock != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastSlashedLogicCallBlock, fieldNumber: 5)
    }
    if self.lastTxPoolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastTxPoolID, fieldNumber: 6)
    }
    if self.lastBatchID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastBatchID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_GravityNonces, rhs: Gravity_V1_GravityNonces) -> Bool {
    if lhs.latestValsetNonce != rhs.latestValsetNonce {return false}
    if lhs.lastObservedNonce != rhs.lastObservedNonce {return false}
    if lhs.lastSlashedValsetNonce != rhs.lastSlashedValsetNonce {return false}
    if lhs.lastSlashedBatchBlock != rhs.lastSlashedBatchBlock {return false}
    if lhs.lastSlashedLogicCallBlock != rhs.lastSlashedLogicCallBlock {return false}
    if lhs.lastTxPoolID != rhs.lastTxPoolID {return false}
    if lhs.lastBatchID != rhs.lastBatchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
