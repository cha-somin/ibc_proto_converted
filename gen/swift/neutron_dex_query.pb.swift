// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: neutron/dex/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryParamsRequest is request type for the Query/Params RPC method.
struct Neutron_Dex_QueryParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryParamsResponse is response type for the Query/Params RPC method.
struct Neutron_Dex_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// params holds all the parameters of this module.
  var params: Neutron_Dex_Params {
    get {return _params ?? Neutron_Dex_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Neutron_Dex_Params? = nil
}

struct Neutron_Dex_QueryGetLimitOrderTrancheUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var trancheKey: String = String()

  var calcWithdrawableShares: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_QueryGetLimitOrderTrancheUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var limitOrderTrancheUser: Neutron_Dex_LimitOrderTrancheUser {
    get {return _limitOrderTrancheUser ?? Neutron_Dex_LimitOrderTrancheUser()}
    set {_limitOrderTrancheUser = newValue}
  }
  /// Returns true if `limitOrderTrancheUser` has been explicitly set.
  var hasLimitOrderTrancheUser: Bool {return self._limitOrderTrancheUser != nil}
  /// Clears the value of `limitOrderTrancheUser`. Subsequent reads from it will return its default value.
  mutating func clearLimitOrderTrancheUser() {self._limitOrderTrancheUser = nil}

  var withdrawableShares: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _limitOrderTrancheUser: Neutron_Dex_LimitOrderTrancheUser? = nil
}

struct Neutron_Dex_QueryAllLimitOrderTrancheUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

struct Neutron_Dex_QueryAllLimitOrderTrancheUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var limitOrderTrancheUser: [Neutron_Dex_LimitOrderTrancheUser] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

struct Neutron_Dex_QueryGetLimitOrderTrancheRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairID: String = String()

  var tickIndex: Int64 = 0

  var tokenIn: String = String()

  var trancheKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_QueryGetLimitOrderTrancheResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var limitOrderTranche: Neutron_Dex_LimitOrderTranche {
    get {return _limitOrderTranche ?? Neutron_Dex_LimitOrderTranche()}
    set {_limitOrderTranche = newValue}
  }
  /// Returns true if `limitOrderTranche` has been explicitly set.
  var hasLimitOrderTranche: Bool {return self._limitOrderTranche != nil}
  /// Clears the value of `limitOrderTranche`. Subsequent reads from it will return its default value.
  mutating func clearLimitOrderTranche() {self._limitOrderTranche = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _limitOrderTranche: Neutron_Dex_LimitOrderTranche? = nil
}

struct Neutron_Dex_QueryAllLimitOrderTrancheRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairID: String = String()

  var tokenIn: String = String()

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

struct Neutron_Dex_QueryAllLimitOrderTrancheResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var limitOrderTranche: [Neutron_Dex_LimitOrderTranche] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

struct Neutron_Dex_QueryAllUserDepositsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var includePoolData: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

struct Neutron_Dex_QueryAllUserDepositsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deposits: [Neutron_Dex_DepositRecord] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

struct Neutron_Dex_QueryAllLimitOrderTrancheUserByAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

struct Neutron_Dex_QueryAllLimitOrderTrancheUserByAddressResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var limitOrders: [Neutron_Dex_LimitOrderTrancheUser] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

struct Neutron_Dex_QueryAllTickLiquidityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairID: String = String()

  var tokenIn: String = String()

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

struct Neutron_Dex_QueryAllTickLiquidityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tickLiquidity: [Neutron_Dex_TickLiquidity] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

struct Neutron_Dex_QueryGetInactiveLimitOrderTrancheRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairID: String = String()

  var tokenIn: String = String()

  var tickIndex: Int64 = 0

  var trancheKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_QueryGetInactiveLimitOrderTrancheResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inactiveLimitOrderTranche: Neutron_Dex_LimitOrderTranche {
    get {return _inactiveLimitOrderTranche ?? Neutron_Dex_LimitOrderTranche()}
    set {_inactiveLimitOrderTranche = newValue}
  }
  /// Returns true if `inactiveLimitOrderTranche` has been explicitly set.
  var hasInactiveLimitOrderTranche: Bool {return self._inactiveLimitOrderTranche != nil}
  /// Clears the value of `inactiveLimitOrderTranche`. Subsequent reads from it will return its default value.
  mutating func clearInactiveLimitOrderTranche() {self._inactiveLimitOrderTranche = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _inactiveLimitOrderTranche: Neutron_Dex_LimitOrderTranche? = nil
}

struct Neutron_Dex_QueryAllInactiveLimitOrderTrancheRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

struct Neutron_Dex_QueryAllInactiveLimitOrderTrancheResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inactiveLimitOrderTranche: [Neutron_Dex_LimitOrderTranche] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

struct Neutron_Dex_QueryAllPoolReservesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairID: String = String()

  var tokenIn: String = String()

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

struct Neutron_Dex_QueryAllPoolReservesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolReserves: [Neutron_Dex_PoolReserves] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

struct Neutron_Dex_QueryGetPoolReservesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairID: String = String()

  var tokenIn: String = String()

  var tickIndex: Int64 = 0

  var fee: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_QueryGetPoolReservesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolReserves: Neutron_Dex_PoolReserves {
    get {return _poolReserves ?? Neutron_Dex_PoolReserves()}
    set {_poolReserves = newValue}
  }
  /// Returns true if `poolReserves` has been explicitly set.
  var hasPoolReserves: Bool {return self._poolReserves != nil}
  /// Clears the value of `poolReserves`. Subsequent reads from it will return its default value.
  mutating func clearPoolReserves() {self._poolReserves = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _poolReserves: Neutron_Dex_PoolReserves? = nil
}

struct Neutron_Dex_QueryEstimateMultiHopSwapRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var receiver: String = String()

  var routes: [Neutron_Dex_MultiHopRoute] = []

  var amountIn: String = String()

  var exitLimitPrice: String = String()

  /// If pickBestRoute == true then all routes are run and the route with the
  /// best price is chosen otherwise, the first succesful route is used.
  var pickBestRoute: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_QueryEstimateMultiHopSwapResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var coinOut: Cosmos_Base_V1beta1_Coin {
    get {return _coinOut ?? Cosmos_Base_V1beta1_Coin()}
    set {_coinOut = newValue}
  }
  /// Returns true if `coinOut` has been explicitly set.
  var hasCoinOut: Bool {return self._coinOut != nil}
  /// Clears the value of `coinOut`. Subsequent reads from it will return its default value.
  mutating func clearCoinOut() {self._coinOut = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _coinOut: Cosmos_Base_V1beta1_Coin? = nil
}

struct Neutron_Dex_QueryEstimatePlaceLimitOrderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var receiver: String = String()

  var tokenIn: String = String()

  var tokenOut: String = String()

  var tickIndexInToOut: Int64 = 0

  var amountIn: String = String()

  var orderType: Neutron_Dex_LimitOrderType = .goodTilCancelled

  /// expirationTime is only valid iff orderType == GOOD_TIL_TIME.
  var expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expirationTime = newValue}
  }
  /// Returns true if `expirationTime` has been explicitly set.
  var hasExpirationTime: Bool {return self._expirationTime != nil}
  /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
  mutating func clearExpirationTime() {self._expirationTime = nil}

  var maxAmountOut: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Neutron_Dex_QueryEstimatePlaceLimitOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Total amount of coin used for the limit order
  /// You can derive makerLimitInCoin using the equation: totalInCoin =
  /// swapInCoin + makerLimitInCoin
  var totalInCoin: Cosmos_Base_V1beta1_Coin {
    get {return _totalInCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_totalInCoin = newValue}
  }
  /// Returns true if `totalInCoin` has been explicitly set.
  var hasTotalInCoin: Bool {return self._totalInCoin != nil}
  /// Clears the value of `totalInCoin`. Subsequent reads from it will return its default value.
  mutating func clearTotalInCoin() {self._totalInCoin = nil}

  /// Total amount of the token in that was immediately swapped for swapOutCoin
  var swapInCoin: Cosmos_Base_V1beta1_Coin {
    get {return _swapInCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_swapInCoin = newValue}
  }
  /// Returns true if `swapInCoin` has been explicitly set.
  var hasSwapInCoin: Bool {return self._swapInCoin != nil}
  /// Clears the value of `swapInCoin`. Subsequent reads from it will return its default value.
  mutating func clearSwapInCoin() {self._swapInCoin = nil}

  /// Total amount of coin received from the taker portion of the limit order
  /// This is the amount of coin immediately available in the users account after
  /// executing the limit order. It does not include any future proceeds from the
  /// maker portion which will have withdrawn in the future
  var swapOutCoin: Cosmos_Base_V1beta1_Coin {
    get {return _swapOutCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_swapOutCoin = newValue}
  }
  /// Returns true if `swapOutCoin` has been explicitly set.
  var hasSwapOutCoin: Bool {return self._swapOutCoin != nil}
  /// Clears the value of `swapOutCoin`. Subsequent reads from it will return its default value.
  mutating func clearSwapOutCoin() {self._swapOutCoin = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totalInCoin: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _swapInCoin: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _swapOutCoin: Cosmos_Base_V1beta1_Coin? = nil
}

struct Neutron_Dex_QueryPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairID: String = String()

  var tickIndex: Int64 = 0

  var fee: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_QueryPoolByIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_QueryPoolResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pool: Neutron_Dex_Pool {
    get {return _pool ?? Neutron_Dex_Pool()}
    set {_pool = newValue}
  }
  /// Returns true if `pool` has been explicitly set.
  var hasPool: Bool {return self._pool != nil}
  /// Clears the value of `pool`. Subsequent reads from it will return its default value.
  mutating func clearPool() {self._pool = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pool: Neutron_Dex_Pool? = nil
}

struct Neutron_Dex_QueryGetPoolMetadataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_QueryGetPoolMetadataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolMetadata: Neutron_Dex_PoolMetadata {
    get {return _poolMetadata ?? Neutron_Dex_PoolMetadata()}
    set {_poolMetadata = newValue}
  }
  /// Returns true if `poolMetadata` has been explicitly set.
  var hasPoolMetadata: Bool {return self._poolMetadata != nil}
  /// Clears the value of `poolMetadata`. Subsequent reads from it will return its default value.
  mutating func clearPoolMetadata() {self._poolMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _poolMetadata: Neutron_Dex_PoolMetadata? = nil
}

struct Neutron_Dex_QueryAllPoolMetadataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

struct Neutron_Dex_QueryAllPoolMetadataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolMetadata: [Neutron_Dex_PoolMetadata] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Neutron_Dex_QueryParamsRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryParamsResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryGetLimitOrderTrancheUserRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryGetLimitOrderTrancheUserResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryAllLimitOrderTrancheUserRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryAllLimitOrderTrancheUserResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryGetLimitOrderTrancheRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryGetLimitOrderTrancheResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryAllLimitOrderTrancheRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryAllLimitOrderTrancheResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryAllUserDepositsRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryAllUserDepositsResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryAllLimitOrderTrancheUserByAddressRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryAllLimitOrderTrancheUserByAddressResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryAllTickLiquidityRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryAllTickLiquidityResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryGetInactiveLimitOrderTrancheRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryGetInactiveLimitOrderTrancheResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryAllInactiveLimitOrderTrancheRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryAllInactiveLimitOrderTrancheResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryAllPoolReservesRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryAllPoolReservesResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryGetPoolReservesRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryGetPoolReservesResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryEstimateMultiHopSwapRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryEstimateMultiHopSwapResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryEstimatePlaceLimitOrderRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryEstimatePlaceLimitOrderResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryPoolRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryPoolByIDRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryPoolResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryGetPoolMetadataRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryGetPoolMetadataResponse: @unchecked Sendable {}
extension Neutron_Dex_QueryAllPoolMetadataRequest: @unchecked Sendable {}
extension Neutron_Dex_QueryAllPoolMetadataResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "neutron.dex"

extension Neutron_Dex_QueryParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryParamsRequest, rhs: Neutron_Dex_QueryParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryParamsResponse, rhs: Neutron_Dex_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryGetLimitOrderTrancheUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetLimitOrderTrancheUserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "tranche_key"),
    3: .standard(proto: "calc_withdrawable_shares"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.trancheKey) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.calcWithdrawableShares) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.trancheKey.isEmpty {
      try visitor.visitSingularStringField(value: self.trancheKey, fieldNumber: 2)
    }
    if self.calcWithdrawableShares != false {
      try visitor.visitSingularBoolField(value: self.calcWithdrawableShares, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryGetLimitOrderTrancheUserRequest, rhs: Neutron_Dex_QueryGetLimitOrderTrancheUserRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.trancheKey != rhs.trancheKey {return false}
    if lhs.calcWithdrawableShares != rhs.calcWithdrawableShares {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryGetLimitOrderTrancheUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetLimitOrderTrancheUserResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "limit_order_tranche_user"),
    2: .standard(proto: "withdrawable_shares"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._limitOrderTrancheUser) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.withdrawableShares) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._limitOrderTrancheUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.withdrawableShares.isEmpty {
      try visitor.visitSingularStringField(value: self.withdrawableShares, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryGetLimitOrderTrancheUserResponse, rhs: Neutron_Dex_QueryGetLimitOrderTrancheUserResponse) -> Bool {
    if lhs._limitOrderTrancheUser != rhs._limitOrderTrancheUser {return false}
    if lhs.withdrawableShares != rhs.withdrawableShares {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllLimitOrderTrancheUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllLimitOrderTrancheUserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllLimitOrderTrancheUserRequest, rhs: Neutron_Dex_QueryAllLimitOrderTrancheUserRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllLimitOrderTrancheUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllLimitOrderTrancheUserResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "limit_order_tranche_user"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.limitOrderTrancheUser) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.limitOrderTrancheUser.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.limitOrderTrancheUser, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllLimitOrderTrancheUserResponse, rhs: Neutron_Dex_QueryAllLimitOrderTrancheUserResponse) -> Bool {
    if lhs.limitOrderTrancheUser != rhs.limitOrderTrancheUser {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryGetLimitOrderTrancheRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetLimitOrderTrancheRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_id"),
    2: .standard(proto: "tick_index"),
    3: .standard(proto: "token_in"),
    4: .standard(proto: "tranche_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pairID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.tickIndex) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tokenIn) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.trancheKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pairID.isEmpty {
      try visitor.visitSingularStringField(value: self.pairID, fieldNumber: 1)
    }
    if self.tickIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.tickIndex, fieldNumber: 2)
    }
    if !self.tokenIn.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenIn, fieldNumber: 3)
    }
    if !self.trancheKey.isEmpty {
      try visitor.visitSingularStringField(value: self.trancheKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryGetLimitOrderTrancheRequest, rhs: Neutron_Dex_QueryGetLimitOrderTrancheRequest) -> Bool {
    if lhs.pairID != rhs.pairID {return false}
    if lhs.tickIndex != rhs.tickIndex {return false}
    if lhs.tokenIn != rhs.tokenIn {return false}
    if lhs.trancheKey != rhs.trancheKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryGetLimitOrderTrancheResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetLimitOrderTrancheResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "limit_order_tranche"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._limitOrderTranche) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._limitOrderTranche {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryGetLimitOrderTrancheResponse, rhs: Neutron_Dex_QueryGetLimitOrderTrancheResponse) -> Bool {
    if lhs._limitOrderTranche != rhs._limitOrderTranche {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllLimitOrderTrancheRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllLimitOrderTrancheRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_id"),
    2: .standard(proto: "token_in"),
    3: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pairID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenIn) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pairID.isEmpty {
      try visitor.visitSingularStringField(value: self.pairID, fieldNumber: 1)
    }
    if !self.tokenIn.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenIn, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllLimitOrderTrancheRequest, rhs: Neutron_Dex_QueryAllLimitOrderTrancheRequest) -> Bool {
    if lhs.pairID != rhs.pairID {return false}
    if lhs.tokenIn != rhs.tokenIn {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllLimitOrderTrancheResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllLimitOrderTrancheResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "limit_order_tranche"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.limitOrderTranche) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.limitOrderTranche.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.limitOrderTranche, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllLimitOrderTrancheResponse, rhs: Neutron_Dex_QueryAllLimitOrderTrancheResponse) -> Bool {
    if lhs.limitOrderTranche != rhs.limitOrderTranche {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllUserDepositsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllUserDepositsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "pagination"),
    3: .standard(proto: "include_pool_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includePoolData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.includePoolData != false {
      try visitor.visitSingularBoolField(value: self.includePoolData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllUserDepositsRequest, rhs: Neutron_Dex_QueryAllUserDepositsRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.includePoolData != rhs.includePoolData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllUserDepositsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllUserDepositsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deposits"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.deposits) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deposits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deposits, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllUserDepositsResponse, rhs: Neutron_Dex_QueryAllUserDepositsResponse) -> Bool {
    if lhs.deposits != rhs.deposits {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllLimitOrderTrancheUserByAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllLimitOrderTrancheUserByAddressRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllLimitOrderTrancheUserByAddressRequest, rhs: Neutron_Dex_QueryAllLimitOrderTrancheUserByAddressRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllLimitOrderTrancheUserByAddressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllLimitOrderTrancheUserByAddressResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "limit_orders"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.limitOrders) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.limitOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.limitOrders, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllLimitOrderTrancheUserByAddressResponse, rhs: Neutron_Dex_QueryAllLimitOrderTrancheUserByAddressResponse) -> Bool {
    if lhs.limitOrders != rhs.limitOrders {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllTickLiquidityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllTickLiquidityRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_id"),
    2: .standard(proto: "token_in"),
    3: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pairID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenIn) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pairID.isEmpty {
      try visitor.visitSingularStringField(value: self.pairID, fieldNumber: 1)
    }
    if !self.tokenIn.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenIn, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllTickLiquidityRequest, rhs: Neutron_Dex_QueryAllTickLiquidityRequest) -> Bool {
    if lhs.pairID != rhs.pairID {return false}
    if lhs.tokenIn != rhs.tokenIn {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllTickLiquidityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllTickLiquidityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tick_liquidity"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tickLiquidity) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tickLiquidity.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tickLiquidity, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllTickLiquidityResponse, rhs: Neutron_Dex_QueryAllTickLiquidityResponse) -> Bool {
    if lhs.tickLiquidity != rhs.tickLiquidity {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryGetInactiveLimitOrderTrancheRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetInactiveLimitOrderTrancheRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_id"),
    2: .standard(proto: "token_in"),
    3: .standard(proto: "tick_index"),
    4: .standard(proto: "tranche_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pairID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenIn) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.tickIndex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.trancheKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pairID.isEmpty {
      try visitor.visitSingularStringField(value: self.pairID, fieldNumber: 1)
    }
    if !self.tokenIn.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenIn, fieldNumber: 2)
    }
    if self.tickIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.tickIndex, fieldNumber: 3)
    }
    if !self.trancheKey.isEmpty {
      try visitor.visitSingularStringField(value: self.trancheKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryGetInactiveLimitOrderTrancheRequest, rhs: Neutron_Dex_QueryGetInactiveLimitOrderTrancheRequest) -> Bool {
    if lhs.pairID != rhs.pairID {return false}
    if lhs.tokenIn != rhs.tokenIn {return false}
    if lhs.tickIndex != rhs.tickIndex {return false}
    if lhs.trancheKey != rhs.trancheKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryGetInactiveLimitOrderTrancheResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetInactiveLimitOrderTrancheResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inactive_limit_order_tranche"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._inactiveLimitOrderTranche) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inactiveLimitOrderTranche {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryGetInactiveLimitOrderTrancheResponse, rhs: Neutron_Dex_QueryGetInactiveLimitOrderTrancheResponse) -> Bool {
    if lhs._inactiveLimitOrderTranche != rhs._inactiveLimitOrderTranche {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllInactiveLimitOrderTrancheRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllInactiveLimitOrderTrancheRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllInactiveLimitOrderTrancheRequest, rhs: Neutron_Dex_QueryAllInactiveLimitOrderTrancheRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllInactiveLimitOrderTrancheResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllInactiveLimitOrderTrancheResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inactive_limit_order_tranche"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inactiveLimitOrderTranche) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.inactiveLimitOrderTranche.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inactiveLimitOrderTranche, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllInactiveLimitOrderTrancheResponse, rhs: Neutron_Dex_QueryAllInactiveLimitOrderTrancheResponse) -> Bool {
    if lhs.inactiveLimitOrderTranche != rhs.inactiveLimitOrderTranche {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllPoolReservesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllPoolReservesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_id"),
    2: .standard(proto: "token_in"),
    3: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pairID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenIn) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pairID.isEmpty {
      try visitor.visitSingularStringField(value: self.pairID, fieldNumber: 1)
    }
    if !self.tokenIn.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenIn, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllPoolReservesRequest, rhs: Neutron_Dex_QueryAllPoolReservesRequest) -> Bool {
    if lhs.pairID != rhs.pairID {return false}
    if lhs.tokenIn != rhs.tokenIn {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllPoolReservesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllPoolReservesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_reserves"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.poolReserves) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.poolReserves.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.poolReserves, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllPoolReservesResponse, rhs: Neutron_Dex_QueryAllPoolReservesResponse) -> Bool {
    if lhs.poolReserves != rhs.poolReserves {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryGetPoolReservesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetPoolReservesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_id"),
    2: .standard(proto: "token_in"),
    3: .standard(proto: "tick_index"),
    4: .same(proto: "fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pairID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenIn) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.tickIndex) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pairID.isEmpty {
      try visitor.visitSingularStringField(value: self.pairID, fieldNumber: 1)
    }
    if !self.tokenIn.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenIn, fieldNumber: 2)
    }
    if self.tickIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.tickIndex, fieldNumber: 3)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryGetPoolReservesRequest, rhs: Neutron_Dex_QueryGetPoolReservesRequest) -> Bool {
    if lhs.pairID != rhs.pairID {return false}
    if lhs.tokenIn != rhs.tokenIn {return false}
    if lhs.tickIndex != rhs.tickIndex {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryGetPoolReservesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetPoolReservesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_reserves"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._poolReserves) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._poolReserves {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryGetPoolReservesResponse, rhs: Neutron_Dex_QueryGetPoolReservesResponse) -> Bool {
    if lhs._poolReserves != rhs._poolReserves {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryEstimateMultiHopSwapRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEstimateMultiHopSwapRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "receiver"),
    3: .same(proto: "routes"),
    4: .standard(proto: "amount_in"),
    5: .standard(proto: "exit_limit_price"),
    6: .standard(proto: "pick_best_route"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.receiver) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.routes) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.amountIn) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.exitLimitPrice) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.pickBestRoute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 2)
    }
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 3)
    }
    if !self.amountIn.isEmpty {
      try visitor.visitSingularStringField(value: self.amountIn, fieldNumber: 4)
    }
    if !self.exitLimitPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.exitLimitPrice, fieldNumber: 5)
    }
    if self.pickBestRoute != false {
      try visitor.visitSingularBoolField(value: self.pickBestRoute, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryEstimateMultiHopSwapRequest, rhs: Neutron_Dex_QueryEstimateMultiHopSwapRequest) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.receiver != rhs.receiver {return false}
    if lhs.routes != rhs.routes {return false}
    if lhs.amountIn != rhs.amountIn {return false}
    if lhs.exitLimitPrice != rhs.exitLimitPrice {return false}
    if lhs.pickBestRoute != rhs.pickBestRoute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryEstimateMultiHopSwapResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEstimateMultiHopSwapResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coin_out"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coinOut) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coinOut {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryEstimateMultiHopSwapResponse, rhs: Neutron_Dex_QueryEstimateMultiHopSwapResponse) -> Bool {
    if lhs._coinOut != rhs._coinOut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryEstimatePlaceLimitOrderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEstimatePlaceLimitOrderRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "receiver"),
    3: .standard(proto: "token_in"),
    4: .standard(proto: "token_out"),
    5: .standard(proto: "tick_index_in_to_out"),
    6: .standard(proto: "amount_in"),
    7: .standard(proto: "order_type"),
    8: .standard(proto: "expiration_time"),
    9: .standard(proto: "maxAmount_out"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.receiver) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tokenIn) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tokenOut) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.tickIndexInToOut) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.amountIn) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._expirationTime) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.maxAmountOut) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 2)
    }
    if !self.tokenIn.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenIn, fieldNumber: 3)
    }
    if !self.tokenOut.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenOut, fieldNumber: 4)
    }
    if self.tickIndexInToOut != 0 {
      try visitor.visitSingularInt64Field(value: self.tickIndexInToOut, fieldNumber: 5)
    }
    if !self.amountIn.isEmpty {
      try visitor.visitSingularStringField(value: self.amountIn, fieldNumber: 6)
    }
    if self.orderType != .goodTilCancelled {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 7)
    }
    try { if let v = self._expirationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.maxAmountOut.isEmpty {
      try visitor.visitSingularStringField(value: self.maxAmountOut, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryEstimatePlaceLimitOrderRequest, rhs: Neutron_Dex_QueryEstimatePlaceLimitOrderRequest) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.receiver != rhs.receiver {return false}
    if lhs.tokenIn != rhs.tokenIn {return false}
    if lhs.tokenOut != rhs.tokenOut {return false}
    if lhs.tickIndexInToOut != rhs.tickIndexInToOut {return false}
    if lhs.amountIn != rhs.amountIn {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs._expirationTime != rhs._expirationTime {return false}
    if lhs.maxAmountOut != rhs.maxAmountOut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryEstimatePlaceLimitOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryEstimatePlaceLimitOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_in_coin"),
    2: .standard(proto: "swap_in_coin"),
    3: .standard(proto: "swap_out_coin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._totalInCoin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._swapInCoin) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._swapOutCoin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._totalInCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._swapInCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._swapOutCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryEstimatePlaceLimitOrderResponse, rhs: Neutron_Dex_QueryEstimatePlaceLimitOrderResponse) -> Bool {
    if lhs._totalInCoin != rhs._totalInCoin {return false}
    if lhs._swapInCoin != rhs._swapInCoin {return false}
    if lhs._swapOutCoin != rhs._swapOutCoin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPoolRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_id"),
    2: .standard(proto: "tick_index"),
    3: .same(proto: "fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pairID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.tickIndex) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pairID.isEmpty {
      try visitor.visitSingularStringField(value: self.pairID, fieldNumber: 1)
    }
    if self.tickIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.tickIndex, fieldNumber: 2)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryPoolRequest, rhs: Neutron_Dex_QueryPoolRequest) -> Bool {
    if lhs.pairID != rhs.pairID {return false}
    if lhs.tickIndex != rhs.tickIndex {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryPoolByIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPoolByIDRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryPoolByIDRequest, rhs: Neutron_Dex_QueryPoolByIDRequest) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryPoolResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPoolResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pool) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryPoolResponse, rhs: Neutron_Dex_QueryPoolResponse) -> Bool {
    if lhs._pool != rhs._pool {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryGetPoolMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetPoolMetadataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryGetPoolMetadataRequest, rhs: Neutron_Dex_QueryGetPoolMetadataRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryGetPoolMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGetPoolMetadataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Pool_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._poolMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._poolMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryGetPoolMetadataResponse, rhs: Neutron_Dex_QueryGetPoolMetadataResponse) -> Bool {
    if lhs._poolMetadata != rhs._poolMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllPoolMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllPoolMetadataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllPoolMetadataRequest, rhs: Neutron_Dex_QueryAllPoolMetadataRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_QueryAllPoolMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllPoolMetadataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_metadata"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.poolMetadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.poolMetadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.poolMetadata, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_QueryAllPoolMetadataResponse, rhs: Neutron_Dex_QueryAllPoolMetadataResponse) -> Bool {
    if lhs.poolMetadata != rhs.poolMetadata {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
