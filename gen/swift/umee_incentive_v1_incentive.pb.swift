// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: umee/incentive/v1/incentive.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Params defines the parameters for the incentive module.
struct Umee_Incentive_V1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// max_unbondings is the maximum amount of concurrent unbondings an address can have
  /// of each bonded uToken denom. Zero is interpreted as no limit.
  var maxUnbondings: UInt32 = 0

  /// unbonding_duration is the unbonding duration (in seconds).
  var unbondingDuration: Int64 = 0

  /// emergency_unbond_fee is the portion of a bond that is paid when it is instantly
  /// released using MsgEmergencyUnbond. For example, 0.01 is a 1% fee. Ranges 0-1.
  var emergencyUnbondFee: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// IncentiveProgram defines a liquidity mining incentive program on a single
/// locked uToken denom that will run for a set amount of time.
struct Umee_Incentive_V1_IncentiveProgram {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID uniquely identifies the incentive program after it has been created.
  /// It is zero when the program is being proposed by governance, and is set
  /// to its final value when the proposal passes.
  var id: UInt32 = 0

  /// start_time is the unix time (in seconds) at which the incentives begin.
  /// If a program is passed after its intended start time, its start time
  /// will be increased to the current time, with program duration unchanged.
  var startTime: Int64 = 0

  /// duration is the length of the incentive program from start time to
  /// completion in seconds.
  var duration: Int64 = 0

  /// uToken is the incentivized uToken collateral denom. Suppliers who collateralize
  /// this asset then bond it to the incentive module are eligible for this program's
  /// rewards.
  var uToken: String = String()

  /// funded indicates whether a program bas been funded. This can happen when
  /// a program passes if funding from community fund, or any time before the
  /// program's start time if funding with MsgSponsor. A program that reaches
  /// its start time without being funded is cancelled.
  var funded: Bool = false

  /// total_rewards are total amount of rewards which can be distributed to
  /// suppliers by this program. This is set to its final value when the program
  /// is proposed by governance.
  var totalRewards: Cosmos_Base_V1beta1_Coin {
    get {return _totalRewards ?? Cosmos_Base_V1beta1_Coin()}
    set {_totalRewards = newValue}
  }
  /// Returns true if `totalRewards` has been explicitly set.
  var hasTotalRewards: Bool {return self._totalRewards != nil}
  /// Clears the value of `totalRewards`. Subsequent reads from it will return its default value.
  mutating func clearTotalRewards() {self._totalRewards = nil}

  /// remaining_rewards are total amount of this program's funded rewards
  /// which have not yet been allocated to suppliers. This is zero until the
  /// program is both passed by governance and funded, at which point it
  /// starts at the same value as total_rewards then begins decreasing
  /// to zero as the program runs to completion.
  var remainingRewards: Cosmos_Base_V1beta1_Coin {
    get {return _remainingRewards ?? Cosmos_Base_V1beta1_Coin()}
    set {_remainingRewards = newValue}
  }
  /// Returns true if `remainingRewards` has been explicitly set.
  var hasRemainingRewards: Bool {return self._remainingRewards != nil}
  /// Clears the value of `remainingRewards`. Subsequent reads from it will return its default value.
  mutating func clearRemainingRewards() {self._remainingRewards = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totalRewards: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _remainingRewards: Cosmos_Base_V1beta1_Coin? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Umee_Incentive_V1_Params: @unchecked Sendable {}
extension Umee_Incentive_V1_IncentiveProgram: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "umee.incentive.v1"

extension Umee_Incentive_V1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_unbondings"),
    2: .standard(proto: "unbonding_duration"),
    3: .standard(proto: "emergency_unbond_fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.maxUnbondings) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.unbondingDuration) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.emergencyUnbondFee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxUnbondings != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxUnbondings, fieldNumber: 1)
    }
    if self.unbondingDuration != 0 {
      try visitor.visitSingularInt64Field(value: self.unbondingDuration, fieldNumber: 2)
    }
    if !self.emergencyUnbondFee.isEmpty {
      try visitor.visitSingularStringField(value: self.emergencyUnbondFee, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_Params, rhs: Umee_Incentive_V1_Params) -> Bool {
    if lhs.maxUnbondings != rhs.maxUnbondings {return false}
    if lhs.unbondingDuration != rhs.unbondingDuration {return false}
    if lhs.emergencyUnbondFee != rhs.emergencyUnbondFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_IncentiveProgram: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IncentiveProgram"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .standard(proto: "start_time"),
    3: .same(proto: "duration"),
    4: .same(proto: "uToken"),
    5: .same(proto: "funded"),
    6: .standard(proto: "total_rewards"),
    7: .standard(proto: "remaining_rewards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.startTime) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uToken) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.funded) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._totalRewards) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._remainingRewards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.startTime != 0 {
      try visitor.visitSingularInt64Field(value: self.startTime, fieldNumber: 2)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 3)
    }
    if !self.uToken.isEmpty {
      try visitor.visitSingularStringField(value: self.uToken, fieldNumber: 4)
    }
    if self.funded != false {
      try visitor.visitSingularBoolField(value: self.funded, fieldNumber: 5)
    }
    try { if let v = self._totalRewards {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._remainingRewards {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_IncentiveProgram, rhs: Umee_Incentive_V1_IncentiveProgram) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.uToken != rhs.uToken {return false}
    if lhs.funded != rhs.funded {return false}
    if lhs._totalRewards != rhs._totalRewards {return false}
    if lhs._remainingRewards != rhs._remainingRewards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
