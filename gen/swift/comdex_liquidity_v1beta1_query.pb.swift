// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: comdex/liquidity/v1beta1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryParamsRequest is request type for the Query/Params RPC method.
struct Comdex_Liquidity_V1beta1_QueryParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryParamsResponse is response type for the Query/Params RPC method.
struct Comdex_Liquidity_V1beta1_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Comdex_Liquidity_V1beta1_Params {
    get {return _params ?? Comdex_Liquidity_V1beta1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Comdex_Liquidity_V1beta1_Params? = nil
}

/// QueryGenericParamsRequest is request type for the Query/GenericParams RPC method.
struct Comdex_Liquidity_V1beta1_QueryGenericParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryGenericParamsResponse is response type for the Query/GenericParams RPC method.
struct Comdex_Liquidity_V1beta1_QueryGenericParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Comdex_Liquidity_V1beta1_GenericParams {
    get {return _params ?? Comdex_Liquidity_V1beta1_GenericParams()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Comdex_Liquidity_V1beta1_GenericParams? = nil
}

/// QueryPoolsRequest is request type for the Query/Pools RPC method.
struct Comdex_Liquidity_V1beta1_QueryPoolsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairID: UInt64 = 0

  var disabled: String = String()

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryPoolsResponse is response type for the Query/Pools RPC method.
struct Comdex_Liquidity_V1beta1_QueryPoolsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pools: [Comdex_Liquidity_V1beta1_PoolResponse] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryPoolRequest is request type for the Query/Pool RPC method.
struct Comdex_Liquidity_V1beta1_QueryPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryPoolResponse is response type for the Query/Pool RPC method.
struct Comdex_Liquidity_V1beta1_QueryPoolResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pool: Comdex_Liquidity_V1beta1_PoolResponse {
    get {return _pool ?? Comdex_Liquidity_V1beta1_PoolResponse()}
    set {_pool = newValue}
  }
  /// Returns true if `pool` has been explicitly set.
  var hasPool: Bool {return self._pool != nil}
  /// Clears the value of `pool`. Subsequent reads from it will return its default value.
  mutating func clearPool() {self._pool = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pool: Comdex_Liquidity_V1beta1_PoolResponse? = nil
}

/// QueryPoolByReserveAddressRequest is request type for the Query/PoolByReserveAddress RPC method.
struct Comdex_Liquidity_V1beta1_QueryPoolByReserveAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reserveAddress: String = String()

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryPoolByPoolCoinDenomRequest is request type for the Query/PoolByPoolCoinDenom RPC method.
struct Comdex_Liquidity_V1beta1_QueryPoolByPoolCoinDenomRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolCoinDenom: String = String()

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryPairsRequest is request type for the Query/Pairs RPC method.
struct Comdex_Liquidity_V1beta1_QueryPairsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denoms: [String] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryPairsResponse is response type for the Query/Pairs RPC method.
struct Comdex_Liquidity_V1beta1_QueryPairsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairs: [Comdex_Liquidity_V1beta1_Pair] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryPairRequest is request type for the Query/Pair RPC method.
struct Comdex_Liquidity_V1beta1_QueryPairRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairID: UInt64 = 0

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryPairResponse is response type for the Query/Pair RPC method.
struct Comdex_Liquidity_V1beta1_QueryPairResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pair: Comdex_Liquidity_V1beta1_Pair {
    get {return _pair ?? Comdex_Liquidity_V1beta1_Pair()}
    set {_pair = newValue}
  }
  /// Returns true if `pair` has been explicitly set.
  var hasPair: Bool {return self._pair != nil}
  /// Clears the value of `pair`. Subsequent reads from it will return its default value.
  mutating func clearPair() {self._pair = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pair: Comdex_Liquidity_V1beta1_Pair? = nil
}

/// QueryDepositRequestsRequest is request type for the Query/DepositRequests RPC method.
struct Comdex_Liquidity_V1beta1_QueryDepositRequestsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var appID: UInt64 = 0

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryDepositRequestsResponse is response type for the Query/DepositRequests RPC method.
struct Comdex_Liquidity_V1beta1_QueryDepositRequestsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var depositRequests: [Comdex_Liquidity_V1beta1_DepositRequest] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryDepositRequestRequest is request type for the Query/DepositRequest RPC method.
struct Comdex_Liquidity_V1beta1_QueryDepositRequestRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var id: UInt64 = 0

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDepositRequestResponse is response type for the Query/DepositRequest RPC method.
struct Comdex_Liquidity_V1beta1_QueryDepositRequestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var depositRequest: Comdex_Liquidity_V1beta1_DepositRequest {
    get {return _depositRequest ?? Comdex_Liquidity_V1beta1_DepositRequest()}
    set {_depositRequest = newValue}
  }
  /// Returns true if `depositRequest` has been explicitly set.
  var hasDepositRequest: Bool {return self._depositRequest != nil}
  /// Clears the value of `depositRequest`. Subsequent reads from it will return its default value.
  mutating func clearDepositRequest() {self._depositRequest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _depositRequest: Comdex_Liquidity_V1beta1_DepositRequest? = nil
}

/// QueryWithdrawRequestsRequest is request type for the Query/WithdrawRequests RPC method.
struct Comdex_Liquidity_V1beta1_QueryWithdrawRequestsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryWithdrawRequestsResponse is response type for the Query/WithdrawRequests RPC method.
struct Comdex_Liquidity_V1beta1_QueryWithdrawRequestsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var withdrawRequests: [Comdex_Liquidity_V1beta1_WithdrawRequest] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryWithdrawRequestRequest is request type for the Query/WithdrawRequest RPC method.
struct Comdex_Liquidity_V1beta1_QueryWithdrawRequestRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var id: UInt64 = 0

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryWithdrawRequestResponse is response type for the Query/WithdrawRequest RPC method.
struct Comdex_Liquidity_V1beta1_QueryWithdrawRequestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var withdrawRequest: Comdex_Liquidity_V1beta1_WithdrawRequest {
    get {return _withdrawRequest ?? Comdex_Liquidity_V1beta1_WithdrawRequest()}
    set {_withdrawRequest = newValue}
  }
  /// Returns true if `withdrawRequest` has been explicitly set.
  var hasWithdrawRequest: Bool {return self._withdrawRequest != nil}
  /// Clears the value of `withdrawRequest`. Subsequent reads from it will return its default value.
  mutating func clearWithdrawRequest() {self._withdrawRequest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _withdrawRequest: Comdex_Liquidity_V1beta1_WithdrawRequest? = nil
}

/// QueryOrdersRequest is request type for the Query/Orders RPC method.
struct Comdex_Liquidity_V1beta1_QueryOrdersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairID: UInt64 = 0

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryOrdersResponse is response type for the Query/Orders RPC method.
struct Comdex_Liquidity_V1beta1_QueryOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orders: [Comdex_Liquidity_V1beta1_Order] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryOrderRequest is request type for the Query/Order RPC method.
struct Comdex_Liquidity_V1beta1_QueryOrderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairID: UInt64 = 0

  var id: UInt64 = 0

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryOrderResponse is response type for the Query/Order RPC method.
struct Comdex_Liquidity_V1beta1_QueryOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var order: Comdex_Liquidity_V1beta1_Order {
    get {return _order ?? Comdex_Liquidity_V1beta1_Order()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Comdex_Liquidity_V1beta1_Order? = nil
}

/// QueryOrdersByOrdererRequest is request type for the Query/OrdersByOrderer RPC method.
struct Comdex_Liquidity_V1beta1_QueryOrdersByOrdererRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderer: String = String()

  var pairID: UInt64 = 0

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// PoolResponse defines a custom pool response message.
struct Comdex_Liquidity_V1beta1_PoolResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var pairID: UInt64 {
    get {return _storage._pairID}
    set {_uniqueStorage()._pairID = newValue}
  }

  var reserveAddress: String {
    get {return _storage._reserveAddress}
    set {_uniqueStorage()._reserveAddress = newValue}
  }

  var poolCoinDenom: String {
    get {return _storage._poolCoinDenom}
    set {_uniqueStorage()._poolCoinDenom = newValue}
  }

  var balances: Comdex_Liquidity_V1beta1_PoolBalances {
    get {return _storage._balances ?? Comdex_Liquidity_V1beta1_PoolBalances()}
    set {_uniqueStorage()._balances = newValue}
  }
  /// Returns true if `balances` has been explicitly set.
  var hasBalances: Bool {return _storage._balances != nil}
  /// Clears the value of `balances`. Subsequent reads from it will return its default value.
  mutating func clearBalances() {_uniqueStorage()._balances = nil}

  var lastDepositRequestID: UInt64 {
    get {return _storage._lastDepositRequestID}
    set {_uniqueStorage()._lastDepositRequestID = newValue}
  }

  var lastWithdrawRequestID: UInt64 {
    get {return _storage._lastWithdrawRequestID}
    set {_uniqueStorage()._lastWithdrawRequestID = newValue}
  }

  var appID: UInt64 {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  var type: Comdex_Liquidity_V1beta1_PoolType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var creator: String {
    get {return _storage._creator}
    set {_uniqueStorage()._creator = newValue}
  }

  var poolCoinSupply: String {
    get {return _storage._poolCoinSupply}
    set {_uniqueStorage()._poolCoinSupply = newValue}
  }

  var minPrice: String {
    get {return _storage._minPrice}
    set {_uniqueStorage()._minPrice = newValue}
  }

  var maxPrice: String {
    get {return _storage._maxPrice}
    set {_uniqueStorage()._maxPrice = newValue}
  }

  var price: String {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  var disabled: Bool {
    get {return _storage._disabled}
    set {_uniqueStorage()._disabled = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Comdex_Liquidity_V1beta1_PoolBalances {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseCoin: Cosmos_Base_V1beta1_Coin {
    get {return _baseCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_baseCoin = newValue}
  }
  /// Returns true if `baseCoin` has been explicitly set.
  var hasBaseCoin: Bool {return self._baseCoin != nil}
  /// Clears the value of `baseCoin`. Subsequent reads from it will return its default value.
  mutating func clearBaseCoin() {self._baseCoin = nil}

  var quoteCoin: Cosmos_Base_V1beta1_Coin {
    get {return _quoteCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_quoteCoin = newValue}
  }
  /// Returns true if `quoteCoin` has been explicitly set.
  var hasQuoteCoin: Bool {return self._quoteCoin != nil}
  /// Clears the value of `quoteCoin`. Subsequent reads from it will return its default value.
  mutating func clearQuoteCoin() {self._quoteCoin = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseCoin: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _quoteCoin: Cosmos_Base_V1beta1_Coin? = nil
}

/// QueryFarmerRequest is request type for the Query/Farmer RPC method.
struct Comdex_Liquidity_V1beta1_QueryFarmerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt64 = 0

  var poolID: UInt64 = 0

  var farmer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Liquidity_V1beta1_QueuedPoolCoin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolCoin: Cosmos_Base_V1beta1_Coin {
    get {return _poolCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_poolCoin = newValue}
  }
  /// Returns true if `poolCoin` has been explicitly set.
  var hasPoolCoin: Bool {return self._poolCoin != nil}
  /// Clears the value of `poolCoin`. Subsequent reads from it will return its default value.
  mutating func clearPoolCoin() {self._poolCoin = nil}

  var dequeAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _dequeAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_dequeAt = newValue}
  }
  /// Returns true if `dequeAt` has been explicitly set.
  var hasDequeAt: Bool {return self._dequeAt != nil}
  /// Clears the value of `dequeAt`. Subsequent reads from it will return its default value.
  mutating func clearDequeAt() {self._dequeAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _poolCoin: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _dequeAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// QueryFarmerResponse is response type for the Query/Farmer RPC method.
struct Comdex_Liquidity_V1beta1_QueryFarmerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activePoolCoin: Cosmos_Base_V1beta1_Coin {
    get {return _activePoolCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_activePoolCoin = newValue}
  }
  /// Returns true if `activePoolCoin` has been explicitly set.
  var hasActivePoolCoin: Bool {return self._activePoolCoin != nil}
  /// Clears the value of `activePoolCoin`. Subsequent reads from it will return its default value.
  mutating func clearActivePoolCoin() {self._activePoolCoin = nil}

  var queuedPoolCoin: [Comdex_Liquidity_V1beta1_QueuedPoolCoin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _activePoolCoin: Cosmos_Base_V1beta1_Coin? = nil
}

/// QueryDeserializePoolCoinRequest is request type for the Query/DeserializePoolCoin RPC method.
struct Comdex_Liquidity_V1beta1_QueryDeserializePoolCoinRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var poolCoinAmount: UInt64 = 0

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDeserializePoolCoinResponse is response type for the Query/DeserializePoolCoin RPC method.
struct Comdex_Liquidity_V1beta1_QueryDeserializePoolCoinResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var coins: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryPoolsIncentivesRequest is request type for the Query/PoolsIncentives RPC method.
struct Comdex_Liquidity_V1beta1_QueryPoolsIncentivesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Liquidity_V1beta1_PoolIncentive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var masterPool: Bool = false

  var childPoolIds: [UInt64] = []

  var totalRewards: Cosmos_Base_V1beta1_Coin {
    get {return _totalRewards ?? Cosmos_Base_V1beta1_Coin()}
    set {_totalRewards = newValue}
  }
  /// Returns true if `totalRewards` has been explicitly set.
  var hasTotalRewards: Bool {return self._totalRewards != nil}
  /// Clears the value of `totalRewards`. Subsequent reads from it will return its default value.
  mutating func clearTotalRewards() {self._totalRewards = nil}

  var distributedRewards: Cosmos_Base_V1beta1_Coin {
    get {return _distributedRewards ?? Cosmos_Base_V1beta1_Coin()}
    set {_distributedRewards = newValue}
  }
  /// Returns true if `distributedRewards` has been explicitly set.
  var hasDistributedRewards: Bool {return self._distributedRewards != nil}
  /// Clears the value of `distributedRewards`. Subsequent reads from it will return its default value.
  mutating func clearDistributedRewards() {self._distributedRewards = nil}

  var totalEpochs: UInt64 = 0

  var filledEpochs: UInt64 = 0

  var epochDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _epochDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_epochDuration = newValue}
  }
  /// Returns true if `epochDuration` has been explicitly set.
  var hasEpochDuration: Bool {return self._epochDuration != nil}
  /// Clears the value of `epochDuration`. Subsequent reads from it will return its default value.
  mutating func clearEpochDuration() {self._epochDuration = nil}

  var nextDistribution: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _nextDistribution ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_nextDistribution = newValue}
  }
  /// Returns true if `nextDistribution` has been explicitly set.
  var hasNextDistribution: Bool {return self._nextDistribution != nil}
  /// Clears the value of `nextDistribution`. Subsequent reads from it will return its default value.
  mutating func clearNextDistribution() {self._nextDistribution = nil}

  var isSwapFee: Bool = false

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totalRewards: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _distributedRewards: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _epochDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _nextDistribution: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// QueryPoolIncentivesResponse is response type for the Query/PoolsIncentives RPC method.
struct Comdex_Liquidity_V1beta1_QueryPoolIncentivesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolIncentives: [Comdex_Liquidity_V1beta1_PoolIncentive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Liquidity_V1beta1_QueryFarmedPoolCoinRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Liquidity_V1beta1_QueryFarmedPoolCoinResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var coin: Cosmos_Base_V1beta1_Coin {
    get {return _coin ?? Cosmos_Base_V1beta1_Coin()}
    set {_coin = newValue}
  }
  /// Returns true if `coin` has been explicitly set.
  var hasCoin: Bool {return self._coin != nil}
  /// Clears the value of `coin`. Subsequent reads from it will return its default value.
  mutating func clearCoin() {self._coin = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _coin: Cosmos_Base_V1beta1_Coin? = nil
}

/// QueryOrderBooksRequest is request type for the Query/OrderBooks RPC method.
struct Comdex_Liquidity_V1beta1_QueryOrderBooksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt64 = 0

  var pairIds: [UInt64] = []

  var priceUnitPowers: [UInt32] = []

  var numTicks: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryOrderBooksResponse is response type for Query/OrderBooks RPC method.
struct Comdex_Liquidity_V1beta1_QueryOrderBooksResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairs: [Comdex_Liquidity_V1beta1_OrderBookPairResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Liquidity_V1beta1_OrderBookPairResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pairID: UInt64 = 0

  var basePrice: String = String()

  var orderBooks: [Comdex_Liquidity_V1beta1_OrderBookResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Liquidity_V1beta1_OrderBookResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var priceUnit: String = String()

  var sells: [Comdex_Liquidity_V1beta1_OrderBookTickResponse] = []

  var buys: [Comdex_Liquidity_V1beta1_OrderBookTickResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Liquidity_V1beta1_OrderBookTickResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var price: String = String()

  var userOrderAmount: String = String()

  var poolOrderAmount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Liquidity_V1beta1_TotalActiveAndQueuedPoolCoins {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var totalActivePoolCoin: Cosmos_Base_V1beta1_Coin {
    get {return _totalActivePoolCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_totalActivePoolCoin = newValue}
  }
  /// Returns true if `totalActivePoolCoin` has been explicitly set.
  var hasTotalActivePoolCoin: Bool {return self._totalActivePoolCoin != nil}
  /// Clears the value of `totalActivePoolCoin`. Subsequent reads from it will return its default value.
  mutating func clearTotalActivePoolCoin() {self._totalActivePoolCoin = nil}

  var totalQueuedPoolCoin: Cosmos_Base_V1beta1_Coin {
    get {return _totalQueuedPoolCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_totalQueuedPoolCoin = newValue}
  }
  /// Returns true if `totalQueuedPoolCoin` has been explicitly set.
  var hasTotalQueuedPoolCoin: Bool {return self._totalQueuedPoolCoin != nil}
  /// Clears the value of `totalQueuedPoolCoin`. Subsequent reads from it will return its default value.
  mutating func clearTotalQueuedPoolCoin() {self._totalQueuedPoolCoin = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totalActivePoolCoin: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _totalQueuedPoolCoin: Cosmos_Base_V1beta1_Coin? = nil
}

struct Comdex_Liquidity_V1beta1_QueryAllFarmedPoolCoinsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Liquidity_V1beta1_QueryAllFarmedPoolCoinsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt64 = 0

  var totalActiveAndQueuedCoins: [Comdex_Liquidity_V1beta1_TotalActiveAndQueuedPoolCoins] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Comdex_Liquidity_V1beta1_QueryParamsRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryParamsResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryGenericParamsRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryGenericParamsResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryPoolsRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryPoolsResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryPoolRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryPoolResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryPoolByReserveAddressRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryPoolByPoolCoinDenomRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryPairsRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryPairsResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryPairRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryPairResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryDepositRequestsRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryDepositRequestsResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryDepositRequestRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryDepositRequestResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryWithdrawRequestsRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryWithdrawRequestsResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryWithdrawRequestRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryWithdrawRequestResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryOrdersRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryOrdersResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryOrderRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryOrderResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryOrdersByOrdererRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_PoolResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_PoolBalances: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryFarmerRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueuedPoolCoin: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryFarmerResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryDeserializePoolCoinRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryDeserializePoolCoinResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryPoolsIncentivesRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_PoolIncentive: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryPoolIncentivesResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryFarmedPoolCoinRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryFarmedPoolCoinResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryOrderBooksRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryOrderBooksResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_OrderBookPairResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_OrderBookResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_OrderBookTickResponse: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_TotalActiveAndQueuedPoolCoins: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryAllFarmedPoolCoinsRequest: @unchecked Sendable {}
extension Comdex_Liquidity_V1beta1_QueryAllFarmedPoolCoinsResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "comdex.liquidity.v1beta1"

extension Comdex_Liquidity_V1beta1_QueryParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryParamsRequest, rhs: Comdex_Liquidity_V1beta1_QueryParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryParamsResponse, rhs: Comdex_Liquidity_V1beta1_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryGenericParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGenericParamsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryGenericParamsRequest, rhs: Comdex_Liquidity_V1beta1_QueryGenericParamsRequest) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryGenericParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryGenericParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryGenericParamsResponse, rhs: Comdex_Liquidity_V1beta1_QueryGenericParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryPoolsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPoolsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_id"),
    2: .same(proto: "disabled"),
    3: .same(proto: "pagination"),
    4: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.pairID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.disabled) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pairID, fieldNumber: 1)
    }
    if !self.disabled.isEmpty {
      try visitor.visitSingularStringField(value: self.disabled, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryPoolsRequest, rhs: Comdex_Liquidity_V1beta1_QueryPoolsRequest) -> Bool {
    if lhs.pairID != rhs.pairID {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryPoolsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPoolsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pools"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pools) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pools, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryPoolsResponse, rhs: Comdex_Liquidity_V1beta1_QueryPoolsResponse) -> Bool {
    if lhs.pools != rhs.pools {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPoolRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryPoolRequest, rhs: Comdex_Liquidity_V1beta1_QueryPoolRequest) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryPoolResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPoolResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pool"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pool) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryPoolResponse, rhs: Comdex_Liquidity_V1beta1_QueryPoolResponse) -> Bool {
    if lhs._pool != rhs._pool {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryPoolByReserveAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPoolByReserveAddressRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reserve_address"),
    2: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reserveAddress) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reserveAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.reserveAddress, fieldNumber: 1)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryPoolByReserveAddressRequest, rhs: Comdex_Liquidity_V1beta1_QueryPoolByReserveAddressRequest) -> Bool {
    if lhs.reserveAddress != rhs.reserveAddress {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryPoolByPoolCoinDenomRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPoolByPoolCoinDenomRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_coin_denom"),
    2: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.poolCoinDenom) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.poolCoinDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.poolCoinDenom, fieldNumber: 1)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryPoolByPoolCoinDenomRequest, rhs: Comdex_Liquidity_V1beta1_QueryPoolByPoolCoinDenomRequest) -> Bool {
    if lhs.poolCoinDenom != rhs.poolCoinDenom {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryPairsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPairsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denoms"),
    2: .same(proto: "pagination"),
    3: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.denoms) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.denoms.isEmpty {
      try visitor.visitRepeatedStringField(value: self.denoms, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryPairsRequest, rhs: Comdex_Liquidity_V1beta1_QueryPairsRequest) -> Bool {
    if lhs.denoms != rhs.denoms {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryPairsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPairsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pairs"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pairs) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pairs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pairs, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryPairsResponse, rhs: Comdex_Liquidity_V1beta1_QueryPairsResponse) -> Bool {
    if lhs.pairs != rhs.pairs {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryPairRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPairRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_id"),
    2: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.pairID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pairID, fieldNumber: 1)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryPairRequest, rhs: Comdex_Liquidity_V1beta1_QueryPairRequest) -> Bool {
    if lhs.pairID != rhs.pairID {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryPairResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPairResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pair"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pair) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pair {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryPairResponse, rhs: Comdex_Liquidity_V1beta1_QueryPairResponse) -> Bool {
    if lhs._pair != rhs._pair {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryDepositRequestsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDepositRequestsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "app_id"),
    3: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryDepositRequestsRequest, rhs: Comdex_Liquidity_V1beta1_QueryDepositRequestsRequest) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryDepositRequestsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDepositRequestsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deposit_requests"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.depositRequests) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.depositRequests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.depositRequests, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryDepositRequestsResponse, rhs: Comdex_Liquidity_V1beta1_QueryDepositRequestsResponse) -> Bool {
    if lhs.depositRequests != rhs.depositRequests {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryDepositRequestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDepositRequestRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .same(proto: "id"),
    3: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryDepositRequestRequest, rhs: Comdex_Liquidity_V1beta1_QueryDepositRequestRequest) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryDepositRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDepositRequestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deposit_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._depositRequest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._depositRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryDepositRequestResponse, rhs: Comdex_Liquidity_V1beta1_QueryDepositRequestResponse) -> Bool {
    if lhs._depositRequest != rhs._depositRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryWithdrawRequestsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryWithdrawRequestsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .same(proto: "pagination"),
    3: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryWithdrawRequestsRequest, rhs: Comdex_Liquidity_V1beta1_QueryWithdrawRequestsRequest) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryWithdrawRequestsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryWithdrawRequestsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "withdraw_requests"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.withdrawRequests) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.withdrawRequests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.withdrawRequests, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryWithdrawRequestsResponse, rhs: Comdex_Liquidity_V1beta1_QueryWithdrawRequestsResponse) -> Bool {
    if lhs.withdrawRequests != rhs.withdrawRequests {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryWithdrawRequestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryWithdrawRequestRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .same(proto: "id"),
    3: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryWithdrawRequestRequest, rhs: Comdex_Liquidity_V1beta1_QueryWithdrawRequestRequest) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryWithdrawRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryWithdrawRequestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "withdraw_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._withdrawRequest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._withdrawRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryWithdrawRequestResponse, rhs: Comdex_Liquidity_V1beta1_QueryWithdrawRequestResponse) -> Bool {
    if lhs._withdrawRequest != rhs._withdrawRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryOrdersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOrdersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_id"),
    2: .same(proto: "pagination"),
    3: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.pairID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pairID, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryOrdersRequest, rhs: Comdex_Liquidity_V1beta1_QueryOrdersRequest) -> Bool {
    if lhs.pairID != rhs.pairID {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orders"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryOrdersResponse, rhs: Comdex_Liquidity_V1beta1_QueryOrdersResponse) -> Bool {
    if lhs.orders != rhs.orders {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryOrderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOrderRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_id"),
    2: .same(proto: "id"),
    3: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.pairID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pairID, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryOrderRequest, rhs: Comdex_Liquidity_V1beta1_QueryOrderRequest) -> Bool {
    if lhs.pairID != rhs.pairID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryOrderResponse, rhs: Comdex_Liquidity_V1beta1_QueryOrderResponse) -> Bool {
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryOrdersByOrdererRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOrdersByOrdererRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orderer"),
    2: .standard(proto: "pair_id"),
    3: .same(proto: "pagination"),
    4: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderer) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.pairID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.orderer.isEmpty {
      try visitor.visitSingularStringField(value: self.orderer, fieldNumber: 1)
    }
    if self.pairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pairID, fieldNumber: 2)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryOrdersByOrdererRequest, rhs: Comdex_Liquidity_V1beta1_QueryOrdersByOrdererRequest) -> Bool {
    if lhs.orderer != rhs.orderer {return false}
    if lhs.pairID != rhs.pairID {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_PoolResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pair_id"),
    3: .standard(proto: "reserve_address"),
    4: .standard(proto: "pool_coin_denom"),
    5: .same(proto: "balances"),
    6: .standard(proto: "last_deposit_request_id"),
    7: .standard(proto: "last_withdraw_request_id"),
    8: .standard(proto: "app_id"),
    9: .same(proto: "type"),
    10: .same(proto: "creator"),
    11: .standard(proto: "pool_coin_supply"),
    12: .standard(proto: "min_price"),
    13: .standard(proto: "max_price"),
    14: .same(proto: "price"),
    15: .same(proto: "disabled"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _pairID: UInt64 = 0
    var _reserveAddress: String = String()
    var _poolCoinDenom: String = String()
    var _balances: Comdex_Liquidity_V1beta1_PoolBalances? = nil
    var _lastDepositRequestID: UInt64 = 0
    var _lastWithdrawRequestID: UInt64 = 0
    var _appID: UInt64 = 0
    var _type: Comdex_Liquidity_V1beta1_PoolType = .unspecified
    var _creator: String = String()
    var _poolCoinSupply: String = String()
    var _minPrice: String = String()
    var _maxPrice: String = String()
    var _price: String = String()
    var _disabled: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _pairID = source._pairID
      _reserveAddress = source._reserveAddress
      _poolCoinDenom = source._poolCoinDenom
      _balances = source._balances
      _lastDepositRequestID = source._lastDepositRequestID
      _lastWithdrawRequestID = source._lastWithdrawRequestID
      _appID = source._appID
      _type = source._type
      _creator = source._creator
      _poolCoinSupply = source._poolCoinSupply
      _minPrice = source._minPrice
      _maxPrice = source._maxPrice
      _price = source._price
      _disabled = source._disabled
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._pairID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._reserveAddress) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._poolCoinDenom) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._balances) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._lastDepositRequestID) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._lastWithdrawRequestID) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._appID) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._creator) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._poolCoinSupply) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._minPrice) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._maxPrice) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._price) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._disabled) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._pairID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._pairID, fieldNumber: 2)
      }
      if !_storage._reserveAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reserveAddress, fieldNumber: 3)
      }
      if !_storage._poolCoinDenom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._poolCoinDenom, fieldNumber: 4)
      }
      try { if let v = _storage._balances {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._lastDepositRequestID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lastDepositRequestID, fieldNumber: 6)
      }
      if _storage._lastWithdrawRequestID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lastWithdrawRequestID, fieldNumber: 7)
      }
      if _storage._appID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._appID, fieldNumber: 8)
      }
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 9)
      }
      if !_storage._creator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._creator, fieldNumber: 10)
      }
      if !_storage._poolCoinSupply.isEmpty {
        try visitor.visitSingularStringField(value: _storage._poolCoinSupply, fieldNumber: 11)
      }
      if !_storage._minPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minPrice, fieldNumber: 12)
      }
      if !_storage._maxPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxPrice, fieldNumber: 13)
      }
      if !_storage._price.isEmpty {
        try visitor.visitSingularStringField(value: _storage._price, fieldNumber: 14)
      }
      if _storage._disabled != false {
        try visitor.visitSingularBoolField(value: _storage._disabled, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_PoolResponse, rhs: Comdex_Liquidity_V1beta1_PoolResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._pairID != rhs_storage._pairID {return false}
        if _storage._reserveAddress != rhs_storage._reserveAddress {return false}
        if _storage._poolCoinDenom != rhs_storage._poolCoinDenom {return false}
        if _storage._balances != rhs_storage._balances {return false}
        if _storage._lastDepositRequestID != rhs_storage._lastDepositRequestID {return false}
        if _storage._lastWithdrawRequestID != rhs_storage._lastWithdrawRequestID {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._poolCoinSupply != rhs_storage._poolCoinSupply {return false}
        if _storage._minPrice != rhs_storage._minPrice {return false}
        if _storage._maxPrice != rhs_storage._maxPrice {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._disabled != rhs_storage._disabled {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_PoolBalances: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolBalances"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_coin"),
    2: .standard(proto: "quote_coin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseCoin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._quoteCoin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._quoteCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_PoolBalances, rhs: Comdex_Liquidity_V1beta1_PoolBalances) -> Bool {
    if lhs._baseCoin != rhs._baseCoin {return false}
    if lhs._quoteCoin != rhs._quoteCoin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryFarmerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFarmerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "pool_id"),
    3: .same(proto: "farmer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.farmer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 1)
    }
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 2)
    }
    if !self.farmer.isEmpty {
      try visitor.visitSingularStringField(value: self.farmer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryFarmerRequest, rhs: Comdex_Liquidity_V1beta1_QueryFarmerRequest) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs.farmer != rhs.farmer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueuedPoolCoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueuedPoolCoin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_coin"),
    2: .standard(proto: "deque_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._poolCoin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dequeAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._poolCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dequeAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueuedPoolCoin, rhs: Comdex_Liquidity_V1beta1_QueuedPoolCoin) -> Bool {
    if lhs._poolCoin != rhs._poolCoin {return false}
    if lhs._dequeAt != rhs._dequeAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryFarmerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFarmerResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "active_pool_coin"),
    2: .standard(proto: "queued_pool_coin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._activePoolCoin) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.queuedPoolCoin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._activePoolCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.queuedPoolCoin.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queuedPoolCoin, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryFarmerResponse, rhs: Comdex_Liquidity_V1beta1_QueryFarmerResponse) -> Bool {
    if lhs._activePoolCoin != rhs._activePoolCoin {return false}
    if lhs.queuedPoolCoin != rhs.queuedPoolCoin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryDeserializePoolCoinRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDeserializePoolCoinRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "pool_coin_amount"),
    3: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.poolCoinAmount) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if self.poolCoinAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolCoinAmount, fieldNumber: 2)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryDeserializePoolCoinRequest, rhs: Comdex_Liquidity_V1beta1_QueryDeserializePoolCoinRequest) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.poolCoinAmount != rhs.poolCoinAmount {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryDeserializePoolCoinResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDeserializePoolCoinResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.coins) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.coins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coins, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryDeserializePoolCoinResponse, rhs: Comdex_Liquidity_V1beta1_QueryDeserializePoolCoinResponse) -> Bool {
    if lhs.coins != rhs.coins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryPoolsIncentivesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPoolsIncentivesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryPoolsIncentivesRequest, rhs: Comdex_Liquidity_V1beta1_QueryPoolsIncentivesRequest) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_PoolIncentive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolIncentive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "master_pool"),
    3: .standard(proto: "child_pool_ids"),
    4: .standard(proto: "total_rewards"),
    5: .standard(proto: "distributed_rewards"),
    6: .standard(proto: "total_epochs"),
    7: .standard(proto: "filled_epochs"),
    8: .standard(proto: "epoch_duration"),
    9: .standard(proto: "next_distribution"),
    10: .standard(proto: "is_swap_fee"),
    11: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.masterPool) }()
      case 3: try { try decoder.decodeRepeatedUInt64Field(value: &self.childPoolIds) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._totalRewards) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._distributedRewards) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.totalEpochs) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.filledEpochs) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._epochDuration) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._nextDistribution) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.isSwapFee) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if self.masterPool != false {
      try visitor.visitSingularBoolField(value: self.masterPool, fieldNumber: 2)
    }
    if !self.childPoolIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.childPoolIds, fieldNumber: 3)
    }
    try { if let v = self._totalRewards {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._distributedRewards {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.totalEpochs != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalEpochs, fieldNumber: 6)
    }
    if self.filledEpochs != 0 {
      try visitor.visitSingularUInt64Field(value: self.filledEpochs, fieldNumber: 7)
    }
    try { if let v = self._epochDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._nextDistribution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if self.isSwapFee != false {
      try visitor.visitSingularBoolField(value: self.isSwapFee, fieldNumber: 10)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_PoolIncentive, rhs: Comdex_Liquidity_V1beta1_PoolIncentive) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.masterPool != rhs.masterPool {return false}
    if lhs.childPoolIds != rhs.childPoolIds {return false}
    if lhs._totalRewards != rhs._totalRewards {return false}
    if lhs._distributedRewards != rhs._distributedRewards {return false}
    if lhs.totalEpochs != rhs.totalEpochs {return false}
    if lhs.filledEpochs != rhs.filledEpochs {return false}
    if lhs._epochDuration != rhs._epochDuration {return false}
    if lhs._nextDistribution != rhs._nextDistribution {return false}
    if lhs.isSwapFee != rhs.isSwapFee {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryPoolIncentivesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPoolIncentivesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_incentives"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.poolIncentives) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.poolIncentives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.poolIncentives, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryPoolIncentivesResponse, rhs: Comdex_Liquidity_V1beta1_QueryPoolIncentivesResponse) -> Bool {
    if lhs.poolIncentives != rhs.poolIncentives {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryFarmedPoolCoinRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFarmedPoolCoinRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryFarmedPoolCoinRequest, rhs: Comdex_Liquidity_V1beta1_QueryFarmedPoolCoinRequest) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryFarmedPoolCoinResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFarmedPoolCoinResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryFarmedPoolCoinResponse, rhs: Comdex_Liquidity_V1beta1_QueryFarmedPoolCoinResponse) -> Bool {
    if lhs._coin != rhs._coin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryOrderBooksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOrderBooksRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "pair_ids"),
    3: .standard(proto: "price_unit_powers"),
    4: .standard(proto: "num_ticks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.pairIds) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.priceUnitPowers) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.numTicks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 1)
    }
    if !self.pairIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.pairIds, fieldNumber: 2)
    }
    if !self.priceUnitPowers.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.priceUnitPowers, fieldNumber: 3)
    }
    if self.numTicks != 0 {
      try visitor.visitSingularUInt32Field(value: self.numTicks, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryOrderBooksRequest, rhs: Comdex_Liquidity_V1beta1_QueryOrderBooksRequest) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.pairIds != rhs.pairIds {return false}
    if lhs.priceUnitPowers != rhs.priceUnitPowers {return false}
    if lhs.numTicks != rhs.numTicks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryOrderBooksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOrderBooksResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "pairs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pairs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pairs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pairs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryOrderBooksResponse, rhs: Comdex_Liquidity_V1beta1_QueryOrderBooksResponse) -> Bool {
    if lhs.pairs != rhs.pairs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_OrderBookPairResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderBookPairResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_id"),
    2: .standard(proto: "base_price"),
    3: .standard(proto: "order_books"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.pairID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.basePrice) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.orderBooks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pairID, fieldNumber: 1)
    }
    if !self.basePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.basePrice, fieldNumber: 2)
    }
    if !self.orderBooks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderBooks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_OrderBookPairResponse, rhs: Comdex_Liquidity_V1beta1_OrderBookPairResponse) -> Bool {
    if lhs.pairID != rhs.pairID {return false}
    if lhs.basePrice != rhs.basePrice {return false}
    if lhs.orderBooks != rhs.orderBooks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_OrderBookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderBookResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "price_unit"),
    2: .same(proto: "sells"),
    3: .same(proto: "buys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.priceUnit) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sells) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.buys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.priceUnit.isEmpty {
      try visitor.visitSingularStringField(value: self.priceUnit, fieldNumber: 1)
    }
    if !self.sells.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sells, fieldNumber: 2)
    }
    if !self.buys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buys, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_OrderBookResponse, rhs: Comdex_Liquidity_V1beta1_OrderBookResponse) -> Bool {
    if lhs.priceUnit != rhs.priceUnit {return false}
    if lhs.sells != rhs.sells {return false}
    if lhs.buys != rhs.buys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_OrderBookTickResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderBookTickResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .standard(proto: "user_order_amount"),
    3: .standard(proto: "pool_order_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userOrderAmount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.poolOrderAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 1)
    }
    if !self.userOrderAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.userOrderAmount, fieldNumber: 2)
    }
    if !self.poolOrderAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.poolOrderAmount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_OrderBookTickResponse, rhs: Comdex_Liquidity_V1beta1_OrderBookTickResponse) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.userOrderAmount != rhs.userOrderAmount {return false}
    if lhs.poolOrderAmount != rhs.poolOrderAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_TotalActiveAndQueuedPoolCoins: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TotalActiveAndQueuedPoolCoins"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "total_active_pool_coin"),
    3: .standard(proto: "total_queued_pool_coin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._totalActivePoolCoin) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._totalQueuedPoolCoin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    try { if let v = self._totalActivePoolCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._totalQueuedPoolCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_TotalActiveAndQueuedPoolCoins, rhs: Comdex_Liquidity_V1beta1_TotalActiveAndQueuedPoolCoins) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs._totalActivePoolCoin != rhs._totalActivePoolCoin {return false}
    if lhs._totalQueuedPoolCoin != rhs._totalQueuedPoolCoin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryAllFarmedPoolCoinsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllFarmedPoolCoinsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryAllFarmedPoolCoinsRequest, rhs: Comdex_Liquidity_V1beta1_QueryAllFarmedPoolCoinsRequest) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Liquidity_V1beta1_QueryAllFarmedPoolCoinsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAllFarmedPoolCoinsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "total_active_and_queued_coins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.totalActiveAndQueuedCoins) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 1)
    }
    if !self.totalActiveAndQueuedCoins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalActiveAndQueuedCoins, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Liquidity_V1beta1_QueryAllFarmedPoolCoinsResponse, rhs: Comdex_Liquidity_V1beta1_QueryAllFarmedPoolCoinsResponse) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.totalActiveAndQueuedCoins != rhs.totalActiveAndQueuedCoins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
