// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: zrchain/identity/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgUpdateParams is the Msg/UpdateParams request type.
struct Zrchain_Identity_MsgUpdateParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authority is the address that controls the module (defaults to x/gov unless
  /// overwritten).
  var authority: String = String()

  /// NOTE: All parameters must be supplied.
  var params: Zrchain_Identity_Params {
    get {return _params ?? Zrchain_Identity_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Zrchain_Identity_Params? = nil
}

/// MsgUpdateParamsResponse defines the response structure for executing a
/// MsgUpdateParams message.
struct Zrchain_Identity_MsgUpdateParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgNewWorkspace is the Msg/NewWorkspace request type
struct Zrchain_Identity_MsgNewWorkspace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var adminPolicyID: UInt64 = 0

  var signPolicyID: UInt64 = 0

  /// Optional
  var additionalOwners: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgNewWorkspaceResponse defines the response structure for executing a
/// MsgNewWorkspace message
struct Zrchain_Identity_MsgNewWorkspaceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddWorkspaceOwner is the Msg/AddWorkspaceOwner request type
struct Zrchain_Identity_MsgAddWorkspaceOwner {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var workspaceAddr: String = String()

  var newOwner: String = String()

  var btl: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddWorkspaceOwnerResponse defines the response structure for executing a
/// MsgAddWorkspaceOwner message
struct Zrchain_Identity_MsgAddWorkspaceOwnerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAppendChildWorkspace is the Msg/AppendChildWorkspace request type
struct Zrchain_Identity_MsgAppendChildWorkspace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var parentWorkspaceAddr: String = String()

  var childWorkspaceAddr: String = String()

  var btl: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAppendChildWorkspaceResponse defines the response structure for executing
/// a MsgAppendChildWorkspace message
struct Zrchain_Identity_MsgAppendChildWorkspaceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgNewChildWorkspace is the Msg/NewChildWorkspace request type
struct Zrchain_Identity_MsgNewChildWorkspace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var parentWorkspaceAddr: String = String()

  var btl: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgNewChildWorkspaceResponse defines the response structure for executing a
/// MsgNewChildWorkspaceResponse message
struct Zrchain_Identity_MsgNewChildWorkspaceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRemoveWorkspaceOwner is the Msg/RemoveWorkspaceOwner request type
struct Zrchain_Identity_MsgRemoveWorkspaceOwner {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var workspaceAddr: String = String()

  var owner: String = String()

  var btl: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRemoveWorkspaceOwnerResponse defines the response structure for executing
/// a MsgRemoveWorkspaceOwner message
struct Zrchain_Identity_MsgRemoveWorkspaceOwnerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgNewKeyring is the Msg/NewKeyring request type
struct Zrchain_Identity_MsgNewKeyring {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var description_p: String = String()

  var partyThreshold: UInt32 = 0

  var keyReqFee: UInt64 = 0

  var sigReqFee: UInt64 = 0

  var delegateFees: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgNewKeyringResponse is the Msg/NewKeyringResponse response type
struct Zrchain_Identity_MsgNewKeyringResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddKeyringParty is the Msg/AddKeyringParty request type
struct Zrchain_Identity_MsgAddKeyringParty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var keyringAddr: String = String()

  var party: String = String()

  /// Optional flag
  var increaseThreshold: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddKeyringPartyResponse is the Msg/AddKeyringPartyResponse response type
struct Zrchain_Identity_MsgAddKeyringPartyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateKeyring is the Msg/UpdateKeyring request type
struct Zrchain_Identity_MsgUpdateKeyring {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var keyringAddr: String = String()

  var partyThreshold: UInt32 = 0

  var keyReqFee: UInt64 = 0

  var sigReqFee: UInt64 = 0

  var description_p: String = String()

  var isActive: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateKeyringResponse is the Msg/UpdateKeyringResponse response type
struct Zrchain_Identity_MsgUpdateKeyringResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRemoveKeyringParty is the Msg/RemoveKeyringParty request type
struct Zrchain_Identity_MsgRemoveKeyringParty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var keyringAddr: String = String()

  var party: String = String()

  /// Optional flag
  var decreaseThreshold: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRemoveKeyringPartyResponse is the Msg/RemoveKeyringPartyResponse response
/// type
struct Zrchain_Identity_MsgRemoveKeyringPartyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddKeyringAdmin is the Msg/AddKeyringAdmin request type
struct Zrchain_Identity_MsgAddKeyringAdmin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var keyringAddr: String = String()

  var admin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddKeyringAdminResponse is the Msg/AddKeyringAdminResponse response type
struct Zrchain_Identity_MsgAddKeyringAdminResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRemoveKeyringAdmin is the Msg/RemoveKeyringAdmin request type
struct Zrchain_Identity_MsgRemoveKeyringAdmin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var keyringAddr: String = String()

  var admin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRemoveKeyringAdminResponse is the Msg/RemoveKeyringAdminResponse response
/// type
struct Zrchain_Identity_MsgRemoveKeyringAdminResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateWorkspace is the Msg/UpdateWorkspace request type
struct Zrchain_Identity_MsgUpdateWorkspace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var workspaceAddr: String = String()

  var adminPolicyID: UInt64 = 0

  var signPolicyID: UInt64 = 0

  var btl: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateWorkspaceResponse is the Msg/UpdateWorkspaceResponse response type
struct Zrchain_Identity_MsgUpdateWorkspaceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeactivateKeyring is the Msg/DeactivateKeyring request type
struct Zrchain_Identity_MsgDeactivateKeyring {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var keyringAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeactivateKeyringResponse is the Msg/DeactivateKeyringResponse response
/// type
struct Zrchain_Identity_MsgDeactivateKeyringResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Zrchain_Identity_MsgUpdateParams: @unchecked Sendable {}
extension Zrchain_Identity_MsgUpdateParamsResponse: @unchecked Sendable {}
extension Zrchain_Identity_MsgNewWorkspace: @unchecked Sendable {}
extension Zrchain_Identity_MsgNewWorkspaceResponse: @unchecked Sendable {}
extension Zrchain_Identity_MsgAddWorkspaceOwner: @unchecked Sendable {}
extension Zrchain_Identity_MsgAddWorkspaceOwnerResponse: @unchecked Sendable {}
extension Zrchain_Identity_MsgAppendChildWorkspace: @unchecked Sendable {}
extension Zrchain_Identity_MsgAppendChildWorkspaceResponse: @unchecked Sendable {}
extension Zrchain_Identity_MsgNewChildWorkspace: @unchecked Sendable {}
extension Zrchain_Identity_MsgNewChildWorkspaceResponse: @unchecked Sendable {}
extension Zrchain_Identity_MsgRemoveWorkspaceOwner: @unchecked Sendable {}
extension Zrchain_Identity_MsgRemoveWorkspaceOwnerResponse: @unchecked Sendable {}
extension Zrchain_Identity_MsgNewKeyring: @unchecked Sendable {}
extension Zrchain_Identity_MsgNewKeyringResponse: @unchecked Sendable {}
extension Zrchain_Identity_MsgAddKeyringParty: @unchecked Sendable {}
extension Zrchain_Identity_MsgAddKeyringPartyResponse: @unchecked Sendable {}
extension Zrchain_Identity_MsgUpdateKeyring: @unchecked Sendable {}
extension Zrchain_Identity_MsgUpdateKeyringResponse: @unchecked Sendable {}
extension Zrchain_Identity_MsgRemoveKeyringParty: @unchecked Sendable {}
extension Zrchain_Identity_MsgRemoveKeyringPartyResponse: @unchecked Sendable {}
extension Zrchain_Identity_MsgAddKeyringAdmin: @unchecked Sendable {}
extension Zrchain_Identity_MsgAddKeyringAdminResponse: @unchecked Sendable {}
extension Zrchain_Identity_MsgRemoveKeyringAdmin: @unchecked Sendable {}
extension Zrchain_Identity_MsgRemoveKeyringAdminResponse: @unchecked Sendable {}
extension Zrchain_Identity_MsgUpdateWorkspace: @unchecked Sendable {}
extension Zrchain_Identity_MsgUpdateWorkspaceResponse: @unchecked Sendable {}
extension Zrchain_Identity_MsgDeactivateKeyring: @unchecked Sendable {}
extension Zrchain_Identity_MsgDeactivateKeyringResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "zrchain.identity"

extension Zrchain_Identity_MsgUpdateParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgUpdateParams, rhs: Zrchain_Identity_MsgUpdateParams) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgUpdateParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParamsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgUpdateParamsResponse, rhs: Zrchain_Identity_MsgUpdateParamsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgNewWorkspace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewWorkspace"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "admin_policy_id"),
    3: .standard(proto: "sign_policy_id"),
    4: .standard(proto: "additional_owners"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.adminPolicyID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.signPolicyID) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.additionalOwners) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.adminPolicyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.adminPolicyID, fieldNumber: 2)
    }
    if self.signPolicyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.signPolicyID, fieldNumber: 3)
    }
    if !self.additionalOwners.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalOwners, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgNewWorkspace, rhs: Zrchain_Identity_MsgNewWorkspace) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.adminPolicyID != rhs.adminPolicyID {return false}
    if lhs.signPolicyID != rhs.signPolicyID {return false}
    if lhs.additionalOwners != rhs.additionalOwners {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgNewWorkspaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewWorkspaceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgNewWorkspaceResponse, rhs: Zrchain_Identity_MsgNewWorkspaceResponse) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgAddWorkspaceOwner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddWorkspaceOwner"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "workspace_addr"),
    3: .standard(proto: "new_owner"),
    4: .same(proto: "btl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workspaceAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.newOwner) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.btl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.workspaceAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceAddr, fieldNumber: 2)
    }
    if !self.newOwner.isEmpty {
      try visitor.visitSingularStringField(value: self.newOwner, fieldNumber: 3)
    }
    if self.btl != 0 {
      try visitor.visitSingularUInt64Field(value: self.btl, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgAddWorkspaceOwner, rhs: Zrchain_Identity_MsgAddWorkspaceOwner) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.workspaceAddr != rhs.workspaceAddr {return false}
    if lhs.newOwner != rhs.newOwner {return false}
    if lhs.btl != rhs.btl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgAddWorkspaceOwnerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddWorkspaceOwnerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgAddWorkspaceOwnerResponse, rhs: Zrchain_Identity_MsgAddWorkspaceOwnerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgAppendChildWorkspace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAppendChildWorkspace"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "parent_workspace_addr"),
    3: .standard(proto: "child_workspace_addr"),
    4: .same(proto: "btl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.parentWorkspaceAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.childWorkspaceAddr) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.btl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.parentWorkspaceAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.parentWorkspaceAddr, fieldNumber: 2)
    }
    if !self.childWorkspaceAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.childWorkspaceAddr, fieldNumber: 3)
    }
    if self.btl != 0 {
      try visitor.visitSingularUInt64Field(value: self.btl, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgAppendChildWorkspace, rhs: Zrchain_Identity_MsgAppendChildWorkspace) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.parentWorkspaceAddr != rhs.parentWorkspaceAddr {return false}
    if lhs.childWorkspaceAddr != rhs.childWorkspaceAddr {return false}
    if lhs.btl != rhs.btl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgAppendChildWorkspaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAppendChildWorkspaceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgAppendChildWorkspaceResponse, rhs: Zrchain_Identity_MsgAppendChildWorkspaceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgNewChildWorkspace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewChildWorkspace"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "parent_workspace_addr"),
    3: .same(proto: "btl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.parentWorkspaceAddr) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.btl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.parentWorkspaceAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.parentWorkspaceAddr, fieldNumber: 2)
    }
    if self.btl != 0 {
      try visitor.visitSingularUInt64Field(value: self.btl, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgNewChildWorkspace, rhs: Zrchain_Identity_MsgNewChildWorkspace) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.parentWorkspaceAddr != rhs.parentWorkspaceAddr {return false}
    if lhs.btl != rhs.btl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgNewChildWorkspaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewChildWorkspaceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgNewChildWorkspaceResponse, rhs: Zrchain_Identity_MsgNewChildWorkspaceResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgRemoveWorkspaceOwner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveWorkspaceOwner"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "workspace_addr"),
    3: .same(proto: "owner"),
    4: .same(proto: "btl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workspaceAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.btl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.workspaceAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceAddr, fieldNumber: 2)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 3)
    }
    if self.btl != 0 {
      try visitor.visitSingularUInt64Field(value: self.btl, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgRemoveWorkspaceOwner, rhs: Zrchain_Identity_MsgRemoveWorkspaceOwner) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.workspaceAddr != rhs.workspaceAddr {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.btl != rhs.btl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgRemoveWorkspaceOwnerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveWorkspaceOwnerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgRemoveWorkspaceOwnerResponse, rhs: Zrchain_Identity_MsgRemoveWorkspaceOwnerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgNewKeyring: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewKeyring"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "description"),
    3: .standard(proto: "party_threshold"),
    4: .standard(proto: "key_req_fee"),
    5: .standard(proto: "sig_req_fee"),
    6: .standard(proto: "delegate_fees"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.partyThreshold) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.keyReqFee) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.sigReqFee) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.delegateFees) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if self.partyThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.partyThreshold, fieldNumber: 3)
    }
    if self.keyReqFee != 0 {
      try visitor.visitSingularUInt64Field(value: self.keyReqFee, fieldNumber: 4)
    }
    if self.sigReqFee != 0 {
      try visitor.visitSingularUInt64Field(value: self.sigReqFee, fieldNumber: 5)
    }
    if self.delegateFees != false {
      try visitor.visitSingularBoolField(value: self.delegateFees, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgNewKeyring, rhs: Zrchain_Identity_MsgNewKeyring) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.partyThreshold != rhs.partyThreshold {return false}
    if lhs.keyReqFee != rhs.keyReqFee {return false}
    if lhs.sigReqFee != rhs.sigReqFee {return false}
    if lhs.delegateFees != rhs.delegateFees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgNewKeyringResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewKeyringResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgNewKeyringResponse, rhs: Zrchain_Identity_MsgNewKeyringResponse) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgAddKeyringParty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddKeyringParty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "keyring_addr"),
    3: .same(proto: "party"),
    4: .standard(proto: "increase_threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyringAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.party) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.increaseThreshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.keyringAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.keyringAddr, fieldNumber: 2)
    }
    if !self.party.isEmpty {
      try visitor.visitSingularStringField(value: self.party, fieldNumber: 3)
    }
    if self.increaseThreshold != false {
      try visitor.visitSingularBoolField(value: self.increaseThreshold, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgAddKeyringParty, rhs: Zrchain_Identity_MsgAddKeyringParty) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.keyringAddr != rhs.keyringAddr {return false}
    if lhs.party != rhs.party {return false}
    if lhs.increaseThreshold != rhs.increaseThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgAddKeyringPartyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddKeyringPartyResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgAddKeyringPartyResponse, rhs: Zrchain_Identity_MsgAddKeyringPartyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgUpdateKeyring: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateKeyring"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "keyring_addr"),
    3: .standard(proto: "party_threshold"),
    4: .standard(proto: "key_req_fee"),
    5: .standard(proto: "sig_req_fee"),
    6: .same(proto: "description"),
    7: .standard(proto: "is_active"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyringAddr) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.partyThreshold) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.keyReqFee) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.sigReqFee) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isActive) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.keyringAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.keyringAddr, fieldNumber: 2)
    }
    if self.partyThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.partyThreshold, fieldNumber: 3)
    }
    if self.keyReqFee != 0 {
      try visitor.visitSingularUInt64Field(value: self.keyReqFee, fieldNumber: 4)
    }
    if self.sigReqFee != 0 {
      try visitor.visitSingularUInt64Field(value: self.sigReqFee, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    if self.isActive != false {
      try visitor.visitSingularBoolField(value: self.isActive, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgUpdateKeyring, rhs: Zrchain_Identity_MsgUpdateKeyring) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.keyringAddr != rhs.keyringAddr {return false}
    if lhs.partyThreshold != rhs.partyThreshold {return false}
    if lhs.keyReqFee != rhs.keyReqFee {return false}
    if lhs.sigReqFee != rhs.sigReqFee {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.isActive != rhs.isActive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgUpdateKeyringResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateKeyringResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgUpdateKeyringResponse, rhs: Zrchain_Identity_MsgUpdateKeyringResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgRemoveKeyringParty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveKeyringParty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "keyring_addr"),
    3: .same(proto: "party"),
    4: .standard(proto: "decrease_threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyringAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.party) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.decreaseThreshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.keyringAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.keyringAddr, fieldNumber: 2)
    }
    if !self.party.isEmpty {
      try visitor.visitSingularStringField(value: self.party, fieldNumber: 3)
    }
    if self.decreaseThreshold != false {
      try visitor.visitSingularBoolField(value: self.decreaseThreshold, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgRemoveKeyringParty, rhs: Zrchain_Identity_MsgRemoveKeyringParty) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.keyringAddr != rhs.keyringAddr {return false}
    if lhs.party != rhs.party {return false}
    if lhs.decreaseThreshold != rhs.decreaseThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgRemoveKeyringPartyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveKeyringPartyResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgRemoveKeyringPartyResponse, rhs: Zrchain_Identity_MsgRemoveKeyringPartyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgAddKeyringAdmin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddKeyringAdmin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "keyring_addr"),
    3: .same(proto: "admin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyringAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.keyringAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.keyringAddr, fieldNumber: 2)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgAddKeyringAdmin, rhs: Zrchain_Identity_MsgAddKeyringAdmin) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.keyringAddr != rhs.keyringAddr {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgAddKeyringAdminResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddKeyringAdminResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgAddKeyringAdminResponse, rhs: Zrchain_Identity_MsgAddKeyringAdminResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgRemoveKeyringAdmin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveKeyringAdmin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "keyring_addr"),
    3: .same(proto: "admin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyringAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.keyringAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.keyringAddr, fieldNumber: 2)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgRemoveKeyringAdmin, rhs: Zrchain_Identity_MsgRemoveKeyringAdmin) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.keyringAddr != rhs.keyringAddr {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgRemoveKeyringAdminResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveKeyringAdminResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgRemoveKeyringAdminResponse, rhs: Zrchain_Identity_MsgRemoveKeyringAdminResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgUpdateWorkspace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateWorkspace"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "workspace_addr"),
    3: .standard(proto: "admin_policy_id"),
    4: .standard(proto: "sign_policy_id"),
    5: .same(proto: "btl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workspaceAddr) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.adminPolicyID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.signPolicyID) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.btl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.workspaceAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceAddr, fieldNumber: 2)
    }
    if self.adminPolicyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.adminPolicyID, fieldNumber: 3)
    }
    if self.signPolicyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.signPolicyID, fieldNumber: 4)
    }
    if self.btl != 0 {
      try visitor.visitSingularUInt64Field(value: self.btl, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgUpdateWorkspace, rhs: Zrchain_Identity_MsgUpdateWorkspace) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.workspaceAddr != rhs.workspaceAddr {return false}
    if lhs.adminPolicyID != rhs.adminPolicyID {return false}
    if lhs.signPolicyID != rhs.signPolicyID {return false}
    if lhs.btl != rhs.btl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgUpdateWorkspaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateWorkspaceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgUpdateWorkspaceResponse, rhs: Zrchain_Identity_MsgUpdateWorkspaceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgDeactivateKeyring: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeactivateKeyring"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "keyring_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyringAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.keyringAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.keyringAddr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgDeactivateKeyring, rhs: Zrchain_Identity_MsgDeactivateKeyring) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.keyringAddr != rhs.keyringAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Identity_MsgDeactivateKeyringResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeactivateKeyringResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Identity_MsgDeactivateKeyringResponse, rhs: Zrchain_Identity_MsgDeactivateKeyringResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
