// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cudos/marketplace/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Cudoventures_Cudosnode_Marketplace_MsgPublishCollection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var denomID: String = String()

  var mintRoyalties: [Cudoventures_Cudosnode_Marketplace_Royalty] = []

  var resaleRoyalties: [Cudoventures_Cudosnode_Marketplace_Royalty] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgPublishCollectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgPublishNft {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var tokenID: String = String()

  var denomID: String = String()

  var price: Cosmos_Base_V1beta1_Coin {
    get {return _price ?? Cosmos_Base_V1beta1_Coin()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  mutating func clearPrice() {self._price = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _price: Cosmos_Base_V1beta1_Coin? = nil
}

struct Cudoventures_Cudosnode_Marketplace_MsgPublishNftResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgBuyNft {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgBuyNftResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgMintNft {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var denomID: String = String()

  var recipient: String = String()

  var price: Cosmos_Base_V1beta1_Coin {
    get {return _price ?? Cosmos_Base_V1beta1_Coin()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  mutating func clearPrice() {self._price = nil}

  var name: String = String()

  var uri: String = String()

  var data: String = String()

  var uid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _price: Cosmos_Base_V1beta1_Coin? = nil
}

struct Cudoventures_Cudosnode_Marketplace_MsgMintNftResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgRemoveNft {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgRemoveNftResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgVerifyCollection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgVerifyCollectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgUnverifyCollection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgUnverifyCollectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgCreateCollection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var id: String = String()

  var name: String = String()

  var schema: String = String()

  var symbol: String = String()

  var traits: String = String()

  var description_p: String = String()

  var minter: String = String()

  var data: String = String()

  var mintRoyalties: [Cudoventures_Cudosnode_Marketplace_Royalty] = []

  var resaleRoyalties: [Cudoventures_Cudosnode_Marketplace_Royalty] = []

  var verified: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgCreateCollectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgUpdateRoyalties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var id: UInt64 = 0

  var mintRoyalties: [Cudoventures_Cudosnode_Marketplace_Royalty] = []

  var resaleRoyalties: [Cudoventures_Cudosnode_Marketplace_Royalty] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgUpdateRoyaltiesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgUpdatePrice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var id: UInt64 = 0

  var price: Cosmos_Base_V1beta1_Coin {
    get {return _price ?? Cosmos_Base_V1beta1_Coin()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  mutating func clearPrice() {self._price = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _price: Cosmos_Base_V1beta1_Coin? = nil
}

struct Cudoventures_Cudosnode_Marketplace_MsgUpdatePriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgAddAdmin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgAddAdminResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgRemoveAdmin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Cudoventures_Cudosnode_Marketplace_MsgRemoveAdminResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Cudoventures_Cudosnode_Marketplace_MsgPublishCollection: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgPublishCollectionResponse: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgPublishNft: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgPublishNftResponse: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgBuyNft: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgBuyNftResponse: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgMintNft: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgMintNftResponse: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgRemoveNft: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgRemoveNftResponse: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgVerifyCollection: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgVerifyCollectionResponse: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgUnverifyCollection: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgUnverifyCollectionResponse: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgCreateCollection: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgCreateCollectionResponse: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgUpdateRoyalties: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgUpdateRoyaltiesResponse: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgUpdatePrice: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgUpdatePriceResponse: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgAddAdmin: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgAddAdminResponse: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgRemoveAdmin: @unchecked Sendable {}
extension Cudoventures_Cudosnode_Marketplace_MsgRemoveAdminResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cudoventures.cudosnode.marketplace"

extension Cudoventures_Cudosnode_Marketplace_MsgPublishCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPublishCollection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "denomId"),
    3: .same(proto: "mintRoyalties"),
    4: .same(proto: "resaleRoyalties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denomID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mintRoyalties) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.resaleRoyalties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.denomID.isEmpty {
      try visitor.visitSingularStringField(value: self.denomID, fieldNumber: 2)
    }
    if !self.mintRoyalties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mintRoyalties, fieldNumber: 3)
    }
    if !self.resaleRoyalties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resaleRoyalties, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgPublishCollection, rhs: Cudoventures_Cudosnode_Marketplace_MsgPublishCollection) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.denomID != rhs.denomID {return false}
    if lhs.mintRoyalties != rhs.mintRoyalties {return false}
    if lhs.resaleRoyalties != rhs.resaleRoyalties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgPublishCollectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPublishCollectionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgPublishCollectionResponse, rhs: Cudoventures_Cudosnode_Marketplace_MsgPublishCollectionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgPublishNft: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPublishNft"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "tokenId"),
    3: .same(proto: "denomId"),
    4: .same(proto: "price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.denomID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 2)
    }
    if !self.denomID.isEmpty {
      try visitor.visitSingularStringField(value: self.denomID, fieldNumber: 3)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgPublishNft, rhs: Cudoventures_Cudosnode_Marketplace_MsgPublishNft) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.denomID != rhs.denomID {return false}
    if lhs._price != rhs._price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgPublishNftResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPublishNftResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgPublishNftResponse, rhs: Cudoventures_Cudosnode_Marketplace_MsgPublishNftResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgBuyNft: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBuyNft"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgBuyNft, rhs: Cudoventures_Cudosnode_Marketplace_MsgBuyNft) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgBuyNftResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBuyNftResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgBuyNftResponse, rhs: Cudoventures_Cudosnode_Marketplace_MsgBuyNftResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgMintNft: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMintNft"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "denomId"),
    3: .same(proto: "recipient"),
    4: .same(proto: "price"),
    5: .same(proto: "name"),
    6: .same(proto: "uri"),
    7: .same(proto: "data"),
    8: .same(proto: "uid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denomID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.recipient) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.denomID.isEmpty {
      try visitor.visitSingularStringField(value: self.denomID, fieldNumber: 2)
    }
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 3)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 6)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 7)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgMintNft, rhs: Cudoventures_Cudosnode_Marketplace_MsgMintNft) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.denomID != rhs.denomID {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs._price != rhs._price {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.data != rhs.data {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgMintNftResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMintNftResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgMintNftResponse, rhs: Cudoventures_Cudosnode_Marketplace_MsgMintNftResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgRemoveNft: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveNft"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgRemoveNft, rhs: Cudoventures_Cudosnode_Marketplace_MsgRemoveNft) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgRemoveNftResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveNftResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgRemoveNftResponse, rhs: Cudoventures_Cudosnode_Marketplace_MsgRemoveNftResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgVerifyCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgVerifyCollection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgVerifyCollection, rhs: Cudoventures_Cudosnode_Marketplace_MsgVerifyCollection) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgVerifyCollectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgVerifyCollectionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgVerifyCollectionResponse, rhs: Cudoventures_Cudosnode_Marketplace_MsgVerifyCollectionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgUnverifyCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUnverifyCollection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgUnverifyCollection, rhs: Cudoventures_Cudosnode_Marketplace_MsgUnverifyCollection) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgUnverifyCollectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUnverifyCollectionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgUnverifyCollectionResponse, rhs: Cudoventures_Cudosnode_Marketplace_MsgUnverifyCollectionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgCreateCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateCollection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "id"),
    3: .same(proto: "name"),
    4: .same(proto: "schema"),
    5: .same(proto: "symbol"),
    6: .same(proto: "traits"),
    7: .same(proto: "description"),
    8: .same(proto: "minter"),
    9: .same(proto: "data"),
    10: .same(proto: "mintRoyalties"),
    11: .same(proto: "resaleRoyalties"),
    12: .same(proto: "verified"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.schema) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.traits) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.minter) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.mintRoyalties) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.resaleRoyalties) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.verified) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.schema.isEmpty {
      try visitor.visitSingularStringField(value: self.schema, fieldNumber: 4)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 5)
    }
    if !self.traits.isEmpty {
      try visitor.visitSingularStringField(value: self.traits, fieldNumber: 6)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 7)
    }
    if !self.minter.isEmpty {
      try visitor.visitSingularStringField(value: self.minter, fieldNumber: 8)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 9)
    }
    if !self.mintRoyalties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mintRoyalties, fieldNumber: 10)
    }
    if !self.resaleRoyalties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resaleRoyalties, fieldNumber: 11)
    }
    if self.verified != false {
      try visitor.visitSingularBoolField(value: self.verified, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgCreateCollection, rhs: Cudoventures_Cudosnode_Marketplace_MsgCreateCollection) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.schema != rhs.schema {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.traits != rhs.traits {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.minter != rhs.minter {return false}
    if lhs.data != rhs.data {return false}
    if lhs.mintRoyalties != rhs.mintRoyalties {return false}
    if lhs.resaleRoyalties != rhs.resaleRoyalties {return false}
    if lhs.verified != rhs.verified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgCreateCollectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateCollectionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgCreateCollectionResponse, rhs: Cudoventures_Cudosnode_Marketplace_MsgCreateCollectionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgUpdateRoyalties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateRoyalties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "id"),
    3: .same(proto: "mintRoyalties"),
    4: .same(proto: "resaleRoyalties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mintRoyalties) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.resaleRoyalties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    if !self.mintRoyalties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mintRoyalties, fieldNumber: 3)
    }
    if !self.resaleRoyalties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resaleRoyalties, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgUpdateRoyalties, rhs: Cudoventures_Cudosnode_Marketplace_MsgUpdateRoyalties) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.id != rhs.id {return false}
    if lhs.mintRoyalties != rhs.mintRoyalties {return false}
    if lhs.resaleRoyalties != rhs.resaleRoyalties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgUpdateRoyaltiesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateRoyaltiesResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgUpdateRoyaltiesResponse, rhs: Cudoventures_Cudosnode_Marketplace_MsgUpdateRoyaltiesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgUpdatePrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdatePrice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "id"),
    4: .same(proto: "price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgUpdatePrice, rhs: Cudoventures_Cudosnode_Marketplace_MsgUpdatePrice) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.id != rhs.id {return false}
    if lhs._price != rhs._price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgUpdatePriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdatePriceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgUpdatePriceResponse, rhs: Cudoventures_Cudosnode_Marketplace_MsgUpdatePriceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgAddAdmin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddAdmin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgAddAdmin, rhs: Cudoventures_Cudosnode_Marketplace_MsgAddAdmin) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgAddAdminResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddAdminResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgAddAdminResponse, rhs: Cudoventures_Cudosnode_Marketplace_MsgAddAdminResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgRemoveAdmin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveAdmin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgRemoveAdmin, rhs: Cudoventures_Cudosnode_Marketplace_MsgRemoveAdmin) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cudoventures_Cudosnode_Marketplace_MsgRemoveAdminResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveAdminResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cudoventures_Cudosnode_Marketplace_MsgRemoveAdminResponse, rhs: Cudoventures_Cudosnode_Marketplace_MsgRemoveAdminResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
