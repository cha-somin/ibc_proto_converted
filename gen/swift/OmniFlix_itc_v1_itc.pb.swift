// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: OmniFlix/itc/v1/itc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum OmniFlix_Itc_V1_DistributionType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case instant // = 0
  case stream // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .instant
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .instant
    case 1: self = .stream
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .instant: return 0
    case .stream: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension OmniFlix_Itc_V1_DistributionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [OmniFlix_Itc_V1_DistributionType] = [
    .instant,
    .stream,
  ]
}

#endif  // swift(>=4.2)

enum OmniFlix_Itc_V1_InteractionType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case burn // = 0
  case transfer // = 1
  case hold // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .burn
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .burn
    case 1: self = .transfer
    case 2: self = .hold
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .burn: return 0
    case .transfer: return 1
    case .hold: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension OmniFlix_Itc_V1_InteractionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [OmniFlix_Itc_V1_InteractionType] = [
    .burn,
    .transfer,
    .hold,
  ]
}

#endif  // swift(>=4.2)

enum OmniFlix_Itc_V1_CampaignStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case inactive // = 1
  case active // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .inactive
    case 2: self = .active
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .inactive: return 1
    case .active: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension OmniFlix_Itc_V1_CampaignStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [OmniFlix_Itc_V1_CampaignStatus] = [
    .unspecified,
    .inactive,
    .active,
  ]
}

#endif  // swift(>=4.2)

enum OmniFlix_Itc_V1_ClaimType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ft // = 0
  case nft // = 1
  case ftAndNft // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .ft
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ft
    case 1: self = .nft
    case 2: self = .ftAndNft
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ft: return 0
    case .nft: return 1
    case .ftAndNft: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension OmniFlix_Itc_V1_ClaimType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [OmniFlix_Itc_V1_ClaimType] = [
    .ft,
    .nft,
    .ftAndNft,
  ]
}

#endif  // swift(>=4.2)

struct OmniFlix_Itc_V1_Campaign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  var creator: String {
    get {return _storage._creator}
    set {_uniqueStorage()._creator = newValue}
  }

  var nftDenomID: String {
    get {return _storage._nftDenomID}
    set {_uniqueStorage()._nftDenomID = newValue}
  }

  var maxAllowedClaims: UInt64 {
    get {return _storage._maxAllowedClaims}
    set {_uniqueStorage()._maxAllowedClaims = newValue}
  }

  var interaction: OmniFlix_Itc_V1_InteractionType {
    get {return _storage._interaction}
    set {_uniqueStorage()._interaction = newValue}
  }

  var claimType: OmniFlix_Itc_V1_ClaimType {
    get {return _storage._claimType}
    set {_uniqueStorage()._claimType = newValue}
  }

  var tokensPerClaim: Cosmos_Base_V1beta1_Coin {
    get {return _storage._tokensPerClaim ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._tokensPerClaim = newValue}
  }
  /// Returns true if `tokensPerClaim` has been explicitly set.
  var hasTokensPerClaim: Bool {return _storage._tokensPerClaim != nil}
  /// Clears the value of `tokensPerClaim`. Subsequent reads from it will return its default value.
  mutating func clearTokensPerClaim() {_uniqueStorage()._tokensPerClaim = nil}

  var totalTokens: Cosmos_Base_V1beta1_Coin {
    get {return _storage._totalTokens ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._totalTokens = newValue}
  }
  /// Returns true if `totalTokens` has been explicitly set.
  var hasTotalTokens: Bool {return _storage._totalTokens != nil}
  /// Clears the value of `totalTokens`. Subsequent reads from it will return its default value.
  mutating func clearTotalTokens() {_uniqueStorage()._totalTokens = nil}

  var availableTokens: Cosmos_Base_V1beta1_Coin {
    get {return _storage._availableTokens ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._availableTokens = newValue}
  }
  /// Returns true if `availableTokens` has been explicitly set.
  var hasAvailableTokens: Bool {return _storage._availableTokens != nil}
  /// Clears the value of `availableTokens`. Subsequent reads from it will return its default value.
  mutating func clearAvailableTokens() {_uniqueStorage()._availableTokens = nil}

  var receivedNftIds: [String] {
    get {return _storage._receivedNftIds}
    set {_uniqueStorage()._receivedNftIds = newValue}
  }

  var nftMintDetails: OmniFlix_Itc_V1_NFTDetails {
    get {return _storage._nftMintDetails ?? OmniFlix_Itc_V1_NFTDetails()}
    set {_uniqueStorage()._nftMintDetails = newValue}
  }
  /// Returns true if `nftMintDetails` has been explicitly set.
  var hasNftMintDetails: Bool {return _storage._nftMintDetails != nil}
  /// Clears the value of `nftMintDetails`. Subsequent reads from it will return its default value.
  mutating func clearNftMintDetails() {_uniqueStorage()._nftMintDetails = nil}

  var distribution: OmniFlix_Itc_V1_Distribution {
    get {return _storage._distribution ?? OmniFlix_Itc_V1_Distribution()}
    set {_uniqueStorage()._distribution = newValue}
  }
  /// Returns true if `distribution` has been explicitly set.
  var hasDistribution: Bool {return _storage._distribution != nil}
  /// Clears the value of `distribution`. Subsequent reads from it will return its default value.
  mutating func clearDistribution() {_uniqueStorage()._distribution = nil}

  var mintCount: UInt64 {
    get {return _storage._mintCount}
    set {_uniqueStorage()._mintCount = newValue}
  }

  var claimCount: UInt64 {
    get {return _storage._claimCount}
    set {_uniqueStorage()._claimCount = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct OmniFlix_Itc_V1_Distribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: OmniFlix_Itc_V1_DistributionType = .instant

  var streamDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _streamDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_streamDuration = newValue}
  }
  /// Returns true if `streamDuration` has been explicitly set.
  var hasStreamDuration: Bool {return self._streamDuration != nil}
  /// Clears the value of `streamDuration`. Subsequent reads from it will return its default value.
  mutating func clearStreamDuration() {self._streamDuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _streamDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

struct OmniFlix_Itc_V1_NFTDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denomID: String = String()

  var name: String = String()

  var description_p: String = String()

  var mediaUri: String = String()

  var previewUri: String = String()

  var royaltyShare: String = String()

  var transferable: Bool = false

  var extensible: Bool = false

  var nsfw: Bool = false

  var data: String = String()

  var uriHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct OmniFlix_Itc_V1_Claim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var campaignID: UInt64 = 0

  var address: String = String()

  var nftID: String = String()

  var interaction: OmniFlix_Itc_V1_InteractionType = .burn

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension OmniFlix_Itc_V1_DistributionType: @unchecked Sendable {}
extension OmniFlix_Itc_V1_InteractionType: @unchecked Sendable {}
extension OmniFlix_Itc_V1_CampaignStatus: @unchecked Sendable {}
extension OmniFlix_Itc_V1_ClaimType: @unchecked Sendable {}
extension OmniFlix_Itc_V1_Campaign: @unchecked Sendable {}
extension OmniFlix_Itc_V1_Distribution: @unchecked Sendable {}
extension OmniFlix_Itc_V1_NFTDetails: @unchecked Sendable {}
extension OmniFlix_Itc_V1_Claim: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "OmniFlix.itc.v1"

extension OmniFlix_Itc_V1_DistributionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISTRIBUTION_TYPE_INSTANT"),
    1: .same(proto: "DISTRIBUTION_TYPE_STREAM"),
  ]
}

extension OmniFlix_Itc_V1_InteractionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERACTION_TYPE_BURN"),
    1: .same(proto: "INTERACTION_TYPE_TRANSFER"),
    2: .same(proto: "INTERACTION_TYPE_HOLD"),
  ]
}

extension OmniFlix_Itc_V1_CampaignStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CAMPAIGN_STATUS_UNSPECIFIED"),
    1: .same(proto: "CAMPAIGN_STATUS_INACTIVE"),
    2: .same(proto: "CAMPAIGN_STATUS_ACTIVE"),
  ]
}

extension OmniFlix_Itc_V1_ClaimType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLAIM_TYPE_FT"),
    1: .same(proto: "CLAIM_TYPE_NFT"),
    2: .same(proto: "CLAIM_TYPE_FT_AND_NFT"),
  ]
}

extension OmniFlix_Itc_V1_Campaign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Campaign"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "start_time"),
    5: .standard(proto: "end_time"),
    6: .same(proto: "creator"),
    7: .standard(proto: "nft_denom_id"),
    8: .standard(proto: "max_allowed_claims"),
    9: .same(proto: "interaction"),
    10: .standard(proto: "claim_type"),
    11: .standard(proto: "tokens_per_claim"),
    12: .standard(proto: "total_tokens"),
    13: .standard(proto: "available_tokens"),
    14: .standard(proto: "received_nft_ids"),
    15: .standard(proto: "nft_mint_details"),
    16: .same(proto: "distribution"),
    17: .standard(proto: "mint_count"),
    18: .standard(proto: "claim_count"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _name: String = String()
    var _description_p: String = String()
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _creator: String = String()
    var _nftDenomID: String = String()
    var _maxAllowedClaims: UInt64 = 0
    var _interaction: OmniFlix_Itc_V1_InteractionType = .burn
    var _claimType: OmniFlix_Itc_V1_ClaimType = .ft
    var _tokensPerClaim: Cosmos_Base_V1beta1_Coin? = nil
    var _totalTokens: Cosmos_Base_V1beta1_Coin? = nil
    var _availableTokens: Cosmos_Base_V1beta1_Coin? = nil
    var _receivedNftIds: [String] = []
    var _nftMintDetails: OmniFlix_Itc_V1_NFTDetails? = nil
    var _distribution: OmniFlix_Itc_V1_Distribution? = nil
    var _mintCount: UInt64 = 0
    var _claimCount: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _description_p = source._description_p
      _startTime = source._startTime
      _endTime = source._endTime
      _creator = source._creator
      _nftDenomID = source._nftDenomID
      _maxAllowedClaims = source._maxAllowedClaims
      _interaction = source._interaction
      _claimType = source._claimType
      _tokensPerClaim = source._tokensPerClaim
      _totalTokens = source._totalTokens
      _availableTokens = source._availableTokens
      _receivedNftIds = source._receivedNftIds
      _nftMintDetails = source._nftMintDetails
      _distribution = source._distribution
      _mintCount = source._mintCount
      _claimCount = source._claimCount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._creator) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._nftDenomID) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxAllowedClaims) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._interaction) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._claimType) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._tokensPerClaim) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._totalTokens) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._availableTokens) }()
        case 14: try { try decoder.decodeRepeatedStringField(value: &_storage._receivedNftIds) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._nftMintDetails) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._distribution) }()
        case 17: try { try decoder.decodeSingularUInt64Field(value: &_storage._mintCount) }()
        case 18: try { try decoder.decodeSingularUInt64Field(value: &_storage._claimCount) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._creator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._creator, fieldNumber: 6)
      }
      if !_storage._nftDenomID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nftDenomID, fieldNumber: 7)
      }
      if _storage._maxAllowedClaims != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._maxAllowedClaims, fieldNumber: 8)
      }
      if _storage._interaction != .burn {
        try visitor.visitSingularEnumField(value: _storage._interaction, fieldNumber: 9)
      }
      if _storage._claimType != .ft {
        try visitor.visitSingularEnumField(value: _storage._claimType, fieldNumber: 10)
      }
      try { if let v = _storage._tokensPerClaim {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._totalTokens {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._availableTokens {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._receivedNftIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._receivedNftIds, fieldNumber: 14)
      }
      try { if let v = _storage._nftMintDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._distribution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._mintCount != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._mintCount, fieldNumber: 17)
      }
      if _storage._claimCount != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._claimCount, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OmniFlix_Itc_V1_Campaign, rhs: OmniFlix_Itc_V1_Campaign) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._nftDenomID != rhs_storage._nftDenomID {return false}
        if _storage._maxAllowedClaims != rhs_storage._maxAllowedClaims {return false}
        if _storage._interaction != rhs_storage._interaction {return false}
        if _storage._claimType != rhs_storage._claimType {return false}
        if _storage._tokensPerClaim != rhs_storage._tokensPerClaim {return false}
        if _storage._totalTokens != rhs_storage._totalTokens {return false}
        if _storage._availableTokens != rhs_storage._availableTokens {return false}
        if _storage._receivedNftIds != rhs_storage._receivedNftIds {return false}
        if _storage._nftMintDetails != rhs_storage._nftMintDetails {return false}
        if _storage._distribution != rhs_storage._distribution {return false}
        if _storage._mintCount != rhs_storage._mintCount {return false}
        if _storage._claimCount != rhs_storage._claimCount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OmniFlix_Itc_V1_Distribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Distribution"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "stream_duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._streamDuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .instant {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._streamDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OmniFlix_Itc_V1_Distribution, rhs: OmniFlix_Itc_V1_Distribution) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._streamDuration != rhs._streamDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OmniFlix_Itc_V1_NFTDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NFTDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "denom_id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "media_uri"),
    5: .standard(proto: "preview_uri"),
    6: .standard(proto: "royalty_share"),
    7: .same(proto: "transferable"),
    8: .same(proto: "extensible"),
    9: .same(proto: "nsfw"),
    10: .same(proto: "data"),
    11: .standard(proto: "uri_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denomID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mediaUri) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.previewUri) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.royaltyShare) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.transferable) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.extensible) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.nsfw) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.uriHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denomID.isEmpty {
      try visitor.visitSingularStringField(value: self.denomID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.mediaUri.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaUri, fieldNumber: 4)
    }
    if !self.previewUri.isEmpty {
      try visitor.visitSingularStringField(value: self.previewUri, fieldNumber: 5)
    }
    if !self.royaltyShare.isEmpty {
      try visitor.visitSingularStringField(value: self.royaltyShare, fieldNumber: 6)
    }
    if self.transferable != false {
      try visitor.visitSingularBoolField(value: self.transferable, fieldNumber: 7)
    }
    if self.extensible != false {
      try visitor.visitSingularBoolField(value: self.extensible, fieldNumber: 8)
    }
    if self.nsfw != false {
      try visitor.visitSingularBoolField(value: self.nsfw, fieldNumber: 9)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 10)
    }
    if !self.uriHash.isEmpty {
      try visitor.visitSingularStringField(value: self.uriHash, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OmniFlix_Itc_V1_NFTDetails, rhs: OmniFlix_Itc_V1_NFTDetails) -> Bool {
    if lhs.denomID != rhs.denomID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.mediaUri != rhs.mediaUri {return false}
    if lhs.previewUri != rhs.previewUri {return false}
    if lhs.royaltyShare != rhs.royaltyShare {return false}
    if lhs.transferable != rhs.transferable {return false}
    if lhs.extensible != rhs.extensible {return false}
    if lhs.nsfw != rhs.nsfw {return false}
    if lhs.data != rhs.data {return false}
    if lhs.uriHash != rhs.uriHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OmniFlix_Itc_V1_Claim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Claim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "campaign_id"),
    2: .same(proto: "address"),
    3: .standard(proto: "nft_id"),
    4: .same(proto: "interaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.campaignID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.interaction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.campaignID != 0 {
      try visitor.visitSingularUInt64Field(value: self.campaignID, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 3)
    }
    if self.interaction != .burn {
      try visitor.visitSingularEnumField(value: self.interaction, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OmniFlix_Itc_V1_Claim, rhs: OmniFlix_Itc_V1_Claim) -> Bool {
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.address != rhs.address {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.interaction != rhs.interaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
