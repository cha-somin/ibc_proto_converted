// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: band/bandchain/v1/oracle/proof.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryProofRequest is request type for the Service/Proof RPC method.
struct Bandchain_V1_Oracle_QueryProofRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RequestID is ID of an oracle request
  var requestID: UInt64 = 0

  /// height is block height
  var height: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryChainIDResponse is response type for the Service/Proof RPC method.
struct Bandchain_V1_Oracle_QueryProofResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// height is block height
  var height: Int64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  /// result is the proof
  var result: Bandchain_V1_Oracle_SingleProofResponse {
    get {return _storage._result ?? Bandchain_V1_Oracle_SingleProofResponse()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return _storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {_uniqueStorage()._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// QueryMultiProofRequest is request type for the Service/MultiProof RPC method.
struct Bandchain_V1_Oracle_QueryMultiProofRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// request_ids is the list of request IDs
  var requestIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryMultiProofResponse is response type for the Service/MultiProof RPC method.
struct Bandchain_V1_Oracle_QueryMultiProofResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var height: Int64 = 0

  var result: Bandchain_V1_Oracle_MultiProofResponse {
    get {return _result ?? Bandchain_V1_Oracle_MultiProofResponse()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: Bandchain_V1_Oracle_MultiProofResponse? = nil
}

/// QueryRequestCountProofRequest is request type for the Service/RequestCountProof RPC method.
struct Bandchain_V1_Oracle_QueryRequestCountProofRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryRequestCountProofResponse is response type for the Service/RequestCountProof RPC method.
struct Bandchain_V1_Oracle_QueryRequestCountProofResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var height: Int64 = 0

  var result: Bandchain_V1_Oracle_CountProofResponse {
    get {return _result ?? Bandchain_V1_Oracle_CountProofResponse()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: Bandchain_V1_Oracle_CountProofResponse? = nil
}

/// SingleProofResponse is the data structure for response of single proof
struct Bandchain_V1_Oracle_SingleProofResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proof: Bandchain_V1_Oracle_SingleProof {
    get {return _proof ?? Bandchain_V1_Oracle_SingleProof()}
    set {_proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  var hasProof: Bool {return self._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  mutating func clearProof() {self._proof = nil}

  var evmProofBytes: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proof: Bandchain_V1_Oracle_SingleProof? = nil
}

/// MultiProofResponse is the data structure for response of multi proof
struct Bandchain_V1_Oracle_MultiProofResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proof: Bandchain_V1_Oracle_MultiProof {
    get {return _proof ?? Bandchain_V1_Oracle_MultiProof()}
    set {_proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  var hasProof: Bool {return self._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  mutating func clearProof() {self._proof = nil}

  var evmProofBytes: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proof: Bandchain_V1_Oracle_MultiProof? = nil
}

/// CountProofResponse is the data structure for response of count proof
struct Bandchain_V1_Oracle_CountProofResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proof: Bandchain_V1_Oracle_CountProof {
    get {return _proof ?? Bandchain_V1_Oracle_CountProof()}
    set {_proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  var hasProof: Bool {return self._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  mutating func clearProof() {self._proof = nil}

  var evmProofBytes: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proof: Bandchain_V1_Oracle_CountProof? = nil
}

/// SingleProof contains block height, oracle data proof and block relay proof
struct Bandchain_V1_Oracle_SingleProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockHeight: UInt64 = 0

  var oracleDataProof: Bandchain_V1_Oracle_OracleDataProof {
    get {return _oracleDataProof ?? Bandchain_V1_Oracle_OracleDataProof()}
    set {_oracleDataProof = newValue}
  }
  /// Returns true if `oracleDataProof` has been explicitly set.
  var hasOracleDataProof: Bool {return self._oracleDataProof != nil}
  /// Clears the value of `oracleDataProof`. Subsequent reads from it will return its default value.
  mutating func clearOracleDataProof() {self._oracleDataProof = nil}

  var blockRelayProof: Bandchain_V1_Oracle_BlockRelayProof {
    get {return _blockRelayProof ?? Bandchain_V1_Oracle_BlockRelayProof()}
    set {_blockRelayProof = newValue}
  }
  /// Returns true if `blockRelayProof` has been explicitly set.
  var hasBlockRelayProof: Bool {return self._blockRelayProof != nil}
  /// Clears the value of `blockRelayProof`. Subsequent reads from it will return its default value.
  mutating func clearBlockRelayProof() {self._blockRelayProof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _oracleDataProof: Bandchain_V1_Oracle_OracleDataProof? = nil
  fileprivate var _blockRelayProof: Bandchain_V1_Oracle_BlockRelayProof? = nil
}

/// MultiProof contains block height, list of oracle data proof and block relay proof
struct Bandchain_V1_Oracle_MultiProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockHeight: UInt64 = 0

  var oracleDataMultiProof: [Bandchain_V1_Oracle_OracleDataProof] = []

  var blockRelayProof: Bandchain_V1_Oracle_BlockRelayProof {
    get {return _blockRelayProof ?? Bandchain_V1_Oracle_BlockRelayProof()}
    set {_blockRelayProof = newValue}
  }
  /// Returns true if `blockRelayProof` has been explicitly set.
  var hasBlockRelayProof: Bool {return self._blockRelayProof != nil}
  /// Clears the value of `blockRelayProof`. Subsequent reads from it will return its default value.
  mutating func clearBlockRelayProof() {self._blockRelayProof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockRelayProof: Bandchain_V1_Oracle_BlockRelayProof? = nil
}

/// CountProof contains block height, count proof and block relay proof
struct Bandchain_V1_Oracle_CountProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockHeight: UInt64 = 0

  var countProof: Bandchain_V1_Oracle_RequestsCountProof {
    get {return _countProof ?? Bandchain_V1_Oracle_RequestsCountProof()}
    set {_countProof = newValue}
  }
  /// Returns true if `countProof` has been explicitly set.
  var hasCountProof: Bool {return self._countProof != nil}
  /// Clears the value of `countProof`. Subsequent reads from it will return its default value.
  mutating func clearCountProof() {self._countProof = nil}

  var blockRelayProof: Bandchain_V1_Oracle_BlockRelayProof {
    get {return _blockRelayProof ?? Bandchain_V1_Oracle_BlockRelayProof()}
    set {_blockRelayProof = newValue}
  }
  /// Returns true if `blockRelayProof` has been explicitly set.
  var hasBlockRelayProof: Bool {return self._blockRelayProof != nil}
  /// Clears the value of `blockRelayProof`. Subsequent reads from it will return its default value.
  mutating func clearBlockRelayProof() {self._blockRelayProof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _countProof: Bandchain_V1_Oracle_RequestsCountProof? = nil
  fileprivate var _blockRelayProof: Bandchain_V1_Oracle_BlockRelayProof? = nil
}

/// OracleDataProof contains result, version and merkle paths
struct Bandchain_V1_Oracle_OracleDataProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Oracle_V1_Result {
    get {return _result ?? Oracle_V1_Result()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var version: UInt64 = 0

  var merklePaths: [Bandchain_V1_Oracle_IAVLMerklePath] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: Oracle_V1_Result? = nil
}

/// IAVLMerklePath represents a Merkle step to a leaf data node in an iAVL tree.
struct Bandchain_V1_Oracle_IAVLMerklePath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isDataOnRight: Bool = false

  var subtreeHeight: UInt32 = 0

  var subtreeSize: UInt64 = 0

  var subtreeVersion: UInt64 = 0

  var siblingHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BlockRelayProof contains multi store proof, block header merkle parts, common encoded part and signatures
struct Bandchain_V1_Oracle_BlockRelayProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var multiStoreProof: Bandchain_V1_Oracle_MultiStoreProof {
    get {return _storage._multiStoreProof ?? Bandchain_V1_Oracle_MultiStoreProof()}
    set {_uniqueStorage()._multiStoreProof = newValue}
  }
  /// Returns true if `multiStoreProof` has been explicitly set.
  var hasMultiStoreProof: Bool {return _storage._multiStoreProof != nil}
  /// Clears the value of `multiStoreProof`. Subsequent reads from it will return its default value.
  mutating func clearMultiStoreProof() {_uniqueStorage()._multiStoreProof = nil}

  var blockHeaderMerkleParts: Bandchain_V1_Oracle_BlockHeaderMerkleParts {
    get {return _storage._blockHeaderMerkleParts ?? Bandchain_V1_Oracle_BlockHeaderMerkleParts()}
    set {_uniqueStorage()._blockHeaderMerkleParts = newValue}
  }
  /// Returns true if `blockHeaderMerkleParts` has been explicitly set.
  var hasBlockHeaderMerkleParts: Bool {return _storage._blockHeaderMerkleParts != nil}
  /// Clears the value of `blockHeaderMerkleParts`. Subsequent reads from it will return its default value.
  mutating func clearBlockHeaderMerkleParts() {_uniqueStorage()._blockHeaderMerkleParts = nil}

  var commonEncodedVotePart: Bandchain_V1_Oracle_CommonEncodedVotePart {
    get {return _storage._commonEncodedVotePart ?? Bandchain_V1_Oracle_CommonEncodedVotePart()}
    set {_uniqueStorage()._commonEncodedVotePart = newValue}
  }
  /// Returns true if `commonEncodedVotePart` has been explicitly set.
  var hasCommonEncodedVotePart: Bool {return _storage._commonEncodedVotePart != nil}
  /// Clears the value of `commonEncodedVotePart`. Subsequent reads from it will return its default value.
  mutating func clearCommonEncodedVotePart() {_uniqueStorage()._commonEncodedVotePart = nil}

  var signatures: [Bandchain_V1_Oracle_TMSignature] {
    get {return _storage._signatures}
    set {_uniqueStorage()._signatures = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MultiStoreProof stores a compact of other Cosmos-SDK modules' storage hash in multistore to
/// compute (in combination with oracle store hash) Tendermint's application state hash at a given block.
///
///	                                           ________________[AppHash]_________________________
///	                                          /                                                  \
///	                      _________________[N15]_________________                             __[N16]___
///	                     /                                        \                          /          \
///	          _______[N12]______                          _______[N13]________             [N14]        [I]
///	         /                  \                        /                    \           /     \
///	    __[N8]__             __[N9]__                __[N10]__              __[N11]__    [G]   [H]
///	   /         \          /         \            /          \            /         \
///	  [N0]       [N1]      [N2]       [N3]       [N4]        [N5]         [N6]       [N7]
///	/     \     /    \    /    \     /     \     /     \     /     \     /     \     /    \
///
/// [0]   [1]  [2]   [3] [4]   [5]  [6]    [7]  [8]    [9]  [A]    [B]  [C]    [D]  [E]   [F]
///
/// [0] - acc (auth) [1] - authz    [2] - bank     [3] - capability [4] - crisis   [5] - dist
/// [6] - evidence   [7] - feegrant [8] - gov      [9] - group      [A] - ibccore    [B] - icahost
/// [C] - mint       [D] - oracle   [E] - params   [F] - slashing   [G] - staking    [H] - transfer [I] - upgrade
/// Notice that NOT all leaves of the Merkle tree are needed in order to compute the Merkle
/// root hash, since we only want to validate the correctness of [D] In fact, only
/// [C], [N7], [N10], [N12], and [N16] are needed in order to compute [AppHash].
struct Bandchain_V1_Oracle_MultiStoreProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oracleIavlStateHash: Data = Data()

  var mintStoreMerkleHash: Data = Data()

  var paramsToSlashingStoresMerkleHash: Data = Data()

  var govToIcahostStoresMerkleHash: Data = Data()

  var authToFeegrantStoresMerkleHash: Data = Data()

  var stakingToUpgradeStoresMerkleHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BlockHeaderMerkleParts stores a group of hashes using for computing Tendermint's block
/// header hash from app hash, and height.
///
/// In Tendermint, a block header hash is the Merkle hash of a binary tree with 14 leaf nodes.
/// Each node encodes a data piece of the blockchain. The notable data leaves are: [A] app_hash,
/// [2] height. All data pieces are combined into one 32-byte hash to be signed
/// by block validators. The structure of the Merkle tree is shown below.
///
///	                                 [BlockHeader]
///	                              /                \
///	                 [3A]                                    [3B]
///	               /      \                                /      \
///	       [2A]                [2B]                [2C]                [2D]
///	      /    \              /    \              /    \              /    \
///	  [1A]      [1B]      [1C]      [1D]      [1E]      [1F]        [C]    [D]
///	  /  \      /  \      /  \      /  \      /  \      /  \
///	[0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]  [8]  [9]  [A]  [B]
///
///	[0] - version               [1] - chain_id            [2] - height        [3] - time
///	[4] - last_block_id         [5] - last_commit_hash    [6] - data_hash     [7] - validators_hash
///	[8] - next_validators_hash  [9] - consensus_hash      [A] - app_hash      [B] - last_results_hash
///	[C] - evidence_hash         [D] - proposer_address
///
/// Notice that NOT all leaves of the Merkle tree are needed in order to compute the Merkle
/// root hash, since we only want to validate the correctness of [2], [3], and [A]. In fact, only
/// [1A], [2B], [1E], [B], and [2D] are needed in order to compute [BlockHeader].
struct Bandchain_V1_Oracle_BlockHeaderMerkleParts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var versionAndChainIDHash: Data = Data()

  var height: UInt64 = 0

  var timeSecond: UInt64 = 0

  var timeNanoSecond: UInt32 = 0

  var lastBlockIDAndOther: Data = Data()

  var nextValidatorHashAndConsensusHash: Data = Data()

  var lastResultsHash: Data = Data()

  var evidenceAndProposerHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CommonEncodedVotePart represents the common part of encoded vote
struct Bandchain_V1_Oracle_CommonEncodedVotePart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signedDataPrefix: Data = Data()

  var signedDataSuffix: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TMSignature contains all details of validator signature for performing signer recovery for ECDSA
/// secp256k1 signature. Note that this struct is written specifically for signature signed on
/// Tendermint's precommit data, which includes the block hash and some additional information prepended
/// and appended to the block hash. The prepended part (prefix) and the appended part (suffix) are
/// different for each signer (including signature size, machine clock, validator index, etc).
struct Bandchain_V1_Oracle_TMSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var r: Data = Data()

  var s: Data = Data()

  var v: UInt32 = 0

  var encodedTimestamp: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RequestsCountProof contains count, version and merkle paths
struct Bandchain_V1_Oracle_RequestsCountProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var count: UInt64 = 0

  var version: UInt64 = 0

  var merklePaths: [Bandchain_V1_Oracle_IAVLMerklePath] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Bandchain_V1_Oracle_QueryProofRequest: @unchecked Sendable {}
extension Bandchain_V1_Oracle_QueryProofResponse: @unchecked Sendable {}
extension Bandchain_V1_Oracle_QueryMultiProofRequest: @unchecked Sendable {}
extension Bandchain_V1_Oracle_QueryMultiProofResponse: @unchecked Sendable {}
extension Bandchain_V1_Oracle_QueryRequestCountProofRequest: @unchecked Sendable {}
extension Bandchain_V1_Oracle_QueryRequestCountProofResponse: @unchecked Sendable {}
extension Bandchain_V1_Oracle_SingleProofResponse: @unchecked Sendable {}
extension Bandchain_V1_Oracle_MultiProofResponse: @unchecked Sendable {}
extension Bandchain_V1_Oracle_CountProofResponse: @unchecked Sendable {}
extension Bandchain_V1_Oracle_SingleProof: @unchecked Sendable {}
extension Bandchain_V1_Oracle_MultiProof: @unchecked Sendable {}
extension Bandchain_V1_Oracle_CountProof: @unchecked Sendable {}
extension Bandchain_V1_Oracle_OracleDataProof: @unchecked Sendable {}
extension Bandchain_V1_Oracle_IAVLMerklePath: @unchecked Sendable {}
extension Bandchain_V1_Oracle_BlockRelayProof: @unchecked Sendable {}
extension Bandchain_V1_Oracle_MultiStoreProof: @unchecked Sendable {}
extension Bandchain_V1_Oracle_BlockHeaderMerkleParts: @unchecked Sendable {}
extension Bandchain_V1_Oracle_CommonEncodedVotePart: @unchecked Sendable {}
extension Bandchain_V1_Oracle_TMSignature: @unchecked Sendable {}
extension Bandchain_V1_Oracle_RequestsCountProof: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bandchain.v1.oracle"

extension Bandchain_V1_Oracle_QueryProofRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryProofRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestID, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_QueryProofRequest, rhs: Bandchain_V1_Oracle_QueryProofRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_QueryProofResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryProofResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "result"),
  ]

  fileprivate class _StorageClass {
    var _height: Int64 = 0
    var _result: Bandchain_V1_Oracle_SingleProofResponse? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _height = source._height
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._height) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._result) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._height != 0 {
        try visitor.visitSingularInt64Field(value: _storage._height, fieldNumber: 1)
      }
      try { if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_QueryProofResponse, rhs: Bandchain_V1_Oracle_QueryProofResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._height != rhs_storage._height {return false}
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_QueryMultiProofRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMultiProofRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.requestIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.requestIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_QueryMultiProofRequest, rhs: Bandchain_V1_Oracle_QueryMultiProofRequest) -> Bool {
    if lhs.requestIds != rhs.requestIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_QueryMultiProofResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMultiProofResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_QueryMultiProofResponse, rhs: Bandchain_V1_Oracle_QueryMultiProofResponse) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_QueryRequestCountProofRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRequestCountProofRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_QueryRequestCountProofRequest, rhs: Bandchain_V1_Oracle_QueryRequestCountProofRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_QueryRequestCountProofResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRequestCountProofResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_QueryRequestCountProofResponse, rhs: Bandchain_V1_Oracle_QueryRequestCountProofResponse) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_SingleProofResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SingleProofResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proof"),
    2: .standard(proto: "evm_proof_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._proof) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.evmProofBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._proof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.evmProofBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.evmProofBytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_SingleProofResponse, rhs: Bandchain_V1_Oracle_SingleProofResponse) -> Bool {
    if lhs._proof != rhs._proof {return false}
    if lhs.evmProofBytes != rhs.evmProofBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_MultiProofResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MultiProofResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proof"),
    2: .standard(proto: "evm_proof_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._proof) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.evmProofBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._proof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.evmProofBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.evmProofBytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_MultiProofResponse, rhs: Bandchain_V1_Oracle_MultiProofResponse) -> Bool {
    if lhs._proof != rhs._proof {return false}
    if lhs.evmProofBytes != rhs.evmProofBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_CountProofResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountProofResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proof"),
    2: .standard(proto: "evm_proof_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._proof) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.evmProofBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._proof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.evmProofBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.evmProofBytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_CountProofResponse, rhs: Bandchain_V1_Oracle_CountProofResponse) -> Bool {
    if lhs._proof != rhs._proof {return false}
    if lhs.evmProofBytes != rhs.evmProofBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_SingleProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SingleProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_height"),
    2: .standard(proto: "oracle_data_proof"),
    3: .standard(proto: "block_relay_proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.blockHeight) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._oracleDataProof) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blockRelayProof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 1)
    }
    try { if let v = self._oracleDataProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._blockRelayProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_SingleProof, rhs: Bandchain_V1_Oracle_SingleProof) -> Bool {
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs._oracleDataProof != rhs._oracleDataProof {return false}
    if lhs._blockRelayProof != rhs._blockRelayProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_MultiProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MultiProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_height"),
    2: .standard(proto: "oracle_data_multi_proof"),
    3: .standard(proto: "block_relay_proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.blockHeight) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.oracleDataMultiProof) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blockRelayProof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 1)
    }
    if !self.oracleDataMultiProof.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oracleDataMultiProof, fieldNumber: 2)
    }
    try { if let v = self._blockRelayProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_MultiProof, rhs: Bandchain_V1_Oracle_MultiProof) -> Bool {
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.oracleDataMultiProof != rhs.oracleDataMultiProof {return false}
    if lhs._blockRelayProof != rhs._blockRelayProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_CountProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CountProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_height"),
    2: .standard(proto: "count_proof"),
    3: .standard(proto: "block_relay_proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.blockHeight) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._countProof) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blockRelayProof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 1)
    }
    try { if let v = self._countProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._blockRelayProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_CountProof, rhs: Bandchain_V1_Oracle_CountProof) -> Bool {
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs._countProof != rhs._countProof {return false}
    if lhs._blockRelayProof != rhs._blockRelayProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_OracleDataProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OracleDataProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "version"),
    3: .standard(proto: "merkle_paths"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.merklePaths) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 2)
    }
    if !self.merklePaths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.merklePaths, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_OracleDataProof, rhs: Bandchain_V1_Oracle_OracleDataProof) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.version != rhs.version {return false}
    if lhs.merklePaths != rhs.merklePaths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_IAVLMerklePath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IAVLMerklePath"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_data_on_right"),
    2: .standard(proto: "subtree_height"),
    3: .standard(proto: "subtree_size"),
    4: .standard(proto: "subtree_version"),
    5: .standard(proto: "sibling_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isDataOnRight) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.subtreeHeight) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.subtreeSize) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.subtreeVersion) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.siblingHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isDataOnRight != false {
      try visitor.visitSingularBoolField(value: self.isDataOnRight, fieldNumber: 1)
    }
    if self.subtreeHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.subtreeHeight, fieldNumber: 2)
    }
    if self.subtreeSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.subtreeSize, fieldNumber: 3)
    }
    if self.subtreeVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.subtreeVersion, fieldNumber: 4)
    }
    if !self.siblingHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.siblingHash, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_IAVLMerklePath, rhs: Bandchain_V1_Oracle_IAVLMerklePath) -> Bool {
    if lhs.isDataOnRight != rhs.isDataOnRight {return false}
    if lhs.subtreeHeight != rhs.subtreeHeight {return false}
    if lhs.subtreeSize != rhs.subtreeSize {return false}
    if lhs.subtreeVersion != rhs.subtreeVersion {return false}
    if lhs.siblingHash != rhs.siblingHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_BlockRelayProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockRelayProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "multi_store_proof"),
    2: .standard(proto: "block_header_merkle_parts"),
    3: .standard(proto: "common_encoded_vote_part"),
    4: .same(proto: "signatures"),
  ]

  fileprivate class _StorageClass {
    var _multiStoreProof: Bandchain_V1_Oracle_MultiStoreProof? = nil
    var _blockHeaderMerkleParts: Bandchain_V1_Oracle_BlockHeaderMerkleParts? = nil
    var _commonEncodedVotePart: Bandchain_V1_Oracle_CommonEncodedVotePart? = nil
    var _signatures: [Bandchain_V1_Oracle_TMSignature] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _multiStoreProof = source._multiStoreProof
      _blockHeaderMerkleParts = source._blockHeaderMerkleParts
      _commonEncodedVotePart = source._commonEncodedVotePart
      _signatures = source._signatures
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._multiStoreProof) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._blockHeaderMerkleParts) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._commonEncodedVotePart) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._signatures) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._multiStoreProof {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._blockHeaderMerkleParts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._commonEncodedVotePart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._signatures.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._signatures, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_BlockRelayProof, rhs: Bandchain_V1_Oracle_BlockRelayProof) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._multiStoreProof != rhs_storage._multiStoreProof {return false}
        if _storage._blockHeaderMerkleParts != rhs_storage._blockHeaderMerkleParts {return false}
        if _storage._commonEncodedVotePart != rhs_storage._commonEncodedVotePart {return false}
        if _storage._signatures != rhs_storage._signatures {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_MultiStoreProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MultiStoreProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "oracle_iavl_state_hash"),
    2: .standard(proto: "mint_store_merkle_hash"),
    3: .standard(proto: "params_to_slashing_stores_merkle_hash"),
    4: .standard(proto: "gov_to_icahost_stores_merkle_hash"),
    5: .standard(proto: "auth_to_feegrant_stores_merkle_hash"),
    6: .standard(proto: "staking_to_upgrade_stores_merkle_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.oracleIavlStateHash) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.mintStoreMerkleHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.paramsToSlashingStoresMerkleHash) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.govToIcahostStoresMerkleHash) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.authToFeegrantStoresMerkleHash) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.stakingToUpgradeStoresMerkleHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.oracleIavlStateHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.oracleIavlStateHash, fieldNumber: 1)
    }
    if !self.mintStoreMerkleHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.mintStoreMerkleHash, fieldNumber: 2)
    }
    if !self.paramsToSlashingStoresMerkleHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paramsToSlashingStoresMerkleHash, fieldNumber: 3)
    }
    if !self.govToIcahostStoresMerkleHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.govToIcahostStoresMerkleHash, fieldNumber: 4)
    }
    if !self.authToFeegrantStoresMerkleHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.authToFeegrantStoresMerkleHash, fieldNumber: 5)
    }
    if !self.stakingToUpgradeStoresMerkleHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.stakingToUpgradeStoresMerkleHash, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_MultiStoreProof, rhs: Bandchain_V1_Oracle_MultiStoreProof) -> Bool {
    if lhs.oracleIavlStateHash != rhs.oracleIavlStateHash {return false}
    if lhs.mintStoreMerkleHash != rhs.mintStoreMerkleHash {return false}
    if lhs.paramsToSlashingStoresMerkleHash != rhs.paramsToSlashingStoresMerkleHash {return false}
    if lhs.govToIcahostStoresMerkleHash != rhs.govToIcahostStoresMerkleHash {return false}
    if lhs.authToFeegrantStoresMerkleHash != rhs.authToFeegrantStoresMerkleHash {return false}
    if lhs.stakingToUpgradeStoresMerkleHash != rhs.stakingToUpgradeStoresMerkleHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_BlockHeaderMerkleParts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockHeaderMerkleParts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_and_chain_id_hash"),
    2: .same(proto: "height"),
    3: .standard(proto: "time_second"),
    4: .standard(proto: "time_nano_second"),
    5: .standard(proto: "last_block_id_and_other"),
    6: .standard(proto: "next_validator_hash_and_consensus_hash"),
    7: .standard(proto: "last_results_hash"),
    8: .standard(proto: "evidence_and_proposer_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.versionAndChainIDHash) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timeSecond) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.timeNanoSecond) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.lastBlockIDAndOther) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.nextValidatorHashAndConsensusHash) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.lastResultsHash) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.evidenceAndProposerHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.versionAndChainIDHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.versionAndChainIDHash, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if self.timeSecond != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeSecond, fieldNumber: 3)
    }
    if self.timeNanoSecond != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeNanoSecond, fieldNumber: 4)
    }
    if !self.lastBlockIDAndOther.isEmpty {
      try visitor.visitSingularBytesField(value: self.lastBlockIDAndOther, fieldNumber: 5)
    }
    if !self.nextValidatorHashAndConsensusHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextValidatorHashAndConsensusHash, fieldNumber: 6)
    }
    if !self.lastResultsHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.lastResultsHash, fieldNumber: 7)
    }
    if !self.evidenceAndProposerHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.evidenceAndProposerHash, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_BlockHeaderMerkleParts, rhs: Bandchain_V1_Oracle_BlockHeaderMerkleParts) -> Bool {
    if lhs.versionAndChainIDHash != rhs.versionAndChainIDHash {return false}
    if lhs.height != rhs.height {return false}
    if lhs.timeSecond != rhs.timeSecond {return false}
    if lhs.timeNanoSecond != rhs.timeNanoSecond {return false}
    if lhs.lastBlockIDAndOther != rhs.lastBlockIDAndOther {return false}
    if lhs.nextValidatorHashAndConsensusHash != rhs.nextValidatorHashAndConsensusHash {return false}
    if lhs.lastResultsHash != rhs.lastResultsHash {return false}
    if lhs.evidenceAndProposerHash != rhs.evidenceAndProposerHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_CommonEncodedVotePart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommonEncodedVotePart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_data_prefix"),
    2: .standard(proto: "signed_data_suffix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signedDataPrefix) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signedDataSuffix) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signedDataPrefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedDataPrefix, fieldNumber: 1)
    }
    if !self.signedDataSuffix.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedDataSuffix, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_CommonEncodedVotePart, rhs: Bandchain_V1_Oracle_CommonEncodedVotePart) -> Bool {
    if lhs.signedDataPrefix != rhs.signedDataPrefix {return false}
    if lhs.signedDataSuffix != rhs.signedDataSuffix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_TMSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TMSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r"),
    2: .same(proto: "s"),
    3: .same(proto: "v"),
    4: .standard(proto: "encoded_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.r) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.s) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.v) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.encodedTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.r.isEmpty {
      try visitor.visitSingularBytesField(value: self.r, fieldNumber: 1)
    }
    if !self.s.isEmpty {
      try visitor.visitSingularBytesField(value: self.s, fieldNumber: 2)
    }
    if self.v != 0 {
      try visitor.visitSingularUInt32Field(value: self.v, fieldNumber: 3)
    }
    if !self.encodedTimestamp.isEmpty {
      try visitor.visitSingularBytesField(value: self.encodedTimestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_TMSignature, rhs: Bandchain_V1_Oracle_TMSignature) -> Bool {
    if lhs.r != rhs.r {return false}
    if lhs.s != rhs.s {return false}
    if lhs.v != rhs.v {return false}
    if lhs.encodedTimestamp != rhs.encodedTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bandchain_V1_Oracle_RequestsCountProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestsCountProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "version"),
    3: .standard(proto: "merkle_paths"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.count) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.merklePaths) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 2)
    }
    if !self.merklePaths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.merklePaths, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bandchain_V1_Oracle_RequestsCountProof, rhs: Bandchain_V1_Oracle_RequestsCountProof) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.version != rhs.version {return false}
    if lhs.merklePaths != rhs.merklePaths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
