// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: babylon/checkpointing/v1/checkpoint.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// CheckpointStatus is the status of a checkpoint.
enum Babylon_Checkpointing_V1_CheckpointStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// ACCUMULATING defines a checkpoint that is awaiting for BLS signatures.
  case ckptStatusAccumulating // = 0

  /// SEALED defines a checkpoint that has accumulated sufficient BLS signatures.
  case ckptStatusSealed // = 1

  /// SUBMITTED defines a checkpoint that is included on BTC.
  case ckptStatusSubmitted // = 2

  /// CONFIRMED defines a checkpoint that is k-deep on BTC.
  case ckptStatusConfirmed // = 3

  /// FINALIZED defines a checkpoint that is w-deep on BTC.
  case ckptStatusFinalized // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .ckptStatusAccumulating
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ckptStatusAccumulating
    case 1: self = .ckptStatusSealed
    case 2: self = .ckptStatusSubmitted
    case 3: self = .ckptStatusConfirmed
    case 4: self = .ckptStatusFinalized
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ckptStatusAccumulating: return 0
    case .ckptStatusSealed: return 1
    case .ckptStatusSubmitted: return 2
    case .ckptStatusConfirmed: return 3
    case .ckptStatusFinalized: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Babylon_Checkpointing_V1_CheckpointStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Babylon_Checkpointing_V1_CheckpointStatus] = [
    .ckptStatusAccumulating,
    .ckptStatusSealed,
    .ckptStatusSubmitted,
    .ckptStatusConfirmed,
    .ckptStatusFinalized,
  ]
}

#endif  // swift(>=4.2)

/// RawCheckpoint wraps the BLS multi sig with metadata
struct Babylon_Checkpointing_V1_RawCheckpoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// epoch_num defines the epoch number the raw checkpoint is for
  var epochNum: UInt64 = 0

  /// block_hash defines the 'BlockID.Hash', which is the hash of
  /// the block that individual BLS sigs are signed on
  var blockHash: Data = Data()

  /// bitmap defines the bitmap that indicates the signers of the BLS multi sig
  var bitmap: Data = Data()

  /// bls_multi_sig defines the multi sig that is aggregated from individual BLS
  /// sigs
  var blsMultiSig: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RawCheckpointWithMeta wraps the raw checkpoint with metadata.
struct Babylon_Checkpointing_V1_RawCheckpointWithMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ckpt: Babylon_Checkpointing_V1_RawCheckpoint {
    get {return _ckpt ?? Babylon_Checkpointing_V1_RawCheckpoint()}
    set {_ckpt = newValue}
  }
  /// Returns true if `ckpt` has been explicitly set.
  var hasCkpt: Bool {return self._ckpt != nil}
  /// Clears the value of `ckpt`. Subsequent reads from it will return its default value.
  mutating func clearCkpt() {self._ckpt = nil}

  /// status defines the status of the checkpoint
  var status: Babylon_Checkpointing_V1_CheckpointStatus = .ckptStatusAccumulating

  /// bls_aggr_pk defines the aggregated BLS public key
  var blsAggrPk: Data = Data()

  /// power_sum defines the accumulated voting power for the checkpoint
  var powerSum: UInt64 = 0

  /// lifecycle defines the lifecycle of this checkpoint, i.e., each state
  /// transition and the time (in both timestamp and block height) of this
  /// transition.
  var lifecycle: [Babylon_Checkpointing_V1_CheckpointStateUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ckpt: Babylon_Checkpointing_V1_RawCheckpoint? = nil
}

/// MsgInjectedCheckpoint wraps the checkpoint and the extended votes
/// Note: this is a special message type that is only for internal ABCI++ usage
/// for inserting checkpoint into the block
struct Babylon_Checkpointing_V1_MsgInjectedCheckpoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ckpt: Babylon_Checkpointing_V1_RawCheckpointWithMeta {
    get {return _ckpt ?? Babylon_Checkpointing_V1_RawCheckpointWithMeta()}
    set {_ckpt = newValue}
  }
  /// Returns true if `ckpt` has been explicitly set.
  var hasCkpt: Bool {return self._ckpt != nil}
  /// Clears the value of `ckpt`. Subsequent reads from it will return its default value.
  mutating func clearCkpt() {self._ckpt = nil}

  /// extended_commit_info is the commit info including the vote extensions
  /// from the previous proposal
  var extendedCommitInfo: Tendermint_Abci_ExtendedCommitInfo {
    get {return _extendedCommitInfo ?? Tendermint_Abci_ExtendedCommitInfo()}
    set {_extendedCommitInfo = newValue}
  }
  /// Returns true if `extendedCommitInfo` has been explicitly set.
  var hasExtendedCommitInfo: Bool {return self._extendedCommitInfo != nil}
  /// Clears the value of `extendedCommitInfo`. Subsequent reads from it will return its default value.
  mutating func clearExtendedCommitInfo() {self._extendedCommitInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ckpt: Babylon_Checkpointing_V1_RawCheckpointWithMeta? = nil
  fileprivate var _extendedCommitInfo: Tendermint_Abci_ExtendedCommitInfo? = nil
}

/// CheckpointStateUpdate defines a state transition on the checkpoint.
struct Babylon_Checkpointing_V1_CheckpointStateUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// state defines the event of a state transition towards this state
  var state: Babylon_Checkpointing_V1_CheckpointStatus = .ckptStatusAccumulating

  /// block_height is the height of the Babylon block that triggers the state
  /// update
  var blockHeight: UInt64 = 0

  /// block_time is the timestamp in the Babylon block that triggers the state
  /// update
  var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  var hasBlockTime: Bool {return self._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  mutating func clearBlockTime() {self._blockTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// BlsSig wraps the BLS sig with metadata.
struct Babylon_Checkpointing_V1_BlsSig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// epoch_num defines the epoch number that the BLS sig is signed on
  var epochNum: UInt64 = 0

  /// block_hash defines the 'BlockID.Hash', which is the hash of
  /// the block that individual BLS sigs are signed on
  var blockHash: Data = Data()

  var blsSig: Data = Data()

  /// can't find cosmos_proto.scalar when compiling due to cosmos v0.45.4 does
  /// not support scalar string signer_address = 4 [(cosmos_proto.scalar) =
  /// "cosmos.AddressString"]
  /// the signer_address defines the address of the
  /// signer
  var signerAddress: String = String()

  /// validator_address defines the validator's consensus address
  var validatorAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Babylon_Checkpointing_V1_CheckpointStatus: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_RawCheckpoint: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_RawCheckpointWithMeta: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_MsgInjectedCheckpoint: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_CheckpointStateUpdate: @unchecked Sendable {}
extension Babylon_Checkpointing_V1_BlsSig: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "babylon.checkpointing.v1"

extension Babylon_Checkpointing_V1_CheckpointStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CKPT_STATUS_ACCUMULATING"),
    1: .same(proto: "CKPT_STATUS_SEALED"),
    2: .same(proto: "CKPT_STATUS_SUBMITTED"),
    3: .same(proto: "CKPT_STATUS_CONFIRMED"),
    4: .same(proto: "CKPT_STATUS_FINALIZED"),
  ]
}

extension Babylon_Checkpointing_V1_RawCheckpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RawCheckpoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_num"),
    2: .standard(proto: "block_hash"),
    3: .same(proto: "bitmap"),
    4: .standard(proto: "bls_multi_sig"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNum) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.blockHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.bitmap) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.blsMultiSig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochNum != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNum, fieldNumber: 1)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockHash, fieldNumber: 2)
    }
    if !self.bitmap.isEmpty {
      try visitor.visitSingularBytesField(value: self.bitmap, fieldNumber: 3)
    }
    if !self.blsMultiSig.isEmpty {
      try visitor.visitSingularBytesField(value: self.blsMultiSig, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_RawCheckpoint, rhs: Babylon_Checkpointing_V1_RawCheckpoint) -> Bool {
    if lhs.epochNum != rhs.epochNum {return false}
    if lhs.blockHash != rhs.blockHash {return false}
    if lhs.bitmap != rhs.bitmap {return false}
    if lhs.blsMultiSig != rhs.blsMultiSig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_RawCheckpointWithMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RawCheckpointWithMeta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ckpt"),
    2: .same(proto: "status"),
    3: .standard(proto: "bls_aggr_pk"),
    4: .standard(proto: "power_sum"),
    5: .same(proto: "lifecycle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ckpt) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.blsAggrPk) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.powerSum) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.lifecycle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ckpt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.status != .ckptStatusAccumulating {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.blsAggrPk.isEmpty {
      try visitor.visitSingularBytesField(value: self.blsAggrPk, fieldNumber: 3)
    }
    if self.powerSum != 0 {
      try visitor.visitSingularUInt64Field(value: self.powerSum, fieldNumber: 4)
    }
    if !self.lifecycle.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lifecycle, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_RawCheckpointWithMeta, rhs: Babylon_Checkpointing_V1_RawCheckpointWithMeta) -> Bool {
    if lhs._ckpt != rhs._ckpt {return false}
    if lhs.status != rhs.status {return false}
    if lhs.blsAggrPk != rhs.blsAggrPk {return false}
    if lhs.powerSum != rhs.powerSum {return false}
    if lhs.lifecycle != rhs.lifecycle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_MsgInjectedCheckpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInjectedCheckpoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ckpt"),
    2: .standard(proto: "extended_commit_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ckpt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._extendedCommitInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ckpt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._extendedCommitInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_MsgInjectedCheckpoint, rhs: Babylon_Checkpointing_V1_MsgInjectedCheckpoint) -> Bool {
    if lhs._ckpt != rhs._ckpt {return false}
    if lhs._extendedCommitInfo != rhs._extendedCommitInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_CheckpointStateUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckpointStateUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "block_height"),
    3: .standard(proto: "block_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.blockHeight) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blockTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.state != .ckptStatusAccumulating {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 2)
    }
    try { if let v = self._blockTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_CheckpointStateUpdate, rhs: Babylon_Checkpointing_V1_CheckpointStateUpdate) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs._blockTime != rhs._blockTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Checkpointing_V1_BlsSig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlsSig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_num"),
    2: .standard(proto: "block_hash"),
    3: .standard(proto: "bls_sig"),
    4: .standard(proto: "signer_address"),
    5: .standard(proto: "validator_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNum) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.blockHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.blsSig) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.signerAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochNum != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNum, fieldNumber: 1)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockHash, fieldNumber: 2)
    }
    if !self.blsSig.isEmpty {
      try visitor.visitSingularBytesField(value: self.blsSig, fieldNumber: 3)
    }
    if !self.signerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.signerAddress, fieldNumber: 4)
    }
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Checkpointing_V1_BlsSig, rhs: Babylon_Checkpointing_V1_BlsSig) -> Bool {
    if lhs.epochNum != rhs.epochNum {return false}
    if lhs.blockHash != rhs.blockHash {return false}
    if lhs.blsSig != rhs.blsSig {return false}
    if lhs.signerAddress != rhs.signerAddress {return false}
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
