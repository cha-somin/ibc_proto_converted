// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: babylon/btccheckpoint/v1/btccheckpoint.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// BtcStatus is an enum describing the current btc status of the checkpoint
enum Babylon_Btccheckpoint_V1_BtcStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// SUBMITTED Epoch has Submitted btc status if there ever was at least one
  /// known submission on btc main chain
  case epochStatusSubmitted // = 0

  /// CONFIRMED Epoch has Confirmed btc status if there ever was at least one
  /// known submission on btc main chain which was k-deep
  case epochStatusConfirmed // = 1

  /// CONFIRMED Epoch has Finalized btc status if there is was at exactly one
  /// knon submission on btc main chain which is w-deep
  case epochStatusFinalized // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .epochStatusSubmitted
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .epochStatusSubmitted
    case 1: self = .epochStatusConfirmed
    case 2: self = .epochStatusFinalized
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .epochStatusSubmitted: return 0
    case .epochStatusConfirmed: return 1
    case .epochStatusFinalized: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Babylon_Btccheckpoint_V1_BtcStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Babylon_Btccheckpoint_V1_BtcStatus] = [
    .epochStatusSubmitted,
    .epochStatusConfirmed,
    .epochStatusFinalized,
  ]
}

#endif  // swift(>=4.2)

/// Consider we have a Merkle tree with following structure:
///            ROOT
///           /    \
///      H1234      H5555
///     /     \       \
///   H12     H34      H55
///  /  \    /  \     /
/// H1  H2  H3  H4  H5
/// L1  L2  L3  L4  L5
/// To prove L3 was part of ROOT we need:
/// - btc_transaction_index = 2 which in binary is 010
/// (where 0 means going left, 1 means going right in the tree)
/// - merkle_nodes we'd have H4 || H12 || H5555
/// By looking at 010 we would know that H4 is a right sibling,
/// H12 is left, H5555 is right again.
struct Babylon_Btccheckpoint_V1_BTCSpvProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Valid bitcoin transaction containing OP_RETURN opcode.
  var btcTransaction: Data = Data()

  /// Index of transaction within the block. Index is needed to determine if
  /// currently hashed node is left or right.
  var btcTransactionIndex: UInt32 = 0

  /// List of concatenated intermediate merkle tree nodes, without root node and
  /// leaf node against which we calculate the proof. Each node has 32 byte
  /// length. Example proof can look like: 32_bytes_of_node1 || 32_bytes_of_node2
  /// ||  32_bytes_of_node3 so the length of the proof will always be divisible
  /// by 32.
  var merkleNodes: Data = Data()

  /// Valid btc header which confirms btc_transaction.
  /// Should have exactly 80 bytes
  var confirmingBtcHeader: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Each provided OP_RETURN transaction can be identified by hash of block in
/// which transaction was included and transaction index in the block
struct Babylon_Btccheckpoint_V1_TransactionKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: UInt32 = 0

  var hash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Checkpoint can be composed from multiple transactions, so to identify whole
/// submission we need list of transaction keys.
/// Each submission can generally be identified by this list of (txIdx,
/// blockHash) tuples. Note: this could possibly be optimized as if transactions
/// were in one block they would have the same block hash and different indexes,
/// but each blockhash is only 33 (1  byte for prefix encoding and 32 byte hash),
/// so there should be other strong arguments for this optimization
struct Babylon_Btccheckpoint_V1_SubmissionKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: [Babylon_Btccheckpoint_V1_TransactionKey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TransactionInfo is the info of a tx on Bitcoin,
/// including
/// - the position of the tx on BTC blockchain
/// - the full tx content
/// - the Merkle proof that this tx is on the above position
struct Babylon_Btccheckpoint_V1_TransactionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// key is the position (txIdx, blockHash) of this tx on BTC blockchain
  /// Although it is already a part of SubmissionKey, we store it here again
  /// to make TransactionInfo self-contained.
  /// For example, storing the key allows TransactionInfo to not relay on
  /// the fact that TransactionInfo will be ordered in the same order as
  /// TransactionKeys in SubmissionKey.
  var key: Babylon_Btccheckpoint_V1_TransactionKey {
    get {return _key ?? Babylon_Btccheckpoint_V1_TransactionKey()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// transaction is the full transaction in bytes
  var transaction: Data = Data()

  /// proof is the Merkle proof that this tx is included in the position in `key`
  /// TODO: maybe it could use here better format as we already processed and
  /// validated the proof?
  var proof: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: Babylon_Btccheckpoint_V1_TransactionKey? = nil
}

/// TODO: Determine if we should keep any block number or depth info.
/// On one hand it may be useful to determine if block is stable or not, on
/// other depth/block number info, without context (i.e info about chain) is
/// pretty useless and blockhash in enough to retrieve is from lightclient
struct Babylon_Btccheckpoint_V1_SubmissionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address of the submitter and reporter
  var vigilanteAddresses: Babylon_Btccheckpoint_V1_CheckpointAddresses {
    get {return _vigilanteAddresses ?? Babylon_Btccheckpoint_V1_CheckpointAddresses()}
    set {_vigilanteAddresses = newValue}
  }
  /// Returns true if `vigilanteAddresses` has been explicitly set.
  var hasVigilanteAddresses: Bool {return self._vigilanteAddresses != nil}
  /// Clears the value of `vigilanteAddresses`. Subsequent reads from it will return its default value.
  mutating func clearVigilanteAddresses() {self._vigilanteAddresses = nil}

  /// txs_info is the two `TransactionInfo`s corresponding to the submission
  /// It is used for
  /// - recovering address of sender of btc transaction to payup the reward.
  /// - allowing the ZoneConcierge module to prove the checkpoint is submitted to
  /// BTC
  var txsInfo: [Babylon_Btccheckpoint_V1_TransactionInfo] = []

  var epoch: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vigilanteAddresses: Babylon_Btccheckpoint_V1_CheckpointAddresses? = nil
}

/// Data stored in db and indexed by epoch number
/// TODO: Add btc blockheight at epoch end, when adding handling of epoching
/// callbacks
struct Babylon_Btccheckpoint_V1_EpochData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// keys is the list of all received checkpoints during this epoch, sorted by
  /// order of submission.
  var keys: [Babylon_Btccheckpoint_V1_SubmissionKey] = []

  /// status is the current btc status of the epoch
  var status: Babylon_Btccheckpoint_V1_BtcStatus = .epochStatusSubmitted

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CheckpointAddresses contains the addresses of the submitter and reporter of a
/// given checkpoint
struct Babylon_Btccheckpoint_V1_CheckpointAddresses {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO: this could probably be better typed
  /// submitter is the address of the checkpoint submitter to BTC, extracted from
  /// the checkpoint itself.
  var submitter: Data = Data()

  /// reporter is the address of the reporter who reported the submissions,
  /// calculated from submission message MsgInsertBTCSpvProof itself
  var reporter: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BTCCheckpointInfo contains all data about best submission of checkpoint for
/// given epoch. Best submission is the submission which is deeper in btc ledger
struct Babylon_Btccheckpoint_V1_BTCCheckpointInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// epoch number of this checkpoint
  var epochNumber: UInt64 = 0

  /// btc height of the best submission of the epoch
  var bestSubmissionBtcBlockHeight: UInt32 = 0

  /// hash of the btc block which determines checkpoint btc block height i.e.
  /// youngest block of best submission
  var bestSubmissionBtcBlockHash: Data = Data()

  /// the BTC checkpoint transactions of the best submission
  var bestSubmissionTransactions: [Babylon_Btccheckpoint_V1_TransactionInfo] = []

  /// list of vigilantes' addresses of the best submission
  var bestSubmissionVigilanteAddressList: [Babylon_Btccheckpoint_V1_CheckpointAddresses] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Babylon_Btccheckpoint_V1_BtcStatus: @unchecked Sendable {}
extension Babylon_Btccheckpoint_V1_BTCSpvProof: @unchecked Sendable {}
extension Babylon_Btccheckpoint_V1_TransactionKey: @unchecked Sendable {}
extension Babylon_Btccheckpoint_V1_SubmissionKey: @unchecked Sendable {}
extension Babylon_Btccheckpoint_V1_TransactionInfo: @unchecked Sendable {}
extension Babylon_Btccheckpoint_V1_SubmissionData: @unchecked Sendable {}
extension Babylon_Btccheckpoint_V1_EpochData: @unchecked Sendable {}
extension Babylon_Btccheckpoint_V1_CheckpointAddresses: @unchecked Sendable {}
extension Babylon_Btccheckpoint_V1_BTCCheckpointInfo: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "babylon.btccheckpoint.v1"

extension Babylon_Btccheckpoint_V1_BtcStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EPOCH_STATUS_SUBMITTED"),
    1: .same(proto: "EPOCH_STATUS_CONFIRMED"),
    2: .same(proto: "EPOCH_STATUS_FINALIZED"),
  ]
}

extension Babylon_Btccheckpoint_V1_BTCSpvProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BTCSpvProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "btc_transaction"),
    2: .standard(proto: "btc_transaction_index"),
    3: .standard(proto: "merkle_nodes"),
    4: .standard(proto: "confirming_btc_header"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.btcTransaction) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.btcTransactionIndex) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.merkleNodes) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.confirmingBtcHeader) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.btcTransaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.btcTransaction, fieldNumber: 1)
    }
    if self.btcTransactionIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.btcTransactionIndex, fieldNumber: 2)
    }
    if !self.merkleNodes.isEmpty {
      try visitor.visitSingularBytesField(value: self.merkleNodes, fieldNumber: 3)
    }
    if !self.confirmingBtcHeader.isEmpty {
      try visitor.visitSingularBytesField(value: self.confirmingBtcHeader, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btccheckpoint_V1_BTCSpvProof, rhs: Babylon_Btccheckpoint_V1_BTCSpvProof) -> Bool {
    if lhs.btcTransaction != rhs.btcTransaction {return false}
    if lhs.btcTransactionIndex != rhs.btcTransactionIndex {return false}
    if lhs.merkleNodes != rhs.merkleNodes {return false}
    if lhs.confirmingBtcHeader != rhs.confirmingBtcHeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btccheckpoint_V1_TransactionKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btccheckpoint_V1_TransactionKey, rhs: Babylon_Btccheckpoint_V1_TransactionKey) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btccheckpoint_V1_SubmissionKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubmissionKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btccheckpoint_V1_SubmissionKey, rhs: Babylon_Btccheckpoint_V1_SubmissionKey) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btccheckpoint_V1_TransactionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "transaction"),
    3: .same(proto: "proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.proof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 2)
    }
    if !self.proof.isEmpty {
      try visitor.visitSingularBytesField(value: self.proof, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btccheckpoint_V1_TransactionInfo, rhs: Babylon_Btccheckpoint_V1_TransactionInfo) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btccheckpoint_V1_SubmissionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubmissionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vigilante_addresses"),
    2: .standard(proto: "txs_info"),
    3: .same(proto: "epoch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._vigilanteAddresses) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.txsInfo) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.epoch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._vigilanteAddresses {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.txsInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txsInfo, fieldNumber: 2)
    }
    if self.epoch != 0 {
      try visitor.visitSingularUInt64Field(value: self.epoch, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btccheckpoint_V1_SubmissionData, rhs: Babylon_Btccheckpoint_V1_SubmissionData) -> Bool {
    if lhs._vigilanteAddresses != rhs._vigilanteAddresses {return false}
    if lhs.txsInfo != rhs.txsInfo {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btccheckpoint_V1_EpochData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EpochData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    if self.status != .epochStatusSubmitted {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btccheckpoint_V1_EpochData, rhs: Babylon_Btccheckpoint_V1_EpochData) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btccheckpoint_V1_CheckpointAddresses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckpointAddresses"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "submitter"),
    2: .same(proto: "reporter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.submitter) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.reporter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.submitter.isEmpty {
      try visitor.visitSingularBytesField(value: self.submitter, fieldNumber: 1)
    }
    if !self.reporter.isEmpty {
      try visitor.visitSingularBytesField(value: self.reporter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btccheckpoint_V1_CheckpointAddresses, rhs: Babylon_Btccheckpoint_V1_CheckpointAddresses) -> Bool {
    if lhs.submitter != rhs.submitter {return false}
    if lhs.reporter != rhs.reporter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btccheckpoint_V1_BTCCheckpointInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BTCCheckpointInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_number"),
    2: .standard(proto: "best_submission_btc_block_height"),
    3: .standard(proto: "best_submission_btc_block_hash"),
    4: .standard(proto: "best_submission_transactions"),
    5: .standard(proto: "best_submission_vigilante_address_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNumber) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.bestSubmissionBtcBlockHeight) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.bestSubmissionBtcBlockHash) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bestSubmissionTransactions) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.bestSubmissionVigilanteAddressList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNumber, fieldNumber: 1)
    }
    if self.bestSubmissionBtcBlockHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.bestSubmissionBtcBlockHeight, fieldNumber: 2)
    }
    if !self.bestSubmissionBtcBlockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.bestSubmissionBtcBlockHash, fieldNumber: 3)
    }
    if !self.bestSubmissionTransactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bestSubmissionTransactions, fieldNumber: 4)
    }
    if !self.bestSubmissionVigilanteAddressList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bestSubmissionVigilanteAddressList, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btccheckpoint_V1_BTCCheckpointInfo, rhs: Babylon_Btccheckpoint_V1_BTCCheckpointInfo) -> Bool {
    if lhs.epochNumber != rhs.epochNumber {return false}
    if lhs.bestSubmissionBtcBlockHeight != rhs.bestSubmissionBtcBlockHeight {return false}
    if lhs.bestSubmissionBtcBlockHash != rhs.bestSubmissionBtcBlockHash {return false}
    if lhs.bestSubmissionTransactions != rhs.bestSubmissionTransactions {return false}
    if lhs.bestSubmissionVigilanteAddressList != rhs.bestSubmissionVigilanteAddressList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
