// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: desmos/posts/v2/models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// PostReferenceType represents the different types of references
enum Desmos_Posts_V2_PostReferenceType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// No reference specified
  case unspecified // = 0

  /// This reference represents a reply to the specified post
  case reply // = 1

  /// This reference represents a quote of the specified post
  case quote // = 2

  /// This reference represents a repost of the specified post
  case repost // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .reply
    case 2: self = .quote
    case 3: self = .repost
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .reply: return 1
    case .quote: return 2
    case .repost: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Desmos_Posts_V2_PostReferenceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Desmos_Posts_V2_PostReferenceType] = [
    .unspecified,
    .reply,
    .quote,
    .repost,
  ]
}

#endif  // swift(>=4.2)

/// ReplySetting contains the possible reply settings that a post can have
enum Desmos_Posts_V2_ReplySetting: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// No reply setting specified
  case unspecified // = 0

  /// Everyone will be able to reply to this post
  case everyone // = 1

  /// Only followers of the author will be able to reply to this post
  case followers // = 2

  /// Only the author mutual followers will be able to reply to this post
  case mutual // = 3

  /// Only people mentioned inside this post will be able to reply
  case mentions // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .everyone
    case 2: self = .followers
    case 3: self = .mutual
    case 4: self = .mentions
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .everyone: return 1
    case .followers: return 2
    case .mutual: return 3
    case .mentions: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Desmos_Posts_V2_ReplySetting: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Desmos_Posts_V2_ReplySetting] = [
    .unspecified,
    .everyone,
    .followers,
    .mutual,
    .mentions,
  ]
}

#endif  // swift(>=4.2)

/// Post contains all the information about a single post
struct Desmos_Posts_V2_Post {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id of the subspace inside which the post has been created
  var subspaceID: UInt64 {
    get {return _storage._subspaceID}
    set {_uniqueStorage()._subspaceID = newValue}
  }

  /// Id of the section inside which the post has been created
  var sectionID: UInt32 {
    get {return _storage._sectionID}
    set {_uniqueStorage()._sectionID = newValue}
  }

  /// Unique id of the post
  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// (optional) External id for this post
  var externalID: String {
    get {return _storage._externalID}
    set {_uniqueStorage()._externalID = newValue}
  }

  /// (optional) Text of the post
  var text: String {
    get {return _storage._text}
    set {_uniqueStorage()._text = newValue}
  }

  /// (optional) Entities connected to this post
  var entities: Desmos_Posts_V2_Entities {
    get {return _storage._entities ?? Desmos_Posts_V2_Entities()}
    set {_uniqueStorage()._entities = newValue}
  }
  /// Returns true if `entities` has been explicitly set.
  var hasEntities: Bool {return _storage._entities != nil}
  /// Clears the value of `entities`. Subsequent reads from it will return its default value.
  mutating func clearEntities() {_uniqueStorage()._entities = nil}

  /// Tags related to this post, useful for categorization
  var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  /// Author of the post
  var author: String {
    get {return _storage._author}
    set {_uniqueStorage()._author = newValue}
  }

  /// (optional) Id of the original post of the conversation
  var conversationID: UInt64 {
    get {return _storage._conversationID}
    set {_uniqueStorage()._conversationID = newValue}
  }

  /// A list this posts references (either as a reply, repost or quote)
  var referencedPosts: [Desmos_Posts_V2_PostReference] {
    get {return _storage._referencedPosts}
    set {_uniqueStorage()._referencedPosts = newValue}
  }

  /// Reply settings of this post
  var replySettings: Desmos_Posts_V2_ReplySetting {
    get {return _storage._replySettings}
    set {_uniqueStorage()._replySettings = newValue}
  }

  /// Creation date of the post
  var creationDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._creationDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._creationDate = newValue}
  }
  /// Returns true if `creationDate` has been explicitly set.
  var hasCreationDate: Bool {return _storage._creationDate != nil}
  /// Clears the value of `creationDate`. Subsequent reads from it will return its default value.
  mutating func clearCreationDate() {_uniqueStorage()._creationDate = nil}

  /// (optional) Last edited time of the post
  var lastEditedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastEditedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastEditedDate = newValue}
  }
  /// Returns true if `lastEditedDate` has been explicitly set.
  var hasLastEditedDate: Bool {return _storage._lastEditedDate != nil}
  /// Clears the value of `lastEditedDate`. Subsequent reads from it will return its default value.
  mutating func clearLastEditedDate() {_uniqueStorage()._lastEditedDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PostReference contains the details of a post reference
struct Desmos_Posts_V2_PostReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of reference
  var type: Desmos_Posts_V2_PostReferenceType = .unspecified

  /// Id of the referenced post
  var postID: UInt64 = 0

  /// Position of the reference inside the post's text. This should be used only
  /// with the type set to TYPE_QUOTE
  var position: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Contains the details of entities parsed out of the post text
struct Desmos_Posts_V2_Entities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hashtags represent inside the post text
  var hashtags: [Desmos_Posts_V2_TextTag] = []

  /// Mentions present inside the post text
  var mentions: [Desmos_Posts_V2_TextTag] = []

  /// Links present inside the post text
  var urls: [Desmos_Posts_V2_Url] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TextTag represents a tag within the post text
struct Desmos_Posts_V2_TextTag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index of the character inside the text at which the tag starts
  var start: UInt64 = 0

  /// Index of the character inside the text at which the tag ends
  var end: UInt64 = 0

  /// Tag reference (user address, hashtag value, etc)
  var tag: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Url contains the details of a generic URL
struct Desmos_Posts_V2_Url {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index of the character inside the text at which the URL starts
  var start: UInt64 = 0

  /// Index of the character inside the text at which the URL ends
  var end: UInt64 = 0

  /// Value of the URL where the user should be redirected to
  var url: String = String()

  /// (optional) Display value of the URL
  var displayURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Attachment contains the data of a single post attachment
struct Desmos_Posts_V2_Attachment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id of the subspace inside which the post to which this attachment should be
  /// connected is
  var subspaceID: UInt64 = 0

  /// Id of the post to which this attachment should be connected
  var postID: UInt64 = 0

  /// If of this attachment
  var id: UInt32 = 0

  /// Content of the attachment
  var content: SwiftProtobuf.Google_Protobuf_Any {
    get {return _content ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _content: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// Media represents a media attachment
struct Desmos_Posts_V2_Media {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uri: String = String()

  var mimeType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Poll represents a poll attachment
struct Desmos_Posts_V2_Poll {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Question of the poll
  var question: String = String()

  /// Answers the users can choose from
  var providedAnswers: [Desmos_Posts_V2_Poll.ProvidedAnswer] = []

  /// Date at which the poll will close
  var endDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endDate = newValue}
  }
  /// Returns true if `endDate` has been explicitly set.
  var hasEndDate: Bool {return self._endDate != nil}
  /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
  mutating func clearEndDate() {self._endDate = nil}

  /// Whether the poll allows multiple choices from the same user or not
  var allowsMultipleAnswers: Bool = false

  /// Whether the poll allows to edit an answer or not
  var allowsAnswerEdits: Bool = false

  /// Final poll results
  var finalTallyResults: Desmos_Posts_V2_PollTallyResults {
    get {return _finalTallyResults ?? Desmos_Posts_V2_PollTallyResults()}
    set {_finalTallyResults = newValue}
  }
  /// Returns true if `finalTallyResults` has been explicitly set.
  var hasFinalTallyResults: Bool {return self._finalTallyResults != nil}
  /// Clears the value of `finalTallyResults`. Subsequent reads from it will return its default value.
  mutating func clearFinalTallyResults() {self._finalTallyResults = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Provided answer contains the details of a possible poll answer
  struct ProvidedAnswer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// (optional) Text of the answer
    var text: String = String()

    /// Attachments of the answer
    var attachments: [Desmos_Posts_V2_Attachment] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _endDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _finalTallyResults: Desmos_Posts_V2_PollTallyResults? = nil
}

/// UserAnswer represents a user answer to a poll
struct Desmos_Posts_V2_UserAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Subspace id inside which the post related to this attachment is located
  var subspaceID: UInt64 = 0

  /// Id of the post associated to this attachment
  var postID: UInt64 = 0

  /// Id of the poll to which this answer is associated
  var pollID: UInt32 = 0

  /// Indexes of the answers inside the ProvidedAnswers array
  var answersIndexes: [UInt32] = []

  /// Address of the user answering the poll
  var user: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PollTallyResults contains the tally results for a poll
struct Desmos_Posts_V2_PollTallyResults {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var results: [Desmos_Posts_V2_PollTallyResults.AnswerResult] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// AnswerResult contains the result of a single poll provided answer
  struct AnswerResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Index of the answer inside the poll's ProvidedAnswers slice
    var answerIndex: UInt32 = 0

    /// Number of votes the answer has received
    var votes: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Params contains the parameters for the posts module
struct Desmos_Posts_V2_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Maximum length of the post text
  var maxTextLength: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Desmos_Posts_V2_PostReferenceType: @unchecked Sendable {}
extension Desmos_Posts_V2_ReplySetting: @unchecked Sendable {}
extension Desmos_Posts_V2_Post: @unchecked Sendable {}
extension Desmos_Posts_V2_PostReference: @unchecked Sendable {}
extension Desmos_Posts_V2_Entities: @unchecked Sendable {}
extension Desmos_Posts_V2_TextTag: @unchecked Sendable {}
extension Desmos_Posts_V2_Url: @unchecked Sendable {}
extension Desmos_Posts_V2_Attachment: @unchecked Sendable {}
extension Desmos_Posts_V2_Media: @unchecked Sendable {}
extension Desmos_Posts_V2_Poll: @unchecked Sendable {}
extension Desmos_Posts_V2_Poll.ProvidedAnswer: @unchecked Sendable {}
extension Desmos_Posts_V2_UserAnswer: @unchecked Sendable {}
extension Desmos_Posts_V2_PollTallyResults: @unchecked Sendable {}
extension Desmos_Posts_V2_PollTallyResults.AnswerResult: @unchecked Sendable {}
extension Desmos_Posts_V2_Params: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "desmos.posts.v2"

extension Desmos_Posts_V2_PostReferenceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST_REFERENCE_TYPE_UNSPECIFIED"),
    1: .same(proto: "POST_REFERENCE_TYPE_REPLY"),
    2: .same(proto: "POST_REFERENCE_TYPE_QUOTE"),
    3: .same(proto: "POST_REFERENCE_TYPE_REPOST"),
  ]
}

extension Desmos_Posts_V2_ReplySetting: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REPLY_SETTING_UNSPECIFIED"),
    1: .same(proto: "REPLY_SETTING_EVERYONE"),
    2: .same(proto: "REPLY_SETTING_FOLLOWERS"),
    3: .same(proto: "REPLY_SETTING_MUTUAL"),
    4: .same(proto: "REPLY_SETTING_MENTIONS"),
  ]
}

extension Desmos_Posts_V2_Post: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Post"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subspace_id"),
    2: .standard(proto: "section_id"),
    3: .same(proto: "id"),
    4: .standard(proto: "external_id"),
    5: .same(proto: "text"),
    6: .same(proto: "entities"),
    7: .same(proto: "tags"),
    8: .same(proto: "author"),
    9: .standard(proto: "conversation_id"),
    10: .standard(proto: "referenced_posts"),
    11: .standard(proto: "reply_settings"),
    12: .standard(proto: "creation_date"),
    13: .standard(proto: "last_edited_date"),
  ]

  fileprivate class _StorageClass {
    var _subspaceID: UInt64 = 0
    var _sectionID: UInt32 = 0
    var _id: UInt64 = 0
    var _externalID: String = String()
    var _text: String = String()
    var _entities: Desmos_Posts_V2_Entities? = nil
    var _tags: [String] = []
    var _author: String = String()
    var _conversationID: UInt64 = 0
    var _referencedPosts: [Desmos_Posts_V2_PostReference] = []
    var _replySettings: Desmos_Posts_V2_ReplySetting = .unspecified
    var _creationDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastEditedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _subspaceID = source._subspaceID
      _sectionID = source._sectionID
      _id = source._id
      _externalID = source._externalID
      _text = source._text
      _entities = source._entities
      _tags = source._tags
      _author = source._author
      _conversationID = source._conversationID
      _referencedPosts = source._referencedPosts
      _replySettings = source._replySettings
      _creationDate = source._creationDate
      _lastEditedDate = source._lastEditedDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._subspaceID) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._sectionID) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._externalID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._text) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._entities) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._author) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._conversationID) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._referencedPosts) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._replySettings) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._creationDate) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._lastEditedDate) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._subspaceID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._subspaceID, fieldNumber: 1)
      }
      if _storage._sectionID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sectionID, fieldNumber: 2)
      }
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 3)
      }
      if !_storage._externalID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._externalID, fieldNumber: 4)
      }
      if !_storage._text.isEmpty {
        try visitor.visitSingularStringField(value: _storage._text, fieldNumber: 5)
      }
      try { if let v = _storage._entities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 7)
      }
      if !_storage._author.isEmpty {
        try visitor.visitSingularStringField(value: _storage._author, fieldNumber: 8)
      }
      if _storage._conversationID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._conversationID, fieldNumber: 9)
      }
      if !_storage._referencedPosts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._referencedPosts, fieldNumber: 10)
      }
      if _storage._replySettings != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._replySettings, fieldNumber: 11)
      }
      try { if let v = _storage._creationDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._lastEditedDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Desmos_Posts_V2_Post, rhs: Desmos_Posts_V2_Post) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._subspaceID != rhs_storage._subspaceID {return false}
        if _storage._sectionID != rhs_storage._sectionID {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._externalID != rhs_storage._externalID {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._entities != rhs_storage._entities {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._author != rhs_storage._author {return false}
        if _storage._conversationID != rhs_storage._conversationID {return false}
        if _storage._referencedPosts != rhs_storage._referencedPosts {return false}
        if _storage._replySettings != rhs_storage._replySettings {return false}
        if _storage._creationDate != rhs_storage._creationDate {return false}
        if _storage._lastEditedDate != rhs_storage._lastEditedDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Desmos_Posts_V2_PostReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PostReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "post_id"),
    3: .same(proto: "position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.postID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.postID != 0 {
      try visitor.visitSingularUInt64Field(value: self.postID, fieldNumber: 2)
    }
    if self.position != 0 {
      try visitor.visitSingularUInt64Field(value: self.position, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Desmos_Posts_V2_PostReference, rhs: Desmos_Posts_V2_PostReference) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.postID != rhs.postID {return false}
    if lhs.position != rhs.position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Desmos_Posts_V2_Entities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Entities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hashtags"),
    2: .same(proto: "mentions"),
    3: .same(proto: "urls"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hashtags) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.mentions) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.urls) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hashtags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hashtags, fieldNumber: 1)
    }
    if !self.mentions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mentions, fieldNumber: 2)
    }
    if !self.urls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.urls, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Desmos_Posts_V2_Entities, rhs: Desmos_Posts_V2_Entities) -> Bool {
    if lhs.hashtags != rhs.hashtags {return false}
    if lhs.mentions != rhs.mentions {return false}
    if lhs.urls != rhs.urls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Desmos_Posts_V2_TextTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextTag"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
    3: .same(proto: "tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.end) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularUInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularUInt64Field(value: self.end, fieldNumber: 2)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Desmos_Posts_V2_TextTag, rhs: Desmos_Posts_V2_TextTag) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Desmos_Posts_V2_Url: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Url"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
    3: .same(proto: "url"),
    4: .standard(proto: "display_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.end) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.displayURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularUInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularUInt64Field(value: self.end, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    if !self.displayURL.isEmpty {
      try visitor.visitSingularStringField(value: self.displayURL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Desmos_Posts_V2_Url, rhs: Desmos_Posts_V2_Url) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.url != rhs.url {return false}
    if lhs.displayURL != rhs.displayURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Desmos_Posts_V2_Attachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Attachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subspace_id"),
    2: .standard(proto: "post_id"),
    3: .same(proto: "id"),
    4: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.subspaceID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.postID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.subspaceID != 0 {
      try visitor.visitSingularUInt64Field(value: self.subspaceID, fieldNumber: 1)
    }
    if self.postID != 0 {
      try visitor.visitSingularUInt64Field(value: self.postID, fieldNumber: 2)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 3)
    }
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Desmos_Posts_V2_Attachment, rhs: Desmos_Posts_V2_Attachment) -> Bool {
    if lhs.subspaceID != rhs.subspaceID {return false}
    if lhs.postID != rhs.postID {return false}
    if lhs.id != rhs.id {return false}
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Desmos_Posts_V2_Media: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Media"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "uri"),
    3: .standard(proto: "mime_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Desmos_Posts_V2_Media, rhs: Desmos_Posts_V2_Media) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Desmos_Posts_V2_Poll: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Poll"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "question"),
    2: .standard(proto: "provided_answers"),
    3: .standard(proto: "end_date"),
    4: .standard(proto: "allows_multiple_answers"),
    5: .standard(proto: "allows_answer_edits"),
    6: .standard(proto: "final_tally_results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.question) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.providedAnswers) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._endDate) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowsMultipleAnswers) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.allowsAnswerEdits) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._finalTallyResults) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.question.isEmpty {
      try visitor.visitSingularStringField(value: self.question, fieldNumber: 1)
    }
    if !self.providedAnswers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.providedAnswers, fieldNumber: 2)
    }
    try { if let v = self._endDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.allowsMultipleAnswers != false {
      try visitor.visitSingularBoolField(value: self.allowsMultipleAnswers, fieldNumber: 4)
    }
    if self.allowsAnswerEdits != false {
      try visitor.visitSingularBoolField(value: self.allowsAnswerEdits, fieldNumber: 5)
    }
    try { if let v = self._finalTallyResults {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Desmos_Posts_V2_Poll, rhs: Desmos_Posts_V2_Poll) -> Bool {
    if lhs.question != rhs.question {return false}
    if lhs.providedAnswers != rhs.providedAnswers {return false}
    if lhs._endDate != rhs._endDate {return false}
    if lhs.allowsMultipleAnswers != rhs.allowsMultipleAnswers {return false}
    if lhs.allowsAnswerEdits != rhs.allowsAnswerEdits {return false}
    if lhs._finalTallyResults != rhs._finalTallyResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Desmos_Posts_V2_Poll.ProvidedAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Desmos_Posts_V2_Poll.protoMessageName + ".ProvidedAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "attachments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Desmos_Posts_V2_Poll.ProvidedAnswer, rhs: Desmos_Posts_V2_Poll.ProvidedAnswer) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Desmos_Posts_V2_UserAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subspace_id"),
    2: .standard(proto: "post_id"),
    3: .standard(proto: "poll_id"),
    4: .standard(proto: "answers_indexes"),
    5: .same(proto: "user"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.subspaceID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.postID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.pollID) }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.answersIndexes) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.user) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subspaceID != 0 {
      try visitor.visitSingularUInt64Field(value: self.subspaceID, fieldNumber: 1)
    }
    if self.postID != 0 {
      try visitor.visitSingularUInt64Field(value: self.postID, fieldNumber: 2)
    }
    if self.pollID != 0 {
      try visitor.visitSingularUInt32Field(value: self.pollID, fieldNumber: 3)
    }
    if !self.answersIndexes.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.answersIndexes, fieldNumber: 4)
    }
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Desmos_Posts_V2_UserAnswer, rhs: Desmos_Posts_V2_UserAnswer) -> Bool {
    if lhs.subspaceID != rhs.subspaceID {return false}
    if lhs.postID != rhs.postID {return false}
    if lhs.pollID != rhs.pollID {return false}
    if lhs.answersIndexes != rhs.answersIndexes {return false}
    if lhs.user != rhs.user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Desmos_Posts_V2_PollTallyResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PollTallyResults"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Desmos_Posts_V2_PollTallyResults, rhs: Desmos_Posts_V2_PollTallyResults) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Desmos_Posts_V2_PollTallyResults.AnswerResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Desmos_Posts_V2_PollTallyResults.protoMessageName + ".AnswerResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "answer_index"),
    2: .same(proto: "votes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.answerIndex) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.votes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.answerIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.answerIndex, fieldNumber: 1)
    }
    if self.votes != 0 {
      try visitor.visitSingularUInt64Field(value: self.votes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Desmos_Posts_V2_PollTallyResults.AnswerResult, rhs: Desmos_Posts_V2_PollTallyResults.AnswerResult) -> Bool {
    if lhs.answerIndex != rhs.answerIndex {return false}
    if lhs.votes != rhs.votes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Desmos_Posts_V2_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_text_length"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.maxTextLength) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxTextLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxTextLength, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Desmos_Posts_V2_Params, rhs: Desmos_Posts_V2_Params) -> Bool {
    if lhs.maxTextLength != rhs.maxTextLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
