// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: quicksilver/interchainstaking/v1/interchainstaking.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Quicksilver_Interchainstaking_V1_Zone {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectionID: String {
    get {return _storage._connectionID}
    set {_uniqueStorage()._connectionID = newValue}
  }

  var chainID: String {
    get {return _storage._chainID}
    set {_uniqueStorage()._chainID = newValue}
  }

  var depositAddress: Quicksilver_Interchainstaking_V1_ICAAccount {
    get {return _storage._depositAddress ?? Quicksilver_Interchainstaking_V1_ICAAccount()}
    set {_uniqueStorage()._depositAddress = newValue}
  }
  /// Returns true if `depositAddress` has been explicitly set.
  var hasDepositAddress: Bool {return _storage._depositAddress != nil}
  /// Clears the value of `depositAddress`. Subsequent reads from it will return its default value.
  mutating func clearDepositAddress() {_uniqueStorage()._depositAddress = nil}

  var withdrawalAddress: Quicksilver_Interchainstaking_V1_ICAAccount {
    get {return _storage._withdrawalAddress ?? Quicksilver_Interchainstaking_V1_ICAAccount()}
    set {_uniqueStorage()._withdrawalAddress = newValue}
  }
  /// Returns true if `withdrawalAddress` has been explicitly set.
  var hasWithdrawalAddress: Bool {return _storage._withdrawalAddress != nil}
  /// Clears the value of `withdrawalAddress`. Subsequent reads from it will return its default value.
  mutating func clearWithdrawalAddress() {_uniqueStorage()._withdrawalAddress = nil}

  var performanceAddress: Quicksilver_Interchainstaking_V1_ICAAccount {
    get {return _storage._performanceAddress ?? Quicksilver_Interchainstaking_V1_ICAAccount()}
    set {_uniqueStorage()._performanceAddress = newValue}
  }
  /// Returns true if `performanceAddress` has been explicitly set.
  var hasPerformanceAddress: Bool {return _storage._performanceAddress != nil}
  /// Clears the value of `performanceAddress`. Subsequent reads from it will return its default value.
  mutating func clearPerformanceAddress() {_uniqueStorage()._performanceAddress = nil}

  var delegationAddress: Quicksilver_Interchainstaking_V1_ICAAccount {
    get {return _storage._delegationAddress ?? Quicksilver_Interchainstaking_V1_ICAAccount()}
    set {_uniqueStorage()._delegationAddress = newValue}
  }
  /// Returns true if `delegationAddress` has been explicitly set.
  var hasDelegationAddress: Bool {return _storage._delegationAddress != nil}
  /// Clears the value of `delegationAddress`. Subsequent reads from it will return its default value.
  mutating func clearDelegationAddress() {_uniqueStorage()._delegationAddress = nil}

  var accountPrefix: String {
    get {return _storage._accountPrefix}
    set {_uniqueStorage()._accountPrefix = newValue}
  }

  var localDenom: String {
    get {return _storage._localDenom}
    set {_uniqueStorage()._localDenom = newValue}
  }

  var baseDenom: String {
    get {return _storage._baseDenom}
    set {_uniqueStorage()._baseDenom = newValue}
  }

  var redemptionRate: String {
    get {return _storage._redemptionRate}
    set {_uniqueStorage()._redemptionRate = newValue}
  }

  var lastRedemptionRate: String {
    get {return _storage._lastRedemptionRate}
    set {_uniqueStorage()._lastRedemptionRate = newValue}
  }

  var validators: [Quicksilver_Interchainstaking_V1_Validator] {
    get {return _storage._validators}
    set {_uniqueStorage()._validators = newValue}
  }

  var aggregateIntent: [Quicksilver_Interchainstaking_V1_ValidatorIntent] {
    get {return _storage._aggregateIntent}
    set {_uniqueStorage()._aggregateIntent = newValue}
  }

  /// deprecated
  var multiSend: Bool {
    get {return _storage._multiSend}
    set {_uniqueStorage()._multiSend = newValue}
  }

  var liquidityModule: Bool {
    get {return _storage._liquidityModule}
    set {_uniqueStorage()._liquidityModule = newValue}
  }

  var withdrawalWaitgroup: UInt32 {
    get {return _storage._withdrawalWaitgroup}
    set {_uniqueStorage()._withdrawalWaitgroup = newValue}
  }

  var ibcNextValidatorsHash: Data {
    get {return _storage._ibcNextValidatorsHash}
    set {_uniqueStorage()._ibcNextValidatorsHash = newValue}
  }

  var validatorSelectionAllocation: UInt64 {
    get {return _storage._validatorSelectionAllocation}
    set {_uniqueStorage()._validatorSelectionAllocation = newValue}
  }

  var holdingsAllocation: UInt64 {
    get {return _storage._holdingsAllocation}
    set {_uniqueStorage()._holdingsAllocation = newValue}
  }

  /// deprecated
  var lastEpochHeight: Int64 {
    get {return _storage._lastEpochHeight}
    set {_uniqueStorage()._lastEpochHeight = newValue}
  }

  var tvl: String {
    get {return _storage._tvl}
    set {_uniqueStorage()._tvl = newValue}
  }

  var unbondingPeriod: Int64 {
    get {return _storage._unbondingPeriod}
    set {_uniqueStorage()._unbondingPeriod = newValue}
  }

  var messagesPerTx: Int64 {
    get {return _storage._messagesPerTx}
    set {_uniqueStorage()._messagesPerTx = newValue}
  }

  var decimals: Int64 {
    get {return _storage._decimals}
    set {_uniqueStorage()._decimals = newValue}
  }

  var unbondingEnabled: Bool {
    get {return _storage._unbondingEnabled}
    set {_uniqueStorage()._unbondingEnabled = newValue}
  }

  var depositsEnabled: Bool {
    get {return _storage._depositsEnabled}
    set {_uniqueStorage()._depositsEnabled = newValue}
  }

  var returnToSender: Bool {
    get {return _storage._returnToSender}
    set {_uniqueStorage()._returnToSender = newValue}
  }

  var is118: Bool {
    get {return _storage._is118}
    set {_uniqueStorage()._is118 = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Quicksilver_Interchainstaking_V1_ICAAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  /// balance defines the different coins this balance holds.
  var balance: [Cosmos_Base_V1beta1_Coin] = []

  var portName: String = String()

  var withdrawalAddress: String = String()

  var balanceWaitgroup: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Quicksilver_Interchainstaking_V1_Distribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valoper: String = String()

  var amount: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Quicksilver_Interchainstaking_V1_WithdrawalRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chainID: String = String()

  var delegator: String = String()

  var distribution: [Quicksilver_Interchainstaking_V1_Distribution] = []

  var recipient: String = String()

  var amount: [Cosmos_Base_V1beta1_Coin] = []

  var burnAmount: Cosmos_Base_V1beta1_Coin {
    get {return _burnAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_burnAmount = newValue}
  }
  /// Returns true if `burnAmount` has been explicitly set.
  var hasBurnAmount: Bool {return self._burnAmount != nil}
  /// Clears the value of `burnAmount`. Subsequent reads from it will return its default value.
  mutating func clearBurnAmount() {self._burnAmount = nil}

  var txhash: String = String()

  var status: Int32 = 0

  var completionTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _completionTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_completionTime = newValue}
  }
  /// Returns true if `completionTime` has been explicitly set.
  var hasCompletionTime: Bool {return self._completionTime != nil}
  /// Clears the value of `completionTime`. Subsequent reads from it will return its default value.
  mutating func clearCompletionTime() {self._completionTime = nil}

  var requeued: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _burnAmount: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _completionTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Quicksilver_Interchainstaking_V1_UnbondingRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chainID: String = String()

  var epochNumber: Int64 = 0

  var validator: String = String()

  var relatedTxhash: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Quicksilver_Interchainstaking_V1_RedelegationRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chainID: String = String()

  var epochNumber: Int64 = 0

  var source: String = String()

  var destination: String = String()

  var amount: Int64 = 0

  var completionTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _completionTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_completionTime = newValue}
  }
  /// Returns true if `completionTime` has been explicitly set.
  var hasCompletionTime: Bool {return self._completionTime != nil}
  /// Clears the value of `completionTime`. Subsequent reads from it will return its default value.
  mutating func clearCompletionTime() {self._completionTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _completionTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Quicksilver_Interchainstaking_V1_TransferRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var recipient: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Quicksilver_Interchainstaking_V1_Validator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valoperAddress: String = String()

  var commissionRate: String = String()

  var delegatorShares: String = String()

  var votingPower: String = String()

  var score: String = String()

  var status: String = String()

  var jailed: Bool = false

  var tombstoned: Bool = false

  var jailedSince: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _jailedSince ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_jailedSince = newValue}
  }
  /// Returns true if `jailedSince` has been explicitly set.
  var hasJailedSince: Bool {return self._jailedSince != nil}
  /// Clears the value of `jailedSince`. Subsequent reads from it will return its default value.
  mutating func clearJailedSince() {self._jailedSince = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _jailedSince: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Quicksilver_Interchainstaking_V1_DelegatorIntent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delegator: String = String()

  var intents: [Quicksilver_Interchainstaking_V1_ValidatorIntent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Quicksilver_Interchainstaking_V1_ValidatorIntent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valoperAddress: String = String()

  var weight: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Quicksilver_Interchainstaking_V1_Delegation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delegationAddress: String = String()

  var validatorAddress: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var height: Int64 = 0

  var redelegationEnd: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Quicksilver_Interchainstaking_V1_PortConnectionTuple {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectionID: String = String()

  var portID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Quicksilver_Interchainstaking_V1_Receipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chainID: String = String()

  var sender: String = String()

  var txhash: String = String()

  var amount: [Cosmos_Base_V1beta1_Coin] = []

  var firstSeen: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _firstSeen ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_firstSeen = newValue}
  }
  /// Returns true if `firstSeen` has been explicitly set.
  var hasFirstSeen: Bool {return self._firstSeen != nil}
  /// Clears the value of `firstSeen`. Subsequent reads from it will return its default value.
  mutating func clearFirstSeen() {self._firstSeen = nil}

  var completed: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _completed ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_completed = newValue}
  }
  /// Returns true if `completed` has been explicitly set.
  var hasCompleted: Bool {return self._completed != nil}
  /// Clears the value of `completed`. Subsequent reads from it will return its default value.
  mutating func clearCompleted() {self._completed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _firstSeen: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _completed: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Quicksilver_Interchainstaking_V1_Zone: @unchecked Sendable {}
extension Quicksilver_Interchainstaking_V1_ICAAccount: @unchecked Sendable {}
extension Quicksilver_Interchainstaking_V1_Distribution: @unchecked Sendable {}
extension Quicksilver_Interchainstaking_V1_WithdrawalRecord: @unchecked Sendable {}
extension Quicksilver_Interchainstaking_V1_UnbondingRecord: @unchecked Sendable {}
extension Quicksilver_Interchainstaking_V1_RedelegationRecord: @unchecked Sendable {}
extension Quicksilver_Interchainstaking_V1_TransferRecord: @unchecked Sendable {}
extension Quicksilver_Interchainstaking_V1_Validator: @unchecked Sendable {}
extension Quicksilver_Interchainstaking_V1_DelegatorIntent: @unchecked Sendable {}
extension Quicksilver_Interchainstaking_V1_ValidatorIntent: @unchecked Sendable {}
extension Quicksilver_Interchainstaking_V1_Delegation: @unchecked Sendable {}
extension Quicksilver_Interchainstaking_V1_PortConnectionTuple: @unchecked Sendable {}
extension Quicksilver_Interchainstaking_V1_Receipt: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "quicksilver.interchainstaking.v1"

extension Quicksilver_Interchainstaking_V1_Zone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Zone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connection_id"),
    2: .standard(proto: "chain_id"),
    3: .standard(proto: "deposit_address"),
    4: .standard(proto: "withdrawal_address"),
    5: .standard(proto: "performance_address"),
    6: .standard(proto: "delegation_address"),
    7: .standard(proto: "account_prefix"),
    8: .standard(proto: "local_denom"),
    9: .standard(proto: "base_denom"),
    10: .standard(proto: "redemption_rate"),
    11: .standard(proto: "last_redemption_rate"),
    12: .same(proto: "validators"),
    13: .standard(proto: "aggregate_intent"),
    14: .standard(proto: "multi_send"),
    15: .standard(proto: "liquidity_module"),
    16: .standard(proto: "withdrawal_waitgroup"),
    17: .standard(proto: "ibc_next_validators_hash"),
    18: .standard(proto: "validator_selection_allocation"),
    19: .standard(proto: "holdings_allocation"),
    20: .standard(proto: "last_epoch_height"),
    21: .same(proto: "tvl"),
    22: .standard(proto: "unbonding_period"),
    23: .standard(proto: "messages_per_tx"),
    24: .same(proto: "decimals"),
    25: .standard(proto: "unbonding_enabled"),
    26: .standard(proto: "deposits_enabled"),
    27: .standard(proto: "return_to_sender"),
    28: .standard(proto: "is_118"),
  ]

  fileprivate class _StorageClass {
    var _connectionID: String = String()
    var _chainID: String = String()
    var _depositAddress: Quicksilver_Interchainstaking_V1_ICAAccount? = nil
    var _withdrawalAddress: Quicksilver_Interchainstaking_V1_ICAAccount? = nil
    var _performanceAddress: Quicksilver_Interchainstaking_V1_ICAAccount? = nil
    var _delegationAddress: Quicksilver_Interchainstaking_V1_ICAAccount? = nil
    var _accountPrefix: String = String()
    var _localDenom: String = String()
    var _baseDenom: String = String()
    var _redemptionRate: String = String()
    var _lastRedemptionRate: String = String()
    var _validators: [Quicksilver_Interchainstaking_V1_Validator] = []
    var _aggregateIntent: [Quicksilver_Interchainstaking_V1_ValidatorIntent] = []
    var _multiSend: Bool = false
    var _liquidityModule: Bool = false
    var _withdrawalWaitgroup: UInt32 = 0
    var _ibcNextValidatorsHash: Data = Data()
    var _validatorSelectionAllocation: UInt64 = 0
    var _holdingsAllocation: UInt64 = 0
    var _lastEpochHeight: Int64 = 0
    var _tvl: String = String()
    var _unbondingPeriod: Int64 = 0
    var _messagesPerTx: Int64 = 0
    var _decimals: Int64 = 0
    var _unbondingEnabled: Bool = false
    var _depositsEnabled: Bool = false
    var _returnToSender: Bool = false
    var _is118: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connectionID = source._connectionID
      _chainID = source._chainID
      _depositAddress = source._depositAddress
      _withdrawalAddress = source._withdrawalAddress
      _performanceAddress = source._performanceAddress
      _delegationAddress = source._delegationAddress
      _accountPrefix = source._accountPrefix
      _localDenom = source._localDenom
      _baseDenom = source._baseDenom
      _redemptionRate = source._redemptionRate
      _lastRedemptionRate = source._lastRedemptionRate
      _validators = source._validators
      _aggregateIntent = source._aggregateIntent
      _multiSend = source._multiSend
      _liquidityModule = source._liquidityModule
      _withdrawalWaitgroup = source._withdrawalWaitgroup
      _ibcNextValidatorsHash = source._ibcNextValidatorsHash
      _validatorSelectionAllocation = source._validatorSelectionAllocation
      _holdingsAllocation = source._holdingsAllocation
      _lastEpochHeight = source._lastEpochHeight
      _tvl = source._tvl
      _unbondingPeriod = source._unbondingPeriod
      _messagesPerTx = source._messagesPerTx
      _decimals = source._decimals
      _unbondingEnabled = source._unbondingEnabled
      _depositsEnabled = source._depositsEnabled
      _returnToSender = source._returnToSender
      _is118 = source._is118
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._connectionID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._chainID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._depositAddress) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._withdrawalAddress) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._performanceAddress) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._delegationAddress) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._accountPrefix) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._localDenom) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._baseDenom) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._redemptionRate) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._lastRedemptionRate) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._validators) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._aggregateIntent) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._multiSend) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._liquidityModule) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._withdrawalWaitgroup) }()
        case 17: try { try decoder.decodeSingularBytesField(value: &_storage._ibcNextValidatorsHash) }()
        case 18: try { try decoder.decodeSingularUInt64Field(value: &_storage._validatorSelectionAllocation) }()
        case 19: try { try decoder.decodeSingularUInt64Field(value: &_storage._holdingsAllocation) }()
        case 20: try { try decoder.decodeSingularInt64Field(value: &_storage._lastEpochHeight) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._tvl) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._unbondingPeriod) }()
        case 23: try { try decoder.decodeSingularInt64Field(value: &_storage._messagesPerTx) }()
        case 24: try { try decoder.decodeSingularInt64Field(value: &_storage._decimals) }()
        case 25: try { try decoder.decodeSingularBoolField(value: &_storage._unbondingEnabled) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._depositsEnabled) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._returnToSender) }()
        case 28: try { try decoder.decodeSingularBoolField(value: &_storage._is118) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._connectionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectionID, fieldNumber: 1)
      }
      if !_storage._chainID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chainID, fieldNumber: 2)
      }
      try { if let v = _storage._depositAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._withdrawalAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._performanceAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._delegationAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._accountPrefix.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountPrefix, fieldNumber: 7)
      }
      if !_storage._localDenom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._localDenom, fieldNumber: 8)
      }
      if !_storage._baseDenom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._baseDenom, fieldNumber: 9)
      }
      if !_storage._redemptionRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._redemptionRate, fieldNumber: 10)
      }
      if !_storage._lastRedemptionRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastRedemptionRate, fieldNumber: 11)
      }
      if !_storage._validators.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._validators, fieldNumber: 12)
      }
      if !_storage._aggregateIntent.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._aggregateIntent, fieldNumber: 13)
      }
      if _storage._multiSend != false {
        try visitor.visitSingularBoolField(value: _storage._multiSend, fieldNumber: 14)
      }
      if _storage._liquidityModule != false {
        try visitor.visitSingularBoolField(value: _storage._liquidityModule, fieldNumber: 15)
      }
      if _storage._withdrawalWaitgroup != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._withdrawalWaitgroup, fieldNumber: 16)
      }
      if !_storage._ibcNextValidatorsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._ibcNextValidatorsHash, fieldNumber: 17)
      }
      if _storage._validatorSelectionAllocation != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._validatorSelectionAllocation, fieldNumber: 18)
      }
      if _storage._holdingsAllocation != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._holdingsAllocation, fieldNumber: 19)
      }
      if _storage._lastEpochHeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastEpochHeight, fieldNumber: 20)
      }
      if !_storage._tvl.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tvl, fieldNumber: 21)
      }
      if _storage._unbondingPeriod != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unbondingPeriod, fieldNumber: 22)
      }
      if _storage._messagesPerTx != 0 {
        try visitor.visitSingularInt64Field(value: _storage._messagesPerTx, fieldNumber: 23)
      }
      if _storage._decimals != 0 {
        try visitor.visitSingularInt64Field(value: _storage._decimals, fieldNumber: 24)
      }
      if _storage._unbondingEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._unbondingEnabled, fieldNumber: 25)
      }
      if _storage._depositsEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._depositsEnabled, fieldNumber: 26)
      }
      if _storage._returnToSender != false {
        try visitor.visitSingularBoolField(value: _storage._returnToSender, fieldNumber: 27)
      }
      if _storage._is118 != false {
        try visitor.visitSingularBoolField(value: _storage._is118, fieldNumber: 28)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quicksilver_Interchainstaking_V1_Zone, rhs: Quicksilver_Interchainstaking_V1_Zone) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._connectionID != rhs_storage._connectionID {return false}
        if _storage._chainID != rhs_storage._chainID {return false}
        if _storage._depositAddress != rhs_storage._depositAddress {return false}
        if _storage._withdrawalAddress != rhs_storage._withdrawalAddress {return false}
        if _storage._performanceAddress != rhs_storage._performanceAddress {return false}
        if _storage._delegationAddress != rhs_storage._delegationAddress {return false}
        if _storage._accountPrefix != rhs_storage._accountPrefix {return false}
        if _storage._localDenom != rhs_storage._localDenom {return false}
        if _storage._baseDenom != rhs_storage._baseDenom {return false}
        if _storage._redemptionRate != rhs_storage._redemptionRate {return false}
        if _storage._lastRedemptionRate != rhs_storage._lastRedemptionRate {return false}
        if _storage._validators != rhs_storage._validators {return false}
        if _storage._aggregateIntent != rhs_storage._aggregateIntent {return false}
        if _storage._multiSend != rhs_storage._multiSend {return false}
        if _storage._liquidityModule != rhs_storage._liquidityModule {return false}
        if _storage._withdrawalWaitgroup != rhs_storage._withdrawalWaitgroup {return false}
        if _storage._ibcNextValidatorsHash != rhs_storage._ibcNextValidatorsHash {return false}
        if _storage._validatorSelectionAllocation != rhs_storage._validatorSelectionAllocation {return false}
        if _storage._holdingsAllocation != rhs_storage._holdingsAllocation {return false}
        if _storage._lastEpochHeight != rhs_storage._lastEpochHeight {return false}
        if _storage._tvl != rhs_storage._tvl {return false}
        if _storage._unbondingPeriod != rhs_storage._unbondingPeriod {return false}
        if _storage._messagesPerTx != rhs_storage._messagesPerTx {return false}
        if _storage._decimals != rhs_storage._decimals {return false}
        if _storage._unbondingEnabled != rhs_storage._unbondingEnabled {return false}
        if _storage._depositsEnabled != rhs_storage._depositsEnabled {return false}
        if _storage._returnToSender != rhs_storage._returnToSender {return false}
        if _storage._is118 != rhs_storage._is118 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quicksilver_Interchainstaking_V1_ICAAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ICAAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "balance"),
    3: .standard(proto: "port_name"),
    4: .standard(proto: "withdrawal_address"),
    5: .standard(proto: "balance_waitgroup"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.balance) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.portName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.withdrawalAddress) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.balanceWaitgroup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.balance.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.balance, fieldNumber: 2)
    }
    if !self.portName.isEmpty {
      try visitor.visitSingularStringField(value: self.portName, fieldNumber: 3)
    }
    if !self.withdrawalAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.withdrawalAddress, fieldNumber: 4)
    }
    if self.balanceWaitgroup != 0 {
      try visitor.visitSingularUInt32Field(value: self.balanceWaitgroup, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quicksilver_Interchainstaking_V1_ICAAccount, rhs: Quicksilver_Interchainstaking_V1_ICAAccount) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.portName != rhs.portName {return false}
    if lhs.withdrawalAddress != rhs.withdrawalAddress {return false}
    if lhs.balanceWaitgroup != rhs.balanceWaitgroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quicksilver_Interchainstaking_V1_Distribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Distribution"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "valoper"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.valoper) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.valoper.isEmpty {
      try visitor.visitSingularStringField(value: self.valoper, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quicksilver_Interchainstaking_V1_Distribution, rhs: Quicksilver_Interchainstaking_V1_Distribution) -> Bool {
    if lhs.valoper != rhs.valoper {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quicksilver_Interchainstaking_V1_WithdrawalRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WithdrawalRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    2: .same(proto: "delegator"),
    3: .same(proto: "distribution"),
    4: .same(proto: "recipient"),
    5: .same(proto: "amount"),
    6: .standard(proto: "burn_amount"),
    7: .same(proto: "txhash"),
    8: .same(proto: "status"),
    9: .standard(proto: "completion_time"),
    10: .same(proto: "requeued"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.delegator) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.distribution) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.recipient) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.amount) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._burnAmount) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.txhash) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._completionTime) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.requeued) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 1)
    }
    if !self.delegator.isEmpty {
      try visitor.visitSingularStringField(value: self.delegator, fieldNumber: 2)
    }
    if !self.distribution.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.distribution, fieldNumber: 3)
    }
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 4)
    }
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 5)
    }
    try { if let v = self._burnAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.txhash.isEmpty {
      try visitor.visitSingularStringField(value: self.txhash, fieldNumber: 7)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 8)
    }
    try { if let v = self._completionTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if self.requeued != false {
      try visitor.visitSingularBoolField(value: self.requeued, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quicksilver_Interchainstaking_V1_WithdrawalRecord, rhs: Quicksilver_Interchainstaking_V1_WithdrawalRecord) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.delegator != rhs.delegator {return false}
    if lhs.distribution != rhs.distribution {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._burnAmount != rhs._burnAmount {return false}
    if lhs.txhash != rhs.txhash {return false}
    if lhs.status != rhs.status {return false}
    if lhs._completionTime != rhs._completionTime {return false}
    if lhs.requeued != rhs.requeued {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quicksilver_Interchainstaking_V1_UnbondingRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnbondingRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    2: .standard(proto: "epoch_number"),
    3: .same(proto: "validator"),
    4: .standard(proto: "related_txhash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.epochNumber) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.validator) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.relatedTxhash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 1)
    }
    if self.epochNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.epochNumber, fieldNumber: 2)
    }
    if !self.validator.isEmpty {
      try visitor.visitSingularStringField(value: self.validator, fieldNumber: 3)
    }
    if !self.relatedTxhash.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relatedTxhash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quicksilver_Interchainstaking_V1_UnbondingRecord, rhs: Quicksilver_Interchainstaking_V1_UnbondingRecord) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.epochNumber != rhs.epochNumber {return false}
    if lhs.validator != rhs.validator {return false}
    if lhs.relatedTxhash != rhs.relatedTxhash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quicksilver_Interchainstaking_V1_RedelegationRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RedelegationRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    2: .standard(proto: "epoch_number"),
    3: .same(proto: "source"),
    4: .same(proto: "destination"),
    5: .same(proto: "amount"),
    6: .standard(proto: "completion_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.epochNumber) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._completionTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 1)
    }
    if self.epochNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.epochNumber, fieldNumber: 2)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 3)
    }
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 4)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 5)
    }
    try { if let v = self._completionTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quicksilver_Interchainstaking_V1_RedelegationRecord, rhs: Quicksilver_Interchainstaking_V1_RedelegationRecord) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.epochNumber != rhs.epochNumber {return false}
    if lhs.source != rhs.source {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._completionTime != rhs._completionTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quicksilver_Interchainstaking_V1_TransferRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransferRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "recipient"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.recipient) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quicksilver_Interchainstaking_V1_TransferRecord, rhs: Quicksilver_Interchainstaking_V1_TransferRecord) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quicksilver_Interchainstaking_V1_Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Validator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "valoper_address"),
    2: .standard(proto: "commission_rate"),
    3: .standard(proto: "delegator_shares"),
    4: .standard(proto: "voting_power"),
    5: .same(proto: "score"),
    6: .same(proto: "status"),
    7: .same(proto: "jailed"),
    8: .same(proto: "tombstoned"),
    9: .standard(proto: "jailed_since"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.valoperAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.commissionRate) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.delegatorShares) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.votingPower) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.score) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.jailed) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.tombstoned) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._jailedSince) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.valoperAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.valoperAddress, fieldNumber: 1)
    }
    if !self.commissionRate.isEmpty {
      try visitor.visitSingularStringField(value: self.commissionRate, fieldNumber: 2)
    }
    if !self.delegatorShares.isEmpty {
      try visitor.visitSingularStringField(value: self.delegatorShares, fieldNumber: 3)
    }
    if !self.votingPower.isEmpty {
      try visitor.visitSingularStringField(value: self.votingPower, fieldNumber: 4)
    }
    if !self.score.isEmpty {
      try visitor.visitSingularStringField(value: self.score, fieldNumber: 5)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 6)
    }
    if self.jailed != false {
      try visitor.visitSingularBoolField(value: self.jailed, fieldNumber: 7)
    }
    if self.tombstoned != false {
      try visitor.visitSingularBoolField(value: self.tombstoned, fieldNumber: 8)
    }
    try { if let v = self._jailedSince {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quicksilver_Interchainstaking_V1_Validator, rhs: Quicksilver_Interchainstaking_V1_Validator) -> Bool {
    if lhs.valoperAddress != rhs.valoperAddress {return false}
    if lhs.commissionRate != rhs.commissionRate {return false}
    if lhs.delegatorShares != rhs.delegatorShares {return false}
    if lhs.votingPower != rhs.votingPower {return false}
    if lhs.score != rhs.score {return false}
    if lhs.status != rhs.status {return false}
    if lhs.jailed != rhs.jailed {return false}
    if lhs.tombstoned != rhs.tombstoned {return false}
    if lhs._jailedSince != rhs._jailedSince {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quicksilver_Interchainstaking_V1_DelegatorIntent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelegatorIntent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delegator"),
    2: .same(proto: "intents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.delegator) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.intents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.delegator.isEmpty {
      try visitor.visitSingularStringField(value: self.delegator, fieldNumber: 1)
    }
    if !self.intents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.intents, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quicksilver_Interchainstaking_V1_DelegatorIntent, rhs: Quicksilver_Interchainstaking_V1_DelegatorIntent) -> Bool {
    if lhs.delegator != rhs.delegator {return false}
    if lhs.intents != rhs.intents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quicksilver_Interchainstaking_V1_ValidatorIntent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatorIntent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "valoper_address"),
    2: .same(proto: "weight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.valoperAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.weight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.valoperAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.valoperAddress, fieldNumber: 1)
    }
    if !self.weight.isEmpty {
      try visitor.visitSingularStringField(value: self.weight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quicksilver_Interchainstaking_V1_ValidatorIntent, rhs: Quicksilver_Interchainstaking_V1_ValidatorIntent) -> Bool {
    if lhs.valoperAddress != rhs.valoperAddress {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quicksilver_Interchainstaking_V1_Delegation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Delegation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegation_address"),
    2: .standard(proto: "validator_address"),
    3: .same(proto: "amount"),
    4: .same(proto: "height"),
    5: .standard(proto: "redelegation_end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.delegationAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.redelegationEnd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.delegationAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.delegationAddress, fieldNumber: 1)
    }
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 4)
    }
    if self.redelegationEnd != 0 {
      try visitor.visitSingularInt64Field(value: self.redelegationEnd, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quicksilver_Interchainstaking_V1_Delegation, rhs: Quicksilver_Interchainstaking_V1_Delegation) -> Bool {
    if lhs.delegationAddress != rhs.delegationAddress {return false}
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.height != rhs.height {return false}
    if lhs.redelegationEnd != rhs.redelegationEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quicksilver_Interchainstaking_V1_PortConnectionTuple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PortConnectionTuple"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connection_id"),
    2: .standard(proto: "port_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.portID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 1)
    }
    if !self.portID.isEmpty {
      try visitor.visitSingularStringField(value: self.portID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quicksilver_Interchainstaking_V1_PortConnectionTuple, rhs: Quicksilver_Interchainstaking_V1_PortConnectionTuple) -> Bool {
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.portID != rhs.portID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Quicksilver_Interchainstaking_V1_Receipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Receipt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    2: .same(proto: "sender"),
    3: .same(proto: "txhash"),
    4: .same(proto: "amount"),
    5: .standard(proto: "first_seen"),
    6: .same(proto: "completed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.txhash) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._firstSeen) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._completed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 1)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 2)
    }
    if !self.txhash.isEmpty {
      try visitor.visitSingularStringField(value: self.txhash, fieldNumber: 3)
    }
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 4)
    }
    try { if let v = self._firstSeen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._completed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Quicksilver_Interchainstaking_V1_Receipt, rhs: Quicksilver_Interchainstaking_V1_Receipt) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.txhash != rhs.txhash {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._firstSeen != rhs._firstSeen {return false}
    if lhs._completed != rhs._completed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
