// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: injective/oracle/v1beta1/oracle.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Injective_Oracle_V1beta1_OracleType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case band // = 1
  case priceFeed // = 2
  case coinbase // = 3
  case chainlink // = 4
  case razor // = 5
  case dia // = 6
  case api3 // = 7
  case uma // = 8
  case pyth // = 9
  case bandIbc // = 10
  case provider // = 11
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .band
    case 2: self = .priceFeed
    case 3: self = .coinbase
    case 4: self = .chainlink
    case 5: self = .razor
    case 6: self = .dia
    case 7: self = .api3
    case 8: self = .uma
    case 9: self = .pyth
    case 10: self = .bandIbc
    case 11: self = .provider
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .band: return 1
    case .priceFeed: return 2
    case .coinbase: return 3
    case .chainlink: return 4
    case .razor: return 5
    case .dia: return 6
    case .api3: return 7
    case .uma: return 8
    case .pyth: return 9
    case .bandIbc: return 10
    case .provider: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Oracle_V1beta1_OracleType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Oracle_V1beta1_OracleType] = [
    .unspecified,
    .band,
    .priceFeed,
    .coinbase,
    .chainlink,
    .razor,
    .dia,
    .api3,
    .uma,
    .pyth,
    .bandIbc,
    .provider,
  ]
}

#endif  // swift(>=4.2)

struct Injective_Oracle_V1beta1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pythContract: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_OracleInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var symbol: String = String()

  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  var scaleFactor: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_ChainlinkPriceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var feedID: String = String()

  var answer: String = String()

  var timestamp: UInt64 = 0

  var priceState: Injective_Oracle_V1beta1_PriceState {
    get {return _priceState ?? Injective_Oracle_V1beta1_PriceState()}
    set {_priceState = newValue}
  }
  /// Returns true if `priceState` has been explicitly set.
  var hasPriceState: Bool {return self._priceState != nil}
  /// Clears the value of `priceState`. Subsequent reads from it will return its default value.
  mutating func clearPriceState() {self._priceState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _priceState: Injective_Oracle_V1beta1_PriceState? = nil
}

struct Injective_Oracle_V1beta1_BandPriceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var symbol: String = String()

  var rate: String = String()

  var resolveTime: UInt64 = 0

  var requestID: UInt64 = 0

  var priceState: Injective_Oracle_V1beta1_PriceState {
    get {return _priceState ?? Injective_Oracle_V1beta1_PriceState()}
    set {_priceState = newValue}
  }
  /// Returns true if `priceState` has been explicitly set.
  var hasPriceState: Bool {return self._priceState != nil}
  /// Clears the value of `priceState`. Subsequent reads from it will return its default value.
  mutating func clearPriceState() {self._priceState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _priceState: Injective_Oracle_V1beta1_PriceState? = nil
}

struct Injective_Oracle_V1beta1_PriceFeedState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base: String = String()

  var quote: String = String()

  var priceState: Injective_Oracle_V1beta1_PriceState {
    get {return _priceState ?? Injective_Oracle_V1beta1_PriceState()}
    set {_priceState = newValue}
  }
  /// Returns true if `priceState` has been explicitly set.
  var hasPriceState: Bool {return self._priceState != nil}
  /// Clears the value of `priceState`. Subsequent reads from it will return its default value.
  mutating func clearPriceState() {self._priceState = nil}

  var relayers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _priceState: Injective_Oracle_V1beta1_PriceState? = nil
}

struct Injective_Oracle_V1beta1_ProviderInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var provider: String = String()

  var relayers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_ProviderState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var providerInfo: Injective_Oracle_V1beta1_ProviderInfo {
    get {return _providerInfo ?? Injective_Oracle_V1beta1_ProviderInfo()}
    set {_providerInfo = newValue}
  }
  /// Returns true if `providerInfo` has been explicitly set.
  var hasProviderInfo: Bool {return self._providerInfo != nil}
  /// Clears the value of `providerInfo`. Subsequent reads from it will return its default value.
  mutating func clearProviderInfo() {self._providerInfo = nil}

  var providerPriceStates: [Injective_Oracle_V1beta1_ProviderPriceState] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _providerInfo: Injective_Oracle_V1beta1_ProviderInfo? = nil
}

struct Injective_Oracle_V1beta1_ProviderPriceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var symbol: String = String()

  var state: Injective_Oracle_V1beta1_PriceState {
    get {return _state ?? Injective_Oracle_V1beta1_PriceState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _state: Injective_Oracle_V1beta1_PriceState? = nil
}

struct Injective_Oracle_V1beta1_PriceFeedInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base: String = String()

  var quote: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_PriceFeedPrice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var price: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_CoinbasePriceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// kind should always be "prices"
  var kind: String = String()

  /// timestamp of the when the price was signed by coinbase
  var timestamp: UInt64 = 0

  /// the symbol of the price, e.g. BTC
  var key: String = String()

  /// the value of the price scaled by 1e6
  var value: UInt64 = 0

  /// the price state
  var priceState: Injective_Oracle_V1beta1_PriceState {
    get {return _priceState ?? Injective_Oracle_V1beta1_PriceState()}
    set {_priceState = newValue}
  }
  /// Returns true if `priceState` has been explicitly set.
  var hasPriceState: Bool {return self._priceState != nil}
  /// Clears the value of `priceState`. Subsequent reads from it will return its default value.
  mutating func clearPriceState() {self._priceState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _priceState: Injective_Oracle_V1beta1_PriceState? = nil
}

struct Injective_Oracle_V1beta1_PriceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var price: String = String()

  var cumulativePrice: String = String()

  var timestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_PythPriceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var priceID: String = String()

  var emaPrice: String = String()

  var emaConf: String = String()

  var conf: String = String()

  var publishTime: UInt64 = 0

  var priceState: Injective_Oracle_V1beta1_PriceState {
    get {return _priceState ?? Injective_Oracle_V1beta1_PriceState()}
    set {_priceState = newValue}
  }
  /// Returns true if `priceState` has been explicitly set.
  var hasPriceState: Bool {return self._priceState != nil}
  /// Clears the value of `priceState`. Subsequent reads from it will return its default value.
  mutating func clearPriceState() {self._priceState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _priceState: Injective_Oracle_V1beta1_PriceState? = nil
}

struct Injective_Oracle_V1beta1_BandOracleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique Identifier for band ibc oracle request
  var requestID: UInt64 = 0

  /// OracleScriptID is the unique identifier of the oracle script to be
  /// executed.
  var oracleScriptID: Int64 = 0

  /// Symbols is the list of symbols to prepare in the calldata
  var symbols: [String] = []

  /// AskCount is the number of validators that are requested to respond to this
  /// oracle request. Higher value means more security, at a higher gas cost.
  var askCount: UInt64 = 0

  /// MinCount is the minimum number of validators necessary for the request to
  /// proceed to the execution phase. Higher value means more security, at the
  /// cost of liveness.
  var minCount: UInt64 = 0

  /// FeeLimit is the maximum tokens that will be paid to all data source
  /// providers.
  var feeLimit: [Cosmos_Base_V1beta1_Coin] = []

  /// PrepareGas is amount of gas to pay to prepare raw requests
  var prepareGas: UInt64 = 0

  /// ExecuteGas is amount of gas to reserve for executing
  var executeGas: UInt64 = 0

  /// MinSourceCount is the minimum number of data sources that must be used by
  /// each validator
  var minSourceCount: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_BandIBCParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// true if Band IBC should be enabled
  var bandIbcEnabled: Bool = false

  /// block request interval to send Band IBC prices
  var ibcRequestInterval: Int64 = 0

  /// band IBC source channel
  var ibcSourceChannel: String = String()

  /// band IBC version
  var ibcVersion: String = String()

  /// band IBC portID
  var ibcPortID: String = String()

  ///  legacy oracle scheme ids
  var legacyOracleIds: [Int64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_SymbolPriceTimestamp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oracle: Injective_Oracle_V1beta1_OracleType = .unspecified

  var symbolID: String = String()

  var timestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_LastPriceTimestamps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastPriceTimestamps: [Injective_Oracle_V1beta1_SymbolPriceTimestamp] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_PriceRecords {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oracle: Injective_Oracle_V1beta1_OracleType = .unspecified

  var symbolID: String = String()

  var latestPriceRecords: [Injective_Oracle_V1beta1_PriceRecord] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_PriceRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: Int64 = 0

  var price: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MetadataStatistics refers to the metadata summary statistics of the
/// historical sample considered
struct Injective_Oracle_V1beta1_MetadataStatistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// GroupCount refers to the number of groups used. Equals RecordsSampleSize if
  /// no grouping is used
  var groupCount: UInt32 = 0

  /// RecordsSampleSize refers to the total number of records used.
  var recordsSampleSize: UInt32 = 0

  /// Mean refers to the arithmetic mean
  /// For trades, the mean is the VWAP computed over the grouped trade records ∑
  /// (price * quantity) / ∑ quantity For oracle prices, the mean is computed
  /// over the price records ∑ (price) / prices_count
  var mean: String = String()

  /// TWAP refers to the time-weighted average price which equals ∑ (price_i *
  /// ∆t_i) / ∑ ∆t_i where ∆t_i = t_i - t_{i-1}
  var twap: String = String()

  /// FirstTimestamp is the timestamp of the oldest record considered
  var firstTimestamp: Int64 = 0

  /// LastTimestamp is the timestamp of the youngest record considered
  var lastTimestamp: Int64 = 0

  /// MinPrice refers to the smallest individual raw price considered
  var minPrice: String = String()

  /// MaxPrice refers to the largest individual raw price considered
  var maxPrice: String = String()

  /// MedianPrice refers to the median individual raw price considered
  var medianPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_PriceAttestation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var priceID: String = String()

  /// MaxPrice refers to the largest individual raw price considered
  var price: Int64 = 0

  var conf: UInt64 = 0

  var expo: Int32 = 0

  var emaPrice: Int64 = 0

  var emaConf: UInt64 = 0

  var emaExpo: Int32 = 0

  var publishTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Injective_Oracle_V1beta1_OracleType: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_Params: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_OracleInfo: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_ChainlinkPriceState: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_BandPriceState: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_PriceFeedState: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_ProviderInfo: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_ProviderState: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_ProviderPriceState: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_PriceFeedInfo: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_PriceFeedPrice: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_CoinbasePriceState: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_PriceState: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_PythPriceState: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_BandOracleRequest: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_BandIBCParams: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_SymbolPriceTimestamp: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_LastPriceTimestamps: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_PriceRecords: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_PriceRecord: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_MetadataStatistics: @unchecked Sendable {}
extension Injective_Oracle_V1beta1_PriceAttestation: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "injective.oracle.v1beta1"

extension Injective_Oracle_V1beta1_OracleType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unspecified"),
    1: .same(proto: "Band"),
    2: .same(proto: "PriceFeed"),
    3: .same(proto: "Coinbase"),
    4: .same(proto: "Chainlink"),
    5: .same(proto: "Razor"),
    6: .same(proto: "Dia"),
    7: .same(proto: "API3"),
    8: .same(proto: "Uma"),
    9: .same(proto: "Pyth"),
    10: .same(proto: "BandIBC"),
    11: .same(proto: "Provider"),
  ]
}

extension Injective_Oracle_V1beta1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pyth_contract"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pythContract) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pythContract.isEmpty {
      try visitor.visitSingularStringField(value: self.pythContract, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_Params, rhs: Injective_Oracle_V1beta1_Params) -> Bool {
    if lhs.pythContract != rhs.pythContract {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_OracleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OracleInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbol"),
    2: .standard(proto: "oracle_type"),
    3: .standard(proto: "scale_factor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.scaleFactor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 1)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 2)
    }
    if self.scaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.scaleFactor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_OracleInfo, rhs: Injective_Oracle_V1beta1_OracleInfo) -> Bool {
    if lhs.symbol != rhs.symbol {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.scaleFactor != rhs.scaleFactor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_ChainlinkPriceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainlinkPriceState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "feed_id"),
    2: .same(proto: "answer"),
    3: .same(proto: "timestamp"),
    4: .standard(proto: "price_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.feedID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.answer) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._priceState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.feedID.isEmpty {
      try visitor.visitSingularStringField(value: self.feedID, fieldNumber: 1)
    }
    if !self.answer.isEmpty {
      try visitor.visitSingularStringField(value: self.answer, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try { if let v = self._priceState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_ChainlinkPriceState, rhs: Injective_Oracle_V1beta1_ChainlinkPriceState) -> Bool {
    if lhs.feedID != rhs.feedID {return false}
    if lhs.answer != rhs.answer {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._priceState != rhs._priceState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_BandPriceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BandPriceState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbol"),
    2: .same(proto: "rate"),
    3: .standard(proto: "resolve_time"),
    4: .standard(proto: "request_ID"),
    5: .standard(proto: "price_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rate) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.resolveTime) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.requestID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._priceState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 1)
    }
    if !self.rate.isEmpty {
      try visitor.visitSingularStringField(value: self.rate, fieldNumber: 2)
    }
    if self.resolveTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.resolveTime, fieldNumber: 3)
    }
    if self.requestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestID, fieldNumber: 4)
    }
    try { if let v = self._priceState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_BandPriceState, rhs: Injective_Oracle_V1beta1_BandPriceState) -> Bool {
    if lhs.symbol != rhs.symbol {return false}
    if lhs.rate != rhs.rate {return false}
    if lhs.resolveTime != rhs.resolveTime {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs._priceState != rhs._priceState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_PriceFeedState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceFeedState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .same(proto: "quote"),
    3: .standard(proto: "price_state"),
    4: .same(proto: "relayers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.base) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quote) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._priceState) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.relayers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.base.isEmpty {
      try visitor.visitSingularStringField(value: self.base, fieldNumber: 1)
    }
    if !self.quote.isEmpty {
      try visitor.visitSingularStringField(value: self.quote, fieldNumber: 2)
    }
    try { if let v = self._priceState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.relayers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relayers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_PriceFeedState, rhs: Injective_Oracle_V1beta1_PriceFeedState) -> Bool {
    if lhs.base != rhs.base {return false}
    if lhs.quote != rhs.quote {return false}
    if lhs._priceState != rhs._priceState {return false}
    if lhs.relayers != rhs.relayers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_ProviderInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProviderInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
    2: .same(proto: "relayers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.relayers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 1)
    }
    if !self.relayers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relayers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_ProviderInfo, rhs: Injective_Oracle_V1beta1_ProviderInfo) -> Bool {
    if lhs.provider != rhs.provider {return false}
    if lhs.relayers != rhs.relayers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_ProviderState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProviderState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "provider_info"),
    2: .standard(proto: "provider_price_states"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._providerInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.providerPriceStates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._providerInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.providerPriceStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.providerPriceStates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_ProviderState, rhs: Injective_Oracle_V1beta1_ProviderState) -> Bool {
    if lhs._providerInfo != rhs._providerInfo {return false}
    if lhs.providerPriceStates != rhs.providerPriceStates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_ProviderPriceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProviderPriceState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbol"),
    2: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_ProviderPriceState, rhs: Injective_Oracle_V1beta1_ProviderPriceState) -> Bool {
    if lhs.symbol != rhs.symbol {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_PriceFeedInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceFeedInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .same(proto: "quote"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.base) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quote) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.base.isEmpty {
      try visitor.visitSingularStringField(value: self.base, fieldNumber: 1)
    }
    if !self.quote.isEmpty {
      try visitor.visitSingularStringField(value: self.quote, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_PriceFeedInfo, rhs: Injective_Oracle_V1beta1_PriceFeedInfo) -> Bool {
    if lhs.base != rhs.base {return false}
    if lhs.quote != rhs.quote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_PriceFeedPrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceFeedPrice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.price) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_PriceFeedPrice, rhs: Injective_Oracle_V1beta1_PriceFeedPrice) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_CoinbasePriceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CoinbasePriceState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "key"),
    4: .same(proto: "value"),
    5: .standard(proto: "price_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._priceState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 4)
    }
    try { if let v = self._priceState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_CoinbasePriceState, rhs: Injective_Oracle_V1beta1_CoinbasePriceState) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs._priceState != rhs._priceState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_PriceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .standard(proto: "cumulative_price"),
    3: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cumulativePrice) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 1)
    }
    if !self.cumulativePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.cumulativePrice, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_PriceState, rhs: Injective_Oracle_V1beta1_PriceState) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.cumulativePrice != rhs.cumulativePrice {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_PythPriceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PythPriceState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "price_id"),
    2: .standard(proto: "ema_price"),
    3: .standard(proto: "ema_conf"),
    4: .same(proto: "conf"),
    5: .standard(proto: "publish_time"),
    6: .standard(proto: "price_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.priceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.emaPrice) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.emaConf) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.conf) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.publishTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._priceState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.priceID.isEmpty {
      try visitor.visitSingularStringField(value: self.priceID, fieldNumber: 1)
    }
    if !self.emaPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.emaPrice, fieldNumber: 2)
    }
    if !self.emaConf.isEmpty {
      try visitor.visitSingularStringField(value: self.emaConf, fieldNumber: 3)
    }
    if !self.conf.isEmpty {
      try visitor.visitSingularStringField(value: self.conf, fieldNumber: 4)
    }
    if self.publishTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.publishTime, fieldNumber: 5)
    }
    try { if let v = self._priceState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_PythPriceState, rhs: Injective_Oracle_V1beta1_PythPriceState) -> Bool {
    if lhs.priceID != rhs.priceID {return false}
    if lhs.emaPrice != rhs.emaPrice {return false}
    if lhs.emaConf != rhs.emaConf {return false}
    if lhs.conf != rhs.conf {return false}
    if lhs.publishTime != rhs.publishTime {return false}
    if lhs._priceState != rhs._priceState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_BandOracleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BandOracleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "oracle_script_id"),
    3: .same(proto: "symbols"),
    4: .standard(proto: "ask_count"),
    5: .standard(proto: "min_count"),
    6: .standard(proto: "fee_limit"),
    7: .standard(proto: "prepare_gas"),
    8: .standard(proto: "execute_gas"),
    9: .standard(proto: "min_source_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.oracleScriptID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.symbols) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.askCount) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.minCount) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.feeLimit) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.prepareGas) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.executeGas) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.minSourceCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestID, fieldNumber: 1)
    }
    if self.oracleScriptID != 0 {
      try visitor.visitSingularInt64Field(value: self.oracleScriptID, fieldNumber: 2)
    }
    if !self.symbols.isEmpty {
      try visitor.visitRepeatedStringField(value: self.symbols, fieldNumber: 3)
    }
    if self.askCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.askCount, fieldNumber: 4)
    }
    if self.minCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.minCount, fieldNumber: 5)
    }
    if !self.feeLimit.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.feeLimit, fieldNumber: 6)
    }
    if self.prepareGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.prepareGas, fieldNumber: 7)
    }
    if self.executeGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.executeGas, fieldNumber: 8)
    }
    if self.minSourceCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.minSourceCount, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_BandOracleRequest, rhs: Injective_Oracle_V1beta1_BandOracleRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.oracleScriptID != rhs.oracleScriptID {return false}
    if lhs.symbols != rhs.symbols {return false}
    if lhs.askCount != rhs.askCount {return false}
    if lhs.minCount != rhs.minCount {return false}
    if lhs.feeLimit != rhs.feeLimit {return false}
    if lhs.prepareGas != rhs.prepareGas {return false}
    if lhs.executeGas != rhs.executeGas {return false}
    if lhs.minSourceCount != rhs.minSourceCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_BandIBCParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BandIBCParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "band_ibc_enabled"),
    2: .standard(proto: "ibc_request_interval"),
    3: .standard(proto: "ibc_source_channel"),
    4: .standard(proto: "ibc_version"),
    5: .standard(proto: "ibc_port_id"),
    6: .standard(proto: "legacy_oracle_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.bandIbcEnabled) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.ibcRequestInterval) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ibcSourceChannel) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ibcVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ibcPortID) }()
      case 6: try { try decoder.decodeRepeatedInt64Field(value: &self.legacyOracleIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bandIbcEnabled != false {
      try visitor.visitSingularBoolField(value: self.bandIbcEnabled, fieldNumber: 1)
    }
    if self.ibcRequestInterval != 0 {
      try visitor.visitSingularInt64Field(value: self.ibcRequestInterval, fieldNumber: 2)
    }
    if !self.ibcSourceChannel.isEmpty {
      try visitor.visitSingularStringField(value: self.ibcSourceChannel, fieldNumber: 3)
    }
    if !self.ibcVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.ibcVersion, fieldNumber: 4)
    }
    if !self.ibcPortID.isEmpty {
      try visitor.visitSingularStringField(value: self.ibcPortID, fieldNumber: 5)
    }
    if !self.legacyOracleIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.legacyOracleIds, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_BandIBCParams, rhs: Injective_Oracle_V1beta1_BandIBCParams) -> Bool {
    if lhs.bandIbcEnabled != rhs.bandIbcEnabled {return false}
    if lhs.ibcRequestInterval != rhs.ibcRequestInterval {return false}
    if lhs.ibcSourceChannel != rhs.ibcSourceChannel {return false}
    if lhs.ibcVersion != rhs.ibcVersion {return false}
    if lhs.ibcPortID != rhs.ibcPortID {return false}
    if lhs.legacyOracleIds != rhs.legacyOracleIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_SymbolPriceTimestamp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SymbolPriceTimestamp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oracle"),
    2: .standard(proto: "symbol_id"),
    3: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.oracle) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbolID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.oracle != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracle, fieldNumber: 1)
    }
    if !self.symbolID.isEmpty {
      try visitor.visitSingularStringField(value: self.symbolID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_SymbolPriceTimestamp, rhs: Injective_Oracle_V1beta1_SymbolPriceTimestamp) -> Bool {
    if lhs.oracle != rhs.oracle {return false}
    if lhs.symbolID != rhs.symbolID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_LastPriceTimestamps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LastPriceTimestamps"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_price_timestamps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lastPriceTimestamps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastPriceTimestamps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lastPriceTimestamps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_LastPriceTimestamps, rhs: Injective_Oracle_V1beta1_LastPriceTimestamps) -> Bool {
    if lhs.lastPriceTimestamps != rhs.lastPriceTimestamps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_PriceRecords: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceRecords"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oracle"),
    2: .standard(proto: "symbol_id"),
    3: .standard(proto: "latest_price_records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.oracle) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbolID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.latestPriceRecords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.oracle != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracle, fieldNumber: 1)
    }
    if !self.symbolID.isEmpty {
      try visitor.visitSingularStringField(value: self.symbolID, fieldNumber: 2)
    }
    if !self.latestPriceRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.latestPriceRecords, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_PriceRecords, rhs: Injective_Oracle_V1beta1_PriceRecords) -> Bool {
    if lhs.oracle != rhs.oracle {return false}
    if lhs.symbolID != rhs.symbolID {return false}
    if lhs.latestPriceRecords != rhs.latestPriceRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_PriceRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.price) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_PriceRecord, rhs: Injective_Oracle_V1beta1_PriceRecord) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.price != rhs.price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_MetadataStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetadataStatistics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_count"),
    2: .standard(proto: "records_sample_size"),
    3: .same(proto: "mean"),
    4: .same(proto: "twap"),
    5: .standard(proto: "first_timestamp"),
    6: .standard(proto: "last_timestamp"),
    7: .standard(proto: "min_price"),
    8: .standard(proto: "max_price"),
    9: .standard(proto: "median_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.groupCount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.recordsSampleSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mean) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.twap) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.firstTimestamp) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.lastTimestamp) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.minPrice) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.maxPrice) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.medianPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.groupCount, fieldNumber: 1)
    }
    if self.recordsSampleSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.recordsSampleSize, fieldNumber: 2)
    }
    if !self.mean.isEmpty {
      try visitor.visitSingularStringField(value: self.mean, fieldNumber: 3)
    }
    if !self.twap.isEmpty {
      try visitor.visitSingularStringField(value: self.twap, fieldNumber: 4)
    }
    if self.firstTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.firstTimestamp, fieldNumber: 5)
    }
    if self.lastTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.lastTimestamp, fieldNumber: 6)
    }
    if !self.minPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.minPrice, fieldNumber: 7)
    }
    if !self.maxPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.maxPrice, fieldNumber: 8)
    }
    if !self.medianPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.medianPrice, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_MetadataStatistics, rhs: Injective_Oracle_V1beta1_MetadataStatistics) -> Bool {
    if lhs.groupCount != rhs.groupCount {return false}
    if lhs.recordsSampleSize != rhs.recordsSampleSize {return false}
    if lhs.mean != rhs.mean {return false}
    if lhs.twap != rhs.twap {return false}
    if lhs.firstTimestamp != rhs.firstTimestamp {return false}
    if lhs.lastTimestamp != rhs.lastTimestamp {return false}
    if lhs.minPrice != rhs.minPrice {return false}
    if lhs.maxPrice != rhs.maxPrice {return false}
    if lhs.medianPrice != rhs.medianPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_PriceAttestation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceAttestation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "price_id"),
    2: .same(proto: "price"),
    3: .same(proto: "conf"),
    4: .same(proto: "expo"),
    5: .standard(proto: "ema_price"),
    6: .standard(proto: "ema_conf"),
    7: .standard(proto: "ema_expo"),
    8: .standard(proto: "publish_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.priceID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.price) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.conf) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.expo) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.emaPrice) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.emaConf) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.emaExpo) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.publishTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.priceID.isEmpty {
      try visitor.visitSingularStringField(value: self.priceID, fieldNumber: 1)
    }
    if self.price != 0 {
      try visitor.visitSingularInt64Field(value: self.price, fieldNumber: 2)
    }
    if self.conf != 0 {
      try visitor.visitSingularUInt64Field(value: self.conf, fieldNumber: 3)
    }
    if self.expo != 0 {
      try visitor.visitSingularInt32Field(value: self.expo, fieldNumber: 4)
    }
    if self.emaPrice != 0 {
      try visitor.visitSingularInt64Field(value: self.emaPrice, fieldNumber: 5)
    }
    if self.emaConf != 0 {
      try visitor.visitSingularUInt64Field(value: self.emaConf, fieldNumber: 6)
    }
    if self.emaExpo != 0 {
      try visitor.visitSingularInt32Field(value: self.emaExpo, fieldNumber: 7)
    }
    if self.publishTime != 0 {
      try visitor.visitSingularInt64Field(value: self.publishTime, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_PriceAttestation, rhs: Injective_Oracle_V1beta1_PriceAttestation) -> Bool {
    if lhs.priceID != rhs.priceID {return false}
    if lhs.price != rhs.price {return false}
    if lhs.conf != rhs.conf {return false}
    if lhs.expo != rhs.expo {return false}
    if lhs.emaPrice != rhs.emaPrice {return false}
    if lhs.emaConf != rhs.emaConf {return false}
    if lhs.emaExpo != rhs.emaExpo {return false}
    if lhs.publishTime != rhs.publishTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
