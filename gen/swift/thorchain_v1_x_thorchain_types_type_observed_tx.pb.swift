// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: thorchain/v1/x/thorchain/types/type_observed_tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Types_Status: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case incomplete // = 0
  case done // = 1
  case reverted // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .incomplete
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .incomplete
    case 1: self = .done
    case 2: self = .reverted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .incomplete: return 0
    case .done: return 1
    case .reverted: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Types_Status] = [
    .incomplete,
    .done,
    .reverted,
  ]
}

#endif  // swift(>=4.2)

struct Types_ObservedTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tx: Common_Tx {
    get {return _storage._tx ?? Common_Tx()}
    set {_uniqueStorage()._tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  var hasTx: Bool {return _storage._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  mutating func clearTx() {_uniqueStorage()._tx = nil}

  var status: Types_Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var outHashes: [String] {
    get {return _storage._outHashes}
    set {_uniqueStorage()._outHashes = newValue}
  }

  var blockHeight: Int64 {
    get {return _storage._blockHeight}
    set {_uniqueStorage()._blockHeight = newValue}
  }

  var signers: [String] {
    get {return _storage._signers}
    set {_uniqueStorage()._signers = newValue}
  }

  var observedPubKey: String {
    get {return _storage._observedPubKey}
    set {_uniqueStorage()._observedPubKey = newValue}
  }

  var keysignMs: Int64 {
    get {return _storage._keysignMs}
    set {_uniqueStorage()._keysignMs = newValue}
  }

  var finaliseHeight: Int64 {
    get {return _storage._finaliseHeight}
    set {_uniqueStorage()._finaliseHeight = newValue}
  }

  var aggregator: String {
    get {return _storage._aggregator}
    set {_uniqueStorage()._aggregator = newValue}
  }

  var aggregatorTarget: String {
    get {return _storage._aggregatorTarget}
    set {_uniqueStorage()._aggregatorTarget = newValue}
  }

  var aggregatorTargetLimit: String {
    get {return _storage._aggregatorTargetLimit}
    set {_uniqueStorage()._aggregatorTargetLimit = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_ObservedTxVoter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: String = String()

  var tx: Types_ObservedTx {
    get {return _tx ?? Types_ObservedTx()}
    set {_tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  var hasTx: Bool {return self._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  mutating func clearTx() {self._tx = nil}

  var height: Int64 = 0

  var txs: [Types_ObservedTx] = []

  var actions: [Types_TxOutItem] = []

  var outTxs: [Common_Tx] = []

  var finalisedHeight: Int64 = 0

  var updatedVault: Bool = false

  var reverted: Bool = false

  var outboundHeight: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tx: Types_ObservedTx? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Types_Status: @unchecked Sendable {}
extension Types_ObservedTx: @unchecked Sendable {}
extension Types_ObservedTxVoter: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "types"

extension Types_Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "incomplete"),
    1: .same(proto: "done"),
    2: .same(proto: "reverted"),
  ]
}

extension Types_ObservedTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObservedTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "status"),
    3: .standard(proto: "out_hashes"),
    4: .standard(proto: "block_height"),
    5: .same(proto: "signers"),
    6: .standard(proto: "observed_pub_key"),
    7: .standard(proto: "keysign_ms"),
    8: .standard(proto: "finalise_height"),
    9: .same(proto: "aggregator"),
    10: .standard(proto: "aggregator_target"),
    11: .standard(proto: "aggregator_target_limit"),
  ]

  fileprivate class _StorageClass {
    var _tx: Common_Tx? = nil
    var _status: Types_Status = .incomplete
    var _outHashes: [String] = []
    var _blockHeight: Int64 = 0
    var _signers: [String] = []
    var _observedPubKey: String = String()
    var _keysignMs: Int64 = 0
    var _finaliseHeight: Int64 = 0
    var _aggregator: String = String()
    var _aggregatorTarget: String = String()
    var _aggregatorTargetLimit: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tx = source._tx
      _status = source._status
      _outHashes = source._outHashes
      _blockHeight = source._blockHeight
      _signers = source._signers
      _observedPubKey = source._observedPubKey
      _keysignMs = source._keysignMs
      _finaliseHeight = source._finaliseHeight
      _aggregator = source._aggregator
      _aggregatorTarget = source._aggregatorTarget
      _aggregatorTargetLimit = source._aggregatorTargetLimit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._tx) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._outHashes) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._blockHeight) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._signers) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._observedPubKey) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._keysignMs) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._finaliseHeight) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._aggregator) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._aggregatorTarget) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._aggregatorTargetLimit) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._tx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._status != .incomplete {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 2)
      }
      if !_storage._outHashes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._outHashes, fieldNumber: 3)
      }
      if _storage._blockHeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._blockHeight, fieldNumber: 4)
      }
      if !_storage._signers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._signers, fieldNumber: 5)
      }
      if !_storage._observedPubKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._observedPubKey, fieldNumber: 6)
      }
      if _storage._keysignMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._keysignMs, fieldNumber: 7)
      }
      if _storage._finaliseHeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._finaliseHeight, fieldNumber: 8)
      }
      if !_storage._aggregator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._aggregator, fieldNumber: 9)
      }
      if !_storage._aggregatorTarget.isEmpty {
        try visitor.visitSingularStringField(value: _storage._aggregatorTarget, fieldNumber: 10)
      }
      if !_storage._aggregatorTargetLimit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._aggregatorTargetLimit, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ObservedTx, rhs: Types_ObservedTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tx != rhs_storage._tx {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._outHashes != rhs_storage._outHashes {return false}
        if _storage._blockHeight != rhs_storage._blockHeight {return false}
        if _storage._signers != rhs_storage._signers {return false}
        if _storage._observedPubKey != rhs_storage._observedPubKey {return false}
        if _storage._keysignMs != rhs_storage._keysignMs {return false}
        if _storage._finaliseHeight != rhs_storage._finaliseHeight {return false}
        if _storage._aggregator != rhs_storage._aggregator {return false}
        if _storage._aggregatorTarget != rhs_storage._aggregatorTarget {return false}
        if _storage._aggregatorTargetLimit != rhs_storage._aggregatorTargetLimit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ObservedTxVoter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObservedTxVoter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .same(proto: "tx"),
    3: .same(proto: "height"),
    4: .same(proto: "txs"),
    5: .same(proto: "actions"),
    6: .standard(proto: "out_txs"),
    7: .standard(proto: "finalised_height"),
    8: .standard(proto: "updated_vault"),
    9: .same(proto: "reverted"),
    10: .standard(proto: "outbound_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tx) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.txs) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.outTxs) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.finalisedHeight) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.updatedVault) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.reverted) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.outboundHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.txID.isEmpty {
      try visitor.visitSingularStringField(value: self.txID, fieldNumber: 1)
    }
    try { if let v = self._tx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 3)
    }
    if !self.txs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txs, fieldNumber: 4)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 5)
    }
    if !self.outTxs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outTxs, fieldNumber: 6)
    }
    if self.finalisedHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.finalisedHeight, fieldNumber: 7)
    }
    if self.updatedVault != false {
      try visitor.visitSingularBoolField(value: self.updatedVault, fieldNumber: 8)
    }
    if self.reverted != false {
      try visitor.visitSingularBoolField(value: self.reverted, fieldNumber: 9)
    }
    if self.outboundHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.outboundHeight, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ObservedTxVoter, rhs: Types_ObservedTxVoter) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs._tx != rhs._tx {return false}
    if lhs.height != rhs.height {return false}
    if lhs.txs != rhs.txs {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.outTxs != rhs.outTxs {return false}
    if lhs.finalisedHeight != rhs.finalisedHeight {return false}
    if lhs.updatedVault != rhs.updatedVault {return false}
    if lhs.reverted != rhs.reverted {return false}
    if lhs.outboundHeight != rhs.outboundHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
