// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: coreum/feemodel/v1/params.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ModelParams define fee model params.
/// There are four regions on the fee model curve
/// - between 0 and "long average block gas" where gas price goes down exponentially from InitialGasPrice to gas price with maximum discount (InitialGasPrice * (1 - MaxDiscount))
/// - between "long average block gas" and EscalationStartBlockGas (EscalationStartBlockGas = MaxBlockGas * EscalationStartFraction) where we offer gas price with maximum discount all the time
/// - between EscalationStartBlockGas (EscalationStartBlockGas = MaxBlockGas * EscalationStartFraction) and MaxBlockGas where price goes up rapidly (being an output of a power function) from gas price with maximum discount to MaxGasPrice  (MaxGasPrice = InitialGasPrice * MaxGasMultiplier)
/// - above MaxBlockGas (if it happens for any reason) where price is equal to MaxGasPrice (MaxGasPrice = InitialGasPrice * MaxGasMultiplier)
///
/// The input (x value) for that function is calculated by taking short block gas average.
/// Price (y value) being an output of the fee model is used as the minimum gas price for next block.
struct Coreum_Feemodel_V1_ModelParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// initial_gas_price is used when block gas short average is 0. It happens when there are no transactions being broadcasted. This value is also used to initialize gas price on brand-new chain.
  var initialGasPrice: String = String()

  /// max_gas_price_multiplier is used to compute max_gas_price (max_gas_price = initial_gas_price * max_gas_price_multiplier). Max gas price is charged when block gas short average is greater than or equal to MaxBlockGas. This value is used to limit gas price escalation to avoid having possible infinity GasPrice value otherwise.
  var maxGasPriceMultiplier: String = String()

  /// max_discount is th maximum discount we offer on top of initial gas price if short average block gas is between long average block gas and escalation start block gas.
  var maxDiscount: String = String()

  /// escalation_start_fraction defines fraction of max block gas usage where gas price escalation starts if short average block gas is higher than this value.
  var escalationStartFraction: String = String()

  /// max_block_gas sets the maximum capacity of block. This is enforced on tendermint level in genesis configuration. Once short average block gas goes above this value, gas price is a flat line equal to MaxGasPrice.
  var maxBlockGas: Int64 = 0

  /// short_ema_block_length defines inertia for short average long gas in EMA model. The equation is: NewAverage = ((ShortAverageBlockLength - 1)*PreviousAverage + GasUsedByCurrentBlock) / ShortAverageBlockLength
  /// The value might be interpreted as the number of blocks which are taken to calculate the average. It would be exactly like that in SMA model, in EMA this is an approximation.
  var shortEmaBlockLength: UInt32 = 0

  /// long_ema_block_length defines inertia for long average block gas in EMA model. The equation is: NewAverage = ((LongAverageBlockLength - 1)*PreviousAverage + GasUsedByCurrentBlock) / LongAverageBlockLength
  /// The value might be interpreted as the number of blocks which are taken to calculate the average. It would be exactly like that in SMA model, in EMA this is an approximation.
  var longEmaBlockLength: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Params store gov manageable feemodel parameters.
struct Coreum_Feemodel_V1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// model is a fee model params.
  var model: Coreum_Feemodel_V1_ModelParams {
    get {return _model ?? Coreum_Feemodel_V1_ModelParams()}
    set {_model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  var hasModel: Bool {return self._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  mutating func clearModel() {self._model = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _model: Coreum_Feemodel_V1_ModelParams? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Coreum_Feemodel_V1_ModelParams: @unchecked Sendable {}
extension Coreum_Feemodel_V1_Params: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coreum.feemodel.v1"

extension Coreum_Feemodel_V1_ModelParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModelParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "initial_gas_price"),
    2: .standard(proto: "max_gas_price_multiplier"),
    3: .standard(proto: "max_discount"),
    4: .standard(proto: "escalation_start_fraction"),
    5: .standard(proto: "max_block_gas"),
    6: .standard(proto: "short_ema_block_length"),
    7: .standard(proto: "long_ema_block_length"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.initialGasPrice) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.maxGasPriceMultiplier) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.maxDiscount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.escalationStartFraction) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.maxBlockGas) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.shortEmaBlockLength) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.longEmaBlockLength) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.initialGasPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.initialGasPrice, fieldNumber: 1)
    }
    if !self.maxGasPriceMultiplier.isEmpty {
      try visitor.visitSingularStringField(value: self.maxGasPriceMultiplier, fieldNumber: 2)
    }
    if !self.maxDiscount.isEmpty {
      try visitor.visitSingularStringField(value: self.maxDiscount, fieldNumber: 3)
    }
    if !self.escalationStartFraction.isEmpty {
      try visitor.visitSingularStringField(value: self.escalationStartFraction, fieldNumber: 4)
    }
    if self.maxBlockGas != 0 {
      try visitor.visitSingularInt64Field(value: self.maxBlockGas, fieldNumber: 5)
    }
    if self.shortEmaBlockLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.shortEmaBlockLength, fieldNumber: 6)
    }
    if self.longEmaBlockLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.longEmaBlockLength, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Coreum_Feemodel_V1_ModelParams, rhs: Coreum_Feemodel_V1_ModelParams) -> Bool {
    if lhs.initialGasPrice != rhs.initialGasPrice {return false}
    if lhs.maxGasPriceMultiplier != rhs.maxGasPriceMultiplier {return false}
    if lhs.maxDiscount != rhs.maxDiscount {return false}
    if lhs.escalationStartFraction != rhs.escalationStartFraction {return false}
    if lhs.maxBlockGas != rhs.maxBlockGas {return false}
    if lhs.shortEmaBlockLength != rhs.shortEmaBlockLength {return false}
    if lhs.longEmaBlockLength != rhs.longEmaBlockLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coreum_Feemodel_V1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._model) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._model {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Coreum_Feemodel_V1_Params, rhs: Coreum_Feemodel_V1_Params) -> Bool {
    if lhs._model != rhs._model {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
