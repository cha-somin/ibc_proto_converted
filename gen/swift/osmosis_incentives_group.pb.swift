// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: osmosis/incentives/group.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// SplittingPolicy determines the way we want to split incentives in groupGauges
enum Osmosis_Incentives_SplittingPolicy: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case byVolume // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .byVolume
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .byVolume
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .byVolume: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Osmosis_Incentives_SplittingPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Osmosis_Incentives_SplittingPolicy] = [
    .byVolume,
  ]
}

#endif  // swift(>=4.2)

/// Note that while both InternalGaugeInfo and InternalGaugeRecord could
/// technically be replaced by DistrInfo and DistrRecord from the pool-incentives
/// module, we create separate types here to keep our abstractions clean and
/// readable (pool-incentives distribution abstractions are used in a very
/// specific way that does not directly relate to gauge logic). This also helps
/// us sidestep a refactor to avoid an import cycle.
struct Osmosis_Incentives_InternalGaugeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalWeight: String = String()

  var gaugeRecords: [Osmosis_Incentives_InternalGaugeRecord] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Osmosis_Incentives_InternalGaugeRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gaugeID: UInt64 = 0

  /// CurrentWeight is the current weight of this gauge being distributed to for
  /// this epoch. For instance, for volume splitting policy, this stores the
  /// volume generated in the last epoch of the linked pool.
  var currentWeight: String = String()

  /// CumulativeWeight serves as a snapshot of the accumulator being tracked
  /// based on splitting policy. For instance, for volume splitting policy, this
  /// stores the cumulative volume for the linked pool at time of last update.
  var cumulativeWeight: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Group is an object that stores a 1:1 mapped gauge ID, a list of pool gauge
/// info, and a splitting policy. These are grouped into a single abstraction to
/// allow for distribution of group incentives to internal gauges according to
/// the specified splitting policy.
struct Osmosis_Incentives_Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupGaugeID: UInt64 = 0

  var internalGaugeInfo: Osmosis_Incentives_InternalGaugeInfo {
    get {return _internalGaugeInfo ?? Osmosis_Incentives_InternalGaugeInfo()}
    set {_internalGaugeInfo = newValue}
  }
  /// Returns true if `internalGaugeInfo` has been explicitly set.
  var hasInternalGaugeInfo: Bool {return self._internalGaugeInfo != nil}
  /// Clears the value of `internalGaugeInfo`. Subsequent reads from it will return its default value.
  mutating func clearInternalGaugeInfo() {self._internalGaugeInfo = nil}

  var splittingPolicy: Osmosis_Incentives_SplittingPolicy = .byVolume

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _internalGaugeInfo: Osmosis_Incentives_InternalGaugeInfo? = nil
}

/// CreateGroup is called via governance to create a new group.
/// It takes an array of pool IDs to split the incentives across.
struct Osmosis_Incentives_CreateGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GroupsWithGauge is a helper struct that stores a group and its
/// associated gauge.
struct Osmosis_Incentives_GroupsWithGauge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: Osmosis_Incentives_Group {
    get {return _storage._group ?? Osmosis_Incentives_Group()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {_uniqueStorage()._group = nil}

  var gauge: Osmosis_Incentives_Gauge {
    get {return _storage._gauge ?? Osmosis_Incentives_Gauge()}
    set {_uniqueStorage()._gauge = newValue}
  }
  /// Returns true if `gauge` has been explicitly set.
  var hasGauge: Bool {return _storage._gauge != nil}
  /// Clears the value of `gauge`. Subsequent reads from it will return its default value.
  mutating func clearGauge() {_uniqueStorage()._gauge = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Osmosis_Incentives_SplittingPolicy: @unchecked Sendable {}
extension Osmosis_Incentives_InternalGaugeInfo: @unchecked Sendable {}
extension Osmosis_Incentives_InternalGaugeRecord: @unchecked Sendable {}
extension Osmosis_Incentives_Group: @unchecked Sendable {}
extension Osmosis_Incentives_CreateGroup: @unchecked Sendable {}
extension Osmosis_Incentives_GroupsWithGauge: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "osmosis.incentives"

extension Osmosis_Incentives_SplittingPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ByVolume"),
  ]
}

extension Osmosis_Incentives_InternalGaugeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InternalGaugeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_weight"),
    2: .standard(proto: "gauge_records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.totalWeight) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.gaugeRecords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.totalWeight.isEmpty {
      try visitor.visitSingularStringField(value: self.totalWeight, fieldNumber: 1)
    }
    if !self.gaugeRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gaugeRecords, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Incentives_InternalGaugeInfo, rhs: Osmosis_Incentives_InternalGaugeInfo) -> Bool {
    if lhs.totalWeight != rhs.totalWeight {return false}
    if lhs.gaugeRecords != rhs.gaugeRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Incentives_InternalGaugeRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InternalGaugeRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gauge_id"),
    2: .standard(proto: "current_weight"),
    3: .standard(proto: "cumulative_weight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.gaugeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.currentWeight) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cumulativeWeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gaugeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.gaugeID, fieldNumber: 1)
    }
    if !self.currentWeight.isEmpty {
      try visitor.visitSingularStringField(value: self.currentWeight, fieldNumber: 2)
    }
    if !self.cumulativeWeight.isEmpty {
      try visitor.visitSingularStringField(value: self.cumulativeWeight, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Incentives_InternalGaugeRecord, rhs: Osmosis_Incentives_InternalGaugeRecord) -> Bool {
    if lhs.gaugeID != rhs.gaugeID {return false}
    if lhs.currentWeight != rhs.currentWeight {return false}
    if lhs.cumulativeWeight != rhs.cumulativeWeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Incentives_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_gauge_id"),
    2: .standard(proto: "internal_gauge_info"),
    3: .standard(proto: "splitting_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.groupGaugeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._internalGaugeInfo) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.splittingPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.groupGaugeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupGaugeID, fieldNumber: 1)
    }
    try { if let v = self._internalGaugeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.splittingPolicy != .byVolume {
      try visitor.visitSingularEnumField(value: self.splittingPolicy, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Incentives_Group, rhs: Osmosis_Incentives_Group) -> Bool {
    if lhs.groupGaugeID != rhs.groupGaugeID {return false}
    if lhs._internalGaugeInfo != rhs._internalGaugeInfo {return false}
    if lhs.splittingPolicy != rhs.splittingPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Incentives_CreateGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.poolIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.poolIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.poolIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Incentives_CreateGroup, rhs: Osmosis_Incentives_CreateGroup) -> Bool {
    if lhs.poolIds != rhs.poolIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Osmosis_Incentives_GroupsWithGauge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupsWithGauge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "gauge"),
  ]

  fileprivate class _StorageClass {
    var _group: Osmosis_Incentives_Group? = nil
    var _gauge: Osmosis_Incentives_Gauge? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _group = source._group
      _gauge = source._gauge
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._gauge) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._gauge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Osmosis_Incentives_GroupsWithGauge, rhs: Osmosis_Incentives_GroupsWithGauge) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._group != rhs_storage._group {return false}
        if _storage._gauge != rhs_storage._gauge {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
