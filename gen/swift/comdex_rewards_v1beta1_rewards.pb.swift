// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: comdex/rewards/v1beta1/rewards.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Comdex_Rewards_V1beta1_InternalRewards {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appMappingID: UInt64 = 0

  var assetID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Rewards_V1beta1_LockerRewardsTracker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lockerID: UInt64 = 0

  var appMappingID: UInt64 = 0

  var rewardsAccumulated: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Rewards_V1beta1_VaultInterestTracker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vaultID: UInt64 = 0

  var appMappingID: UInt64 = 0

  var interestAccumulated: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Rewards_V1beta1_LockerExternalRewards {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var appMappingID: UInt64 = 0

  var assetID: UInt64 = 0

  var totalRewards: Cosmos_Base_V1beta1_Coin {
    get {return _totalRewards ?? Cosmos_Base_V1beta1_Coin()}
    set {_totalRewards = newValue}
  }
  /// Returns true if `totalRewards` has been explicitly set.
  var hasTotalRewards: Bool {return self._totalRewards != nil}
  /// Clears the value of `totalRewards`. Subsequent reads from it will return its default value.
  mutating func clearTotalRewards() {self._totalRewards = nil}

  var durationDays: Int64 = 0

  var isActive: Bool = false

  var availableRewards: Cosmos_Base_V1beta1_Coin {
    get {return _availableRewards ?? Cosmos_Base_V1beta1_Coin()}
    set {_availableRewards = newValue}
  }
  /// Returns true if `availableRewards` has been explicitly set.
  var hasAvailableRewards: Bool {return self._availableRewards != nil}
  /// Clears the value of `availableRewards`. Subsequent reads from it will return its default value.
  mutating func clearAvailableRewards() {self._availableRewards = nil}

  var depositor: String = String()

  var startTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTimestamp = newValue}
  }
  /// Returns true if `startTimestamp` has been explicitly set.
  var hasStartTimestamp: Bool {return self._startTimestamp != nil}
  /// Clears the value of `startTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearStartTimestamp() {self._startTimestamp = nil}

  var endTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTimestamp = newValue}
  }
  /// Returns true if `endTimestamp` has been explicitly set.
  var hasEndTimestamp: Bool {return self._endTimestamp != nil}
  /// Clears the value of `endTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearEndTimestamp() {self._endTimestamp = nil}

  var minLockupTimeSeconds: Int64 = 0

  var epochID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totalRewards: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _availableRewards: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _startTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Comdex_Rewards_V1beta1_VaultExternalRewards {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var appMappingID: UInt64 = 0

  var extendedPairID: UInt64 = 0

  var totalRewards: Cosmos_Base_V1beta1_Coin {
    get {return _totalRewards ?? Cosmos_Base_V1beta1_Coin()}
    set {_totalRewards = newValue}
  }
  /// Returns true if `totalRewards` has been explicitly set.
  var hasTotalRewards: Bool {return self._totalRewards != nil}
  /// Clears the value of `totalRewards`. Subsequent reads from it will return its default value.
  mutating func clearTotalRewards() {self._totalRewards = nil}

  var durationDays: Int64 = 0

  var isActive: Bool = false

  var availableRewards: Cosmos_Base_V1beta1_Coin {
    get {return _availableRewards ?? Cosmos_Base_V1beta1_Coin()}
    set {_availableRewards = newValue}
  }
  /// Returns true if `availableRewards` has been explicitly set.
  var hasAvailableRewards: Bool {return self._availableRewards != nil}
  /// Clears the value of `availableRewards`. Subsequent reads from it will return its default value.
  mutating func clearAvailableRewards() {self._availableRewards = nil}

  var depositor: String = String()

  var startTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTimestamp = newValue}
  }
  /// Returns true if `startTimestamp` has been explicitly set.
  var hasStartTimestamp: Bool {return self._startTimestamp != nil}
  /// Clears the value of `startTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearStartTimestamp() {self._startTimestamp = nil}

  var endTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTimestamp = newValue}
  }
  /// Returns true if `endTimestamp` has been explicitly set.
  var hasEndTimestamp: Bool {return self._endTimestamp != nil}
  /// Clears the value of `endTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearEndTimestamp() {self._endTimestamp = nil}

  var minLockupTimeSeconds: Int64 = 0

  var epochID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totalRewards: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _availableRewards: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _startTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Comdex_Rewards_V1beta1_EpochTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var appMappingID: UInt64 = 0

  var startingTime: Int64 = 0

  var count: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Rewards_V1beta1_LendExternalRewards {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var appMappingID: UInt64 {
    get {return _storage._appMappingID}
    set {_uniqueStorage()._appMappingID = newValue}
  }

  var rewardsAssetPoolData: Comdex_Rewards_V1beta1_RewardsAssetPoolData {
    get {return _storage._rewardsAssetPoolData ?? Comdex_Rewards_V1beta1_RewardsAssetPoolData()}
    set {_uniqueStorage()._rewardsAssetPoolData = newValue}
  }
  /// Returns true if `rewardsAssetPoolData` has been explicitly set.
  var hasRewardsAssetPoolData: Bool {return _storage._rewardsAssetPoolData != nil}
  /// Clears the value of `rewardsAssetPoolData`. Subsequent reads from it will return its default value.
  mutating func clearRewardsAssetPoolData() {_uniqueStorage()._rewardsAssetPoolData = nil}

  var totalRewards: Cosmos_Base_V1beta1_Coin {
    get {return _storage._totalRewards ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._totalRewards = newValue}
  }
  /// Returns true if `totalRewards` has been explicitly set.
  var hasTotalRewards: Bool {return _storage._totalRewards != nil}
  /// Clears the value of `totalRewards`. Subsequent reads from it will return its default value.
  mutating func clearTotalRewards() {_uniqueStorage()._totalRewards = nil}

  var masterPoolID: Int64 {
    get {return _storage._masterPoolID}
    set {_uniqueStorage()._masterPoolID = newValue}
  }

  var durationDays: Int64 {
    get {return _storage._durationDays}
    set {_uniqueStorage()._durationDays = newValue}
  }

  var isActive: Bool {
    get {return _storage._isActive}
    set {_uniqueStorage()._isActive = newValue}
  }

  var availableRewards: Cosmos_Base_V1beta1_Coin {
    get {return _storage._availableRewards ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._availableRewards = newValue}
  }
  /// Returns true if `availableRewards` has been explicitly set.
  var hasAvailableRewards: Bool {return _storage._availableRewards != nil}
  /// Clears the value of `availableRewards`. Subsequent reads from it will return its default value.
  mutating func clearAvailableRewards() {_uniqueStorage()._availableRewards = nil}

  var depositor: String {
    get {return _storage._depositor}
    set {_uniqueStorage()._depositor = newValue}
  }

  var startTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTimestamp = newValue}
  }
  /// Returns true if `startTimestamp` has been explicitly set.
  var hasStartTimestamp: Bool {return _storage._startTimestamp != nil}
  /// Clears the value of `startTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearStartTimestamp() {_uniqueStorage()._startTimestamp = nil}

  var endTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTimestamp = newValue}
  }
  /// Returns true if `endTimestamp` has been explicitly set.
  var hasEndTimestamp: Bool {return _storage._endTimestamp != nil}
  /// Clears the value of `endTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearEndTimestamp() {_uniqueStorage()._endTimestamp = nil}

  var minLockupTimeSeconds: Int64 {
    get {return _storage._minLockupTimeSeconds}
    set {_uniqueStorage()._minLockupTimeSeconds = newValue}
  }

  var epochID: UInt64 {
    get {return _storage._epochID}
    set {_uniqueStorage()._epochID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Comdex_Rewards_V1beta1_RewardsAssetPoolData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cPoolID: UInt64 = 0

  var assetID: [UInt64] = []

  var cSwapAppID: UInt64 = 0

  var cSwapMinLockAmount: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Rewards_V1beta1_StableVaultExternalRewards {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var appID: UInt64 {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  var cswapAppID: UInt64 {
    get {return _storage._cswapAppID}
    set {_uniqueStorage()._cswapAppID = newValue}
  }

  var commodoAppID: UInt64 {
    get {return _storage._commodoAppID}
    set {_uniqueStorage()._commodoAppID = newValue}
  }

  var totalRewards: Cosmos_Base_V1beta1_Coin {
    get {return _storage._totalRewards ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._totalRewards = newValue}
  }
  /// Returns true if `totalRewards` has been explicitly set.
  var hasTotalRewards: Bool {return _storage._totalRewards != nil}
  /// Clears the value of `totalRewards`. Subsequent reads from it will return its default value.
  mutating func clearTotalRewards() {_uniqueStorage()._totalRewards = nil}

  var durationDays: Int64 {
    get {return _storage._durationDays}
    set {_uniqueStorage()._durationDays = newValue}
  }

  var isActive: Bool {
    get {return _storage._isActive}
    set {_uniqueStorage()._isActive = newValue}
  }

  var availableRewards: Cosmos_Base_V1beta1_Coin {
    get {return _storage._availableRewards ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._availableRewards = newValue}
  }
  /// Returns true if `availableRewards` has been explicitly set.
  var hasAvailableRewards: Bool {return _storage._availableRewards != nil}
  /// Clears the value of `availableRewards`. Subsequent reads from it will return its default value.
  mutating func clearAvailableRewards() {_uniqueStorage()._availableRewards = nil}

  var depositor: String {
    get {return _storage._depositor}
    set {_uniqueStorage()._depositor = newValue}
  }

  var startTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTimestamp = newValue}
  }
  /// Returns true if `startTimestamp` has been explicitly set.
  var hasStartTimestamp: Bool {return _storage._startTimestamp != nil}
  /// Clears the value of `startTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearStartTimestamp() {_uniqueStorage()._startTimestamp = nil}

  var endTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTimestamp = newValue}
  }
  /// Returns true if `endTimestamp` has been explicitly set.
  var hasEndTimestamp: Bool {return _storage._endTimestamp != nil}
  /// Clears the value of `endTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearEndTimestamp() {_uniqueStorage()._endTimestamp = nil}

  var acceptedBlockHeight: Int64 {
    get {return _storage._acceptedBlockHeight}
    set {_uniqueStorage()._acceptedBlockHeight = newValue}
  }

  var epochID: UInt64 {
    get {return _storage._epochID}
    set {_uniqueStorage()._epochID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Comdex_Rewards_V1beta1_InternalRewards: @unchecked Sendable {}
extension Comdex_Rewards_V1beta1_LockerRewardsTracker: @unchecked Sendable {}
extension Comdex_Rewards_V1beta1_VaultInterestTracker: @unchecked Sendable {}
extension Comdex_Rewards_V1beta1_LockerExternalRewards: @unchecked Sendable {}
extension Comdex_Rewards_V1beta1_VaultExternalRewards: @unchecked Sendable {}
extension Comdex_Rewards_V1beta1_EpochTime: @unchecked Sendable {}
extension Comdex_Rewards_V1beta1_LendExternalRewards: @unchecked Sendable {}
extension Comdex_Rewards_V1beta1_RewardsAssetPoolData: @unchecked Sendable {}
extension Comdex_Rewards_V1beta1_StableVaultExternalRewards: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "comdex.rewards.v1beta1"

extension Comdex_Rewards_V1beta1_InternalRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InternalRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_mapping_id"),
    2: .standard(proto: "asset_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.appMappingID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.appMappingID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appMappingID, fieldNumber: 1)
    }
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Rewards_V1beta1_InternalRewards, rhs: Comdex_Rewards_V1beta1_InternalRewards) -> Bool {
    if lhs.appMappingID != rhs.appMappingID {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Rewards_V1beta1_LockerRewardsTracker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LockerRewardsTracker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "locker_id"),
    2: .standard(proto: "app_mapping_id"),
    3: .standard(proto: "rewards_accumulated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.lockerID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.appMappingID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rewardsAccumulated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lockerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lockerID, fieldNumber: 1)
    }
    if self.appMappingID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appMappingID, fieldNumber: 2)
    }
    if !self.rewardsAccumulated.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardsAccumulated, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Rewards_V1beta1_LockerRewardsTracker, rhs: Comdex_Rewards_V1beta1_LockerRewardsTracker) -> Bool {
    if lhs.lockerID != rhs.lockerID {return false}
    if lhs.appMappingID != rhs.appMappingID {return false}
    if lhs.rewardsAccumulated != rhs.rewardsAccumulated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Rewards_V1beta1_VaultInterestTracker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VaultInterestTracker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vault_id"),
    2: .standard(proto: "app_mapping_id"),
    3: .standard(proto: "interest_accumulated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.vaultID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.appMappingID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.interestAccumulated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vaultID != 0 {
      try visitor.visitSingularUInt64Field(value: self.vaultID, fieldNumber: 1)
    }
    if self.appMappingID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appMappingID, fieldNumber: 2)
    }
    if !self.interestAccumulated.isEmpty {
      try visitor.visitSingularStringField(value: self.interestAccumulated, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Rewards_V1beta1_VaultInterestTracker, rhs: Comdex_Rewards_V1beta1_VaultInterestTracker) -> Bool {
    if lhs.vaultID != rhs.vaultID {return false}
    if lhs.appMappingID != rhs.appMappingID {return false}
    if lhs.interestAccumulated != rhs.interestAccumulated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Rewards_V1beta1_LockerExternalRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LockerExternalRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "app_mapping_id"),
    3: .standard(proto: "asset_id"),
    4: .standard(proto: "total_rewards"),
    5: .standard(proto: "duration_days"),
    6: .standard(proto: "is_active"),
    7: .standard(proto: "available_rewards"),
    8: .same(proto: "depositor"),
    9: .standard(proto: "start_timestamp"),
    10: .standard(proto: "end_timestamp"),
    11: .standard(proto: "min_lockup_time_seconds"),
    12: .standard(proto: "epoch_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.appMappingID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._totalRewards) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.durationDays) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isActive) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._availableRewards) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.depositor) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._startTimestamp) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._endTimestamp) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.minLockupTimeSeconds) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self.epochID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.appMappingID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appMappingID, fieldNumber: 2)
    }
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 3)
    }
    try { if let v = self._totalRewards {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.durationDays != 0 {
      try visitor.visitSingularInt64Field(value: self.durationDays, fieldNumber: 5)
    }
    if self.isActive != false {
      try visitor.visitSingularBoolField(value: self.isActive, fieldNumber: 6)
    }
    try { if let v = self._availableRewards {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.depositor.isEmpty {
      try visitor.visitSingularStringField(value: self.depositor, fieldNumber: 8)
    }
    try { if let v = self._startTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._endTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if self.minLockupTimeSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.minLockupTimeSeconds, fieldNumber: 11)
    }
    if self.epochID != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochID, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Rewards_V1beta1_LockerExternalRewards, rhs: Comdex_Rewards_V1beta1_LockerExternalRewards) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.appMappingID != rhs.appMappingID {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs._totalRewards != rhs._totalRewards {return false}
    if lhs.durationDays != rhs.durationDays {return false}
    if lhs.isActive != rhs.isActive {return false}
    if lhs._availableRewards != rhs._availableRewards {return false}
    if lhs.depositor != rhs.depositor {return false}
    if lhs._startTimestamp != rhs._startTimestamp {return false}
    if lhs._endTimestamp != rhs._endTimestamp {return false}
    if lhs.minLockupTimeSeconds != rhs.minLockupTimeSeconds {return false}
    if lhs.epochID != rhs.epochID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Rewards_V1beta1_VaultExternalRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VaultExternalRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "app_mapping_id"),
    3: .standard(proto: "extended_pair_id"),
    4: .standard(proto: "total_rewards"),
    5: .standard(proto: "duration_days"),
    6: .standard(proto: "is_active"),
    7: .standard(proto: "available_rewards"),
    8: .same(proto: "depositor"),
    9: .standard(proto: "start_timestamp"),
    10: .standard(proto: "end_timestamp"),
    11: .standard(proto: "min_lockup_time_seconds"),
    12: .standard(proto: "epoch_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.appMappingID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.extendedPairID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._totalRewards) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.durationDays) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isActive) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._availableRewards) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.depositor) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._startTimestamp) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._endTimestamp) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.minLockupTimeSeconds) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self.epochID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.appMappingID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appMappingID, fieldNumber: 2)
    }
    if self.extendedPairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.extendedPairID, fieldNumber: 3)
    }
    try { if let v = self._totalRewards {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.durationDays != 0 {
      try visitor.visitSingularInt64Field(value: self.durationDays, fieldNumber: 5)
    }
    if self.isActive != false {
      try visitor.visitSingularBoolField(value: self.isActive, fieldNumber: 6)
    }
    try { if let v = self._availableRewards {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.depositor.isEmpty {
      try visitor.visitSingularStringField(value: self.depositor, fieldNumber: 8)
    }
    try { if let v = self._startTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._endTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if self.minLockupTimeSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.minLockupTimeSeconds, fieldNumber: 11)
    }
    if self.epochID != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochID, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Rewards_V1beta1_VaultExternalRewards, rhs: Comdex_Rewards_V1beta1_VaultExternalRewards) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.appMappingID != rhs.appMappingID {return false}
    if lhs.extendedPairID != rhs.extendedPairID {return false}
    if lhs._totalRewards != rhs._totalRewards {return false}
    if lhs.durationDays != rhs.durationDays {return false}
    if lhs.isActive != rhs.isActive {return false}
    if lhs._availableRewards != rhs._availableRewards {return false}
    if lhs.depositor != rhs.depositor {return false}
    if lhs._startTimestamp != rhs._startTimestamp {return false}
    if lhs._endTimestamp != rhs._endTimestamp {return false}
    if lhs.minLockupTimeSeconds != rhs.minLockupTimeSeconds {return false}
    if lhs.epochID != rhs.epochID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Rewards_V1beta1_EpochTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EpochTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "app_mapping_id"),
    3: .standard(proto: "starting_time"),
    4: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.appMappingID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.startingTime) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.appMappingID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appMappingID, fieldNumber: 2)
    }
    if self.startingTime != 0 {
      try visitor.visitSingularInt64Field(value: self.startingTime, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Rewards_V1beta1_EpochTime, rhs: Comdex_Rewards_V1beta1_EpochTime) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.appMappingID != rhs.appMappingID {return false}
    if lhs.startingTime != rhs.startingTime {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Rewards_V1beta1_LendExternalRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LendExternalRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "app_mapping_id"),
    3: .standard(proto: "rewards_asset_pool_data"),
    4: .standard(proto: "total_rewards"),
    5: .standard(proto: "master_pool_id"),
    6: .standard(proto: "duration_days"),
    7: .standard(proto: "is_active"),
    8: .standard(proto: "available_rewards"),
    9: .same(proto: "depositor"),
    10: .standard(proto: "start_timestamp"),
    11: .standard(proto: "end_timestamp"),
    12: .standard(proto: "min_lockup_time_seconds"),
    13: .standard(proto: "epoch_id"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _appMappingID: UInt64 = 0
    var _rewardsAssetPoolData: Comdex_Rewards_V1beta1_RewardsAssetPoolData? = nil
    var _totalRewards: Cosmos_Base_V1beta1_Coin? = nil
    var _masterPoolID: Int64 = 0
    var _durationDays: Int64 = 0
    var _isActive: Bool = false
    var _availableRewards: Cosmos_Base_V1beta1_Coin? = nil
    var _depositor: String = String()
    var _startTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _minLockupTimeSeconds: Int64 = 0
    var _epochID: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _appMappingID = source._appMappingID
      _rewardsAssetPoolData = source._rewardsAssetPoolData
      _totalRewards = source._totalRewards
      _masterPoolID = source._masterPoolID
      _durationDays = source._durationDays
      _isActive = source._isActive
      _availableRewards = source._availableRewards
      _depositor = source._depositor
      _startTimestamp = source._startTimestamp
      _endTimestamp = source._endTimestamp
      _minLockupTimeSeconds = source._minLockupTimeSeconds
      _epochID = source._epochID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._appMappingID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._rewardsAssetPoolData) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._totalRewards) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._masterPoolID) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._durationDays) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._isActive) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._availableRewards) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._depositor) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._startTimestamp) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._endTimestamp) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._minLockupTimeSeconds) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._epochID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._appMappingID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._appMappingID, fieldNumber: 2)
      }
      try { if let v = _storage._rewardsAssetPoolData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._totalRewards {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._masterPoolID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._masterPoolID, fieldNumber: 5)
      }
      if _storage._durationDays != 0 {
        try visitor.visitSingularInt64Field(value: _storage._durationDays, fieldNumber: 6)
      }
      if _storage._isActive != false {
        try visitor.visitSingularBoolField(value: _storage._isActive, fieldNumber: 7)
      }
      try { if let v = _storage._availableRewards {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._depositor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._depositor, fieldNumber: 9)
      }
      try { if let v = _storage._startTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._endTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._minLockupTimeSeconds != 0 {
        try visitor.visitSingularInt64Field(value: _storage._minLockupTimeSeconds, fieldNumber: 12)
      }
      if _storage._epochID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._epochID, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Rewards_V1beta1_LendExternalRewards, rhs: Comdex_Rewards_V1beta1_LendExternalRewards) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._appMappingID != rhs_storage._appMappingID {return false}
        if _storage._rewardsAssetPoolData != rhs_storage._rewardsAssetPoolData {return false}
        if _storage._totalRewards != rhs_storage._totalRewards {return false}
        if _storage._masterPoolID != rhs_storage._masterPoolID {return false}
        if _storage._durationDays != rhs_storage._durationDays {return false}
        if _storage._isActive != rhs_storage._isActive {return false}
        if _storage._availableRewards != rhs_storage._availableRewards {return false}
        if _storage._depositor != rhs_storage._depositor {return false}
        if _storage._startTimestamp != rhs_storage._startTimestamp {return false}
        if _storage._endTimestamp != rhs_storage._endTimestamp {return false}
        if _storage._minLockupTimeSeconds != rhs_storage._minLockupTimeSeconds {return false}
        if _storage._epochID != rhs_storage._epochID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Rewards_V1beta1_RewardsAssetPoolData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RewardsAssetPoolData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "c_pool_id"),
    2: .standard(proto: "asset_id"),
    3: .standard(proto: "c_swap_app_id"),
    4: .standard(proto: "c_swap_min_lock_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.cPoolID) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.assetID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.cSwapAppID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.cSwapMinLockAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cPoolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.cPoolID, fieldNumber: 1)
    }
    if !self.assetID.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.assetID, fieldNumber: 2)
    }
    if self.cSwapAppID != 0 {
      try visitor.visitSingularUInt64Field(value: self.cSwapAppID, fieldNumber: 3)
    }
    if self.cSwapMinLockAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.cSwapMinLockAmount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Rewards_V1beta1_RewardsAssetPoolData, rhs: Comdex_Rewards_V1beta1_RewardsAssetPoolData) -> Bool {
    if lhs.cPoolID != rhs.cPoolID {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.cSwapAppID != rhs.cSwapAppID {return false}
    if lhs.cSwapMinLockAmount != rhs.cSwapMinLockAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Rewards_V1beta1_StableVaultExternalRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StableVaultExternalRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "app_id"),
    3: .standard(proto: "cswap_app_id"),
    4: .standard(proto: "commodo_app_id"),
    5: .standard(proto: "total_rewards"),
    6: .standard(proto: "duration_days"),
    7: .standard(proto: "is_active"),
    8: .standard(proto: "available_rewards"),
    9: .same(proto: "depositor"),
    10: .standard(proto: "start_timestamp"),
    11: .standard(proto: "end_timestamp"),
    12: .standard(proto: "accepted_block_height"),
    13: .standard(proto: "epoch_id"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _appID: UInt64 = 0
    var _cswapAppID: UInt64 = 0
    var _commodoAppID: UInt64 = 0
    var _totalRewards: Cosmos_Base_V1beta1_Coin? = nil
    var _durationDays: Int64 = 0
    var _isActive: Bool = false
    var _availableRewards: Cosmos_Base_V1beta1_Coin? = nil
    var _depositor: String = String()
    var _startTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _acceptedBlockHeight: Int64 = 0
    var _epochID: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _appID = source._appID
      _cswapAppID = source._cswapAppID
      _commodoAppID = source._commodoAppID
      _totalRewards = source._totalRewards
      _durationDays = source._durationDays
      _isActive = source._isActive
      _availableRewards = source._availableRewards
      _depositor = source._depositor
      _startTimestamp = source._startTimestamp
      _endTimestamp = source._endTimestamp
      _acceptedBlockHeight = source._acceptedBlockHeight
      _epochID = source._epochID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._appID) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._cswapAppID) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._commodoAppID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._totalRewards) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._durationDays) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._isActive) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._availableRewards) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._depositor) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._startTimestamp) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._endTimestamp) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._acceptedBlockHeight) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._epochID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._appID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._appID, fieldNumber: 2)
      }
      if _storage._cswapAppID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._cswapAppID, fieldNumber: 3)
      }
      if _storage._commodoAppID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._commodoAppID, fieldNumber: 4)
      }
      try { if let v = _storage._totalRewards {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._durationDays != 0 {
        try visitor.visitSingularInt64Field(value: _storage._durationDays, fieldNumber: 6)
      }
      if _storage._isActive != false {
        try visitor.visitSingularBoolField(value: _storage._isActive, fieldNumber: 7)
      }
      try { if let v = _storage._availableRewards {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._depositor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._depositor, fieldNumber: 9)
      }
      try { if let v = _storage._startTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._endTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._acceptedBlockHeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._acceptedBlockHeight, fieldNumber: 12)
      }
      if _storage._epochID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._epochID, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Rewards_V1beta1_StableVaultExternalRewards, rhs: Comdex_Rewards_V1beta1_StableVaultExternalRewards) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._cswapAppID != rhs_storage._cswapAppID {return false}
        if _storage._commodoAppID != rhs_storage._commodoAppID {return false}
        if _storage._totalRewards != rhs_storage._totalRewards {return false}
        if _storage._durationDays != rhs_storage._durationDays {return false}
        if _storage._isActive != rhs_storage._isActive {return false}
        if _storage._availableRewards != rhs_storage._availableRewards {return false}
        if _storage._depositor != rhs_storage._depositor {return false}
        if _storage._startTimestamp != rhs_storage._startTimestamp {return false}
        if _storage._endTimestamp != rhs_storage._endTimestamp {return false}
        if _storage._acceptedBlockHeight != rhs_storage._acceptedBlockHeight {return false}
        if _storage._epochID != rhs_storage._epochID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
