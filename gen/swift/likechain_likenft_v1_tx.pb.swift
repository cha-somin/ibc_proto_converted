// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: likechain/likenft/v1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Likechain_Likenft_V1_MsgNewClass {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var parent: Likechain_Likenft_V1_ClassParentInput {
    get {return _parent ?? Likechain_Likenft_V1_ClassParentInput()}
    set {_parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  var hasParent: Bool {return self._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  mutating func clearParent() {self._parent = nil}

  var input: Likechain_Likenft_V1_ClassInput {
    get {return _input ?? Likechain_Likenft_V1_ClassInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _parent: Likechain_Likenft_V1_ClassParentInput? = nil
  fileprivate var _input: Likechain_Likenft_V1_ClassInput? = nil
}

struct Likechain_Likenft_V1_MsgNewClassResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `class`: Cosmos_Nft_V1beta1_Class {
    get {return _class ?? Cosmos_Nft_V1beta1_Class()}
    set {_class = newValue}
  }
  /// Returns true if ``class`` has been explicitly set.
  var hasClass: Bool {return self._class != nil}
  /// Clears the value of ``class``. Subsequent reads from it will return its default value.
  mutating func clearClass() {self._class = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _class: Cosmos_Nft_V1beta1_Class? = nil
}

struct Likechain_Likenft_V1_MsgUpdateClass {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var input: Likechain_Likenft_V1_ClassInput {
    get {return _input ?? Likechain_Likenft_V1_ClassInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Likechain_Likenft_V1_ClassInput? = nil
}

struct Likechain_Likenft_V1_MsgUpdateClassResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `class`: Cosmos_Nft_V1beta1_Class {
    get {return _class ?? Cosmos_Nft_V1beta1_Class()}
    set {_class = newValue}
  }
  /// Returns true if ``class`` has been explicitly set.
  var hasClass: Bool {return self._class != nil}
  /// Clears the value of ``class``. Subsequent reads from it will return its default value.
  mutating func clearClass() {self._class = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _class: Cosmos_Nft_V1beta1_Class? = nil
}

struct Likechain_Likenft_V1_MsgMintNFT {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var id: String = String()

  var input: Likechain_Likenft_V1_NFTInput {
    get {return _input ?? Likechain_Likenft_V1_NFTInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Likechain_Likenft_V1_NFTInput? = nil
}

struct Likechain_Likenft_V1_MsgMintNFTResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nft: Cosmos_Nft_V1beta1_NFT {
    get {return _nft ?? Cosmos_Nft_V1beta1_NFT()}
    set {_nft = newValue}
  }
  /// Returns true if `nft` has been explicitly set.
  var hasNft: Bool {return self._nft != nil}
  /// Clears the value of `nft`. Subsequent reads from it will return its default value.
  mutating func clearNft() {self._nft = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nft: Cosmos_Nft_V1beta1_NFT? = nil
}

struct Likechain_Likenft_V1_MsgBurnNFT {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var nftID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MsgBurnNFTResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MsgCreateBlindBoxContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var id: String = String()

  var input: Likechain_Likenft_V1_NFTInput {
    get {return _input ?? Likechain_Likenft_V1_NFTInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Likechain_Likenft_V1_NFTInput? = nil
}

struct Likechain_Likenft_V1_MsgCreateBlindBoxContentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blindBoxContent: Likechain_Likenft_V1_BlindBoxContent {
    get {return _blindBoxContent ?? Likechain_Likenft_V1_BlindBoxContent()}
    set {_blindBoxContent = newValue}
  }
  /// Returns true if `blindBoxContent` has been explicitly set.
  var hasBlindBoxContent: Bool {return self._blindBoxContent != nil}
  /// Clears the value of `blindBoxContent`. Subsequent reads from it will return its default value.
  mutating func clearBlindBoxContent() {self._blindBoxContent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blindBoxContent: Likechain_Likenft_V1_BlindBoxContent? = nil
}

struct Likechain_Likenft_V1_MsgUpdateBlindBoxContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var id: String = String()

  var input: Likechain_Likenft_V1_NFTInput {
    get {return _input ?? Likechain_Likenft_V1_NFTInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Likechain_Likenft_V1_NFTInput? = nil
}

struct Likechain_Likenft_V1_MsgUpdateBlindBoxContentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blindBoxContent: Likechain_Likenft_V1_BlindBoxContent {
    get {return _blindBoxContent ?? Likechain_Likenft_V1_BlindBoxContent()}
    set {_blindBoxContent = newValue}
  }
  /// Returns true if `blindBoxContent` has been explicitly set.
  var hasBlindBoxContent: Bool {return self._blindBoxContent != nil}
  /// Clears the value of `blindBoxContent`. Subsequent reads from it will return its default value.
  mutating func clearBlindBoxContent() {self._blindBoxContent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blindBoxContent: Likechain_Likenft_V1_BlindBoxContent? = nil
}

struct Likechain_Likenft_V1_MsgDeleteBlindBoxContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MsgDeleteBlindBoxContentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MsgCreateOffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var nftID: String = String()

  var price: UInt64 = 0

  var expiration: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiration ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiration = newValue}
  }
  /// Returns true if `expiration` has been explicitly set.
  var hasExpiration: Bool {return self._expiration != nil}
  /// Clears the value of `expiration`. Subsequent reads from it will return its default value.
  mutating func clearExpiration() {self._expiration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expiration: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Likechain_Likenft_V1_MsgCreateOfferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offer: Likechain_Likenft_V1_Offer {
    get {return _offer ?? Likechain_Likenft_V1_Offer()}
    set {_offer = newValue}
  }
  /// Returns true if `offer` has been explicitly set.
  var hasOffer: Bool {return self._offer != nil}
  /// Clears the value of `offer`. Subsequent reads from it will return its default value.
  mutating func clearOffer() {self._offer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offer: Likechain_Likenft_V1_Offer? = nil
}

struct Likechain_Likenft_V1_MsgUpdateOffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var nftID: String = String()

  var price: UInt64 = 0

  var expiration: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiration ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiration = newValue}
  }
  /// Returns true if `expiration` has been explicitly set.
  var hasExpiration: Bool {return self._expiration != nil}
  /// Clears the value of `expiration`. Subsequent reads from it will return its default value.
  mutating func clearExpiration() {self._expiration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expiration: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Likechain_Likenft_V1_MsgUpdateOfferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offer: Likechain_Likenft_V1_Offer {
    get {return _offer ?? Likechain_Likenft_V1_Offer()}
    set {_offer = newValue}
  }
  /// Returns true if `offer` has been explicitly set.
  var hasOffer: Bool {return self._offer != nil}
  /// Clears the value of `offer`. Subsequent reads from it will return its default value.
  mutating func clearOffer() {self._offer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offer: Likechain_Likenft_V1_Offer? = nil
}

struct Likechain_Likenft_V1_MsgDeleteOffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var nftID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MsgDeleteOfferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MsgCreateListing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var nftID: String = String()

  var price: UInt64 = 0

  var expiration: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiration ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiration = newValue}
  }
  /// Returns true if `expiration` has been explicitly set.
  var hasExpiration: Bool {return self._expiration != nil}
  /// Clears the value of `expiration`. Subsequent reads from it will return its default value.
  mutating func clearExpiration() {self._expiration = nil}

  var fullPayToRoyalty: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expiration: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Likechain_Likenft_V1_MsgCreateListingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var listing: Likechain_Likenft_V1_Listing {
    get {return _listing ?? Likechain_Likenft_V1_Listing()}
    set {_listing = newValue}
  }
  /// Returns true if `listing` has been explicitly set.
  var hasListing: Bool {return self._listing != nil}
  /// Clears the value of `listing`. Subsequent reads from it will return its default value.
  mutating func clearListing() {self._listing = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _listing: Likechain_Likenft_V1_Listing? = nil
}

struct Likechain_Likenft_V1_MsgUpdateListing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var nftID: String = String()

  var price: UInt64 = 0

  var expiration: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiration ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiration = newValue}
  }
  /// Returns true if `expiration` has been explicitly set.
  var hasExpiration: Bool {return self._expiration != nil}
  /// Clears the value of `expiration`. Subsequent reads from it will return its default value.
  mutating func clearExpiration() {self._expiration = nil}

  var fullPayToRoyalty: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expiration: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Likechain_Likenft_V1_MsgUpdateListingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var listing: Likechain_Likenft_V1_Listing {
    get {return _listing ?? Likechain_Likenft_V1_Listing()}
    set {_listing = newValue}
  }
  /// Returns true if `listing` has been explicitly set.
  var hasListing: Bool {return self._listing != nil}
  /// Clears the value of `listing`. Subsequent reads from it will return its default value.
  mutating func clearListing() {self._listing = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _listing: Likechain_Likenft_V1_Listing? = nil
}

struct Likechain_Likenft_V1_MsgDeleteListing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var nftID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MsgDeleteListingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MsgSellNFT {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var nftID: String = String()

  var buyer: String = String()

  var price: UInt64 = 0

  var fullPayToRoyalty: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MsgSellNFTResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MsgBuyNFT {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var nftID: String = String()

  var seller: String = String()

  var price: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MsgBuyNFTResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MsgCreateRoyaltyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var royaltyConfig: Likechain_Likenft_V1_RoyaltyConfigInput {
    get {return _royaltyConfig ?? Likechain_Likenft_V1_RoyaltyConfigInput()}
    set {_royaltyConfig = newValue}
  }
  /// Returns true if `royaltyConfig` has been explicitly set.
  var hasRoyaltyConfig: Bool {return self._royaltyConfig != nil}
  /// Clears the value of `royaltyConfig`. Subsequent reads from it will return its default value.
  mutating func clearRoyaltyConfig() {self._royaltyConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _royaltyConfig: Likechain_Likenft_V1_RoyaltyConfigInput? = nil
}

struct Likechain_Likenft_V1_MsgCreateRoyaltyConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var royaltyConfig: Likechain_Likenft_V1_RoyaltyConfig {
    get {return _royaltyConfig ?? Likechain_Likenft_V1_RoyaltyConfig()}
    set {_royaltyConfig = newValue}
  }
  /// Returns true if `royaltyConfig` has been explicitly set.
  var hasRoyaltyConfig: Bool {return self._royaltyConfig != nil}
  /// Clears the value of `royaltyConfig`. Subsequent reads from it will return its default value.
  mutating func clearRoyaltyConfig() {self._royaltyConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _royaltyConfig: Likechain_Likenft_V1_RoyaltyConfig? = nil
}

struct Likechain_Likenft_V1_MsgUpdateRoyaltyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var royaltyConfig: Likechain_Likenft_V1_RoyaltyConfigInput {
    get {return _royaltyConfig ?? Likechain_Likenft_V1_RoyaltyConfigInput()}
    set {_royaltyConfig = newValue}
  }
  /// Returns true if `royaltyConfig` has been explicitly set.
  var hasRoyaltyConfig: Bool {return self._royaltyConfig != nil}
  /// Clears the value of `royaltyConfig`. Subsequent reads from it will return its default value.
  mutating func clearRoyaltyConfig() {self._royaltyConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _royaltyConfig: Likechain_Likenft_V1_RoyaltyConfigInput? = nil
}

struct Likechain_Likenft_V1_MsgUpdateRoyaltyConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var royaltyConfig: Likechain_Likenft_V1_RoyaltyConfig {
    get {return _royaltyConfig ?? Likechain_Likenft_V1_RoyaltyConfig()}
    set {_royaltyConfig = newValue}
  }
  /// Returns true if `royaltyConfig` has been explicitly set.
  var hasRoyaltyConfig: Bool {return self._royaltyConfig != nil}
  /// Clears the value of `royaltyConfig`. Subsequent reads from it will return its default value.
  mutating func clearRoyaltyConfig() {self._royaltyConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _royaltyConfig: Likechain_Likenft_V1_RoyaltyConfig? = nil
}

struct Likechain_Likenft_V1_MsgDeleteRoyaltyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var classID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_MsgDeleteRoyaltyConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Likechain_Likenft_V1_MsgNewClass: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgNewClassResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgUpdateClass: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgUpdateClassResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgMintNFT: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgMintNFTResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgBurnNFT: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgBurnNFTResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgCreateBlindBoxContent: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgCreateBlindBoxContentResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgUpdateBlindBoxContent: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgUpdateBlindBoxContentResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgDeleteBlindBoxContent: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgDeleteBlindBoxContentResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgCreateOffer: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgCreateOfferResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgUpdateOffer: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgUpdateOfferResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgDeleteOffer: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgDeleteOfferResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgCreateListing: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgCreateListingResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgUpdateListing: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgUpdateListingResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgDeleteListing: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgDeleteListingResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgSellNFT: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgSellNFTResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgBuyNFT: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgBuyNFTResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgCreateRoyaltyConfig: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgCreateRoyaltyConfigResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgUpdateRoyaltyConfig: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgUpdateRoyaltyConfigResponse: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgDeleteRoyaltyConfig: @unchecked Sendable {}
extension Likechain_Likenft_V1_MsgDeleteRoyaltyConfigResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "likechain.likenft.v1"

extension Likechain_Likenft_V1_MsgNewClass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewClass"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "parent"),
    3: .same(proto: "input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parent) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    try { if let v = self._parent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgNewClass, rhs: Likechain_Likenft_V1_MsgNewClass) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs._parent != rhs._parent {return false}
    if lhs._input != rhs._input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgNewClassResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewClassResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "class"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._class) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._class {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgNewClassResponse, rhs: Likechain_Likenft_V1_MsgNewClassResponse) -> Bool {
    if lhs._class != rhs._class {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgUpdateClass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateClass"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .same(proto: "input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgUpdateClass, rhs: Likechain_Likenft_V1_MsgUpdateClass) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs._input != rhs._input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgUpdateClassResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateClassResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "class"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._class) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._class {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgUpdateClassResponse, rhs: Likechain_Likenft_V1_MsgUpdateClassResponse) -> Bool {
    if lhs._class != rhs._class {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgMintNFT: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMintNFT"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .same(proto: "id"),
    4: .same(proto: "input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgMintNFT, rhs: Likechain_Likenft_V1_MsgMintNFT) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.id != rhs.id {return false}
    if lhs._input != rhs._input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgMintNFTResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMintNFTResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nft"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nft) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nft {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgMintNFTResponse, rhs: Likechain_Likenft_V1_MsgMintNFTResponse) -> Bool {
    if lhs._nft != rhs._nft {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgBurnNFT: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBurnNFT"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .standard(proto: "nft_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgBurnNFT, rhs: Likechain_Likenft_V1_MsgBurnNFT) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgBurnNFTResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBurnNFTResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgBurnNFTResponse, rhs: Likechain_Likenft_V1_MsgBurnNFTResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgCreateBlindBoxContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBlindBoxContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .same(proto: "id"),
    4: .same(proto: "input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgCreateBlindBoxContent, rhs: Likechain_Likenft_V1_MsgCreateBlindBoxContent) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.id != rhs.id {return false}
    if lhs._input != rhs._input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgCreateBlindBoxContentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBlindBoxContentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "blind_box_content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blindBoxContent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blindBoxContent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgCreateBlindBoxContentResponse, rhs: Likechain_Likenft_V1_MsgCreateBlindBoxContentResponse) -> Bool {
    if lhs._blindBoxContent != rhs._blindBoxContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgUpdateBlindBoxContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateBlindBoxContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .same(proto: "id"),
    4: .same(proto: "input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgUpdateBlindBoxContent, rhs: Likechain_Likenft_V1_MsgUpdateBlindBoxContent) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.id != rhs.id {return false}
    if lhs._input != rhs._input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgUpdateBlindBoxContentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateBlindBoxContentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "blind_box_content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blindBoxContent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blindBoxContent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgUpdateBlindBoxContentResponse, rhs: Likechain_Likenft_V1_MsgUpdateBlindBoxContentResponse) -> Bool {
    if lhs._blindBoxContent != rhs._blindBoxContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgDeleteBlindBoxContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteBlindBoxContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgDeleteBlindBoxContent, rhs: Likechain_Likenft_V1_MsgDeleteBlindBoxContent) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgDeleteBlindBoxContentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteBlindBoxContentResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgDeleteBlindBoxContentResponse, rhs: Likechain_Likenft_V1_MsgDeleteBlindBoxContentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgCreateOffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateOffer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .standard(proto: "nft_id"),
    4: .same(proto: "price"),
    5: .same(proto: "expiration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.price) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 3)
    }
    if self.price != 0 {
      try visitor.visitSingularUInt64Field(value: self.price, fieldNumber: 4)
    }
    try { if let v = self._expiration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgCreateOffer, rhs: Likechain_Likenft_V1_MsgCreateOffer) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.price != rhs.price {return false}
    if lhs._expiration != rhs._expiration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgCreateOfferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateOfferResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._offer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgCreateOfferResponse, rhs: Likechain_Likenft_V1_MsgCreateOfferResponse) -> Bool {
    if lhs._offer != rhs._offer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgUpdateOffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateOffer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .standard(proto: "nft_id"),
    4: .same(proto: "price"),
    5: .same(proto: "expiration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.price) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 3)
    }
    if self.price != 0 {
      try visitor.visitSingularUInt64Field(value: self.price, fieldNumber: 4)
    }
    try { if let v = self._expiration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgUpdateOffer, rhs: Likechain_Likenft_V1_MsgUpdateOffer) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.price != rhs.price {return false}
    if lhs._expiration != rhs._expiration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgUpdateOfferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateOfferResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._offer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgUpdateOfferResponse, rhs: Likechain_Likenft_V1_MsgUpdateOfferResponse) -> Bool {
    if lhs._offer != rhs._offer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgDeleteOffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteOffer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .standard(proto: "nft_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgDeleteOffer, rhs: Likechain_Likenft_V1_MsgDeleteOffer) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgDeleteOfferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteOfferResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgDeleteOfferResponse, rhs: Likechain_Likenft_V1_MsgDeleteOfferResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgCreateListing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateListing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .standard(proto: "nft_id"),
    4: .same(proto: "price"),
    5: .same(proto: "expiration"),
    6: .standard(proto: "full_pay_to_royalty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.price) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiration) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.fullPayToRoyalty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 3)
    }
    if self.price != 0 {
      try visitor.visitSingularUInt64Field(value: self.price, fieldNumber: 4)
    }
    try { if let v = self._expiration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.fullPayToRoyalty != false {
      try visitor.visitSingularBoolField(value: self.fullPayToRoyalty, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgCreateListing, rhs: Likechain_Likenft_V1_MsgCreateListing) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.price != rhs.price {return false}
    if lhs._expiration != rhs._expiration {return false}
    if lhs.fullPayToRoyalty != rhs.fullPayToRoyalty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgCreateListingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateListingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "listing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._listing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._listing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgCreateListingResponse, rhs: Likechain_Likenft_V1_MsgCreateListingResponse) -> Bool {
    if lhs._listing != rhs._listing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgUpdateListing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateListing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .standard(proto: "nft_id"),
    4: .same(proto: "price"),
    5: .same(proto: "expiration"),
    6: .standard(proto: "full_pay_to_royalty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.price) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiration) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.fullPayToRoyalty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 3)
    }
    if self.price != 0 {
      try visitor.visitSingularUInt64Field(value: self.price, fieldNumber: 4)
    }
    try { if let v = self._expiration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.fullPayToRoyalty != false {
      try visitor.visitSingularBoolField(value: self.fullPayToRoyalty, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgUpdateListing, rhs: Likechain_Likenft_V1_MsgUpdateListing) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.price != rhs.price {return false}
    if lhs._expiration != rhs._expiration {return false}
    if lhs.fullPayToRoyalty != rhs.fullPayToRoyalty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgUpdateListingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateListingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "listing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._listing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._listing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgUpdateListingResponse, rhs: Likechain_Likenft_V1_MsgUpdateListingResponse) -> Bool {
    if lhs._listing != rhs._listing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgDeleteListing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteListing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .standard(proto: "nft_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgDeleteListing, rhs: Likechain_Likenft_V1_MsgDeleteListing) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgDeleteListingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteListingResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgDeleteListingResponse, rhs: Likechain_Likenft_V1_MsgDeleteListingResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgSellNFT: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSellNFT"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .standard(proto: "nft_id"),
    4: .same(proto: "buyer"),
    5: .same(proto: "price"),
    6: .standard(proto: "full_pay_to_royalty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.buyer) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.price) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.fullPayToRoyalty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 3)
    }
    if !self.buyer.isEmpty {
      try visitor.visitSingularStringField(value: self.buyer, fieldNumber: 4)
    }
    if self.price != 0 {
      try visitor.visitSingularUInt64Field(value: self.price, fieldNumber: 5)
    }
    if self.fullPayToRoyalty != false {
      try visitor.visitSingularBoolField(value: self.fullPayToRoyalty, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgSellNFT, rhs: Likechain_Likenft_V1_MsgSellNFT) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.buyer != rhs.buyer {return false}
    if lhs.price != rhs.price {return false}
    if lhs.fullPayToRoyalty != rhs.fullPayToRoyalty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgSellNFTResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSellNFTResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgSellNFTResponse, rhs: Likechain_Likenft_V1_MsgSellNFTResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgBuyNFT: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBuyNFT"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .standard(proto: "nft_id"),
    4: .same(proto: "seller"),
    5: .same(proto: "price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.seller) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.price) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 3)
    }
    if !self.seller.isEmpty {
      try visitor.visitSingularStringField(value: self.seller, fieldNumber: 4)
    }
    if self.price != 0 {
      try visitor.visitSingularUInt64Field(value: self.price, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgBuyNFT, rhs: Likechain_Likenft_V1_MsgBuyNFT) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.seller != rhs.seller {return false}
    if lhs.price != rhs.price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgBuyNFTResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBuyNFTResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgBuyNFTResponse, rhs: Likechain_Likenft_V1_MsgBuyNFTResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgCreateRoyaltyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateRoyaltyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .standard(proto: "royalty_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._royaltyConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    try { if let v = self._royaltyConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgCreateRoyaltyConfig, rhs: Likechain_Likenft_V1_MsgCreateRoyaltyConfig) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs._royaltyConfig != rhs._royaltyConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgCreateRoyaltyConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateRoyaltyConfigResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "royalty_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._royaltyConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._royaltyConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgCreateRoyaltyConfigResponse, rhs: Likechain_Likenft_V1_MsgCreateRoyaltyConfigResponse) -> Bool {
    if lhs._royaltyConfig != rhs._royaltyConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgUpdateRoyaltyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateRoyaltyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
    3: .standard(proto: "royalty_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._royaltyConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    try { if let v = self._royaltyConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgUpdateRoyaltyConfig, rhs: Likechain_Likenft_V1_MsgUpdateRoyaltyConfig) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs._royaltyConfig != rhs._royaltyConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgUpdateRoyaltyConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateRoyaltyConfigResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "royalty_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._royaltyConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._royaltyConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgUpdateRoyaltyConfigResponse, rhs: Likechain_Likenft_V1_MsgUpdateRoyaltyConfigResponse) -> Bool {
    if lhs._royaltyConfig != rhs._royaltyConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgDeleteRoyaltyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteRoyaltyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "class_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgDeleteRoyaltyConfig, rhs: Likechain_Likenft_V1_MsgDeleteRoyaltyConfig) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_MsgDeleteRoyaltyConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteRoyaltyConfigResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_MsgDeleteRoyaltyConfigResponse, rhs: Likechain_Likenft_V1_MsgDeleteRoyaltyConfigResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
