// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: babylon/btcstaking/v1/packet.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// SlashedFinalityProvider carries a slashed finality provider on a consumer
struct Babylon_Btcstaking_V1_SlashedFinalityProvider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// btc_pk_hex is the Bitcoin secp256k1 PK of this finality provider
  /// the PK follows encoding in BIP-340 spec in hex format
  var btcPkHex: String = String()

  /// recovered_fp_btc_sk is the finality provider's BTC SK extracted due to slashing
  /// this allows the consumer to verify the BTC delegation is indeed slashed
  var recoveredFpBtcSk: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BTCStakingIBCPacket is an IBC packet sent from Babylon to a consumer
/// It carries a set of events related to BTC staking for a given consumer
/// It will be constructed and sent upon `EndBlock` of ZoneConcierge
/// (if there are any BTC staking events for a consumer)
struct Babylon_Btcstaking_V1_BTCStakingIBCPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var newFp: [Babylon_Btcstaking_V1_NewFinalityProvider] = []

  var activeDel: [Babylon_Btcstaking_V1_ActiveBTCDelegation] = []

  var slashedDel: [Babylon_Btcstaking_V1_SlashedBTCDelegation] = []

  var unbondedDel: [Babylon_Btcstaking_V1_UnbondedBTCDelegation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NewFinalityProvider is an IBC packet sent from Babylon to consumer
/// upon a newly registered finality provider on this consumer
struct Babylon_Btcstaking_V1_NewFinalityProvider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// description defines the description terms for the finality provider.
  var description_p: Cosmos_Staking_V1beta1_Description {
    get {return _description_p ?? Cosmos_Staking_V1beta1_Description()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  /// commission defines the commission rate of the finality provider.
  /// It forms as a string converted from "cosmossdk.io/math.LegacyDec"
  var commission: String = String()

  /// addr is the bech32 address identifier of the finality provider.
  var addr: String = String()

  /// btc_pk_hex is the Bitcoin secp256k1 PK of this finality provider
  /// the PK follows encoding in BIP-340 spec in hex format
  var btcPkHex: String = String()

  /// pop is the proof of possession of babylon_pk and btc_pk
  var pop: Babylon_Btcstaking_V1_ProofOfPossessionBTC {
    get {return _pop ?? Babylon_Btcstaking_V1_ProofOfPossessionBTC()}
    set {_pop = newValue}
  }
  /// Returns true if `pop` has been explicitly set.
  var hasPop: Bool {return self._pop != nil}
  /// Clears the value of `pop`. Subsequent reads from it will return its default value.
  mutating func clearPop() {self._pop = nil}

  /// consumer_id is the ID of the consumer the finality provider is operating on.
  /// If it's missing / empty, it's assumed the finality provider is operating in Babylon.
  var consumerID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _description_p: Cosmos_Staking_V1beta1_Description? = nil
  fileprivate var _pop: Babylon_Btcstaking_V1_ProofOfPossessionBTC? = nil
}

/// ActiveBTCDelegation is an IBC packet sent from Babylon to consumer
/// upon a BTC delegation newly receives covenant signatures and thus becomes active
struct Babylon_Btcstaking_V1_ActiveBTCDelegation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// staker_addr is the address to receive rewards from BTC delegation.
  var stakerAddr: String {
    get {return _storage._stakerAddr}
    set {_uniqueStorage()._stakerAddr = newValue}
  }

  /// btc_pk_hex is the Bitcoin secp256k1 PK of this BTC delegation
  /// the PK follows encoding in BIP-340 spec in hex format
  var btcPkHex: String {
    get {return _storage._btcPkHex}
    set {_uniqueStorage()._btcPkHex = newValue}
  }

  /// fp_btc_pk_list is the list of BIP-340 PKs of the finality providers that
  /// this BTC delegation delegates to
  var fpBtcPkList: [String] {
    get {return _storage._fpBtcPkList}
    set {_uniqueStorage()._fpBtcPkList = newValue}
  }

  /// start_height is the start BTC height of the BTC delegation
  /// it is the start BTC height of the timelock
  var startHeight: UInt32 {
    get {return _storage._startHeight}
    set {_uniqueStorage()._startHeight = newValue}
  }

  /// end_height is the end height of the BTC delegation
  /// it is the end BTC height of the timelock - w
  var endHeight: UInt32 {
    get {return _storage._endHeight}
    set {_uniqueStorage()._endHeight = newValue}
  }

  /// total_sat is the total amount of BTC stakes in this delegation
  /// quantified in satoshi
  var totalSat: UInt64 {
    get {return _storage._totalSat}
    set {_uniqueStorage()._totalSat = newValue}
  }

  /// staking_tx is the staking tx
  var stakingTx: Data {
    get {return _storage._stakingTx}
    set {_uniqueStorage()._stakingTx = newValue}
  }

  /// slashing_tx is the slashing tx
  var slashingTx: Data {
    get {return _storage._slashingTx}
    set {_uniqueStorage()._slashingTx = newValue}
  }

  /// delegator_slashing_sig is the signature on the slashing tx
  /// by the delegator (i.e., SK corresponding to btc_pk) as string hex.
  /// It will be a part of the witness for the staking tx output.
  var delegatorSlashingSig: Data {
    get {return _storage._delegatorSlashingSig}
    set {_uniqueStorage()._delegatorSlashingSig = newValue}
  }

  /// covenant_sigs is a list of adaptor signatures on the slashing tx
  /// by each covenant member
  /// It will be a part of the witness for the staking tx output.
  var covenantSigs: [Babylon_Btcstaking_V1_CovenantAdaptorSignatures] {
    get {return _storage._covenantSigs}
    set {_uniqueStorage()._covenantSigs = newValue}
  }

  /// staking_output_idx is the index of the staking output in the staking tx
  var stakingOutputIdx: UInt32 {
    get {return _storage._stakingOutputIdx}
    set {_uniqueStorage()._stakingOutputIdx = newValue}
  }

  /// unbonding_time used in unbonding output timelock path and in slashing transactions
  /// change outputs
  var unbondingTime: UInt32 {
    get {return _storage._unbondingTime}
    set {_uniqueStorage()._unbondingTime = newValue}
  }

  /// undelegation_info is the undelegation info of this delegation.
  var undelegationInfo: Babylon_Btcstaking_V1_BTCUndelegationInfo {
    get {return _storage._undelegationInfo ?? Babylon_Btcstaking_V1_BTCUndelegationInfo()}
    set {_uniqueStorage()._undelegationInfo = newValue}
  }
  /// Returns true if `undelegationInfo` has been explicitly set.
  var hasUndelegationInfo: Bool {return _storage._undelegationInfo != nil}
  /// Clears the value of `undelegationInfo`. Subsequent reads from it will return its default value.
  mutating func clearUndelegationInfo() {_uniqueStorage()._undelegationInfo = nil}

  /// params version used to validate delegation
  var paramsVersion: UInt32 {
    get {return _storage._paramsVersion}
    set {_uniqueStorage()._paramsVersion = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// BTCUndelegationInfo provides all necessary info about the undeleagation
struct Babylon_Btcstaking_V1_BTCUndelegationInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unbonding_tx is the transaction which will transfer the funds from staking
  /// output to unbonding output. Unbonding output will usually have lower timelock
  /// than staking output.
  var unbondingTx: Data = Data()

  /// slashing_tx is the slashing tx for unbonding transactions
  /// It is partially signed by SK corresponding to btc_pk, but not signed by
  /// finality provider or covenant yet.
  var slashingTx: Data = Data()

  /// delegator_slashing_sig is the signature on the slashing tx
  /// by the delegator (i.e., SK corresponding to btc_pk).
  /// It will be a part of the witness for the unbonding tx output.
  var delegatorSlashingSig: Data = Data()

  /// covenant_slashing_sigs is a list of adaptor signatures on the slashing tx
  /// by each covenant member
  /// It will be a part of the witness for the staking tx output.
  var covenantSlashingSigs: [Babylon_Btcstaking_V1_CovenantAdaptorSignatures] = []

  /// covenant_unbonding_sig_list is the list of signatures on the unbonding tx
  /// by covenant members
  /// It must be provided after processing undelegate message by Babylon
  var covenantUnbondingSigList: [Babylon_Btcstaking_V1_SignatureInfo] = []

  /// delegator_unbonding_info is the information about transaction which spent
  /// the staking output
  var delegatorUnbondingInfo: Babylon_Btcstaking_V1_DelegatorUnbondingInfo {
    get {return _delegatorUnbondingInfo ?? Babylon_Btcstaking_V1_DelegatorUnbondingInfo()}
    set {_delegatorUnbondingInfo = newValue}
  }
  /// Returns true if `delegatorUnbondingInfo` has been explicitly set.
  var hasDelegatorUnbondingInfo: Bool {return self._delegatorUnbondingInfo != nil}
  /// Clears the value of `delegatorUnbondingInfo`. Subsequent reads from it will return its default value.
  mutating func clearDelegatorUnbondingInfo() {self._delegatorUnbondingInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _delegatorUnbondingInfo: Babylon_Btcstaking_V1_DelegatorUnbondingInfo? = nil
}

/// SlashedBTCDelegation is an IBC packet sent from Babylon to consumer
/// about a slashed BTC delegation restaked to >=1 of this consumer's 
/// finality provider
struct Babylon_Btcstaking_V1_SlashedBTCDelegation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// staking tx hash of the BTC delegation. It uniquely identifies a BTC delegation
  var stakingTxHash: String = String()

  /// recovered_fp_btc_sk is the extracted BTC SK of the finality provider on
  /// this consumer
  /// this allows the consumer to verify the BTC delegation is indeed slashed
  var recoveredFpBtcSk: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UnbondedBTCDelegation is an IBC packet sent from Babylon to consumer
/// upon an early unbonded BTC delegation
struct Babylon_Btcstaking_V1_UnbondedBTCDelegation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// staking tx hash of the BTC delegation. It uniquely identifies a BTC delegation
  var stakingTxHash: String = String()

  /// unbonding_tx_sig is the signature on the unbonding tx signed by the BTC delegator
  /// It proves that the BTC delegator wants to unbond
  var unbondingTxSig: Data = Data()

  /// stake_spending_tx is the stake spending tx
  var stakeSpendingTx: Data = Data()

  /// proof is the inclusion proof for the stake spending tx
  var proof: Babylon_Btcstaking_V1_InclusionProof {
    get {return _proof ?? Babylon_Btcstaking_V1_InclusionProof()}
    set {_proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  var hasProof: Bool {return self._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  mutating func clearProof() {self._proof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proof: Babylon_Btcstaking_V1_InclusionProof? = nil
}

/// BTCStakingConsumerEvent defines the structure for storing BTC staking events
/// which will be later sent to consumer chains as IBC packets.
struct Babylon_Btcstaking_V1_BTCStakingConsumerEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof event represents a mutually exclusive choice among different event types.
  /// Only one event type can be set within each BTCStakingEvent message instance.
  var event: Babylon_Btcstaking_V1_BTCStakingConsumerEvent.OneOf_Event? = nil

  /// NewFinalityProvider represents the event of a new finality provider being created.
  var newFp: Babylon_Btcstaking_V1_NewFinalityProvider {
    get {
      if case .newFp(let v)? = event {return v}
      return Babylon_Btcstaking_V1_NewFinalityProvider()
    }
    set {event = .newFp(newValue)}
  }

  /// ActiveBTCDelegation represents the event of an active BTC delegation.
  var activeDel: Babylon_Btcstaking_V1_ActiveBTCDelegation {
    get {
      if case .activeDel(let v)? = event {return v}
      return Babylon_Btcstaking_V1_ActiveBTCDelegation()
    }
    set {event = .activeDel(newValue)}
  }

  /// SlashedBTCDelegation represents the event of a slashed BTC delegation.
  var slashedDel: Babylon_Btcstaking_V1_SlashedBTCDelegation {
    get {
      if case .slashedDel(let v)? = event {return v}
      return Babylon_Btcstaking_V1_SlashedBTCDelegation()
    }
    set {event = .slashedDel(newValue)}
  }

  /// UnbondedBTCDelegation represents the event of an unbonded BTC delegation.
  var unbondedDel: Babylon_Btcstaking_V1_UnbondedBTCDelegation {
    get {
      if case .unbondedDel(let v)? = event {return v}
      return Babylon_Btcstaking_V1_UnbondedBTCDelegation()
    }
    set {event = .unbondedDel(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// oneof event represents a mutually exclusive choice among different event types.
  /// Only one event type can be set within each BTCStakingEvent message instance.
  enum OneOf_Event: Equatable {
    /// NewFinalityProvider represents the event of a new finality provider being created.
    case newFp(Babylon_Btcstaking_V1_NewFinalityProvider)
    /// ActiveBTCDelegation represents the event of an active BTC delegation.
    case activeDel(Babylon_Btcstaking_V1_ActiveBTCDelegation)
    /// SlashedBTCDelegation represents the event of a slashed BTC delegation.
    case slashedDel(Babylon_Btcstaking_V1_SlashedBTCDelegation)
    /// UnbondedBTCDelegation represents the event of an unbonded BTC delegation.
    case unbondedDel(Babylon_Btcstaking_V1_UnbondedBTCDelegation)

  #if !swift(>=4.1)
    static func ==(lhs: Babylon_Btcstaking_V1_BTCStakingConsumerEvent.OneOf_Event, rhs: Babylon_Btcstaking_V1_BTCStakingConsumerEvent.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.newFp, .newFp): return {
        guard case .newFp(let l) = lhs, case .newFp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.activeDel, .activeDel): return {
        guard case .activeDel(let l) = lhs, case .activeDel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.slashedDel, .slashedDel): return {
        guard case .slashedDel(let l) = lhs, case .slashedDel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unbondedDel, .unbondedDel): return {
        guard case .unbondedDel(let l) = lhs, case .unbondedDel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Babylon_Btcstaking_V1_SlashedFinalityProvider: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_BTCStakingIBCPacket: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_NewFinalityProvider: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_ActiveBTCDelegation: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_BTCUndelegationInfo: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_SlashedBTCDelegation: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_UnbondedBTCDelegation: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_BTCStakingConsumerEvent: @unchecked Sendable {}
extension Babylon_Btcstaking_V1_BTCStakingConsumerEvent.OneOf_Event: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "babylon.btcstaking.v1"

extension Babylon_Btcstaking_V1_SlashedFinalityProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlashedFinalityProvider"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "btc_pk_hex"),
    2: .standard(proto: "recovered_fp_btc_sk"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.btcPkHex) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.recoveredFpBtcSk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.btcPkHex.isEmpty {
      try visitor.visitSingularStringField(value: self.btcPkHex, fieldNumber: 1)
    }
    if !self.recoveredFpBtcSk.isEmpty {
      try visitor.visitSingularStringField(value: self.recoveredFpBtcSk, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_SlashedFinalityProvider, rhs: Babylon_Btcstaking_V1_SlashedFinalityProvider) -> Bool {
    if lhs.btcPkHex != rhs.btcPkHex {return false}
    if lhs.recoveredFpBtcSk != rhs.recoveredFpBtcSk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_BTCStakingIBCPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BTCStakingIBCPacket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_fp"),
    2: .standard(proto: "active_del"),
    3: .standard(proto: "slashed_del"),
    4: .standard(proto: "unbonded_del"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.newFp) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.activeDel) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.slashedDel) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.unbondedDel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newFp.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newFp, fieldNumber: 1)
    }
    if !self.activeDel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activeDel, fieldNumber: 2)
    }
    if !self.slashedDel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slashedDel, fieldNumber: 3)
    }
    if !self.unbondedDel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unbondedDel, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_BTCStakingIBCPacket, rhs: Babylon_Btcstaking_V1_BTCStakingIBCPacket) -> Bool {
    if lhs.newFp != rhs.newFp {return false}
    if lhs.activeDel != rhs.activeDel {return false}
    if lhs.slashedDel != rhs.slashedDel {return false}
    if lhs.unbondedDel != rhs.unbondedDel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_NewFinalityProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewFinalityProvider"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "commission"),
    3: .same(proto: "addr"),
    4: .standard(proto: "btc_pk_hex"),
    5: .same(proto: "pop"),
    8: .standard(proto: "consumer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._description_p) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.commission) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.btcPkHex) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._pop) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.consumerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.commission.isEmpty {
      try visitor.visitSingularStringField(value: self.commission, fieldNumber: 2)
    }
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 3)
    }
    if !self.btcPkHex.isEmpty {
      try visitor.visitSingularStringField(value: self.btcPkHex, fieldNumber: 4)
    }
    try { if let v = self._pop {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.consumerID.isEmpty {
      try visitor.visitSingularStringField(value: self.consumerID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_NewFinalityProvider, rhs: Babylon_Btcstaking_V1_NewFinalityProvider) -> Bool {
    if lhs._description_p != rhs._description_p {return false}
    if lhs.commission != rhs.commission {return false}
    if lhs.addr != rhs.addr {return false}
    if lhs.btcPkHex != rhs.btcPkHex {return false}
    if lhs._pop != rhs._pop {return false}
    if lhs.consumerID != rhs.consumerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_ActiveBTCDelegation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActiveBTCDelegation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staker_addr"),
    2: .standard(proto: "btc_pk_hex"),
    3: .standard(proto: "fp_btc_pk_list"),
    4: .standard(proto: "start_height"),
    5: .standard(proto: "end_height"),
    6: .standard(proto: "total_sat"),
    7: .standard(proto: "staking_tx"),
    8: .standard(proto: "slashing_tx"),
    9: .standard(proto: "delegator_slashing_sig"),
    10: .standard(proto: "covenant_sigs"),
    11: .standard(proto: "staking_output_idx"),
    12: .standard(proto: "unbonding_time"),
    13: .standard(proto: "undelegation_info"),
    14: .standard(proto: "params_version"),
  ]

  fileprivate class _StorageClass {
    var _stakerAddr: String = String()
    var _btcPkHex: String = String()
    var _fpBtcPkList: [String] = []
    var _startHeight: UInt32 = 0
    var _endHeight: UInt32 = 0
    var _totalSat: UInt64 = 0
    var _stakingTx: Data = Data()
    var _slashingTx: Data = Data()
    var _delegatorSlashingSig: Data = Data()
    var _covenantSigs: [Babylon_Btcstaking_V1_CovenantAdaptorSignatures] = []
    var _stakingOutputIdx: UInt32 = 0
    var _unbondingTime: UInt32 = 0
    var _undelegationInfo: Babylon_Btcstaking_V1_BTCUndelegationInfo? = nil
    var _paramsVersion: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _stakerAddr = source._stakerAddr
      _btcPkHex = source._btcPkHex
      _fpBtcPkList = source._fpBtcPkList
      _startHeight = source._startHeight
      _endHeight = source._endHeight
      _totalSat = source._totalSat
      _stakingTx = source._stakingTx
      _slashingTx = source._slashingTx
      _delegatorSlashingSig = source._delegatorSlashingSig
      _covenantSigs = source._covenantSigs
      _stakingOutputIdx = source._stakingOutputIdx
      _unbondingTime = source._unbondingTime
      _undelegationInfo = source._undelegationInfo
      _paramsVersion = source._paramsVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._stakerAddr) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._btcPkHex) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._fpBtcPkList) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._startHeight) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._endHeight) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalSat) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._stakingTx) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._slashingTx) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._delegatorSlashingSig) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._covenantSigs) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._stakingOutputIdx) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._unbondingTime) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._undelegationInfo) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._paramsVersion) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._stakerAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stakerAddr, fieldNumber: 1)
      }
      if !_storage._btcPkHex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._btcPkHex, fieldNumber: 2)
      }
      if !_storage._fpBtcPkList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._fpBtcPkList, fieldNumber: 3)
      }
      if _storage._startHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._startHeight, fieldNumber: 4)
      }
      if _storage._endHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._endHeight, fieldNumber: 5)
      }
      if _storage._totalSat != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalSat, fieldNumber: 6)
      }
      if !_storage._stakingTx.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._stakingTx, fieldNumber: 7)
      }
      if !_storage._slashingTx.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._slashingTx, fieldNumber: 8)
      }
      if !_storage._delegatorSlashingSig.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._delegatorSlashingSig, fieldNumber: 9)
      }
      if !_storage._covenantSigs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._covenantSigs, fieldNumber: 10)
      }
      if _storage._stakingOutputIdx != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._stakingOutputIdx, fieldNumber: 11)
      }
      if _storage._unbondingTime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._unbondingTime, fieldNumber: 12)
      }
      try { if let v = _storage._undelegationInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if _storage._paramsVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._paramsVersion, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_ActiveBTCDelegation, rhs: Babylon_Btcstaking_V1_ActiveBTCDelegation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._stakerAddr != rhs_storage._stakerAddr {return false}
        if _storage._btcPkHex != rhs_storage._btcPkHex {return false}
        if _storage._fpBtcPkList != rhs_storage._fpBtcPkList {return false}
        if _storage._startHeight != rhs_storage._startHeight {return false}
        if _storage._endHeight != rhs_storage._endHeight {return false}
        if _storage._totalSat != rhs_storage._totalSat {return false}
        if _storage._stakingTx != rhs_storage._stakingTx {return false}
        if _storage._slashingTx != rhs_storage._slashingTx {return false}
        if _storage._delegatorSlashingSig != rhs_storage._delegatorSlashingSig {return false}
        if _storage._covenantSigs != rhs_storage._covenantSigs {return false}
        if _storage._stakingOutputIdx != rhs_storage._stakingOutputIdx {return false}
        if _storage._unbondingTime != rhs_storage._unbondingTime {return false}
        if _storage._undelegationInfo != rhs_storage._undelegationInfo {return false}
        if _storage._paramsVersion != rhs_storage._paramsVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_BTCUndelegationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BTCUndelegationInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unbonding_tx"),
    2: .standard(proto: "slashing_tx"),
    3: .standard(proto: "delegator_slashing_sig"),
    4: .standard(proto: "covenant_slashing_sigs"),
    5: .standard(proto: "covenant_unbonding_sig_list"),
    6: .standard(proto: "delegator_unbonding_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.unbondingTx) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.slashingTx) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.delegatorSlashingSig) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.covenantSlashingSigs) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.covenantUnbondingSigList) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._delegatorUnbondingInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.unbondingTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.unbondingTx, fieldNumber: 1)
    }
    if !self.slashingTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.slashingTx, fieldNumber: 2)
    }
    if !self.delegatorSlashingSig.isEmpty {
      try visitor.visitSingularBytesField(value: self.delegatorSlashingSig, fieldNumber: 3)
    }
    if !self.covenantSlashingSigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.covenantSlashingSigs, fieldNumber: 4)
    }
    if !self.covenantUnbondingSigList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.covenantUnbondingSigList, fieldNumber: 5)
    }
    try { if let v = self._delegatorUnbondingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_BTCUndelegationInfo, rhs: Babylon_Btcstaking_V1_BTCUndelegationInfo) -> Bool {
    if lhs.unbondingTx != rhs.unbondingTx {return false}
    if lhs.slashingTx != rhs.slashingTx {return false}
    if lhs.delegatorSlashingSig != rhs.delegatorSlashingSig {return false}
    if lhs.covenantSlashingSigs != rhs.covenantSlashingSigs {return false}
    if lhs.covenantUnbondingSigList != rhs.covenantUnbondingSigList {return false}
    if lhs._delegatorUnbondingInfo != rhs._delegatorUnbondingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_SlashedBTCDelegation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlashedBTCDelegation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staking_tx_hash"),
    2: .standard(proto: "recovered_fp_btc_sk"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stakingTxHash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.recoveredFpBtcSk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stakingTxHash.isEmpty {
      try visitor.visitSingularStringField(value: self.stakingTxHash, fieldNumber: 1)
    }
    if !self.recoveredFpBtcSk.isEmpty {
      try visitor.visitSingularStringField(value: self.recoveredFpBtcSk, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_SlashedBTCDelegation, rhs: Babylon_Btcstaking_V1_SlashedBTCDelegation) -> Bool {
    if lhs.stakingTxHash != rhs.stakingTxHash {return false}
    if lhs.recoveredFpBtcSk != rhs.recoveredFpBtcSk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_UnbondedBTCDelegation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnbondedBTCDelegation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staking_tx_hash"),
    2: .standard(proto: "unbonding_tx_sig"),
    3: .standard(proto: "stake_spending_tx"),
    4: .same(proto: "proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stakingTxHash) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.unbondingTxSig) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.stakeSpendingTx) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._proof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.stakingTxHash.isEmpty {
      try visitor.visitSingularStringField(value: self.stakingTxHash, fieldNumber: 1)
    }
    if !self.unbondingTxSig.isEmpty {
      try visitor.visitSingularBytesField(value: self.unbondingTxSig, fieldNumber: 2)
    }
    if !self.stakeSpendingTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.stakeSpendingTx, fieldNumber: 3)
    }
    try { if let v = self._proof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_UnbondedBTCDelegation, rhs: Babylon_Btcstaking_V1_UnbondedBTCDelegation) -> Bool {
    if lhs.stakingTxHash != rhs.stakingTxHash {return false}
    if lhs.unbondingTxSig != rhs.unbondingTxSig {return false}
    if lhs.stakeSpendingTx != rhs.stakeSpendingTx {return false}
    if lhs._proof != rhs._proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Btcstaking_V1_BTCStakingConsumerEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BTCStakingConsumerEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_fp"),
    2: .standard(proto: "active_del"),
    3: .standard(proto: "slashed_del"),
    4: .standard(proto: "unbonded_del"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Babylon_Btcstaking_V1_NewFinalityProvider?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .newFp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .newFp(v)
        }
      }()
      case 2: try {
        var v: Babylon_Btcstaking_V1_ActiveBTCDelegation?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .activeDel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .activeDel(v)
        }
      }()
      case 3: try {
        var v: Babylon_Btcstaking_V1_SlashedBTCDelegation?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .slashedDel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .slashedDel(v)
        }
      }()
      case 4: try {
        var v: Babylon_Btcstaking_V1_UnbondedBTCDelegation?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .unbondedDel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .unbondedDel(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .newFp?: try {
      guard case .newFp(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .activeDel?: try {
      guard case .activeDel(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .slashedDel?: try {
      guard case .slashedDel(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .unbondedDel?: try {
      guard case .unbondedDel(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Btcstaking_V1_BTCStakingConsumerEvent, rhs: Babylon_Btcstaking_V1_BTCStakingConsumerEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
