// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: axelar/evm/v1beta1/events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Axelar_Evm_V1beta1_PollFailed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: Data = Data()

  var chain: String = String()

  var pollID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_PollExpired {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: Data = Data()

  var chain: String = String()

  var pollID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_PollCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: Data = Data()

  var chain: String = String()

  var pollID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_NoEventsConfirmed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: Data = Data()

  var chain: String = String()

  var pollID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_ConfirmKeyTransferStarted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var txID: Data = Data()

  var gatewayAddress: Data = Data()

  var confirmationHeight: UInt64 = 0

  var participants: Axelar_Vote_Exported_V1beta1_PollParticipants {
    get {return _participants ?? Axelar_Vote_Exported_V1beta1_PollParticipants()}
    set {_participants = newValue}
  }
  /// Returns true if `participants` has been explicitly set.
  var hasParticipants: Bool {return self._participants != nil}
  /// Clears the value of `participants`. Subsequent reads from it will return its default value.
  mutating func clearParticipants() {self._participants = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _participants: Axelar_Vote_Exported_V1beta1_PollParticipants? = nil
}

struct Axelar_Evm_V1beta1_ConfirmGatewayTxStarted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: Data = Data()

  var chain: String = String()

  var gatewayAddress: Data = Data()

  var confirmationHeight: UInt64 = 0

  var participants: Axelar_Vote_Exported_V1beta1_PollParticipants {
    get {return _participants ?? Axelar_Vote_Exported_V1beta1_PollParticipants()}
    set {_participants = newValue}
  }
  /// Returns true if `participants` has been explicitly set.
  var hasParticipants: Bool {return self._participants != nil}
  /// Clears the value of `participants`. Subsequent reads from it will return its default value.
  mutating func clearParticipants() {self._participants = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _participants: Axelar_Vote_Exported_V1beta1_PollParticipants? = nil
}

struct Axelar_Evm_V1beta1_PollMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: Data = Data()

  var pollID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_ConfirmGatewayTxsStarted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pollMappings: [Axelar_Evm_V1beta1_PollMapping] = []

  var chain: String = String()

  var gatewayAddress: Data = Data()

  var confirmationHeight: UInt64 = 0

  var participants: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_ConfirmDepositStarted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: Data = Data()

  var chain: String = String()

  var depositAddress: Data = Data()

  var tokenAddress: Data = Data()

  var confirmationHeight: UInt64 = 0

  var participants: Axelar_Vote_Exported_V1beta1_PollParticipants {
    get {return _participants ?? Axelar_Vote_Exported_V1beta1_PollParticipants()}
    set {_participants = newValue}
  }
  /// Returns true if `participants` has been explicitly set.
  var hasParticipants: Bool {return self._participants != nil}
  /// Clears the value of `participants`. Subsequent reads from it will return its default value.
  mutating func clearParticipants() {self._participants = nil}

  var asset: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _participants: Axelar_Vote_Exported_V1beta1_PollParticipants? = nil
}

struct Axelar_Evm_V1beta1_ConfirmTokenStarted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txID: Data = Data()

  var chain: String = String()

  var gatewayAddress: Data = Data()

  var tokenAddress: Data = Data()

  var tokenDetails: Axelar_Evm_V1beta1_TokenDetails {
    get {return _tokenDetails ?? Axelar_Evm_V1beta1_TokenDetails()}
    set {_tokenDetails = newValue}
  }
  /// Returns true if `tokenDetails` has been explicitly set.
  var hasTokenDetails: Bool {return self._tokenDetails != nil}
  /// Clears the value of `tokenDetails`. Subsequent reads from it will return its default value.
  mutating func clearTokenDetails() {self._tokenDetails = nil}

  var confirmationHeight: UInt64 = 0

  var participants: Axelar_Vote_Exported_V1beta1_PollParticipants {
    get {return _participants ?? Axelar_Vote_Exported_V1beta1_PollParticipants()}
    set {_participants = newValue}
  }
  /// Returns true if `participants` has been explicitly set.
  var hasParticipants: Bool {return self._participants != nil}
  /// Clears the value of `participants`. Subsequent reads from it will return its default value.
  mutating func clearParticipants() {self._participants = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tokenDetails: Axelar_Evm_V1beta1_TokenDetails? = nil
  fileprivate var _participants: Axelar_Vote_Exported_V1beta1_PollParticipants? = nil
}

struct Axelar_Evm_V1beta1_ChainAdded {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_CommandBatchSigned {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var commandBatchID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_CommandBatchAborted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var commandBatchID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_EVMEventConfirmed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var eventID: String = String()

  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_EVMEventCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var eventID: String = String()

  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_EVMEventFailed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var eventID: String = String()

  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_EVMEventRetryFailed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var eventID: String = String()

  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_ContractCallApproved {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var eventID: String = String()

  var commandID: Data = Data()

  var sender: String = String()

  var destinationChain: String = String()

  var contractAddress: String = String()

  var payloadHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_ContractCallFailed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var msgID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Evm_V1beta1_ContractCallWithMintApproved {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var eventID: String = String()

  var commandID: Data = Data()

  var sender: String = String()

  var destinationChain: String = String()

  var contractAddress: String = String()

  var payloadHash: Data = Data()

  var asset: Cosmos_Base_V1beta1_Coin {
    get {return _asset ?? Cosmos_Base_V1beta1_Coin()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Cosmos_Base_V1beta1_Coin? = nil
}

struct Axelar_Evm_V1beta1_TokenSent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var eventID: String = String()

  var transferID: UInt64 = 0

  var sender: String = String()

  var destinationChain: String = String()

  var destinationAddress: String = String()

  var asset: Cosmos_Base_V1beta1_Coin {
    get {return _asset ?? Cosmos_Base_V1beta1_Coin()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Cosmos_Base_V1beta1_Coin? = nil
}

struct Axelar_Evm_V1beta1_MintCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var transferID: UInt64 = 0

  var commandID: Data = Data()

  var destinationChain: String = String()

  var destinationAddress: String = String()

  var asset: Cosmos_Base_V1beta1_Coin {
    get {return _asset ?? Cosmos_Base_V1beta1_Coin()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {self._asset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asset: Cosmos_Base_V1beta1_Coin? = nil
}

struct Axelar_Evm_V1beta1_BurnCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var commandID: Data = Data()

  var destinationChain: String = String()

  var depositAddress: String = String()

  var asset: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Axelar_Evm_V1beta1_PollFailed: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_PollExpired: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_PollCompleted: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_NoEventsConfirmed: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_ConfirmKeyTransferStarted: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_ConfirmGatewayTxStarted: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_PollMapping: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_ConfirmGatewayTxsStarted: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_ConfirmDepositStarted: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_ConfirmTokenStarted: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_ChainAdded: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_CommandBatchSigned: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_CommandBatchAborted: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_EVMEventConfirmed: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_EVMEventCompleted: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_EVMEventFailed: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_EVMEventRetryFailed: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_ContractCallApproved: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_ContractCallFailed: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_ContractCallWithMintApproved: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_TokenSent: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_MintCommand: @unchecked Sendable {}
extension Axelar_Evm_V1beta1_BurnCommand: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "axelar.evm.v1beta1"

extension Axelar_Evm_V1beta1_PollFailed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PollFailed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .same(proto: "chain"),
    3: .standard(proto: "poll_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.pollID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 1)
    }
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 2)
    }
    if self.pollID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pollID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_PollFailed, rhs: Axelar_Evm_V1beta1_PollFailed) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.pollID != rhs.pollID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_PollExpired: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PollExpired"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .same(proto: "chain"),
    3: .standard(proto: "poll_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.pollID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 1)
    }
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 2)
    }
    if self.pollID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pollID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_PollExpired, rhs: Axelar_Evm_V1beta1_PollExpired) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.pollID != rhs.pollID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_PollCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PollCompleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .same(proto: "chain"),
    3: .standard(proto: "poll_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.pollID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 1)
    }
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 2)
    }
    if self.pollID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pollID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_PollCompleted, rhs: Axelar_Evm_V1beta1_PollCompleted) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.pollID != rhs.pollID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_NoEventsConfirmed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NoEventsConfirmed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .same(proto: "chain"),
    3: .standard(proto: "poll_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.pollID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 1)
    }
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 2)
    }
    if self.pollID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pollID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_NoEventsConfirmed, rhs: Axelar_Evm_V1beta1_NoEventsConfirmed) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.pollID != rhs.pollID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_ConfirmKeyTransferStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmKeyTransferStarted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "tx_id"),
    3: .standard(proto: "gateway_address"),
    4: .standard(proto: "confirmation_height"),
    5: .same(proto: "participants"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.gatewayAddress) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.confirmationHeight) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._participants) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 2)
    }
    if !self.gatewayAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.gatewayAddress, fieldNumber: 3)
    }
    if self.confirmationHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.confirmationHeight, fieldNumber: 4)
    }
    try { if let v = self._participants {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_ConfirmKeyTransferStarted, rhs: Axelar_Evm_V1beta1_ConfirmKeyTransferStarted) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.txID != rhs.txID {return false}
    if lhs.gatewayAddress != rhs.gatewayAddress {return false}
    if lhs.confirmationHeight != rhs.confirmationHeight {return false}
    if lhs._participants != rhs._participants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_ConfirmGatewayTxStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmGatewayTxStarted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .same(proto: "chain"),
    3: .standard(proto: "gateway_address"),
    4: .standard(proto: "confirmation_height"),
    5: .same(proto: "participants"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.gatewayAddress) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.confirmationHeight) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._participants) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 1)
    }
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 2)
    }
    if !self.gatewayAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.gatewayAddress, fieldNumber: 3)
    }
    if self.confirmationHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.confirmationHeight, fieldNumber: 4)
    }
    try { if let v = self._participants {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_ConfirmGatewayTxStarted, rhs: Axelar_Evm_V1beta1_ConfirmGatewayTxStarted) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.gatewayAddress != rhs.gatewayAddress {return false}
    if lhs.confirmationHeight != rhs.confirmationHeight {return false}
    if lhs._participants != rhs._participants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_PollMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PollMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .standard(proto: "poll_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.pollID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 1)
    }
    if self.pollID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pollID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_PollMapping, rhs: Axelar_Evm_V1beta1_PollMapping) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.pollID != rhs.pollID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_ConfirmGatewayTxsStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmGatewayTxsStarted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "poll_mappings"),
    2: .same(proto: "chain"),
    3: .standard(proto: "gateway_address"),
    4: .standard(proto: "confirmation_height"),
    5: .same(proto: "participants"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pollMappings) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.gatewayAddress) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.confirmationHeight) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.participants) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pollMappings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pollMappings, fieldNumber: 1)
    }
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 2)
    }
    if !self.gatewayAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.gatewayAddress, fieldNumber: 3)
    }
    if self.confirmationHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.confirmationHeight, fieldNumber: 4)
    }
    if !self.participants.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.participants, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_ConfirmGatewayTxsStarted, rhs: Axelar_Evm_V1beta1_ConfirmGatewayTxsStarted) -> Bool {
    if lhs.pollMappings != rhs.pollMappings {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.gatewayAddress != rhs.gatewayAddress {return false}
    if lhs.confirmationHeight != rhs.confirmationHeight {return false}
    if lhs.participants != rhs.participants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_ConfirmDepositStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmDepositStarted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .same(proto: "chain"),
    3: .standard(proto: "deposit_address"),
    4: .standard(proto: "token_address"),
    5: .standard(proto: "confirmation_height"),
    6: .same(proto: "participants"),
    7: .same(proto: "asset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.depositAddress) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.tokenAddress) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.confirmationHeight) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._participants) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.asset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 1)
    }
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 2)
    }
    if !self.depositAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.depositAddress, fieldNumber: 3)
    }
    if !self.tokenAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenAddress, fieldNumber: 4)
    }
    if self.confirmationHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.confirmationHeight, fieldNumber: 5)
    }
    try { if let v = self._participants {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.asset.isEmpty {
      try visitor.visitSingularStringField(value: self.asset, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_ConfirmDepositStarted, rhs: Axelar_Evm_V1beta1_ConfirmDepositStarted) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.depositAddress != rhs.depositAddress {return false}
    if lhs.tokenAddress != rhs.tokenAddress {return false}
    if lhs.confirmationHeight != rhs.confirmationHeight {return false}
    if lhs._participants != rhs._participants {return false}
    if lhs.asset != rhs.asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_ConfirmTokenStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmTokenStarted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .same(proto: "chain"),
    3: .standard(proto: "gateway_address"),
    4: .standard(proto: "token_address"),
    5: .standard(proto: "token_details"),
    6: .standard(proto: "confirmation_height"),
    7: .same(proto: "participants"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.gatewayAddress) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.tokenAddress) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._tokenDetails) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.confirmationHeight) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._participants) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 1)
    }
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 2)
    }
    if !self.gatewayAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.gatewayAddress, fieldNumber: 3)
    }
    if !self.tokenAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenAddress, fieldNumber: 4)
    }
    try { if let v = self._tokenDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.confirmationHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.confirmationHeight, fieldNumber: 6)
    }
    try { if let v = self._participants {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_ConfirmTokenStarted, rhs: Axelar_Evm_V1beta1_ConfirmTokenStarted) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.gatewayAddress != rhs.gatewayAddress {return false}
    if lhs.tokenAddress != rhs.tokenAddress {return false}
    if lhs._tokenDetails != rhs._tokenDetails {return false}
    if lhs.confirmationHeight != rhs.confirmationHeight {return false}
    if lhs._participants != rhs._participants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_ChainAdded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainAdded"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_ChainAdded, rhs: Axelar_Evm_V1beta1_ChainAdded) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_CommandBatchSigned: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandBatchSigned"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "chain"),
    3: .standard(proto: "command_batch_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.commandBatchID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 2)
    }
    if !self.commandBatchID.isEmpty {
      try visitor.visitSingularBytesField(value: self.commandBatchID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_CommandBatchSigned, rhs: Axelar_Evm_V1beta1_CommandBatchSigned) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.commandBatchID != rhs.commandBatchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_CommandBatchAborted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandBatchAborted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "chain"),
    3: .standard(proto: "command_batch_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.commandBatchID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 2)
    }
    if !self.commandBatchID.isEmpty {
      try visitor.visitSingularBytesField(value: self.commandBatchID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_CommandBatchAborted, rhs: Axelar_Evm_V1beta1_CommandBatchAborted) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.commandBatchID != rhs.commandBatchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_EVMEventConfirmed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EVMEventConfirmed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "event_id"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_EVMEventConfirmed, rhs: Axelar_Evm_V1beta1_EVMEventConfirmed) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_EVMEventCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EVMEventCompleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "event_id"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_EVMEventCompleted, rhs: Axelar_Evm_V1beta1_EVMEventCompleted) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_EVMEventFailed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EVMEventFailed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "event_id"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_EVMEventFailed, rhs: Axelar_Evm_V1beta1_EVMEventFailed) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_EVMEventRetryFailed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EVMEventRetryFailed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "event_id"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_EVMEventRetryFailed, rhs: Axelar_Evm_V1beta1_EVMEventRetryFailed) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_ContractCallApproved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractCallApproved"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "event_id"),
    3: .standard(proto: "command_id"),
    4: .same(proto: "sender"),
    5: .standard(proto: "destination_chain"),
    6: .standard(proto: "contract_address"),
    7: .standard(proto: "payload_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.commandID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.destinationChain) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.payloadHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 2)
    }
    if !self.commandID.isEmpty {
      try visitor.visitSingularBytesField(value: self.commandID, fieldNumber: 3)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 4)
    }
    if !self.destinationChain.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationChain, fieldNumber: 5)
    }
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 6)
    }
    if !self.payloadHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.payloadHash, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_ContractCallApproved, rhs: Axelar_Evm_V1beta1_ContractCallApproved) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.commandID != rhs.commandID {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.destinationChain != rhs.destinationChain {return false}
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.payloadHash != rhs.payloadHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_ContractCallFailed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractCallFailed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "msg_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_ContractCallFailed, rhs: Axelar_Evm_V1beta1_ContractCallFailed) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.msgID != rhs.msgID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_ContractCallWithMintApproved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractCallWithMintApproved"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "event_id"),
    3: .standard(proto: "command_id"),
    4: .same(proto: "sender"),
    5: .standard(proto: "destination_chain"),
    6: .standard(proto: "contract_address"),
    7: .standard(proto: "payload_hash"),
    8: .same(proto: "asset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.commandID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.destinationChain) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.payloadHash) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 2)
    }
    if !self.commandID.isEmpty {
      try visitor.visitSingularBytesField(value: self.commandID, fieldNumber: 3)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 4)
    }
    if !self.destinationChain.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationChain, fieldNumber: 5)
    }
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 6)
    }
    if !self.payloadHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.payloadHash, fieldNumber: 7)
    }
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_ContractCallWithMintApproved, rhs: Axelar_Evm_V1beta1_ContractCallWithMintApproved) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.commandID != rhs.commandID {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.destinationChain != rhs.destinationChain {return false}
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.payloadHash != rhs.payloadHash {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_TokenSent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenSent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "event_id"),
    3: .standard(proto: "transfer_id"),
    4: .same(proto: "sender"),
    5: .standard(proto: "destination_chain"),
    6: .standard(proto: "destination_address"),
    7: .same(proto: "asset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.transferID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.destinationChain) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.destinationAddress) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 2)
    }
    if self.transferID != 0 {
      try visitor.visitSingularUInt64Field(value: self.transferID, fieldNumber: 3)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 4)
    }
    if !self.destinationChain.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationChain, fieldNumber: 5)
    }
    if !self.destinationAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationAddress, fieldNumber: 6)
    }
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_TokenSent, rhs: Axelar_Evm_V1beta1_TokenSent) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.transferID != rhs.transferID {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.destinationChain != rhs.destinationChain {return false}
    if lhs.destinationAddress != rhs.destinationAddress {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_MintCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MintCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "transfer_id"),
    3: .standard(proto: "command_id"),
    4: .standard(proto: "destination_chain"),
    5: .standard(proto: "destination_address"),
    6: .same(proto: "asset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.transferID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.commandID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.destinationChain) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.destinationAddress) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if self.transferID != 0 {
      try visitor.visitSingularUInt64Field(value: self.transferID, fieldNumber: 2)
    }
    if !self.commandID.isEmpty {
      try visitor.visitSingularBytesField(value: self.commandID, fieldNumber: 3)
    }
    if !self.destinationChain.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationChain, fieldNumber: 4)
    }
    if !self.destinationAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationAddress, fieldNumber: 5)
    }
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_MintCommand, rhs: Axelar_Evm_V1beta1_MintCommand) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.transferID != rhs.transferID {return false}
    if lhs.commandID != rhs.commandID {return false}
    if lhs.destinationChain != rhs.destinationChain {return false}
    if lhs.destinationAddress != rhs.destinationAddress {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Evm_V1beta1_BurnCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BurnCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "command_id"),
    3: .standard(proto: "destination_chain"),
    4: .standard(proto: "deposit_address"),
    5: .same(proto: "asset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.commandID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationChain) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.depositAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.asset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.commandID.isEmpty {
      try visitor.visitSingularBytesField(value: self.commandID, fieldNumber: 2)
    }
    if !self.destinationChain.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationChain, fieldNumber: 3)
    }
    if !self.depositAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.depositAddress, fieldNumber: 4)
    }
    if !self.asset.isEmpty {
      try visitor.visitSingularStringField(value: self.asset, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Evm_V1beta1_BurnCommand, rhs: Axelar_Evm_V1beta1_BurnCommand) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.commandID != rhs.commandID {return false}
    if lhs.destinationChain != rhs.destinationChain {return false}
    if lhs.depositAddress != rhs.depositAddress {return false}
    if lhs.asset != rhs.asset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
