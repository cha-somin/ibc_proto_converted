// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ixo/entity/v1beta1/entity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Ixo_Entity_V1beta1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nftContractAddress: String = String()

  var nftContractMinter: String = String()

  var createSequence: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Entity_V1beta1_Entity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id represents the id for the entity document.
  var id: String = String()

  /// Type of entity, eg protocol or asset
  var type: String = String()

  /// Start Date of the Entity as defined by the implementer and interpreted by
  /// Client applications
  var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  var hasStartDate: Bool {return self._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  mutating func clearStartDate() {self._startDate = nil}

  /// End Date of the Entity as defined by the implementer and interpreted by
  /// Client applications
  var endDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endDate = newValue}
  }
  /// Returns true if `endDate` has been explicitly set.
  var hasEndDate: Bool {return self._endDate != nil}
  /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
  mutating func clearEndDate() {self._endDate = nil}

  /// Status of the Entity as defined by the implementer and interpreted by
  /// Client applications
  var status: Int32 = 0

  /// Address of the operator through which the Entity was created
  var relayerNode: String = String()

  /// Credentials of the enitity to be verified
  var credentials: [String] = []

  /// Used as check whether the credentials of entity is verified
  var entityVerified: Bool = false

  /// Metadata concerning the Entity such as versionId, created, updated and
  /// deactivated
  var metadata: Ixo_Entity_V1beta1_EntityMetadata {
    get {return _metadata ?? Ixo_Entity_V1beta1_EntityMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// module accounts created for entity
  var accounts: [Ixo_Entity_V1beta1_EntityAccount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _metadata: Ixo_Entity_V1beta1_EntityMetadata? = nil
}

struct Ixo_Entity_V1beta1_EntityAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EntityMetadata defines metadata associated to a entity
struct Ixo_Entity_V1beta1_EntityMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var versionID: String = String()

  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return self._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {self._created = nil}

  var updated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updated = newValue}
  }
  /// Returns true if `updated` has been explicitly set.
  var hasUpdated: Bool {return self._updated != nil}
  /// Clears the value of `updated`. Subsequent reads from it will return its default value.
  mutating func clearUpdated() {self._updated = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Ixo_Entity_V1beta1_Params: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_Entity: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_EntityAccount: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_EntityMetadata: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ixo.entity.v1beta1"

extension Ixo_Entity_V1beta1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nftContractAddress"),
    2: .same(proto: "nftContractMinter"),
    3: .same(proto: "createSequence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nftContractAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nftContractMinter) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.createSequence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nftContractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.nftContractAddress, fieldNumber: 1)
    }
    if !self.nftContractMinter.isEmpty {
      try visitor.visitSingularStringField(value: self.nftContractMinter, fieldNumber: 2)
    }
    if self.createSequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.createSequence, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_Params, rhs: Ixo_Entity_V1beta1_Params) -> Bool {
    if lhs.nftContractAddress != rhs.nftContractAddress {return false}
    if lhs.nftContractMinter != rhs.nftContractMinter {return false}
    if lhs.createSequence != rhs.createSequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_Entity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Entity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "start_date"),
    4: .standard(proto: "end_date"),
    5: .same(proto: "status"),
    6: .standard(proto: "relayer_node"),
    7: .same(proto: "credentials"),
    8: .standard(proto: "entity_verified"),
    9: .same(proto: "metadata"),
    10: .same(proto: "accounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startDate) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._endDate) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.relayerNode) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.credentials) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.entityVerified) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._startDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._endDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 5)
    }
    if !self.relayerNode.isEmpty {
      try visitor.visitSingularStringField(value: self.relayerNode, fieldNumber: 6)
    }
    if !self.credentials.isEmpty {
      try visitor.visitRepeatedStringField(value: self.credentials, fieldNumber: 7)
    }
    if self.entityVerified != false {
      try visitor.visitSingularBoolField(value: self.entityVerified, fieldNumber: 8)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_Entity, rhs: Ixo_Entity_V1beta1_Entity) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs._startDate != rhs._startDate {return false}
    if lhs._endDate != rhs._endDate {return false}
    if lhs.status != rhs.status {return false}
    if lhs.relayerNode != rhs.relayerNode {return false}
    if lhs.credentials != rhs.credentials {return false}
    if lhs.entityVerified != rhs.entityVerified {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_EntityAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntityAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_EntityAccount, rhs: Ixo_Entity_V1beta1_EntityAccount) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_EntityMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntityMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_id"),
    2: .same(proto: "created"),
    3: .same(proto: "updated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._created) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 1)
    }
    try { if let v = self._created {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updated {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_EntityMetadata, rhs: Ixo_Entity_V1beta1_EntityMetadata) -> Bool {
    if lhs.versionID != rhs.versionID {return false}
    if lhs._created != rhs._created {return false}
    if lhs._updated != rhs._updated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
