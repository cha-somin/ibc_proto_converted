// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: zrchain/treasury/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Verification contains any data required to verify the incoming
/// data_fop_signing 1st case is to check the sighashes generated from the
/// supplied Bitcoin TX are correct
enum Zrchain_Treasury_VerificationVersion: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case bitcoinPlus // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .bitcoinPlus
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .bitcoinPlus: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Zrchain_Treasury_VerificationVersion: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Zrchain_Treasury_VerificationVersion] = [
    .unknown,
    .bitcoinPlus,
  ]
}

#endif  // swift(>=4.2)

/// Define an enum for Solana network types
enum Zrchain_Treasury_SolanaNetworkType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case undefined // = 0
  case mainnet // = 1
  case devnet // = 2
  case testnet // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .mainnet
    case 2: self = .devnet
    case 3: self = .testnet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .mainnet: return 1
    case .devnet: return 2
    case .testnet: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Zrchain_Treasury_SolanaNetworkType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Zrchain_Treasury_SolanaNetworkType] = [
    .undefined,
    .mainnet,
    .devnet,
    .testnet,
  ]
}

#endif  // swift(>=4.2)

/// MsgUpdateParams is the Msg/UpdateParams request type.
struct Zrchain_Treasury_MsgUpdateParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authority is the address that controls the module (defaults to x/gov unless
  /// overwritten).
  var authority: String = String()

  /// NOTE: All parameters must be supplied.
  var params: Zrchain_Treasury_Params {
    get {return _params ?? Zrchain_Treasury_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Zrchain_Treasury_Params? = nil
}

/// MsgUpdateParamsResponse defines the response structure for executing a
/// MsgUpdateParams message.
struct Zrchain_Treasury_MsgUpdateParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgNewKeyRequest is the Msg/NewKeyRequest request type.
struct Zrchain_Treasury_MsgNewKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var workspaceAddr: String = String()

  var keyringAddr: String = String()

  var keyType: String = String()

  var btl: UInt64 = 0

  var index: UInt64 = 0

  var extRequester: String = String()

  var extKeyType: UInt64 = 0

  var signPolicyID: UInt64 = 0

  /// Optional
  var zenbtcMetadata: Zrchain_Treasury_ZenBTCMetadata {
    get {return _zenbtcMetadata ?? Zrchain_Treasury_ZenBTCMetadata()}
    set {_zenbtcMetadata = newValue}
  }
  /// Returns true if `zenbtcMetadata` has been explicitly set.
  var hasZenbtcMetadata: Bool {return self._zenbtcMetadata != nil}
  /// Clears the value of `zenbtcMetadata`. Subsequent reads from it will return its default value.
  mutating func clearZenbtcMetadata() {self._zenbtcMetadata = nil}

  var mpcBtl: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _zenbtcMetadata: Zrchain_Treasury_ZenBTCMetadata? = nil
}

/// MsgNewKeyRequestResponse defines the response structure for executing a
/// MsgNewKeyRequest message.
struct Zrchain_Treasury_MsgNewKeyRequestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyReqID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgFulfilKeyRequest is the Msg/FulfilKeyRequest request type.
struct Zrchain_Treasury_MsgFulfilKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var requestID: UInt64 = 0

  var status: Zrchain_Treasury_KeyRequestStatus = .unspecified

  /// Holds the result of the request. If status is approved, the result will
  /// contain the requested key's public key that can be used for signing
  /// payloads.
  /// If status is rejected, the result will contain the reason.
  var result: Zrchain_Treasury_MsgFulfilKeyRequest.OneOf_Result? = nil

  var key: Zrchain_Treasury_MsgNewKey {
    get {
      if case .key(let v)? = result {return v}
      return Zrchain_Treasury_MsgNewKey()
    }
    set {result = .key(newValue)}
  }

  var rejectReason: String {
    get {
      if case .rejectReason(let v)? = result {return v}
      return String()
    }
    set {result = .rejectReason(newValue)}
  }

  var keyringPartySignature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Holds the result of the request. If status is approved, the result will
  /// contain the requested key's public key that can be used for signing
  /// payloads.
  /// If status is rejected, the result will contain the reason.
  enum OneOf_Result: Equatable {
    case key(Zrchain_Treasury_MsgNewKey)
    case rejectReason(String)

  #if !swift(>=4.1)
    static func ==(lhs: Zrchain_Treasury_MsgFulfilKeyRequest.OneOf_Result, rhs: Zrchain_Treasury_MsgFulfilKeyRequest.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.key, .key): return {
        guard case .key(let l) = lhs, case .key(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rejectReason, .rejectReason): return {
        guard case .rejectReason(let l) = lhs, case .rejectReason(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// MsgNewKey defines the attributes of a key
struct Zrchain_Treasury_MsgNewKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgNewKeyRequestResponse defines the response structure for executing a
/// MsgNewKeyRequest message.
struct Zrchain_Treasury_MsgFulfilKeyRequestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgNewSignatureRequest is the Msg/NewSignatureRequest request type.
struct Zrchain_Treasury_MsgNewSignatureRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var keyIds: [UInt64] = []

  var dataForSigning: String = String()

  var btl: UInt64 = 0

  var cacheID: Data = Data()

  var verifySigningData: Data = Data()

  var verifySigningDataVersion: Zrchain_Treasury_VerificationVersion = .unknown

  var mpcBtl: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgNewKeyRequestResponse defines the response structure for executing a
/// MsgNewKeyRequest message.
struct Zrchain_Treasury_MsgNewSignatureRequestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sigReqID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgFulfilSignatureRequest is the Msg/NewSignatureRequest request type.
struct Zrchain_Treasury_MsgFulfilSignatureRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var requestID: UInt64 = 0

  var status: Zrchain_Treasury_SignRequestStatus = .unspecified

  var keyringPartySignature: Data = Data()

  var signedData: Data = Data()

  var rejectReason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgFulfilSignatureRequestResponse defines the response structure for
/// executing a MsgFulfilSignatureRequest message.
struct Zrchain_Treasury_MsgFulfilSignatureRequestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MetadataEthereum defines the chain id
struct Zrchain_Treasury_MetadataEthereum {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chainID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MetadataSolana defines the network (i.e. mainnet, devnet, testnet) for a given transaction
struct Zrchain_Treasury_MetadataSolana {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var network: Zrchain_Treasury_SolanaNetworkType = .undefined

  var mintAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgNewSignTransactionRequest is the Msg/NewSignTransactionRequest request
/// type.
struct Zrchain_Treasury_MsgNewSignTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var keyID: UInt64 = 0

  var walletType: Zrchain_Treasury_WalletType = .unspecified

  var unsignedTransaction: Data = Data()

  /// Additional metadata required when parsing the unsigned transaction.
  var metadata: SwiftProtobuf.Google_Protobuf_Any {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var btl: UInt64 = 0

  var cacheID: Data = Data()

  var noBroadcast: Bool = false

  var mpcBtl: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// MsgNewSignTransactionRequestResponse defines the response structure for
/// executing a MsgNewSignTransactionRequest message.
struct Zrchain_Treasury_MsgNewSignTransactionRequestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var signatureRequestID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgTransferFromKeyring is the Msg/TransferFromKeyring request type.
struct Zrchain_Treasury_MsgTransferFromKeyring {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var keyring: String = String()

  var recipient: String = String()

  var amount: UInt64 = 0

  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgTransferFromKeyringResponse defines the response structure for executing a
/// MsgTransferFromKeyring message.
struct Zrchain_Treasury_MsgTransferFromKeyringResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// ---------------------
///  INTERCHAIN ACCOUNTS
/// ---------------------
///
/// MsgNewICATransactionRequest is the Msg/NewIcaTransactionRequest request type.
struct Zrchain_Treasury_MsgNewICATransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var keyID: UInt64 = 0

  var inputPayload: String = String()

  var connectionID: String = String()

  var relativeTimeoutTimestamp: UInt64 = 0

  var btl: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgNewICATransactionRequestResponse defines the response structure for
/// executing a MsgNewICATransactionRequest message.
struct Zrchain_Treasury_MsgNewICATransactionRequestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var signatureRequestID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgFulfilICATransactionRequest is the Msg/FulfilICATransactionRequest request
/// type.
struct Zrchain_Treasury_MsgFulfilICATransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var requestID: UInt64 = 0

  var status: Zrchain_Treasury_SignRequestStatus = .unspecified

  var keyringPartySignature: Data = Data()

  var signedData: Data = Data()

  var rejectReason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgFulfilICATransactionRequestResponse defines the response structure for
/// executing a MsgFulfilICATransactionRequest message.
struct Zrchain_Treasury_MsgFulfilICATransactionRequestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Zrchain_Treasury_MsgNewZrSignSignatureRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var address: String = String()

  var keyType: UInt64 = 0

  var walletIndex: UInt64 = 0

  var cacheID: Data = Data()

  var data: String = String()

  var verifySigningData: Data = Data()

  var verifySigningDataVersion: Zrchain_Treasury_VerificationVersion = .unknown

  var walletType: Zrchain_Treasury_WalletType = .unspecified

  var metadata: SwiftProtobuf.Google_Protobuf_Any {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var noBroadcast: Bool = false

  var btl: UInt64 = 0

  var tx: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Any? = nil
}

struct Zrchain_Treasury_MsgNewZrSignSignatureRequestResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reqID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Zrchain_Treasury_MsgUpdateKeyPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var keyID: UInt64 = 0

  var signPolicyID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Zrchain_Treasury_MsgUpdateKeyPolicyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Zrchain_Treasury_VerificationVersion: @unchecked Sendable {}
extension Zrchain_Treasury_SolanaNetworkType: @unchecked Sendable {}
extension Zrchain_Treasury_MsgUpdateParams: @unchecked Sendable {}
extension Zrchain_Treasury_MsgUpdateParamsResponse: @unchecked Sendable {}
extension Zrchain_Treasury_MsgNewKeyRequest: @unchecked Sendable {}
extension Zrchain_Treasury_MsgNewKeyRequestResponse: @unchecked Sendable {}
extension Zrchain_Treasury_MsgFulfilKeyRequest: @unchecked Sendable {}
extension Zrchain_Treasury_MsgFulfilKeyRequest.OneOf_Result: @unchecked Sendable {}
extension Zrchain_Treasury_MsgNewKey: @unchecked Sendable {}
extension Zrchain_Treasury_MsgFulfilKeyRequestResponse: @unchecked Sendable {}
extension Zrchain_Treasury_MsgNewSignatureRequest: @unchecked Sendable {}
extension Zrchain_Treasury_MsgNewSignatureRequestResponse: @unchecked Sendable {}
extension Zrchain_Treasury_MsgFulfilSignatureRequest: @unchecked Sendable {}
extension Zrchain_Treasury_MsgFulfilSignatureRequestResponse: @unchecked Sendable {}
extension Zrchain_Treasury_MetadataEthereum: @unchecked Sendable {}
extension Zrchain_Treasury_MetadataSolana: @unchecked Sendable {}
extension Zrchain_Treasury_MsgNewSignTransactionRequest: @unchecked Sendable {}
extension Zrchain_Treasury_MsgNewSignTransactionRequestResponse: @unchecked Sendable {}
extension Zrchain_Treasury_MsgTransferFromKeyring: @unchecked Sendable {}
extension Zrchain_Treasury_MsgTransferFromKeyringResponse: @unchecked Sendable {}
extension Zrchain_Treasury_MsgNewICATransactionRequest: @unchecked Sendable {}
extension Zrchain_Treasury_MsgNewICATransactionRequestResponse: @unchecked Sendable {}
extension Zrchain_Treasury_MsgFulfilICATransactionRequest: @unchecked Sendable {}
extension Zrchain_Treasury_MsgFulfilICATransactionRequestResponse: @unchecked Sendable {}
extension Zrchain_Treasury_MsgNewZrSignSignatureRequest: @unchecked Sendable {}
extension Zrchain_Treasury_MsgNewZrSignSignatureRequestResponse: @unchecked Sendable {}
extension Zrchain_Treasury_MsgUpdateKeyPolicy: @unchecked Sendable {}
extension Zrchain_Treasury_MsgUpdateKeyPolicyResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "zrchain.treasury"

extension Zrchain_Treasury_VerificationVersion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "BITCOIN_PLUS"),
  ]
}

extension Zrchain_Treasury_SolanaNetworkType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "MAINNET"),
    2: .same(proto: "DEVNET"),
    3: .same(proto: "TESTNET"),
  ]
}

extension Zrchain_Treasury_MsgUpdateParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgUpdateParams, rhs: Zrchain_Treasury_MsgUpdateParams) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgUpdateParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParamsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgUpdateParamsResponse, rhs: Zrchain_Treasury_MsgUpdateParamsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgNewKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewKeyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "workspace_addr"),
    3: .standard(proto: "keyring_addr"),
    4: .standard(proto: "key_type"),
    5: .same(proto: "btl"),
    6: .same(proto: "index"),
    7: .standard(proto: "ext_requester"),
    8: .standard(proto: "ext_key_type"),
    9: .standard(proto: "sign_policy_id"),
    10: .standard(proto: "zenbtc_metadata"),
    11: .standard(proto: "mpc_btl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workspaceAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyringAddr) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.keyType) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.btl) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.extRequester) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.extKeyType) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.signPolicyID) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._zenbtcMetadata) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.mpcBtl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.workspaceAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceAddr, fieldNumber: 2)
    }
    if !self.keyringAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.keyringAddr, fieldNumber: 3)
    }
    if !self.keyType.isEmpty {
      try visitor.visitSingularStringField(value: self.keyType, fieldNumber: 4)
    }
    if self.btl != 0 {
      try visitor.visitSingularUInt64Field(value: self.btl, fieldNumber: 5)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 6)
    }
    if !self.extRequester.isEmpty {
      try visitor.visitSingularStringField(value: self.extRequester, fieldNumber: 7)
    }
    if self.extKeyType != 0 {
      try visitor.visitSingularUInt64Field(value: self.extKeyType, fieldNumber: 8)
    }
    if self.signPolicyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.signPolicyID, fieldNumber: 9)
    }
    try { if let v = self._zenbtcMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if self.mpcBtl != 0 {
      try visitor.visitSingularUInt64Field(value: self.mpcBtl, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgNewKeyRequest, rhs: Zrchain_Treasury_MsgNewKeyRequest) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.workspaceAddr != rhs.workspaceAddr {return false}
    if lhs.keyringAddr != rhs.keyringAddr {return false}
    if lhs.keyType != rhs.keyType {return false}
    if lhs.btl != rhs.btl {return false}
    if lhs.index != rhs.index {return false}
    if lhs.extRequester != rhs.extRequester {return false}
    if lhs.extKeyType != rhs.extKeyType {return false}
    if lhs.signPolicyID != rhs.signPolicyID {return false}
    if lhs._zenbtcMetadata != rhs._zenbtcMetadata {return false}
    if lhs.mpcBtl != rhs.mpcBtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgNewKeyRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewKeyRequestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_req_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.keyReqID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyReqID != 0 {
      try visitor.visitSingularUInt64Field(value: self.keyReqID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgNewKeyRequestResponse, rhs: Zrchain_Treasury_MsgNewKeyRequestResponse) -> Bool {
    if lhs.keyReqID != rhs.keyReqID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgFulfilKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgFulfilKeyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "request_id"),
    3: .same(proto: "status"),
    4: .same(proto: "key"),
    5: .standard(proto: "reject_reason"),
    6: .standard(proto: "keyring_party_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.requestID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 4: try {
        var v: Zrchain_Treasury_MsgNewKey?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .key(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .key(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .rejectReason(v)
        }
      }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.keyringPartySignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.requestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestID, fieldNumber: 2)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    switch self.result {
    case .key?: try {
      guard case .key(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .rejectReason?: try {
      guard case .rejectReason(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if !self.keyringPartySignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.keyringPartySignature, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgFulfilKeyRequest, rhs: Zrchain_Treasury_MsgFulfilKeyRequest) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.result != rhs.result {return false}
    if lhs.keyringPartySignature != rhs.keyringPartySignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgNewKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgNewKey, rhs: Zrchain_Treasury_MsgNewKey) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgFulfilKeyRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgFulfilKeyRequestResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgFulfilKeyRequestResponse, rhs: Zrchain_Treasury_MsgFulfilKeyRequestResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgNewSignatureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewSignatureRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "key_ids"),
    3: .standard(proto: "data_for_signing"),
    4: .same(proto: "btl"),
    5: .standard(proto: "cache_id"),
    6: .standard(proto: "verify_signing_data"),
    7: .standard(proto: "verify_signing_data_version"),
    8: .standard(proto: "mpc_btl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.keyIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dataForSigning) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.btl) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.cacheID) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.verifySigningData) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.verifySigningDataVersion) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.mpcBtl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.keyIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.keyIds, fieldNumber: 2)
    }
    if !self.dataForSigning.isEmpty {
      try visitor.visitSingularStringField(value: self.dataForSigning, fieldNumber: 3)
    }
    if self.btl != 0 {
      try visitor.visitSingularUInt64Field(value: self.btl, fieldNumber: 4)
    }
    if !self.cacheID.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheID, fieldNumber: 5)
    }
    if !self.verifySigningData.isEmpty {
      try visitor.visitSingularBytesField(value: self.verifySigningData, fieldNumber: 6)
    }
    if self.verifySigningDataVersion != .unknown {
      try visitor.visitSingularEnumField(value: self.verifySigningDataVersion, fieldNumber: 7)
    }
    if self.mpcBtl != 0 {
      try visitor.visitSingularUInt64Field(value: self.mpcBtl, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgNewSignatureRequest, rhs: Zrchain_Treasury_MsgNewSignatureRequest) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.keyIds != rhs.keyIds {return false}
    if lhs.dataForSigning != rhs.dataForSigning {return false}
    if lhs.btl != rhs.btl {return false}
    if lhs.cacheID != rhs.cacheID {return false}
    if lhs.verifySigningData != rhs.verifySigningData {return false}
    if lhs.verifySigningDataVersion != rhs.verifySigningDataVersion {return false}
    if lhs.mpcBtl != rhs.mpcBtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgNewSignatureRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewSignatureRequestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sig_req_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.sigReqID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sigReqID != 0 {
      try visitor.visitSingularUInt64Field(value: self.sigReqID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgNewSignatureRequestResponse, rhs: Zrchain_Treasury_MsgNewSignatureRequestResponse) -> Bool {
    if lhs.sigReqID != rhs.sigReqID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgFulfilSignatureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgFulfilSignatureRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "request_id"),
    3: .same(proto: "status"),
    4: .standard(proto: "keyring_party_signature"),
    5: .standard(proto: "signed_data"),
    6: .standard(proto: "reject_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.requestID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.keyringPartySignature) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.signedData) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.rejectReason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.requestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestID, fieldNumber: 2)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if !self.keyringPartySignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.keyringPartySignature, fieldNumber: 4)
    }
    if !self.signedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedData, fieldNumber: 5)
    }
    if !self.rejectReason.isEmpty {
      try visitor.visitSingularStringField(value: self.rejectReason, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgFulfilSignatureRequest, rhs: Zrchain_Treasury_MsgFulfilSignatureRequest) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.keyringPartySignature != rhs.keyringPartySignature {return false}
    if lhs.signedData != rhs.signedData {return false}
    if lhs.rejectReason != rhs.rejectReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgFulfilSignatureRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgFulfilSignatureRequestResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgFulfilSignatureRequestResponse, rhs: Zrchain_Treasury_MsgFulfilSignatureRequestResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MetadataEthereum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetadataEthereum"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.chainID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chainID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chainID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MetadataEthereum, rhs: Zrchain_Treasury_MetadataEthereum) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MetadataSolana: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetadataSolana"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "network"),
    2: .same(proto: "mintAddress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.network) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mintAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.network != .undefined {
      try visitor.visitSingularEnumField(value: self.network, fieldNumber: 1)
    }
    if !self.mintAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.mintAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MetadataSolana, rhs: Zrchain_Treasury_MetadataSolana) -> Bool {
    if lhs.network != rhs.network {return false}
    if lhs.mintAddress != rhs.mintAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgNewSignTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewSignTransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "key_id"),
    3: .standard(proto: "wallet_type"),
    4: .standard(proto: "unsigned_transaction"),
    5: .same(proto: "metadata"),
    6: .same(proto: "btl"),
    7: .standard(proto: "cache_id"),
    8: .standard(proto: "no_broadcast"),
    9: .standard(proto: "mpc_btl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.keyID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.walletType) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.unsignedTransaction) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.btl) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.cacheID) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.noBroadcast) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.mpcBtl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.keyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.keyID, fieldNumber: 2)
    }
    if self.walletType != .unspecified {
      try visitor.visitSingularEnumField(value: self.walletType, fieldNumber: 3)
    }
    if !self.unsignedTransaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.unsignedTransaction, fieldNumber: 4)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.btl != 0 {
      try visitor.visitSingularUInt64Field(value: self.btl, fieldNumber: 6)
    }
    if !self.cacheID.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheID, fieldNumber: 7)
    }
    if self.noBroadcast != false {
      try visitor.visitSingularBoolField(value: self.noBroadcast, fieldNumber: 8)
    }
    if self.mpcBtl != 0 {
      try visitor.visitSingularUInt64Field(value: self.mpcBtl, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgNewSignTransactionRequest, rhs: Zrchain_Treasury_MsgNewSignTransactionRequest) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.walletType != rhs.walletType {return false}
    if lhs.unsignedTransaction != rhs.unsignedTransaction {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.btl != rhs.btl {return false}
    if lhs.cacheID != rhs.cacheID {return false}
    if lhs.noBroadcast != rhs.noBroadcast {return false}
    if lhs.mpcBtl != rhs.mpcBtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgNewSignTransactionRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewSignTransactionRequestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "signature_request_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.signatureRequestID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.signatureRequestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.signatureRequestID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgNewSignTransactionRequestResponse, rhs: Zrchain_Treasury_MsgNewSignTransactionRequestResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.signatureRequestID != rhs.signatureRequestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgTransferFromKeyring: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgTransferFromKeyring"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "keyring"),
    3: .same(proto: "recipient"),
    4: .same(proto: "amount"),
    5: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyring) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.recipient) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.keyring.isEmpty {
      try visitor.visitSingularStringField(value: self.keyring, fieldNumber: 2)
    }
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 3)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 4)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgTransferFromKeyring, rhs: Zrchain_Treasury_MsgTransferFromKeyring) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.keyring != rhs.keyring {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgTransferFromKeyringResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgTransferFromKeyringResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgTransferFromKeyringResponse, rhs: Zrchain_Treasury_MsgTransferFromKeyringResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgNewICATransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewICATransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "key_id"),
    3: .standard(proto: "input_payload"),
    4: .standard(proto: "connection_id"),
    5: .standard(proto: "relative_timeout_timestamp"),
    6: .same(proto: "btl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.keyID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.inputPayload) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.connectionID) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.relativeTimeoutTimestamp) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.btl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.keyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.keyID, fieldNumber: 2)
    }
    if !self.inputPayload.isEmpty {
      try visitor.visitSingularStringField(value: self.inputPayload, fieldNumber: 3)
    }
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 4)
    }
    if self.relativeTimeoutTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.relativeTimeoutTimestamp, fieldNumber: 5)
    }
    if self.btl != 0 {
      try visitor.visitSingularUInt64Field(value: self.btl, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgNewICATransactionRequest, rhs: Zrchain_Treasury_MsgNewICATransactionRequest) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.inputPayload != rhs.inputPayload {return false}
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.relativeTimeoutTimestamp != rhs.relativeTimeoutTimestamp {return false}
    if lhs.btl != rhs.btl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgNewICATransactionRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewICATransactionRequestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "signature_request_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.signatureRequestID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.signatureRequestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.signatureRequestID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgNewICATransactionRequestResponse, rhs: Zrchain_Treasury_MsgNewICATransactionRequestResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.signatureRequestID != rhs.signatureRequestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgFulfilICATransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgFulfilICATransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "request_id"),
    3: .same(proto: "status"),
    4: .standard(proto: "keyring_party_signature"),
    5: .standard(proto: "signed_data"),
    6: .standard(proto: "reject_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.requestID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.keyringPartySignature) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.signedData) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.rejectReason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.requestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestID, fieldNumber: 2)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    if !self.keyringPartySignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.keyringPartySignature, fieldNumber: 4)
    }
    if !self.signedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedData, fieldNumber: 5)
    }
    if !self.rejectReason.isEmpty {
      try visitor.visitSingularStringField(value: self.rejectReason, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgFulfilICATransactionRequest, rhs: Zrchain_Treasury_MsgFulfilICATransactionRequest) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.keyringPartySignature != rhs.keyringPartySignature {return false}
    if lhs.signedData != rhs.signedData {return false}
    if lhs.rejectReason != rhs.rejectReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgFulfilICATransactionRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgFulfilICATransactionRequestResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgFulfilICATransactionRequestResponse, rhs: Zrchain_Treasury_MsgFulfilICATransactionRequestResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgNewZrSignSignatureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewZrSignSignatureRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "address"),
    3: .standard(proto: "key_type"),
    4: .standard(proto: "wallet_index"),
    5: .standard(proto: "cache_id"),
    6: .same(proto: "data"),
    7: .standard(proto: "verify_signing_data"),
    8: .standard(proto: "verify_signing_data_version"),
    9: .standard(proto: "wallet_type"),
    10: .same(proto: "metadata"),
    11: .standard(proto: "no_broadcast"),
    12: .same(proto: "btl"),
    13: .same(proto: "tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.keyType) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.walletIndex) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.cacheID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.verifySigningData) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.verifySigningDataVersion) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.walletType) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.noBroadcast) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self.btl) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.tx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if self.keyType != 0 {
      try visitor.visitSingularUInt64Field(value: self.keyType, fieldNumber: 3)
    }
    if self.walletIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.walletIndex, fieldNumber: 4)
    }
    if !self.cacheID.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheID, fieldNumber: 5)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 6)
    }
    if !self.verifySigningData.isEmpty {
      try visitor.visitSingularBytesField(value: self.verifySigningData, fieldNumber: 7)
    }
    if self.verifySigningDataVersion != .unknown {
      try visitor.visitSingularEnumField(value: self.verifySigningDataVersion, fieldNumber: 8)
    }
    if self.walletType != .unspecified {
      try visitor.visitSingularEnumField(value: self.walletType, fieldNumber: 9)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if self.noBroadcast != false {
      try visitor.visitSingularBoolField(value: self.noBroadcast, fieldNumber: 11)
    }
    if self.btl != 0 {
      try visitor.visitSingularUInt64Field(value: self.btl, fieldNumber: 12)
    }
    if self.tx != false {
      try visitor.visitSingularBoolField(value: self.tx, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgNewZrSignSignatureRequest, rhs: Zrchain_Treasury_MsgNewZrSignSignatureRequest) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.address != rhs.address {return false}
    if lhs.keyType != rhs.keyType {return false}
    if lhs.walletIndex != rhs.walletIndex {return false}
    if lhs.cacheID != rhs.cacheID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.verifySigningData != rhs.verifySigningData {return false}
    if lhs.verifySigningDataVersion != rhs.verifySigningDataVersion {return false}
    if lhs.walletType != rhs.walletType {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.noBroadcast != rhs.noBroadcast {return false}
    if lhs.btl != rhs.btl {return false}
    if lhs.tx != rhs.tx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgNewZrSignSignatureRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgNewZrSignSignatureRequestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "req_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.reqID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reqID != 0 {
      try visitor.visitSingularUInt64Field(value: self.reqID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgNewZrSignSignatureRequestResponse, rhs: Zrchain_Treasury_MsgNewZrSignSignatureRequestResponse) -> Bool {
    if lhs.reqID != rhs.reqID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgUpdateKeyPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateKeyPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "key_id"),
    3: .standard(proto: "sign_policy_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.keyID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.signPolicyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if self.keyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.keyID, fieldNumber: 2)
    }
    if self.signPolicyID != 0 {
      try visitor.visitSingularUInt64Field(value: self.signPolicyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgUpdateKeyPolicy, rhs: Zrchain_Treasury_MsgUpdateKeyPolicy) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.signPolicyID != rhs.signPolicyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Zrchain_Treasury_MsgUpdateKeyPolicyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateKeyPolicyResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Zrchain_Treasury_MsgUpdateKeyPolicyResponse, rhs: Zrchain_Treasury_MsgUpdateKeyPolicyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
