// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: umee/incentive/v1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryParams defines the request structure for the Params gRPC service
/// handler.
struct Umee_Incentive_V1_QueryParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryParamsResponse defines the response structure for the Params gRPC
/// service handler.
struct Umee_Incentive_V1_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Umee_Incentive_V1_Params {
    get {return _params ?? Umee_Incentive_V1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Umee_Incentive_V1_Params? = nil
}

/// QueryPendingRewards defines the request structure for the PendingRewards gRPC service handler.
struct Umee_Incentive_V1_QueryPendingRewards {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryPendingRewardsResponse defines the response structure for the PendingRewards gRPC service handler.
struct Umee_Incentive_V1_QueryPendingRewardsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rewards: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountBonds defines the request structure for the AccountBonds gRPC service handler.
struct Umee_Incentive_V1_QueryAccountBonds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountBondsResponse defines the response structure for the AccountBonds gRPC service handler.
struct Umee_Incentive_V1_QueryAccountBondsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bonded: [Cosmos_Base_V1beta1_Coin] = []

  var unbonding: [Cosmos_Base_V1beta1_Coin] = []

  var unbondings: [Umee_Incentive_V1_Unbonding] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTotalBonded defines the request structure for the TotalBonded gRPC service handler.
struct Umee_Incentive_V1_QueryTotalBonded {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// denom is an optional field which causes the query to return the totals of only one uToken
  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTotalBondedResponse defines the response structure for the TotalBonded gRPC service handler.
struct Umee_Incentive_V1_QueryTotalBondedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bonded: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTotalUnbonding defines the request structure for the TotalUnbonding gRPC service handler.
struct Umee_Incentive_V1_QueryTotalUnbonding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// denom is an optional field which causes the query to return the totals of only one uToken
  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTotalUnbondingResponse defines the response structure for the TotalUnbonding gRPC service handler.
struct Umee_Incentive_V1_QueryTotalUnbondingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unbonding: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryUpcomingIncentivePrograms defines the request structure for the
/// OngoingIncentivePrograms and UpcomingIncentivePrograms gRPC service handlers.
struct Umee_Incentive_V1_QueryUpcomingIncentivePrograms {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryUpcomingIncentiveProgramsResponse defines the response structure for the
/// OngoingIncentivePrograms and UpcomingIncentivePrograms gRPC service handlers.
struct Umee_Incentive_V1_QueryUpcomingIncentiveProgramsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var programs: [Umee_Incentive_V1_IncentiveProgram] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryOngoingIncentivePrograms defines the request structure for the
/// OngoingIncentivePrograms and UpcomingIncentivePrograms gRPC service handlers.
struct Umee_Incentive_V1_QueryOngoingIncentivePrograms {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryOngoingIncentiveProgramsResponse defines the response structure for the
/// OngoingIncentivePrograms and UpcomingIncentivePrograms gRPC service handlers.
struct Umee_Incentive_V1_QueryOngoingIncentiveProgramsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var programs: [Umee_Incentive_V1_IncentiveProgram] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCompletedIncentivePrograms defines the request structure for the
/// CompletedIncentivePrograms gRPC service handler.
struct Umee_Incentive_V1_QueryCompletedIncentivePrograms {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCompletedIncentiveProgramsResponse defines the response structure for the
/// CompletedIncentivePrograms gRPC service handler.
struct Umee_Incentive_V1_QueryCompletedIncentiveProgramsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var programs: [Umee_Incentive_V1_IncentiveProgram] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryIncentiveProgram defines the request structure for the IncentiveProgram
/// gRPC service handler.
struct Umee_Incentive_V1_QueryIncentiveProgram {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID specifies which program to query for
  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryIncentivePrograResponse defines the response structure for the
/// IncentiveProgram gRPC service handler.
struct Umee_Incentive_V1_QueryIncentiveProgramResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var program: Umee_Incentive_V1_IncentiveProgram {
    get {return _program ?? Umee_Incentive_V1_IncentiveProgram()}
    set {_program = newValue}
  }
  /// Returns true if `program` has been explicitly set.
  var hasProgram: Bool {return self._program != nil}
  /// Clears the value of `program`. Subsequent reads from it will return its default value.
  mutating func clearProgram() {self._program = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _program: Umee_Incentive_V1_IncentiveProgram? = nil
}

/// QueryCurrentRates defines the request structure for the CurrentRates gRPC service handler.
struct Umee_Incentive_V1_QueryCurrentRates {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uToken is the uToken denomination whose current annual rate of rewards is being queried
  var uToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCurrentRatesResponse defines the response structure for the CurrentRates gRPC service handler.
struct Umee_Incentive_V1_QueryCurrentRatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference Bond is an amount of bonded uTokens (usually 10^exponent) whose current rewards are being
  /// calculated. This amount can be used to compute an individual user's rewards: for example, if a user has
  /// 2.5x the reference amount currently bonded, then they would receive 2.5x the rewards below annually
  /// at current rates.
  var referenceBond: Cosmos_Base_V1beta1_Coin {
    get {return _referenceBond ?? Cosmos_Base_V1beta1_Coin()}
    set {_referenceBond = newValue}
  }
  /// Returns true if `referenceBond` has been explicitly set.
  var hasReferenceBond: Bool {return self._referenceBond != nil}
  /// Clears the value of `referenceBond`. Subsequent reads from it will return its default value.
  mutating func clearReferenceBond() {self._referenceBond = nil}

  /// Rewards are the amount of base token rewards that the reference amount of bonded uTokens would earn
  /// if current rates continued for a full year.
  var rewards: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _referenceBond: Cosmos_Base_V1beta1_Coin? = nil
}

/// QueryLastRewardTime defines the request structure for the LastRewardTime gRPC service
/// handler.
struct Umee_Incentive_V1_QueryLastRewardTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryLastRewardTimeResponse defines the response structure for the LastRewardTime gRPC
/// service handler.
struct Umee_Incentive_V1_QueryLastRewardTimeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryActualRates defines the request structure for the ActualRates gRPC service handler.
struct Umee_Incentive_V1_QueryActualRates {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uToken is the uToken denomination whose current annual rate of rewards is being queried
  var uToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryActualRatesResponse defines the response structure for the ActualRates gRPC service handler.
struct Umee_Incentive_V1_QueryActualRatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// APY is the oracle price-adjusted APY of the bonded uToken.
  var apy: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Umee_Incentive_V1_QueryParams: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryParamsResponse: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryPendingRewards: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryPendingRewardsResponse: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryAccountBonds: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryAccountBondsResponse: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryTotalBonded: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryTotalBondedResponse: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryTotalUnbonding: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryTotalUnbondingResponse: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryUpcomingIncentivePrograms: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryUpcomingIncentiveProgramsResponse: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryOngoingIncentivePrograms: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryOngoingIncentiveProgramsResponse: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryCompletedIncentivePrograms: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryCompletedIncentiveProgramsResponse: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryIncentiveProgram: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryIncentiveProgramResponse: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryCurrentRates: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryCurrentRatesResponse: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryLastRewardTime: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryLastRewardTimeResponse: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryActualRates: @unchecked Sendable {}
extension Umee_Incentive_V1_QueryActualRatesResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "umee.incentive.v1"

extension Umee_Incentive_V1_QueryParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParams"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryParams, rhs: Umee_Incentive_V1_QueryParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryParamsResponse, rhs: Umee_Incentive_V1_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryPendingRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPendingRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryPendingRewards, rhs: Umee_Incentive_V1_QueryPendingRewards) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryPendingRewardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPendingRewardsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rewards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rewards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rewards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rewards, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryPendingRewardsResponse, rhs: Umee_Incentive_V1_QueryPendingRewardsResponse) -> Bool {
    if lhs.rewards != rhs.rewards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryAccountBonds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountBonds"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryAccountBonds, rhs: Umee_Incentive_V1_QueryAccountBonds) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryAccountBondsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountBondsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bonded"),
    2: .same(proto: "unbonding"),
    3: .same(proto: "unbondings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.bonded) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.unbonding) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.unbondings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bonded.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bonded, fieldNumber: 1)
    }
    if !self.unbonding.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unbonding, fieldNumber: 2)
    }
    if !self.unbondings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unbondings, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryAccountBondsResponse, rhs: Umee_Incentive_V1_QueryAccountBondsResponse) -> Bool {
    if lhs.bonded != rhs.bonded {return false}
    if lhs.unbonding != rhs.unbonding {return false}
    if lhs.unbondings != rhs.unbondings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryTotalBonded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTotalBonded"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryTotalBonded, rhs: Umee_Incentive_V1_QueryTotalBonded) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryTotalBondedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTotalBondedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bonded"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.bonded) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bonded.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bonded, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryTotalBondedResponse, rhs: Umee_Incentive_V1_QueryTotalBondedResponse) -> Bool {
    if lhs.bonded != rhs.bonded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryTotalUnbonding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTotalUnbonding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryTotalUnbonding, rhs: Umee_Incentive_V1_QueryTotalUnbonding) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryTotalUnbondingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTotalUnbondingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unbonding"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.unbonding) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.unbonding.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unbonding, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryTotalUnbondingResponse, rhs: Umee_Incentive_V1_QueryTotalUnbondingResponse) -> Bool {
    if lhs.unbonding != rhs.unbonding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryUpcomingIncentivePrograms: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryUpcomingIncentivePrograms"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryUpcomingIncentivePrograms, rhs: Umee_Incentive_V1_QueryUpcomingIncentivePrograms) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryUpcomingIncentiveProgramsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryUpcomingIncentiveProgramsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "programs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.programs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.programs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.programs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryUpcomingIncentiveProgramsResponse, rhs: Umee_Incentive_V1_QueryUpcomingIncentiveProgramsResponse) -> Bool {
    if lhs.programs != rhs.programs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryOngoingIncentivePrograms: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOngoingIncentivePrograms"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryOngoingIncentivePrograms, rhs: Umee_Incentive_V1_QueryOngoingIncentivePrograms) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryOngoingIncentiveProgramsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOngoingIncentiveProgramsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "programs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.programs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.programs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.programs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryOngoingIncentiveProgramsResponse, rhs: Umee_Incentive_V1_QueryOngoingIncentiveProgramsResponse) -> Bool {
    if lhs.programs != rhs.programs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryCompletedIncentivePrograms: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCompletedIncentivePrograms"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryCompletedIncentivePrograms, rhs: Umee_Incentive_V1_QueryCompletedIncentivePrograms) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryCompletedIncentiveProgramsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCompletedIncentiveProgramsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "programs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.programs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.programs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.programs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryCompletedIncentiveProgramsResponse, rhs: Umee_Incentive_V1_QueryCompletedIncentiveProgramsResponse) -> Bool {
    if lhs.programs != rhs.programs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryIncentiveProgram: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryIncentiveProgram"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryIncentiveProgram, rhs: Umee_Incentive_V1_QueryIncentiveProgram) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryIncentiveProgramResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryIncentiveProgramResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "program"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._program) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._program {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryIncentiveProgramResponse, rhs: Umee_Incentive_V1_QueryIncentiveProgramResponse) -> Bool {
    if lhs._program != rhs._program {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryCurrentRates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCurrentRates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uToken"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uToken.isEmpty {
      try visitor.visitSingularStringField(value: self.uToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryCurrentRates, rhs: Umee_Incentive_V1_QueryCurrentRates) -> Bool {
    if lhs.uToken != rhs.uToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryCurrentRatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCurrentRatesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reference_bond"),
    2: .same(proto: "rewards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._referenceBond) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rewards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._referenceBond {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rewards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rewards, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryCurrentRatesResponse, rhs: Umee_Incentive_V1_QueryCurrentRatesResponse) -> Bool {
    if lhs._referenceBond != rhs._referenceBond {return false}
    if lhs.rewards != rhs.rewards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryLastRewardTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryLastRewardTime"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryLastRewardTime, rhs: Umee_Incentive_V1_QueryLastRewardTime) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryLastRewardTimeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryLastRewardTimeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryLastRewardTimeResponse, rhs: Umee_Incentive_V1_QueryLastRewardTimeResponse) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryActualRates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryActualRates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uToken"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uToken.isEmpty {
      try visitor.visitSingularStringField(value: self.uToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryActualRates, rhs: Umee_Incentive_V1_QueryActualRates) -> Bool {
    if lhs.uToken != rhs.uToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umee_Incentive_V1_QueryActualRatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryActualRatesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "APY"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.apy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apy.isEmpty {
      try visitor.visitSingularStringField(value: self.apy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umee_Incentive_V1_QueryActualRatesResponse, rhs: Umee_Incentive_V1_QueryActualRatesResponse) -> Bool {
    if lhs.apy != rhs.apy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
