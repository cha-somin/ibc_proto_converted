// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: comdex/auction/v1beta1/auction.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Comdex_Auction_V1beta1_SurplusAuction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auctionID: UInt64 {
    get {return _storage._auctionID}
    set {_uniqueStorage()._auctionID = newValue}
  }

  var sellToken: Cosmos_Base_V1beta1_Coin {
    get {return _storage._sellToken ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._sellToken = newValue}
  }
  /// Returns true if `sellToken` has been explicitly set.
  var hasSellToken: Bool {return _storage._sellToken != nil}
  /// Clears the value of `sellToken`. Subsequent reads from it will return its default value.
  mutating func clearSellToken() {_uniqueStorage()._sellToken = nil}

  var buyToken: Cosmos_Base_V1beta1_Coin {
    get {return _storage._buyToken ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._buyToken = newValue}
  }
  /// Returns true if `buyToken` has been explicitly set.
  var hasBuyToken: Bool {return _storage._buyToken != nil}
  /// Clears the value of `buyToken`. Subsequent reads from it will return its default value.
  mutating func clearBuyToken() {_uniqueStorage()._buyToken = nil}

  var activeBiddingID: UInt64 {
    get {return _storage._activeBiddingID}
    set {_uniqueStorage()._activeBiddingID = newValue}
  }

  var bidder: String {
    get {return _storage._bidder}
    set {_uniqueStorage()._bidder = newValue}
  }

  var bid: Cosmos_Base_V1beta1_Coin {
    get {return _storage._bid ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._bid = newValue}
  }
  /// Returns true if `bid` has been explicitly set.
  var hasBid: Bool {return _storage._bid != nil}
  /// Clears the value of `bid`. Subsequent reads from it will return its default value.
  mutating func clearBid() {_uniqueStorage()._bid = nil}

  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  var bidFactor: String {
    get {return _storage._bidFactor}
    set {_uniqueStorage()._bidFactor = newValue}
  }

  var biddingIds: [Comdex_Auction_V1beta1_bidOwnerMapping] {
    get {return _storage._biddingIds}
    set {_uniqueStorage()._biddingIds = newValue}
  }

  var auctionStatus: UInt64 {
    get {return _storage._auctionStatus}
    set {_uniqueStorage()._auctionStatus = newValue}
  }

  var appID: UInt64 {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  var assetID: UInt64 {
    get {return _storage._assetID}
    set {_uniqueStorage()._assetID = newValue}
  }

  var auctionMappingID: UInt64 {
    get {return _storage._auctionMappingID}
    set {_uniqueStorage()._auctionMappingID = newValue}
  }

  var assetInID: UInt64 {
    get {return _storage._assetInID}
    set {_uniqueStorage()._assetInID = newValue}
  }

  var assetOutID: UInt64 {
    get {return _storage._assetOutID}
    set {_uniqueStorage()._assetOutID = newValue}
  }

  var bidEndTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._bidEndTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._bidEndTime = newValue}
  }
  /// Returns true if `bidEndTime` has been explicitly set.
  var hasBidEndTime: Bool {return _storage._bidEndTime != nil}
  /// Clears the value of `bidEndTime`. Subsequent reads from it will return its default value.
  mutating func clearBidEndTime() {_uniqueStorage()._bidEndTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Comdex_Auction_V1beta1_DebtAuction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auctionID: UInt64 {
    get {return _storage._auctionID}
    set {_uniqueStorage()._auctionID = newValue}
  }

  var auctionedToken: Cosmos_Base_V1beta1_Coin {
    get {return _storage._auctionedToken ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._auctionedToken = newValue}
  }
  /// Returns true if `auctionedToken` has been explicitly set.
  var hasAuctionedToken: Bool {return _storage._auctionedToken != nil}
  /// Clears the value of `auctionedToken`. Subsequent reads from it will return its default value.
  mutating func clearAuctionedToken() {_uniqueStorage()._auctionedToken = nil}

  var expectedUserToken: Cosmos_Base_V1beta1_Coin {
    get {return _storage._expectedUserToken ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._expectedUserToken = newValue}
  }
  /// Returns true if `expectedUserToken` has been explicitly set.
  var hasExpectedUserToken: Bool {return _storage._expectedUserToken != nil}
  /// Clears the value of `expectedUserToken`. Subsequent reads from it will return its default value.
  mutating func clearExpectedUserToken() {_uniqueStorage()._expectedUserToken = nil}

  var expectedMintedToken: Cosmos_Base_V1beta1_Coin {
    get {return _storage._expectedMintedToken ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._expectedMintedToken = newValue}
  }
  /// Returns true if `expectedMintedToken` has been explicitly set.
  var hasExpectedMintedToken: Bool {return _storage._expectedMintedToken != nil}
  /// Clears the value of `expectedMintedToken`. Subsequent reads from it will return its default value.
  mutating func clearExpectedMintedToken() {_uniqueStorage()._expectedMintedToken = nil}

  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  var activeBiddingID: UInt64 {
    get {return _storage._activeBiddingID}
    set {_uniqueStorage()._activeBiddingID = newValue}
  }

  var bidder: String {
    get {return _storage._bidder}
    set {_uniqueStorage()._bidder = newValue}
  }

  var currentBidAmount: Cosmos_Base_V1beta1_Coin {
    get {return _storage._currentBidAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._currentBidAmount = newValue}
  }
  /// Returns true if `currentBidAmount` has been explicitly set.
  var hasCurrentBidAmount: Bool {return _storage._currentBidAmount != nil}
  /// Clears the value of `currentBidAmount`. Subsequent reads from it will return its default value.
  mutating func clearCurrentBidAmount() {_uniqueStorage()._currentBidAmount = nil}

  var auctionStatus: UInt64 {
    get {return _storage._auctionStatus}
    set {_uniqueStorage()._auctionStatus = newValue}
  }

  var appID: UInt64 {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  var assetID: UInt64 {
    get {return _storage._assetID}
    set {_uniqueStorage()._assetID = newValue}
  }

  var biddingIds: [Comdex_Auction_V1beta1_bidOwnerMapping] {
    get {return _storage._biddingIds}
    set {_uniqueStorage()._biddingIds = newValue}
  }

  var auctionMappingID: UInt64 {
    get {return _storage._auctionMappingID}
    set {_uniqueStorage()._auctionMappingID = newValue}
  }

  var bidFactor: String {
    get {return _storage._bidFactor}
    set {_uniqueStorage()._bidFactor = newValue}
  }

  var assetInID: UInt64 {
    get {return _storage._assetInID}
    set {_uniqueStorage()._assetInID = newValue}
  }

  var assetOutID: UInt64 {
    get {return _storage._assetOutID}
    set {_uniqueStorage()._assetOutID = newValue}
  }

  var bidEndTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._bidEndTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._bidEndTime = newValue}
  }
  /// Returns true if `bidEndTime` has been explicitly set.
  var hasBidEndTime: Bool {return _storage._bidEndTime != nil}
  /// Clears the value of `bidEndTime`. Subsequent reads from it will return its default value.
  mutating func clearBidEndTime() {_uniqueStorage()._bidEndTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Comdex_Auction_V1beta1_DutchAuction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auctionID: UInt64 {
    get {return _storage._auctionID}
    set {_uniqueStorage()._auctionID = newValue}
  }

  var outflowTokenInitAmount: Cosmos_Base_V1beta1_Coin {
    get {return _storage._outflowTokenInitAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._outflowTokenInitAmount = newValue}
  }
  /// Returns true if `outflowTokenInitAmount` has been explicitly set.
  var hasOutflowTokenInitAmount: Bool {return _storage._outflowTokenInitAmount != nil}
  /// Clears the value of `outflowTokenInitAmount`. Subsequent reads from it will return its default value.
  mutating func clearOutflowTokenInitAmount() {_uniqueStorage()._outflowTokenInitAmount = nil}

  var outflowTokenCurrentAmount: Cosmos_Base_V1beta1_Coin {
    get {return _storage._outflowTokenCurrentAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._outflowTokenCurrentAmount = newValue}
  }
  /// Returns true if `outflowTokenCurrentAmount` has been explicitly set.
  var hasOutflowTokenCurrentAmount: Bool {return _storage._outflowTokenCurrentAmount != nil}
  /// Clears the value of `outflowTokenCurrentAmount`. Subsequent reads from it will return its default value.
  mutating func clearOutflowTokenCurrentAmount() {_uniqueStorage()._outflowTokenCurrentAmount = nil}

  var inflowTokenTargetAmount: Cosmos_Base_V1beta1_Coin {
    get {return _storage._inflowTokenTargetAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._inflowTokenTargetAmount = newValue}
  }
  /// Returns true if `inflowTokenTargetAmount` has been explicitly set.
  var hasInflowTokenTargetAmount: Bool {return _storage._inflowTokenTargetAmount != nil}
  /// Clears the value of `inflowTokenTargetAmount`. Subsequent reads from it will return its default value.
  mutating func clearInflowTokenTargetAmount() {_uniqueStorage()._inflowTokenTargetAmount = nil}

  var inflowTokenCurrentAmount: Cosmos_Base_V1beta1_Coin {
    get {return _storage._inflowTokenCurrentAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._inflowTokenCurrentAmount = newValue}
  }
  /// Returns true if `inflowTokenCurrentAmount` has been explicitly set.
  var hasInflowTokenCurrentAmount: Bool {return _storage._inflowTokenCurrentAmount != nil}
  /// Clears the value of `inflowTokenCurrentAmount`. Subsequent reads from it will return its default value.
  mutating func clearInflowTokenCurrentAmount() {_uniqueStorage()._inflowTokenCurrentAmount = nil}

  var outflowTokenInitialPrice: String {
    get {return _storage._outflowTokenInitialPrice}
    set {_uniqueStorage()._outflowTokenInitialPrice = newValue}
  }

  var outflowTokenCurrentPrice: String {
    get {return _storage._outflowTokenCurrentPrice}
    set {_uniqueStorage()._outflowTokenCurrentPrice = newValue}
  }

  var outflowTokenEndPrice: String {
    get {return _storage._outflowTokenEndPrice}
    set {_uniqueStorage()._outflowTokenEndPrice = newValue}
  }

  var inflowTokenCurrentPrice: String {
    get {return _storage._inflowTokenCurrentPrice}
    set {_uniqueStorage()._inflowTokenCurrentPrice = newValue}
  }

  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  var auctionStatus: UInt64 {
    get {return _storage._auctionStatus}
    set {_uniqueStorage()._auctionStatus = newValue}
  }

  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  var biddingIds: [Comdex_Auction_V1beta1_bidOwnerMapping] {
    get {return _storage._biddingIds}
    set {_uniqueStorage()._biddingIds = newValue}
  }

  var auctionMappingID: UInt64 {
    get {return _storage._auctionMappingID}
    set {_uniqueStorage()._auctionMappingID = newValue}
  }

  var appID: UInt64 {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  var assetInID: UInt64 {
    get {return _storage._assetInID}
    set {_uniqueStorage()._assetInID = newValue}
  }

  var assetOutID: UInt64 {
    get {return _storage._assetOutID}
    set {_uniqueStorage()._assetOutID = newValue}
  }

  var lockedVaultID: UInt64 {
    get {return _storage._lockedVaultID}
    set {_uniqueStorage()._lockedVaultID = newValue}
  }

  var vaultOwner: String {
    get {return _storage._vaultOwner}
    set {_uniqueStorage()._vaultOwner = newValue}
  }

  var liquidationPenalty: String {
    get {return _storage._liquidationPenalty}
    set {_uniqueStorage()._liquidationPenalty = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Comdex_Auction_V1beta1_bidOwnerMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bidID: UInt64 = 0

  var bidOwner: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Auction_V1beta1_ProtocolStatistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt64 = 0

  var assetID: UInt64 = 0

  var loss: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Auction_V1beta1_AuctionParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt64 = 0

  var auctionDurationSeconds: UInt64 = 0

  var buffer: String = String()

  var cusp: String = String()

  var step: String = String()

  var priceFunctionType: UInt64 = 0

  var surplusID: UInt64 = 0

  var debtID: UInt64 = 0

  var dutchID: UInt64 = 0

  var bidDurationSeconds: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Comdex_Auction_V1beta1_SurplusAuction: @unchecked Sendable {}
extension Comdex_Auction_V1beta1_DebtAuction: @unchecked Sendable {}
extension Comdex_Auction_V1beta1_DutchAuction: @unchecked Sendable {}
extension Comdex_Auction_V1beta1_bidOwnerMapping: @unchecked Sendable {}
extension Comdex_Auction_V1beta1_ProtocolStatistics: @unchecked Sendable {}
extension Comdex_Auction_V1beta1_AuctionParams: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "comdex.auction.v1beta1"

extension Comdex_Auction_V1beta1_SurplusAuction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SurplusAuction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auction_id"),
    2: .standard(proto: "sell_token"),
    3: .standard(proto: "buy_token"),
    4: .standard(proto: "active_bidding_id"),
    5: .same(proto: "bidder"),
    6: .same(proto: "bid"),
    7: .standard(proto: "end_time"),
    8: .standard(proto: "bid_factor"),
    9: .standard(proto: "bidding_ids"),
    10: .standard(proto: "auction_status"),
    11: .standard(proto: "app_id"),
    12: .standard(proto: "asset_id"),
    13: .standard(proto: "auction_mapping_id"),
    14: .standard(proto: "asset_in_id"),
    15: .standard(proto: "asset_out_id"),
    16: .standard(proto: "bid_end_time"),
  ]

  fileprivate class _StorageClass {
    var _auctionID: UInt64 = 0
    var _sellToken: Cosmos_Base_V1beta1_Coin? = nil
    var _buyToken: Cosmos_Base_V1beta1_Coin? = nil
    var _activeBiddingID: UInt64 = 0
    var _bidder: String = String()
    var _bid: Cosmos_Base_V1beta1_Coin? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _bidFactor: String = String()
    var _biddingIds: [Comdex_Auction_V1beta1_bidOwnerMapping] = []
    var _auctionStatus: UInt64 = 0
    var _appID: UInt64 = 0
    var _assetID: UInt64 = 0
    var _auctionMappingID: UInt64 = 0
    var _assetInID: UInt64 = 0
    var _assetOutID: UInt64 = 0
    var _bidEndTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _auctionID = source._auctionID
      _sellToken = source._sellToken
      _buyToken = source._buyToken
      _activeBiddingID = source._activeBiddingID
      _bidder = source._bidder
      _bid = source._bid
      _endTime = source._endTime
      _bidFactor = source._bidFactor
      _biddingIds = source._biddingIds
      _auctionStatus = source._auctionStatus
      _appID = source._appID
      _assetID = source._assetID
      _auctionMappingID = source._auctionMappingID
      _assetInID = source._assetInID
      _assetOutID = source._assetOutID
      _bidEndTime = source._bidEndTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._auctionID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._sellToken) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._buyToken) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._activeBiddingID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._bidder) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._bid) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._bidFactor) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._biddingIds) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._auctionStatus) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._appID) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._assetID) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._auctionMappingID) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._assetInID) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._assetOutID) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._bidEndTime) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._auctionID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._auctionID, fieldNumber: 1)
      }
      try { if let v = _storage._sellToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._buyToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._activeBiddingID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._activeBiddingID, fieldNumber: 4)
      }
      if !_storage._bidder.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bidder, fieldNumber: 5)
      }
      try { if let v = _storage._bid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._bidFactor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bidFactor, fieldNumber: 8)
      }
      if !_storage._biddingIds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._biddingIds, fieldNumber: 9)
      }
      if _storage._auctionStatus != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._auctionStatus, fieldNumber: 10)
      }
      if _storage._appID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._appID, fieldNumber: 11)
      }
      if _storage._assetID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._assetID, fieldNumber: 12)
      }
      if _storage._auctionMappingID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._auctionMappingID, fieldNumber: 13)
      }
      if _storage._assetInID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._assetInID, fieldNumber: 14)
      }
      if _storage._assetOutID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._assetOutID, fieldNumber: 15)
      }
      try { if let v = _storage._bidEndTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Auction_V1beta1_SurplusAuction, rhs: Comdex_Auction_V1beta1_SurplusAuction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._auctionID != rhs_storage._auctionID {return false}
        if _storage._sellToken != rhs_storage._sellToken {return false}
        if _storage._buyToken != rhs_storage._buyToken {return false}
        if _storage._activeBiddingID != rhs_storage._activeBiddingID {return false}
        if _storage._bidder != rhs_storage._bidder {return false}
        if _storage._bid != rhs_storage._bid {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._bidFactor != rhs_storage._bidFactor {return false}
        if _storage._biddingIds != rhs_storage._biddingIds {return false}
        if _storage._auctionStatus != rhs_storage._auctionStatus {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._assetID != rhs_storage._assetID {return false}
        if _storage._auctionMappingID != rhs_storage._auctionMappingID {return false}
        if _storage._assetInID != rhs_storage._assetInID {return false}
        if _storage._assetOutID != rhs_storage._assetOutID {return false}
        if _storage._bidEndTime != rhs_storage._bidEndTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Auction_V1beta1_DebtAuction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebtAuction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auction_id"),
    2: .standard(proto: "auctioned_token"),
    3: .standard(proto: "expected_user_token"),
    4: .standard(proto: "expected_minted_token"),
    5: .standard(proto: "end_time"),
    6: .standard(proto: "active_bidding_id"),
    7: .same(proto: "bidder"),
    8: .standard(proto: "current_bid_amount"),
    9: .standard(proto: "auction_status"),
    10: .standard(proto: "app_id"),
    11: .standard(proto: "asset_id"),
    12: .standard(proto: "bidding_ids"),
    13: .standard(proto: "auction_mapping_id"),
    14: .standard(proto: "bid_factor"),
    15: .standard(proto: "asset_in_id"),
    16: .standard(proto: "asset_out_id"),
    17: .standard(proto: "bid_end_time"),
  ]

  fileprivate class _StorageClass {
    var _auctionID: UInt64 = 0
    var _auctionedToken: Cosmos_Base_V1beta1_Coin? = nil
    var _expectedUserToken: Cosmos_Base_V1beta1_Coin? = nil
    var _expectedMintedToken: Cosmos_Base_V1beta1_Coin? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _activeBiddingID: UInt64 = 0
    var _bidder: String = String()
    var _currentBidAmount: Cosmos_Base_V1beta1_Coin? = nil
    var _auctionStatus: UInt64 = 0
    var _appID: UInt64 = 0
    var _assetID: UInt64 = 0
    var _biddingIds: [Comdex_Auction_V1beta1_bidOwnerMapping] = []
    var _auctionMappingID: UInt64 = 0
    var _bidFactor: String = String()
    var _assetInID: UInt64 = 0
    var _assetOutID: UInt64 = 0
    var _bidEndTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _auctionID = source._auctionID
      _auctionedToken = source._auctionedToken
      _expectedUserToken = source._expectedUserToken
      _expectedMintedToken = source._expectedMintedToken
      _endTime = source._endTime
      _activeBiddingID = source._activeBiddingID
      _bidder = source._bidder
      _currentBidAmount = source._currentBidAmount
      _auctionStatus = source._auctionStatus
      _appID = source._appID
      _assetID = source._assetID
      _biddingIds = source._biddingIds
      _auctionMappingID = source._auctionMappingID
      _bidFactor = source._bidFactor
      _assetInID = source._assetInID
      _assetOutID = source._assetOutID
      _bidEndTime = source._bidEndTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._auctionID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._auctionedToken) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._expectedUserToken) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._expectedMintedToken) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._activeBiddingID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._bidder) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._currentBidAmount) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._auctionStatus) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._appID) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._assetID) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._biddingIds) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._auctionMappingID) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._bidFactor) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._assetInID) }()
        case 16: try { try decoder.decodeSingularUInt64Field(value: &_storage._assetOutID) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._bidEndTime) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._auctionID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._auctionID, fieldNumber: 1)
      }
      try { if let v = _storage._auctionedToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._expectedUserToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._expectedMintedToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._activeBiddingID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._activeBiddingID, fieldNumber: 6)
      }
      if !_storage._bidder.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bidder, fieldNumber: 7)
      }
      try { if let v = _storage._currentBidAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._auctionStatus != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._auctionStatus, fieldNumber: 9)
      }
      if _storage._appID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._appID, fieldNumber: 10)
      }
      if _storage._assetID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._assetID, fieldNumber: 11)
      }
      if !_storage._biddingIds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._biddingIds, fieldNumber: 12)
      }
      if _storage._auctionMappingID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._auctionMappingID, fieldNumber: 13)
      }
      if !_storage._bidFactor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bidFactor, fieldNumber: 14)
      }
      if _storage._assetInID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._assetInID, fieldNumber: 15)
      }
      if _storage._assetOutID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._assetOutID, fieldNumber: 16)
      }
      try { if let v = _storage._bidEndTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Auction_V1beta1_DebtAuction, rhs: Comdex_Auction_V1beta1_DebtAuction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._auctionID != rhs_storage._auctionID {return false}
        if _storage._auctionedToken != rhs_storage._auctionedToken {return false}
        if _storage._expectedUserToken != rhs_storage._expectedUserToken {return false}
        if _storage._expectedMintedToken != rhs_storage._expectedMintedToken {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._activeBiddingID != rhs_storage._activeBiddingID {return false}
        if _storage._bidder != rhs_storage._bidder {return false}
        if _storage._currentBidAmount != rhs_storage._currentBidAmount {return false}
        if _storage._auctionStatus != rhs_storage._auctionStatus {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._assetID != rhs_storage._assetID {return false}
        if _storage._biddingIds != rhs_storage._biddingIds {return false}
        if _storage._auctionMappingID != rhs_storage._auctionMappingID {return false}
        if _storage._bidFactor != rhs_storage._bidFactor {return false}
        if _storage._assetInID != rhs_storage._assetInID {return false}
        if _storage._assetOutID != rhs_storage._assetOutID {return false}
        if _storage._bidEndTime != rhs_storage._bidEndTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Auction_V1beta1_DutchAuction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DutchAuction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auction_id"),
    2: .standard(proto: "outflow_token_init_amount"),
    3: .standard(proto: "outflow_token_current_amount"),
    4: .standard(proto: "inflow_token_target_amount"),
    5: .standard(proto: "inflow_token_current_amount"),
    6: .standard(proto: "outflow_token_initial_price"),
    7: .standard(proto: "outflow_token_current_price"),
    8: .standard(proto: "outflow_token_end_price"),
    9: .standard(proto: "inflow_token_current_price"),
    10: .standard(proto: "end_time"),
    11: .standard(proto: "auction_status"),
    12: .standard(proto: "start_time"),
    13: .standard(proto: "bidding_ids"),
    14: .standard(proto: "auction_mapping_id"),
    15: .standard(proto: "app_id"),
    16: .standard(proto: "asset_in_id"),
    17: .standard(proto: "asset_out_id"),
    18: .standard(proto: "locked_vault_id"),
    19: .standard(proto: "vault_owner"),
    20: .standard(proto: "liquidation_penalty"),
  ]

  fileprivate class _StorageClass {
    var _auctionID: UInt64 = 0
    var _outflowTokenInitAmount: Cosmos_Base_V1beta1_Coin? = nil
    var _outflowTokenCurrentAmount: Cosmos_Base_V1beta1_Coin? = nil
    var _inflowTokenTargetAmount: Cosmos_Base_V1beta1_Coin? = nil
    var _inflowTokenCurrentAmount: Cosmos_Base_V1beta1_Coin? = nil
    var _outflowTokenInitialPrice: String = String()
    var _outflowTokenCurrentPrice: String = String()
    var _outflowTokenEndPrice: String = String()
    var _inflowTokenCurrentPrice: String = String()
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _auctionStatus: UInt64 = 0
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _biddingIds: [Comdex_Auction_V1beta1_bidOwnerMapping] = []
    var _auctionMappingID: UInt64 = 0
    var _appID: UInt64 = 0
    var _assetInID: UInt64 = 0
    var _assetOutID: UInt64 = 0
    var _lockedVaultID: UInt64 = 0
    var _vaultOwner: String = String()
    var _liquidationPenalty: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _auctionID = source._auctionID
      _outflowTokenInitAmount = source._outflowTokenInitAmount
      _outflowTokenCurrentAmount = source._outflowTokenCurrentAmount
      _inflowTokenTargetAmount = source._inflowTokenTargetAmount
      _inflowTokenCurrentAmount = source._inflowTokenCurrentAmount
      _outflowTokenInitialPrice = source._outflowTokenInitialPrice
      _outflowTokenCurrentPrice = source._outflowTokenCurrentPrice
      _outflowTokenEndPrice = source._outflowTokenEndPrice
      _inflowTokenCurrentPrice = source._inflowTokenCurrentPrice
      _endTime = source._endTime
      _auctionStatus = source._auctionStatus
      _startTime = source._startTime
      _biddingIds = source._biddingIds
      _auctionMappingID = source._auctionMappingID
      _appID = source._appID
      _assetInID = source._assetInID
      _assetOutID = source._assetOutID
      _lockedVaultID = source._lockedVaultID
      _vaultOwner = source._vaultOwner
      _liquidationPenalty = source._liquidationPenalty
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._auctionID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._outflowTokenInitAmount) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._outflowTokenCurrentAmount) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._inflowTokenTargetAmount) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._inflowTokenCurrentAmount) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._outflowTokenInitialPrice) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._outflowTokenCurrentPrice) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._outflowTokenEndPrice) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._inflowTokenCurrentPrice) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._auctionStatus) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._biddingIds) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._auctionMappingID) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._appID) }()
        case 16: try { try decoder.decodeSingularUInt64Field(value: &_storage._assetInID) }()
        case 17: try { try decoder.decodeSingularUInt64Field(value: &_storage._assetOutID) }()
        case 18: try { try decoder.decodeSingularUInt64Field(value: &_storage._lockedVaultID) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._vaultOwner) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._liquidationPenalty) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._auctionID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._auctionID, fieldNumber: 1)
      }
      try { if let v = _storage._outflowTokenInitAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._outflowTokenCurrentAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._inflowTokenTargetAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._inflowTokenCurrentAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._outflowTokenInitialPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._outflowTokenInitialPrice, fieldNumber: 6)
      }
      if !_storage._outflowTokenCurrentPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._outflowTokenCurrentPrice, fieldNumber: 7)
      }
      if !_storage._outflowTokenEndPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._outflowTokenEndPrice, fieldNumber: 8)
      }
      if !_storage._inflowTokenCurrentPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._inflowTokenCurrentPrice, fieldNumber: 9)
      }
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._auctionStatus != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._auctionStatus, fieldNumber: 11)
      }
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._biddingIds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._biddingIds, fieldNumber: 13)
      }
      if _storage._auctionMappingID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._auctionMappingID, fieldNumber: 14)
      }
      if _storage._appID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._appID, fieldNumber: 15)
      }
      if _storage._assetInID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._assetInID, fieldNumber: 16)
      }
      if _storage._assetOutID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._assetOutID, fieldNumber: 17)
      }
      if _storage._lockedVaultID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lockedVaultID, fieldNumber: 18)
      }
      if !_storage._vaultOwner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vaultOwner, fieldNumber: 19)
      }
      if !_storage._liquidationPenalty.isEmpty {
        try visitor.visitSingularStringField(value: _storage._liquidationPenalty, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Auction_V1beta1_DutchAuction, rhs: Comdex_Auction_V1beta1_DutchAuction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._auctionID != rhs_storage._auctionID {return false}
        if _storage._outflowTokenInitAmount != rhs_storage._outflowTokenInitAmount {return false}
        if _storage._outflowTokenCurrentAmount != rhs_storage._outflowTokenCurrentAmount {return false}
        if _storage._inflowTokenTargetAmount != rhs_storage._inflowTokenTargetAmount {return false}
        if _storage._inflowTokenCurrentAmount != rhs_storage._inflowTokenCurrentAmount {return false}
        if _storage._outflowTokenInitialPrice != rhs_storage._outflowTokenInitialPrice {return false}
        if _storage._outflowTokenCurrentPrice != rhs_storage._outflowTokenCurrentPrice {return false}
        if _storage._outflowTokenEndPrice != rhs_storage._outflowTokenEndPrice {return false}
        if _storage._inflowTokenCurrentPrice != rhs_storage._inflowTokenCurrentPrice {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._auctionStatus != rhs_storage._auctionStatus {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._biddingIds != rhs_storage._biddingIds {return false}
        if _storage._auctionMappingID != rhs_storage._auctionMappingID {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._assetInID != rhs_storage._assetInID {return false}
        if _storage._assetOutID != rhs_storage._assetOutID {return false}
        if _storage._lockedVaultID != rhs_storage._lockedVaultID {return false}
        if _storage._vaultOwner != rhs_storage._vaultOwner {return false}
        if _storage._liquidationPenalty != rhs_storage._liquidationPenalty {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Auction_V1beta1_bidOwnerMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".bidOwnerMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bid_id"),
    2: .standard(proto: "bid_owner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.bidID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bidOwner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bidID != 0 {
      try visitor.visitSingularUInt64Field(value: self.bidID, fieldNumber: 1)
    }
    if !self.bidOwner.isEmpty {
      try visitor.visitSingularStringField(value: self.bidOwner, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Auction_V1beta1_bidOwnerMapping, rhs: Comdex_Auction_V1beta1_bidOwnerMapping) -> Bool {
    if lhs.bidID != rhs.bidID {return false}
    if lhs.bidOwner != rhs.bidOwner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Auction_V1beta1_ProtocolStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProtocolStatistics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "asset_id"),
    3: .same(proto: "loss"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.loss) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 1)
    }
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 2)
    }
    if !self.loss.isEmpty {
      try visitor.visitSingularStringField(value: self.loss, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Auction_V1beta1_ProtocolStatistics, rhs: Comdex_Auction_V1beta1_ProtocolStatistics) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.loss != rhs.loss {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Auction_V1beta1_AuctionParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuctionParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "auction_duration_seconds"),
    3: .same(proto: "buffer"),
    4: .same(proto: "cusp"),
    5: .same(proto: "step"),
    6: .standard(proto: "price_function_type"),
    7: .standard(proto: "surplus_id"),
    8: .standard(proto: "debt_id"),
    9: .standard(proto: "dutch_id"),
    10: .standard(proto: "bid_duration_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.auctionDurationSeconds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.buffer) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cusp) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.step) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.priceFunctionType) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.surplusID) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.debtID) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.dutchID) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.bidDurationSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 1)
    }
    if self.auctionDurationSeconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.auctionDurationSeconds, fieldNumber: 2)
    }
    if !self.buffer.isEmpty {
      try visitor.visitSingularStringField(value: self.buffer, fieldNumber: 3)
    }
    if !self.cusp.isEmpty {
      try visitor.visitSingularStringField(value: self.cusp, fieldNumber: 4)
    }
    if !self.step.isEmpty {
      try visitor.visitSingularStringField(value: self.step, fieldNumber: 5)
    }
    if self.priceFunctionType != 0 {
      try visitor.visitSingularUInt64Field(value: self.priceFunctionType, fieldNumber: 6)
    }
    if self.surplusID != 0 {
      try visitor.visitSingularUInt64Field(value: self.surplusID, fieldNumber: 7)
    }
    if self.debtID != 0 {
      try visitor.visitSingularUInt64Field(value: self.debtID, fieldNumber: 8)
    }
    if self.dutchID != 0 {
      try visitor.visitSingularUInt64Field(value: self.dutchID, fieldNumber: 9)
    }
    if self.bidDurationSeconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.bidDurationSeconds, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Auction_V1beta1_AuctionParams, rhs: Comdex_Auction_V1beta1_AuctionParams) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.auctionDurationSeconds != rhs.auctionDurationSeconds {return false}
    if lhs.buffer != rhs.buffer {return false}
    if lhs.cusp != rhs.cusp {return false}
    if lhs.step != rhs.step {return false}
    if lhs.priceFunctionType != rhs.priceFunctionType {return false}
    if lhs.surplusID != rhs.surplusID {return false}
    if lhs.debtID != rhs.debtID {return false}
    if lhs.dutchID != rhs.dutchID {return false}
    if lhs.bidDurationSeconds != rhs.bidDurationSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
