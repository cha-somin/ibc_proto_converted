// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ixo/entity/v1beta1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Ixo_Entity_V1beta1_MsgCreateEntity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An Entity Type as defined by the implementer
  var entityType: String {
    get {return _storage._entityType}
    set {_uniqueStorage()._entityType = newValue}
  }

  /// Status of the Entity as defined by the implementer and interpreted by
  /// Client applications
  var entityStatus: Int32 {
    get {return _storage._entityStatus}
    set {_uniqueStorage()._entityStatus = newValue}
  }

  /// the list of controller DIDs
  var controller: [String] {
    get {return _storage._controller}
    set {_uniqueStorage()._controller = newValue}
  }

  /// JSON-LD contexts
  var context: [Ixo_Iid_V1beta1_Context] {
    get {return _storage._context}
    set {_uniqueStorage()._context = newValue}
  }

  /// Verification Methods and Verification Relationships
  var verification: [Ixo_Iid_V1beta1_Verification] {
    get {return _storage._verification}
    set {_uniqueStorage()._verification = newValue}
  }

  /// Service endpoints
  var service: [Ixo_Iid_V1beta1_Service] {
    get {return _storage._service}
    set {_uniqueStorage()._service = newValue}
  }

  /// Legal or Electronic Rights and associated Object Capabilities
  var accordedRight: [Ixo_Iid_V1beta1_AccordedRight] {
    get {return _storage._accordedRight}
    set {_uniqueStorage()._accordedRight = newValue}
  }

  /// Digital resources associated with the Subject
  var linkedResource: [Ixo_Iid_V1beta1_LinkedResource] {
    get {return _storage._linkedResource}
    set {_uniqueStorage()._linkedResource = newValue}
  }

  /// DID of a linked Entity and its relationship with the Subject
  var linkedEntity: [Ixo_Iid_V1beta1_LinkedEntity] {
    get {return _storage._linkedEntity}
    set {_uniqueStorage()._linkedEntity = newValue}
  }

  /// Start Date of the Entity as defined by the implementer and interpreted by
  /// Client applications
  var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  var hasStartDate: Bool {return _storage._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  mutating func clearStartDate() {_uniqueStorage()._startDate = nil}

  /// End Date of the Entity as defined by the implementer and interpreted by
  /// Client applications
  var endDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endDate = newValue}
  }
  /// Returns true if `endDate` has been explicitly set.
  var hasEndDate: Bool {return _storage._endDate != nil}
  /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
  mutating func clearEndDate() {_uniqueStorage()._endDate = nil}

  /// Address of the operator through which the Entity was created
  var relayerNode: String {
    get {return _storage._relayerNode}
    set {_uniqueStorage()._relayerNode = newValue}
  }

  /// Content ID or Hash of public Verifiable Credentials associated with the
  /// subject
  var credentials: [String] {
    get {return _storage._credentials}
    set {_uniqueStorage()._credentials = newValue}
  }

  /// Owner of the Entity NFT | The ownersdid used to sign this transaction.
  var ownerDid: String {
    get {return _storage._ownerDid}
    set {_uniqueStorage()._ownerDid = newValue}
  }

  /// The ownersdid address used to sign this transaction.
  var ownerAddress: String {
    get {return _storage._ownerAddress}
    set {_uniqueStorage()._ownerAddress = newValue}
  }

  /// Extention data
  var data: Data {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  var alsoKnownAs: String {
    get {return _storage._alsoKnownAs}
    set {_uniqueStorage()._alsoKnownAs = newValue}
  }

  /// Digital claims associated with the Subject
  var linkedClaim: [Ixo_Iid_V1beta1_LinkedClaim] {
    get {return _storage._linkedClaim}
    set {_uniqueStorage()._linkedClaim = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Ixo_Entity_V1beta1_MsgCreateEntityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entityID: String = String()

  var entityType: String = String()

  var entityStatus: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Updates the entity with all the fields, so if field empty will be updated
/// with default go type, aka never null
struct Ixo_Entity_V1beta1_MsgUpdateEntity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id of entity to be updated
  var id: String = String()

  /// Status of the Entity as defined by the implementer and interpreted by
  /// Client applications
  var entityStatus: Int32 = 0

  /// Start Date of the Entity as defined by the implementer and interpreted by
  /// Client applications
  var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  var hasStartDate: Bool {return self._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  mutating func clearStartDate() {self._startDate = nil}

  /// End Date of the Entity as defined by the implementer and interpreted by
  /// Client applications
  var endDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endDate = newValue}
  }
  /// Returns true if `endDate` has been explicitly set.
  var hasEndDate: Bool {return self._endDate != nil}
  /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
  mutating func clearEndDate() {self._endDate = nil}

  /// Content ID or Hash of public Verifiable Credentials associated with the
  /// subject
  var credentials: [String] = []

  /// The controllerDid used to sign this transaction.
  var controllerDid: String = String()

  /// The controllerAddress used to sign this transaction.
  var controllerAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Ixo_Entity_V1beta1_MsgUpdateEntityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Only relayer nodes can update entity field 'entityVerified'
struct Ixo_Entity_V1beta1_MsgUpdateEntityVerified {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id of entity to be updated
  var id: String = String()

  /// Whether entity is verified or not based on credentials
  var entityVerified: Bool = false

  /// The relayer node's did used to sign this transaction.
  var relayerNodeDid: String = String()

  /// The relayer node's address used to sign this transaction.
  var relayerNodeAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Entity_V1beta1_MsgUpdateEntityVerifiedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Entity_V1beta1_MsgTransferEntity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  /// The owner_did used to sign this transaction.
  var ownerDid: String = String()

  /// The owner_address used to sign this transaction.
  var ownerAddress: String = String()

  var recipientDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Entity_V1beta1_MsgTransferEntityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// create a module account for an entity, account details will be added as a
/// linkedEntity on entity iid doc where linkedEntity id is didfragment: did#name
struct Ixo_Entity_V1beta1_MsgCreateEntityAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// entity id (did) to create account for
  var id: String = String()

  /// name of account
  var name: String = String()

  /// The owner_address used to sign this transaction.
  var ownerAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Entity_V1beta1_MsgCreateEntityAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// account address that was created for specific entity and account name
  var account: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Create a authz grant from entity account (as grantor) to recipient in msg as
/// grantee for the specific authorization
struct Ixo_Entity_V1beta1_MsgGrantEntityAccountAuthz {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// entity id (did) to create account for
  var id: String = String()

  /// name of account
  var name: String = String()

  /// the grantee address that will be able to execute the authz authorization
  var granteeAddress: String = String()

  /// grant to be Authorized in authz grant
  var grant: Ixo_Entity_V1beta1_Grant {
    get {return _grant ?? Ixo_Entity_V1beta1_Grant()}
    set {_grant = newValue}
  }
  /// Returns true if `grant` has been explicitly set.
  var hasGrant: Bool {return self._grant != nil}
  /// Clears the value of `grant`. Subsequent reads from it will return its default value.
  mutating func clearGrant() {self._grant = nil}

  /// the owner_address used to sign this transaction.
  var ownerAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _grant: Ixo_Entity_V1beta1_Grant? = nil
}

struct Ixo_Entity_V1beta1_MsgGrantEntityAccountAuthzResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Ixo_Entity_V1beta1_MsgCreateEntity: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_MsgCreateEntityResponse: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_MsgUpdateEntity: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_MsgUpdateEntityResponse: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_MsgUpdateEntityVerified: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_MsgUpdateEntityVerifiedResponse: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_MsgTransferEntity: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_MsgTransferEntityResponse: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_MsgCreateEntityAccount: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_MsgCreateEntityAccountResponse: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_MsgGrantEntityAccountAuthz: @unchecked Sendable {}
extension Ixo_Entity_V1beta1_MsgGrantEntityAccountAuthzResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ixo.entity.v1beta1"

extension Ixo_Entity_V1beta1_MsgCreateEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_type"),
    2: .standard(proto: "entity_status"),
    3: .same(proto: "controller"),
    4: .same(proto: "context"),
    5: .same(proto: "verification"),
    6: .same(proto: "service"),
    7: .standard(proto: "accorded_right"),
    8: .standard(proto: "linked_resource"),
    9: .standard(proto: "linked_entity"),
    10: .standard(proto: "start_date"),
    11: .standard(proto: "end_date"),
    12: .standard(proto: "relayer_node"),
    13: .same(proto: "credentials"),
    14: .standard(proto: "owner_did"),
    15: .standard(proto: "owner_address"),
    16: .same(proto: "data"),
    17: .same(proto: "alsoKnownAs"),
    18: .standard(proto: "linked_claim"),
  ]

  fileprivate class _StorageClass {
    var _entityType: String = String()
    var _entityStatus: Int32 = 0
    var _controller: [String] = []
    var _context: [Ixo_Iid_V1beta1_Context] = []
    var _verification: [Ixo_Iid_V1beta1_Verification] = []
    var _service: [Ixo_Iid_V1beta1_Service] = []
    var _accordedRight: [Ixo_Iid_V1beta1_AccordedRight] = []
    var _linkedResource: [Ixo_Iid_V1beta1_LinkedResource] = []
    var _linkedEntity: [Ixo_Iid_V1beta1_LinkedEntity] = []
    var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _relayerNode: String = String()
    var _credentials: [String] = []
    var _ownerDid: String = String()
    var _ownerAddress: String = String()
    var _data: Data = Data()
    var _alsoKnownAs: String = String()
    var _linkedClaim: [Ixo_Iid_V1beta1_LinkedClaim] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _entityType = source._entityType
      _entityStatus = source._entityStatus
      _controller = source._controller
      _context = source._context
      _verification = source._verification
      _service = source._service
      _accordedRight = source._accordedRight
      _linkedResource = source._linkedResource
      _linkedEntity = source._linkedEntity
      _startDate = source._startDate
      _endDate = source._endDate
      _relayerNode = source._relayerNode
      _credentials = source._credentials
      _ownerDid = source._ownerDid
      _ownerAddress = source._ownerAddress
      _data = source._data
      _alsoKnownAs = source._alsoKnownAs
      _linkedClaim = source._linkedClaim
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._entityType) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._entityStatus) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._controller) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._context) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._verification) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._service) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._accordedRight) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._linkedResource) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._linkedEntity) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._startDate) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._endDate) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._relayerNode) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._credentials) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._ownerDid) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._ownerAddress) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._data) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._alsoKnownAs) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._linkedClaim) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._entityType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._entityType, fieldNumber: 1)
      }
      if _storage._entityStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._entityStatus, fieldNumber: 2)
      }
      if !_storage._controller.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._controller, fieldNumber: 3)
      }
      if !_storage._context.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._context, fieldNumber: 4)
      }
      if !_storage._verification.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._verification, fieldNumber: 5)
      }
      if !_storage._service.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._service, fieldNumber: 6)
      }
      if !_storage._accordedRight.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._accordedRight, fieldNumber: 7)
      }
      if !_storage._linkedResource.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._linkedResource, fieldNumber: 8)
      }
      if !_storage._linkedEntity.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._linkedEntity, fieldNumber: 9)
      }
      try { if let v = _storage._startDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._endDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._relayerNode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._relayerNode, fieldNumber: 12)
      }
      if !_storage._credentials.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._credentials, fieldNumber: 13)
      }
      if !_storage._ownerDid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerDid, fieldNumber: 14)
      }
      if !_storage._ownerAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerAddress, fieldNumber: 15)
      }
      if !_storage._data.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._data, fieldNumber: 16)
      }
      if !_storage._alsoKnownAs.isEmpty {
        try visitor.visitSingularStringField(value: _storage._alsoKnownAs, fieldNumber: 17)
      }
      if !_storage._linkedClaim.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._linkedClaim, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_MsgCreateEntity, rhs: Ixo_Entity_V1beta1_MsgCreateEntity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._entityType != rhs_storage._entityType {return false}
        if _storage._entityStatus != rhs_storage._entityStatus {return false}
        if _storage._controller != rhs_storage._controller {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._verification != rhs_storage._verification {return false}
        if _storage._service != rhs_storage._service {return false}
        if _storage._accordedRight != rhs_storage._accordedRight {return false}
        if _storage._linkedResource != rhs_storage._linkedResource {return false}
        if _storage._linkedEntity != rhs_storage._linkedEntity {return false}
        if _storage._startDate != rhs_storage._startDate {return false}
        if _storage._endDate != rhs_storage._endDate {return false}
        if _storage._relayerNode != rhs_storage._relayerNode {return false}
        if _storage._credentials != rhs_storage._credentials {return false}
        if _storage._ownerDid != rhs_storage._ownerDid {return false}
        if _storage._ownerAddress != rhs_storage._ownerAddress {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._alsoKnownAs != rhs_storage._alsoKnownAs {return false}
        if _storage._linkedClaim != rhs_storage._linkedClaim {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_MsgCreateEntityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateEntityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
    2: .standard(proto: "entity_type"),
    3: .standard(proto: "entity_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entityID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.entityType) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.entityStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entityID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityID, fieldNumber: 1)
    }
    if !self.entityType.isEmpty {
      try visitor.visitSingularStringField(value: self.entityType, fieldNumber: 2)
    }
    if self.entityStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.entityStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_MsgCreateEntityResponse, rhs: Ixo_Entity_V1beta1_MsgCreateEntityResponse) -> Bool {
    if lhs.entityID != rhs.entityID {return false}
    if lhs.entityType != rhs.entityType {return false}
    if lhs.entityStatus != rhs.entityStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_MsgUpdateEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "entity_status"),
    3: .standard(proto: "start_date"),
    4: .standard(proto: "end_date"),
    5: .same(proto: "credentials"),
    6: .standard(proto: "controller_did"),
    7: .standard(proto: "controller_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.entityStatus) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startDate) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._endDate) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.credentials) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.controllerDid) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.controllerAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.entityStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.entityStatus, fieldNumber: 2)
    }
    try { if let v = self._startDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._endDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.credentials.isEmpty {
      try visitor.visitRepeatedStringField(value: self.credentials, fieldNumber: 5)
    }
    if !self.controllerDid.isEmpty {
      try visitor.visitSingularStringField(value: self.controllerDid, fieldNumber: 6)
    }
    if !self.controllerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.controllerAddress, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_MsgUpdateEntity, rhs: Ixo_Entity_V1beta1_MsgUpdateEntity) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.entityStatus != rhs.entityStatus {return false}
    if lhs._startDate != rhs._startDate {return false}
    if lhs._endDate != rhs._endDate {return false}
    if lhs.credentials != rhs.credentials {return false}
    if lhs.controllerDid != rhs.controllerDid {return false}
    if lhs.controllerAddress != rhs.controllerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_MsgUpdateEntityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateEntityResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_MsgUpdateEntityResponse, rhs: Ixo_Entity_V1beta1_MsgUpdateEntityResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_MsgUpdateEntityVerified: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateEntityVerified"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "entity_verified"),
    3: .standard(proto: "relayer_node_did"),
    4: .standard(proto: "relayer_node_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.entityVerified) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.relayerNodeDid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.relayerNodeAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.entityVerified != false {
      try visitor.visitSingularBoolField(value: self.entityVerified, fieldNumber: 2)
    }
    if !self.relayerNodeDid.isEmpty {
      try visitor.visitSingularStringField(value: self.relayerNodeDid, fieldNumber: 3)
    }
    if !self.relayerNodeAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.relayerNodeAddress, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_MsgUpdateEntityVerified, rhs: Ixo_Entity_V1beta1_MsgUpdateEntityVerified) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.entityVerified != rhs.entityVerified {return false}
    if lhs.relayerNodeDid != rhs.relayerNodeDid {return false}
    if lhs.relayerNodeAddress != rhs.relayerNodeAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_MsgUpdateEntityVerifiedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateEntityVerifiedResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_MsgUpdateEntityVerifiedResponse, rhs: Ixo_Entity_V1beta1_MsgUpdateEntityVerifiedResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_MsgTransferEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgTransferEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "owner_did"),
    3: .standard(proto: "owner_address"),
    4: .standard(proto: "recipient_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerDid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ownerAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.recipientDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.ownerDid.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerDid, fieldNumber: 2)
    }
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 3)
    }
    if !self.recipientDid.isEmpty {
      try visitor.visitSingularStringField(value: self.recipientDid, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_MsgTransferEntity, rhs: Ixo_Entity_V1beta1_MsgTransferEntity) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.ownerDid != rhs.ownerDid {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.recipientDid != rhs.recipientDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_MsgTransferEntityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgTransferEntityResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_MsgTransferEntityResponse, rhs: Ixo_Entity_V1beta1_MsgTransferEntityResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_MsgCreateEntityAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateEntityAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "owner_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ownerAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_MsgCreateEntityAccount, rhs: Ixo_Entity_V1beta1_MsgCreateEntityAccount) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_MsgCreateEntityAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateEntityAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_MsgCreateEntityAccountResponse, rhs: Ixo_Entity_V1beta1_MsgCreateEntityAccountResponse) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_MsgGrantEntityAccountAuthz: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGrantEntityAccountAuthz"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "grantee_address"),
    4: .same(proto: "grant"),
    5: .standard(proto: "owner_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.granteeAddress) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._grant) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ownerAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.granteeAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.granteeAddress, fieldNumber: 3)
    }
    try { if let v = self._grant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_MsgGrantEntityAccountAuthz, rhs: Ixo_Entity_V1beta1_MsgGrantEntityAccountAuthz) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.granteeAddress != rhs.granteeAddress {return false}
    if lhs._grant != rhs._grant {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Entity_V1beta1_MsgGrantEntityAccountAuthzResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGrantEntityAccountAuthzResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Entity_V1beta1_MsgGrantEntityAccountAuthzResponse, rhs: Ixo_Entity_V1beta1_MsgGrantEntityAccountAuthzResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
