// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: comdex/lend/v1beta1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Comdex_Lend_V1beta1_MsgLend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lender: String = String()

  var assetID: UInt64 = 0

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var poolID: UInt64 = 0

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Comdex_Lend_V1beta1_MsgWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lender: String = String()

  var lendID: UInt64 = 0

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Comdex_Lend_V1beta1_MsgDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lender: String = String()

  var lendID: UInt64 = 0

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Comdex_Lend_V1beta1_MsgCloseLend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lender: String = String()

  var lendID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgBorrow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var borrower: String = String()

  var lendID: UInt64 = 0

  var pairID: UInt64 = 0

  var isStableBorrow: Bool = false

  var amountIn: Cosmos_Base_V1beta1_Coin {
    get {return _amountIn ?? Cosmos_Base_V1beta1_Coin()}
    set {_amountIn = newValue}
  }
  /// Returns true if `amountIn` has been explicitly set.
  var hasAmountIn: Bool {return self._amountIn != nil}
  /// Clears the value of `amountIn`. Subsequent reads from it will return its default value.
  mutating func clearAmountIn() {self._amountIn = nil}

  var amountOut: Cosmos_Base_V1beta1_Coin {
    get {return _amountOut ?? Cosmos_Base_V1beta1_Coin()}
    set {_amountOut = newValue}
  }
  /// Returns true if `amountOut` has been explicitly set.
  var hasAmountOut: Bool {return self._amountOut != nil}
  /// Clears the value of `amountOut`. Subsequent reads from it will return its default value.
  mutating func clearAmountOut() {self._amountOut = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountIn: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _amountOut: Cosmos_Base_V1beta1_Coin? = nil
}

struct Comdex_Lend_V1beta1_MsgRepay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var borrower: String = String()

  var borrowID: UInt64 = 0

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Comdex_Lend_V1beta1_MsgDepositBorrow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var borrower: String = String()

  var borrowID: UInt64 = 0

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Comdex_Lend_V1beta1_MsgDraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var borrower: String = String()

  var borrowID: UInt64 = 0

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Comdex_Lend_V1beta1_MsgCloseBorrow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var borrower: String = String()

  var borrowID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgBorrowAlternate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lender: String = String()

  var assetID: UInt64 = 0

  var poolID: UInt64 = 0

  var amountIn: Cosmos_Base_V1beta1_Coin {
    get {return _amountIn ?? Cosmos_Base_V1beta1_Coin()}
    set {_amountIn = newValue}
  }
  /// Returns true if `amountIn` has been explicitly set.
  var hasAmountIn: Bool {return self._amountIn != nil}
  /// Clears the value of `amountIn`. Subsequent reads from it will return its default value.
  mutating func clearAmountIn() {self._amountIn = nil}

  var pairID: UInt64 = 0

  var isStableBorrow: Bool = false

  var amountOut: Cosmos_Base_V1beta1_Coin {
    get {return _amountOut ?? Cosmos_Base_V1beta1_Coin()}
    set {_amountOut = newValue}
  }
  /// Returns true if `amountOut` has been explicitly set.
  var hasAmountOut: Bool {return self._amountOut != nil}
  /// Clears the value of `amountOut`. Subsequent reads from it will return its default value.
  mutating func clearAmountOut() {self._amountOut = nil}

  var appID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountIn: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _amountOut: Cosmos_Base_V1beta1_Coin? = nil
}

struct Comdex_Lend_V1beta1_MsgFundModuleAccounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var assetID: UInt64 = 0

  var lender: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Comdex_Lend_V1beta1_MsgCalculateInterestAndRewards {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var borrower: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgFundReserveAccounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: UInt64 = 0

  var lender: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Comdex_Lend_V1beta1_MsgLendResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgWithdrawResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgDepositResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgCloseLendResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgBorrowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgRepayResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgDepositBorrowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgDrawResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgCloseBorrowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgBorrowAlternateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgFundModuleAccountsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgCalculateInterestAndRewardsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_MsgFundReserveAccountsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Comdex_Lend_V1beta1_MsgLend: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgWithdraw: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgDeposit: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgCloseLend: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgBorrow: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgRepay: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgDepositBorrow: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgDraw: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgCloseBorrow: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgBorrowAlternate: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgFundModuleAccounts: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgCalculateInterestAndRewards: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgFundReserveAccounts: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgLendResponse: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgWithdrawResponse: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgDepositResponse: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgCloseLendResponse: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgBorrowResponse: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgRepayResponse: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgDepositBorrowResponse: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgDrawResponse: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgCloseBorrowResponse: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgBorrowAlternateResponse: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgFundModuleAccountsResponse: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgCalculateInterestAndRewardsResponse: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_MsgFundReserveAccountsResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "comdex.lend.v1beta1"

extension Comdex_Lend_V1beta1_MsgLend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgLend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lender"),
    2: .standard(proto: "asset_id"),
    3: .same(proto: "amount"),
    4: .standard(proto: "pool_id"),
    5: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lender) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.lender.isEmpty {
      try visitor.visitSingularStringField(value: self.lender, fieldNumber: 1)
    }
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 4)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgLend, rhs: Comdex_Lend_V1beta1_MsgLend) -> Bool {
    if lhs.lender != rhs.lender {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lender"),
    2: .standard(proto: "lend_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lender) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.lendID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.lender.isEmpty {
      try visitor.visitSingularStringField(value: self.lender, fieldNumber: 1)
    }
    if self.lendID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lendID, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgWithdraw, rhs: Comdex_Lend_V1beta1_MsgWithdraw) -> Bool {
    if lhs.lender != rhs.lender {return false}
    if lhs.lendID != rhs.lendID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lender"),
    2: .standard(proto: "lend_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lender) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.lendID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.lender.isEmpty {
      try visitor.visitSingularStringField(value: self.lender, fieldNumber: 1)
    }
    if self.lendID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lendID, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgDeposit, rhs: Comdex_Lend_V1beta1_MsgDeposit) -> Bool {
    if lhs.lender != rhs.lender {return false}
    if lhs.lendID != rhs.lendID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgCloseLend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCloseLend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lender"),
    2: .standard(proto: "lend_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lender) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.lendID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lender.isEmpty {
      try visitor.visitSingularStringField(value: self.lender, fieldNumber: 1)
    }
    if self.lendID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lendID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgCloseLend, rhs: Comdex_Lend_V1beta1_MsgCloseLend) -> Bool {
    if lhs.lender != rhs.lender {return false}
    if lhs.lendID != rhs.lendID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgBorrow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBorrow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "borrower"),
    2: .standard(proto: "lend_id"),
    3: .standard(proto: "pair_id"),
    4: .standard(proto: "is_stable_borrow"),
    5: .standard(proto: "amount_in"),
    6: .standard(proto: "amount_out"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.borrower) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.lendID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.pairID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isStableBorrow) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._amountIn) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._amountOut) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.borrower.isEmpty {
      try visitor.visitSingularStringField(value: self.borrower, fieldNumber: 1)
    }
    if self.lendID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lendID, fieldNumber: 2)
    }
    if self.pairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pairID, fieldNumber: 3)
    }
    if self.isStableBorrow != false {
      try visitor.visitSingularBoolField(value: self.isStableBorrow, fieldNumber: 4)
    }
    try { if let v = self._amountIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._amountOut {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgBorrow, rhs: Comdex_Lend_V1beta1_MsgBorrow) -> Bool {
    if lhs.borrower != rhs.borrower {return false}
    if lhs.lendID != rhs.lendID {return false}
    if lhs.pairID != rhs.pairID {return false}
    if lhs.isStableBorrow != rhs.isStableBorrow {return false}
    if lhs._amountIn != rhs._amountIn {return false}
    if lhs._amountOut != rhs._amountOut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgRepay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRepay"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "borrower"),
    2: .standard(proto: "borrow_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.borrower) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.borrowID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.borrower.isEmpty {
      try visitor.visitSingularStringField(value: self.borrower, fieldNumber: 1)
    }
    if self.borrowID != 0 {
      try visitor.visitSingularUInt64Field(value: self.borrowID, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgRepay, rhs: Comdex_Lend_V1beta1_MsgRepay) -> Bool {
    if lhs.borrower != rhs.borrower {return false}
    if lhs.borrowID != rhs.borrowID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgDepositBorrow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDepositBorrow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "borrower"),
    2: .standard(proto: "borrow_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.borrower) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.borrowID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.borrower.isEmpty {
      try visitor.visitSingularStringField(value: self.borrower, fieldNumber: 1)
    }
    if self.borrowID != 0 {
      try visitor.visitSingularUInt64Field(value: self.borrowID, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgDepositBorrow, rhs: Comdex_Lend_V1beta1_MsgDepositBorrow) -> Bool {
    if lhs.borrower != rhs.borrower {return false}
    if lhs.borrowID != rhs.borrowID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgDraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "borrower"),
    2: .standard(proto: "borrow_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.borrower) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.borrowID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.borrower.isEmpty {
      try visitor.visitSingularStringField(value: self.borrower, fieldNumber: 1)
    }
    if self.borrowID != 0 {
      try visitor.visitSingularUInt64Field(value: self.borrowID, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgDraw, rhs: Comdex_Lend_V1beta1_MsgDraw) -> Bool {
    if lhs.borrower != rhs.borrower {return false}
    if lhs.borrowID != rhs.borrowID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgCloseBorrow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCloseBorrow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "borrower"),
    2: .standard(proto: "borrow_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.borrower) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.borrowID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.borrower.isEmpty {
      try visitor.visitSingularStringField(value: self.borrower, fieldNumber: 1)
    }
    if self.borrowID != 0 {
      try visitor.visitSingularUInt64Field(value: self.borrowID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgCloseBorrow, rhs: Comdex_Lend_V1beta1_MsgCloseBorrow) -> Bool {
    if lhs.borrower != rhs.borrower {return false}
    if lhs.borrowID != rhs.borrowID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgBorrowAlternate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBorrowAlternate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lender"),
    2: .standard(proto: "asset_id"),
    3: .standard(proto: "pool_id"),
    4: .standard(proto: "amount_in"),
    5: .standard(proto: "pair_id"),
    6: .standard(proto: "is_stable_borrow"),
    7: .standard(proto: "amount_out"),
    8: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lender) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amountIn) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.pairID) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isStableBorrow) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._amountOut) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.lender.isEmpty {
      try visitor.visitSingularStringField(value: self.lender, fieldNumber: 1)
    }
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 2)
    }
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 3)
    }
    try { if let v = self._amountIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.pairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pairID, fieldNumber: 5)
    }
    if self.isStableBorrow != false {
      try visitor.visitSingularBoolField(value: self.isStableBorrow, fieldNumber: 6)
    }
    try { if let v = self._amountOut {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgBorrowAlternate, rhs: Comdex_Lend_V1beta1_MsgBorrowAlternate) -> Bool {
    if lhs.lender != rhs.lender {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs._amountIn != rhs._amountIn {return false}
    if lhs.pairID != rhs.pairID {return false}
    if lhs.isStableBorrow != rhs.isStableBorrow {return false}
    if lhs._amountOut != rhs._amountOut {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgFundModuleAccounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgFundModuleAccounts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "poolId"),
    2: .same(proto: "assetId"),
    3: .same(proto: "lender"),
    4: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lender) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 2)
    }
    if !self.lender.isEmpty {
      try visitor.visitSingularStringField(value: self.lender, fieldNumber: 3)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgFundModuleAccounts, rhs: Comdex_Lend_V1beta1_MsgFundModuleAccounts) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.lender != rhs.lender {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgCalculateInterestAndRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCalculateInterestAndRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "borrower"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.borrower) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.borrower.isEmpty {
      try visitor.visitSingularStringField(value: self.borrower, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgCalculateInterestAndRewards, rhs: Comdex_Lend_V1beta1_MsgCalculateInterestAndRewards) -> Bool {
    if lhs.borrower != rhs.borrower {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgFundReserveAccounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgFundReserveAccounts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "assetId"),
    2: .same(proto: "lender"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lender) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 1)
    }
    if !self.lender.isEmpty {
      try visitor.visitSingularStringField(value: self.lender, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgFundReserveAccounts, rhs: Comdex_Lend_V1beta1_MsgFundReserveAccounts) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.lender != rhs.lender {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgLendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgLendResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgLendResponse, rhs: Comdex_Lend_V1beta1_MsgLendResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgWithdrawResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgWithdrawResponse, rhs: Comdex_Lend_V1beta1_MsgWithdrawResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgDepositResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDepositResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgDepositResponse, rhs: Comdex_Lend_V1beta1_MsgDepositResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgCloseLendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCloseLendResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgCloseLendResponse, rhs: Comdex_Lend_V1beta1_MsgCloseLendResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgBorrowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBorrowResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgBorrowResponse, rhs: Comdex_Lend_V1beta1_MsgBorrowResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgRepayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRepayResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgRepayResponse, rhs: Comdex_Lend_V1beta1_MsgRepayResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgDepositBorrowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDepositBorrowResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgDepositBorrowResponse, rhs: Comdex_Lend_V1beta1_MsgDepositBorrowResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgDrawResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDrawResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgDrawResponse, rhs: Comdex_Lend_V1beta1_MsgDrawResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgCloseBorrowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCloseBorrowResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgCloseBorrowResponse, rhs: Comdex_Lend_V1beta1_MsgCloseBorrowResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgBorrowAlternateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBorrowAlternateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgBorrowAlternateResponse, rhs: Comdex_Lend_V1beta1_MsgBorrowAlternateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgFundModuleAccountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgFundModuleAccountsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgFundModuleAccountsResponse, rhs: Comdex_Lend_V1beta1_MsgFundModuleAccountsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgCalculateInterestAndRewardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCalculateInterestAndRewardsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgCalculateInterestAndRewardsResponse, rhs: Comdex_Lend_V1beta1_MsgCalculateInterestAndRewardsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_MsgFundReserveAccountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgFundReserveAccountsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_MsgFundReserveAccountsResponse, rhs: Comdex_Lend_V1beta1_MsgFundReserveAccountsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
