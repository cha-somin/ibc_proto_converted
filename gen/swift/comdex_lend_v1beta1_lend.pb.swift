// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: comdex/lend/v1beta1/lend.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Comdex_Lend_V1beta1_LendAsset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lendingID: UInt64 = 0

  var assetID: UInt64 = 0

  var poolID: UInt64 = 0

  var owner: String = String()

  var amountIn: Cosmos_Base_V1beta1_Coin {
    get {return _amountIn ?? Cosmos_Base_V1beta1_Coin()}
    set {_amountIn = newValue}
  }
  /// Returns true if `amountIn` has been explicitly set.
  var hasAmountIn: Bool {return self._amountIn != nil}
  /// Clears the value of `amountIn`. Subsequent reads from it will return its default value.
  mutating func clearAmountIn() {self._amountIn = nil}

  var lendingTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lendingTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lendingTime = newValue}
  }
  /// Returns true if `lendingTime` has been explicitly set.
  var hasLendingTime: Bool {return self._lendingTime != nil}
  /// Clears the value of `lendingTime`. Subsequent reads from it will return its default value.
  mutating func clearLendingTime() {self._lendingTime = nil}

  var availableToBorrow: String = String()

  var appID: UInt64 = 0

  var globalIndex: String = String()

  var lastInteractionTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastInteractionTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastInteractionTime = newValue}
  }
  /// Returns true if `lastInteractionTime` has been explicitly set.
  var hasLastInteractionTime: Bool {return self._lastInteractionTime != nil}
  /// Clears the value of `lastInteractionTime`. Subsequent reads from it will return its default value.
  mutating func clearLastInteractionTime() {self._lastInteractionTime = nil}

  var cpoolName: String = String()

  var totalRewards: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountIn: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _lendingTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastInteractionTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Comdex_Lend_V1beta1_BorrowAsset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var borrowingID: UInt64 {
    get {return _storage._borrowingID}
    set {_uniqueStorage()._borrowingID = newValue}
  }

  var lendingID: UInt64 {
    get {return _storage._lendingID}
    set {_uniqueStorage()._lendingID = newValue}
  }

  var isStableBorrow: Bool {
    get {return _storage._isStableBorrow}
    set {_uniqueStorage()._isStableBorrow = newValue}
  }

  var pairID: UInt64 {
    get {return _storage._pairID}
    set {_uniqueStorage()._pairID = newValue}
  }

  var amountIn: Cosmos_Base_V1beta1_Coin {
    get {return _storage._amountIn ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._amountIn = newValue}
  }
  /// Returns true if `amountIn` has been explicitly set.
  var hasAmountIn: Bool {return _storage._amountIn != nil}
  /// Clears the value of `amountIn`. Subsequent reads from it will return its default value.
  mutating func clearAmountIn() {_uniqueStorage()._amountIn = nil}

  var amountOut: Cosmos_Base_V1beta1_Coin {
    get {return _storage._amountOut ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._amountOut = newValue}
  }
  /// Returns true if `amountOut` has been explicitly set.
  var hasAmountOut: Bool {return _storage._amountOut != nil}
  /// Clears the value of `amountOut`. Subsequent reads from it will return its default value.
  mutating func clearAmountOut() {_uniqueStorage()._amountOut = nil}

  var bridgedAssetAmount: Cosmos_Base_V1beta1_Coin {
    get {return _storage._bridgedAssetAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._bridgedAssetAmount = newValue}
  }
  /// Returns true if `bridgedAssetAmount` has been explicitly set.
  var hasBridgedAssetAmount: Bool {return _storage._bridgedAssetAmount != nil}
  /// Clears the value of `bridgedAssetAmount`. Subsequent reads from it will return its default value.
  mutating func clearBridgedAssetAmount() {_uniqueStorage()._bridgedAssetAmount = nil}

  var borrowingTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._borrowingTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._borrowingTime = newValue}
  }
  /// Returns true if `borrowingTime` has been explicitly set.
  var hasBorrowingTime: Bool {return _storage._borrowingTime != nil}
  /// Clears the value of `borrowingTime`. Subsequent reads from it will return its default value.
  mutating func clearBorrowingTime() {_uniqueStorage()._borrowingTime = nil}

  var stableBorrowRate: String {
    get {return _storage._stableBorrowRate}
    set {_uniqueStorage()._stableBorrowRate = newValue}
  }

  var interestAccumulated: String {
    get {return _storage._interestAccumulated}
    set {_uniqueStorage()._interestAccumulated = newValue}
  }

  var globalIndex: String {
    get {return _storage._globalIndex}
    set {_uniqueStorage()._globalIndex = newValue}
  }

  var reserveGlobalIndex: String {
    get {return _storage._reserveGlobalIndex}
    set {_uniqueStorage()._reserveGlobalIndex = newValue}
  }

  var lastInteractionTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastInteractionTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastInteractionTime = newValue}
  }
  /// Returns true if `lastInteractionTime` has been explicitly set.
  var hasLastInteractionTime: Bool {return _storage._lastInteractionTime != nil}
  /// Clears the value of `lastInteractionTime`. Subsequent reads from it will return its default value.
  mutating func clearLastInteractionTime() {_uniqueStorage()._lastInteractionTime = nil}

  var cpoolName: String {
    get {return _storage._cpoolName}
    set {_uniqueStorage()._cpoolName = newValue}
  }

  var isLiquidated: Bool {
    get {return _storage._isLiquidated}
    set {_uniqueStorage()._isLiquidated = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Comdex_Lend_V1beta1_Pool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var moduleName: String = String()

  var cpoolName: String = String()

  var assetData: [Comdex_Lend_V1beta1_AssetDataPoolMapping] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_UserAssetLendBorrowMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var owner: String = String()

  ///to check if poool id is needed
  var lendID: UInt64 = 0

  var poolID: UInt64 = 0

  var borrowID: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_AssetDataPoolMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: UInt64 = 0

  /// 1 for main_asset, 2 for 1st transit_asset, 3 for 2nd transit_asset
  var assetTransitType: UInt64 = 0

  var supplyCap: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_Extended_Pair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var assetIn: UInt64 = 0

  var assetOut: UInt64 = 0

  var isInterPool: Bool = false

  var assetOutPoolID: UInt64 = 0

  var minUsdValueLeft: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_AssetToPairMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var assetID: UInt64 = 0

  var pairID: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///AssetStats
struct Comdex_Lend_V1beta1_PoolAssetLBMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var assetID: UInt64 = 0

  var lendIds: [UInt64] = []

  var borrowIds: [UInt64] = []

  var totalBorrowed: String = String()

  var totalStableBorrowed: String = String()

  var totalLend: String = String()

  var totalInterestAccumulated: String = String()

  var lendApr: String = String()

  var borrowApr: String = String()

  var stableBorrowApr: String = String()

  var utilisationRatio: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///AssetRatesStats
struct Comdex_Lend_V1beta1_AssetRatesParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: UInt64 = 0

  var uOptimal: String = String()

  var base: String = String()

  var slope1: String = String()

  var slope2: String = String()

  var enableStableBorrow: Bool = false

  var stableBase: String = String()

  var stableSlope1: String = String()

  var stableSlope2: String = String()

  var ltv: String = String()

  var liquidationThreshold: String = String()

  var liquidationPenalty: String = String()

  var liquidationBonus: String = String()

  var reserveFactor: String = String()

  var cAssetID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BalanceStats
struct Comdex_Lend_V1beta1_ReserveBuybackAssetData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: UInt64 = 0

  var reserveAmount: String = String()

  var buybackAmount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_AuctionParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt64 = 0

  var auctionDurationSeconds: UInt64 = 0

  var buffer: String = String()

  var cusp: String = String()

  var step: String = String()

  var priceFunctionType: UInt64 = 0

  var dutchID: UInt64 = 0

  var bidDurationSeconds: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_Borrow_interest_tracker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var borrowingID: UInt64 = 0

  var reservePoolInterest: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_Lend_rewards_tracker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lendingID: UInt64 = 0

  var rewardsAccumulated: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_ModuleBalance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var moduleBalanceStats: [Comdex_Lend_V1beta1_ModuleBalanceStats] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_ModuleBalanceStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: UInt64 = 0

  var balance: Cosmos_Base_V1beta1_Coin {
    get {return _balance ?? Cosmos_Base_V1beta1_Coin()}
    set {_balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  var hasBalance: Bool {return self._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  mutating func clearBalance() {self._balance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _balance: Cosmos_Base_V1beta1_Coin? = nil
}

struct Comdex_Lend_V1beta1_ModBal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fundModuleBalance: [Comdex_Lend_V1beta1_FundModBal] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_ReserveBal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fundReserveBalance: [Comdex_Lend_V1beta1_FundReserveBal] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_FundModBal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: UInt64 = 0

  var poolID: UInt64 = 0

  var amountIn: Cosmos_Base_V1beta1_Coin {
    get {return _amountIn ?? Cosmos_Base_V1beta1_Coin()}
    set {_amountIn = newValue}
  }
  /// Returns true if `amountIn` has been explicitly set.
  var hasAmountIn: Bool {return self._amountIn != nil}
  /// Clears the value of `amountIn`. Subsequent reads from it will return its default value.
  mutating func clearAmountIn() {self._amountIn = nil}

  var depositTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _depositTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_depositTime = newValue}
  }
  /// Returns true if `depositTime` has been explicitly set.
  var hasDepositTime: Bool {return self._depositTime != nil}
  /// Clears the value of `depositTime`. Subsequent reads from it will return its default value.
  mutating func clearDepositTime() {self._depositTime = nil}

  var funder: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountIn: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _depositTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Comdex_Lend_V1beta1_FundReserveBal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: UInt64 = 0

  var amountIn: Cosmos_Base_V1beta1_Coin {
    get {return _amountIn ?? Cosmos_Base_V1beta1_Coin()}
    set {_amountIn = newValue}
  }
  /// Returns true if `amountIn` has been explicitly set.
  var hasAmountIn: Bool {return self._amountIn != nil}
  /// Clears the value of `amountIn`. Subsequent reads from it will return its default value.
  mutating func clearAmountIn() {self._amountIn = nil}

  var depositTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _depositTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_depositTime = newValue}
  }
  /// Returns true if `depositTime` has been explicitly set.
  var hasDepositTime: Bool {return self._depositTime != nil}
  /// Clears the value of `depositTime`. Subsequent reads from it will return its default value.
  mutating func clearDepositTime() {self._depositTime = nil}

  var funder: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amountIn: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _depositTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Comdex_Lend_V1beta1_AllReserveStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: UInt64 = 0

  var amountOutFromReserveToLenders: String = String()

  var amountOutFromReserveForAuction: String = String()

  var amountInFromLiqPenalty: String = String()

  var amountInFromRepayments: String = String()

  var totalAmountOutToLenders: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_AssetToPairSingleMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var assetID: UInt64 = 0

  var pairID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_PoolPairs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var moduleName: String = String()

  var cpoolName: String = String()

  var assetData: [Comdex_Lend_V1beta1_AssetDataPoolMapping] = []

  var minUsdValueLeft: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_PoolInterestData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: UInt64 = 0

  var lendInterest: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_PoolInterest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var poolInterestData: [Comdex_Lend_V1beta1_PoolInterestData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_PoolInterestDataB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: UInt64 = 0

  var borrowInterest: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_PoolInterestB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poolID: UInt64 = 0

  var poolInterestData: [Comdex_Lend_V1beta1_PoolInterestDataB] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Comdex_Lend_V1beta1_AssetRatesPoolPairs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: UInt64 {
    get {return _storage._assetID}
    set {_uniqueStorage()._assetID = newValue}
  }

  var uOptimal: String {
    get {return _storage._uOptimal}
    set {_uniqueStorage()._uOptimal = newValue}
  }

  var base: String {
    get {return _storage._base}
    set {_uniqueStorage()._base = newValue}
  }

  var slope1: String {
    get {return _storage._slope1}
    set {_uniqueStorage()._slope1 = newValue}
  }

  var slope2: String {
    get {return _storage._slope2}
    set {_uniqueStorage()._slope2 = newValue}
  }

  var enableStableBorrow: Bool {
    get {return _storage._enableStableBorrow}
    set {_uniqueStorage()._enableStableBorrow = newValue}
  }

  var stableBase: String {
    get {return _storage._stableBase}
    set {_uniqueStorage()._stableBase = newValue}
  }

  var stableSlope1: String {
    get {return _storage._stableSlope1}
    set {_uniqueStorage()._stableSlope1 = newValue}
  }

  var stableSlope2: String {
    get {return _storage._stableSlope2}
    set {_uniqueStorage()._stableSlope2 = newValue}
  }

  var ltv: String {
    get {return _storage._ltv}
    set {_uniqueStorage()._ltv = newValue}
  }

  var liquidationThreshold: String {
    get {return _storage._liquidationThreshold}
    set {_uniqueStorage()._liquidationThreshold = newValue}
  }

  var liquidationPenalty: String {
    get {return _storage._liquidationPenalty}
    set {_uniqueStorage()._liquidationPenalty = newValue}
  }

  var liquidationBonus: String {
    get {return _storage._liquidationBonus}
    set {_uniqueStorage()._liquidationBonus = newValue}
  }

  var reserveFactor: String {
    get {return _storage._reserveFactor}
    set {_uniqueStorage()._reserveFactor = newValue}
  }

  var cAssetID: UInt64 {
    get {return _storage._cAssetID}
    set {_uniqueStorage()._cAssetID = newValue}
  }

  var moduleName: String {
    get {return _storage._moduleName}
    set {_uniqueStorage()._moduleName = newValue}
  }

  var cpoolName: String {
    get {return _storage._cpoolName}
    set {_uniqueStorage()._cpoolName = newValue}
  }

  var assetData: [Comdex_Lend_V1beta1_AssetDataPoolMapping] {
    get {return _storage._assetData}
    set {_uniqueStorage()._assetData = newValue}
  }

  var minUsdValueLeft: UInt64 {
    get {return _storage._minUsdValueLeft}
    set {_uniqueStorage()._minUsdValueLeft = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Comdex_Lend_V1beta1_LendAsset: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_BorrowAsset: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_Pool: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_UserAssetLendBorrowMapping: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_AssetDataPoolMapping: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_Extended_Pair: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_AssetToPairMapping: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_PoolAssetLBMapping: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_AssetRatesParams: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_ReserveBuybackAssetData: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_AuctionParams: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_Borrow_interest_tracker: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_Lend_rewards_tracker: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_ModuleBalance: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_ModuleBalanceStats: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_ModBal: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_ReserveBal: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_FundModBal: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_FundReserveBal: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_AllReserveStats: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_AssetToPairSingleMapping: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_PoolPairs: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_PoolInterestData: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_PoolInterest: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_PoolInterestDataB: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_PoolInterestB: @unchecked Sendable {}
extension Comdex_Lend_V1beta1_AssetRatesPoolPairs: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "comdex.lend.v1beta1"

extension Comdex_Lend_V1beta1_LendAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LendAsset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lending_id"),
    2: .standard(proto: "asset_id"),
    3: .standard(proto: "pool_id"),
    4: .same(proto: "owner"),
    5: .standard(proto: "amount_in"),
    6: .standard(proto: "lending_time"),
    7: .standard(proto: "available_to_borrow"),
    8: .standard(proto: "app_id"),
    9: .standard(proto: "global_index"),
    10: .standard(proto: "last_interaction_time"),
    11: .standard(proto: "cpool_name"),
    12: .standard(proto: "total_rewards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.lendingID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._amountIn) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._lendingTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.availableToBorrow) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.globalIndex) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._lastInteractionTime) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.cpoolName) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.totalRewards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.lendingID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lendingID, fieldNumber: 1)
    }
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 2)
    }
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 3)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 4)
    }
    try { if let v = self._amountIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._lendingTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.availableToBorrow.isEmpty {
      try visitor.visitSingularStringField(value: self.availableToBorrow, fieldNumber: 7)
    }
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 8)
    }
    if !self.globalIndex.isEmpty {
      try visitor.visitSingularStringField(value: self.globalIndex, fieldNumber: 9)
    }
    try { if let v = self._lastInteractionTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if !self.cpoolName.isEmpty {
      try visitor.visitSingularStringField(value: self.cpoolName, fieldNumber: 11)
    }
    if !self.totalRewards.isEmpty {
      try visitor.visitSingularStringField(value: self.totalRewards, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_LendAsset, rhs: Comdex_Lend_V1beta1_LendAsset) -> Bool {
    if lhs.lendingID != rhs.lendingID {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs._amountIn != rhs._amountIn {return false}
    if lhs._lendingTime != rhs._lendingTime {return false}
    if lhs.availableToBorrow != rhs.availableToBorrow {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.globalIndex != rhs.globalIndex {return false}
    if lhs._lastInteractionTime != rhs._lastInteractionTime {return false}
    if lhs.cpoolName != rhs.cpoolName {return false}
    if lhs.totalRewards != rhs.totalRewards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_BorrowAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BorrowAsset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "borrowing_id"),
    2: .standard(proto: "lending_id"),
    3: .standard(proto: "is_stable_borrow"),
    4: .standard(proto: "pair_id"),
    5: .standard(proto: "amount_in"),
    6: .standard(proto: "amount_out"),
    7: .standard(proto: "bridged_asset_amount"),
    8: .standard(proto: "borrowing_time"),
    9: .standard(proto: "stable_borrow_rate"),
    10: .standard(proto: "interest_accumulated"),
    11: .standard(proto: "global_index"),
    12: .standard(proto: "reserve_global_index"),
    13: .standard(proto: "last_interaction_time"),
    14: .standard(proto: "cpool_name"),
    15: .standard(proto: "is_liquidated"),
  ]

  fileprivate class _StorageClass {
    var _borrowingID: UInt64 = 0
    var _lendingID: UInt64 = 0
    var _isStableBorrow: Bool = false
    var _pairID: UInt64 = 0
    var _amountIn: Cosmos_Base_V1beta1_Coin? = nil
    var _amountOut: Cosmos_Base_V1beta1_Coin? = nil
    var _bridgedAssetAmount: Cosmos_Base_V1beta1_Coin? = nil
    var _borrowingTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _stableBorrowRate: String = String()
    var _interestAccumulated: String = String()
    var _globalIndex: String = String()
    var _reserveGlobalIndex: String = String()
    var _lastInteractionTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _cpoolName: String = String()
    var _isLiquidated: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _borrowingID = source._borrowingID
      _lendingID = source._lendingID
      _isStableBorrow = source._isStableBorrow
      _pairID = source._pairID
      _amountIn = source._amountIn
      _amountOut = source._amountOut
      _bridgedAssetAmount = source._bridgedAssetAmount
      _borrowingTime = source._borrowingTime
      _stableBorrowRate = source._stableBorrowRate
      _interestAccumulated = source._interestAccumulated
      _globalIndex = source._globalIndex
      _reserveGlobalIndex = source._reserveGlobalIndex
      _lastInteractionTime = source._lastInteractionTime
      _cpoolName = source._cpoolName
      _isLiquidated = source._isLiquidated
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._borrowingID) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._lendingID) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._isStableBorrow) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._pairID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._amountIn) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._amountOut) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._bridgedAssetAmount) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._borrowingTime) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._stableBorrowRate) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._interestAccumulated) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._globalIndex) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._reserveGlobalIndex) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._lastInteractionTime) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._cpoolName) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._isLiquidated) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._borrowingID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._borrowingID, fieldNumber: 1)
      }
      if _storage._lendingID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lendingID, fieldNumber: 2)
      }
      if _storage._isStableBorrow != false {
        try visitor.visitSingularBoolField(value: _storage._isStableBorrow, fieldNumber: 3)
      }
      if _storage._pairID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._pairID, fieldNumber: 4)
      }
      try { if let v = _storage._amountIn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._amountOut {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._bridgedAssetAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._borrowingTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._stableBorrowRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stableBorrowRate, fieldNumber: 9)
      }
      if !_storage._interestAccumulated.isEmpty {
        try visitor.visitSingularStringField(value: _storage._interestAccumulated, fieldNumber: 10)
      }
      if !_storage._globalIndex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._globalIndex, fieldNumber: 11)
      }
      if !_storage._reserveGlobalIndex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reserveGlobalIndex, fieldNumber: 12)
      }
      try { if let v = _storage._lastInteractionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._cpoolName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cpoolName, fieldNumber: 14)
      }
      if _storage._isLiquidated != false {
        try visitor.visitSingularBoolField(value: _storage._isLiquidated, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_BorrowAsset, rhs: Comdex_Lend_V1beta1_BorrowAsset) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._borrowingID != rhs_storage._borrowingID {return false}
        if _storage._lendingID != rhs_storage._lendingID {return false}
        if _storage._isStableBorrow != rhs_storage._isStableBorrow {return false}
        if _storage._pairID != rhs_storage._pairID {return false}
        if _storage._amountIn != rhs_storage._amountIn {return false}
        if _storage._amountOut != rhs_storage._amountOut {return false}
        if _storage._bridgedAssetAmount != rhs_storage._bridgedAssetAmount {return false}
        if _storage._borrowingTime != rhs_storage._borrowingTime {return false}
        if _storage._stableBorrowRate != rhs_storage._stableBorrowRate {return false}
        if _storage._interestAccumulated != rhs_storage._interestAccumulated {return false}
        if _storage._globalIndex != rhs_storage._globalIndex {return false}
        if _storage._reserveGlobalIndex != rhs_storage._reserveGlobalIndex {return false}
        if _storage._lastInteractionTime != rhs_storage._lastInteractionTime {return false}
        if _storage._cpoolName != rhs_storage._cpoolName {return false}
        if _storage._isLiquidated != rhs_storage._isLiquidated {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_Pool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "module_name"),
    3: .standard(proto: "cpool_name"),
    4: .standard(proto: "asset_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cpoolName) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.assetData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if !self.moduleName.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleName, fieldNumber: 2)
    }
    if !self.cpoolName.isEmpty {
      try visitor.visitSingularStringField(value: self.cpoolName, fieldNumber: 3)
    }
    if !self.assetData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assetData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_Pool, rhs: Comdex_Lend_V1beta1_Pool) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.moduleName != rhs.moduleName {return false}
    if lhs.cpoolName != rhs.cpoolName {return false}
    if lhs.assetData != rhs.assetData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_UserAssetLendBorrowMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserAssetLendBorrowMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .standard(proto: "lend_id"),
    3: .standard(proto: "pool_id"),
    4: .standard(proto: "borrow_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.lendID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 4: try { try decoder.decodeRepeatedUInt64Field(value: &self.borrowID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    if self.lendID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lendID, fieldNumber: 2)
    }
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 3)
    }
    if !self.borrowID.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.borrowID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_UserAssetLendBorrowMapping, rhs: Comdex_Lend_V1beta1_UserAssetLendBorrowMapping) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.lendID != rhs.lendID {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs.borrowID != rhs.borrowID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_AssetDataPoolMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssetDataPoolMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .standard(proto: "asset_transit_type"),
    3: .standard(proto: "supply_cap"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assetTransitType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.supplyCap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 1)
    }
    if self.assetTransitType != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetTransitType, fieldNumber: 2)
    }
    if !self.supplyCap.isEmpty {
      try visitor.visitSingularStringField(value: self.supplyCap, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_AssetDataPoolMapping, rhs: Comdex_Lend_V1beta1_AssetDataPoolMapping) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.assetTransitType != rhs.assetTransitType {return false}
    if lhs.supplyCap != rhs.supplyCap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_Extended_Pair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Extended_Pair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "asset_in"),
    3: .standard(proto: "asset_out"),
    4: .standard(proto: "is_inter_pool"),
    5: .standard(proto: "asset_out_pool_id"),
    6: .standard(proto: "min_usd_value_left"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assetIn) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.assetOut) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isInterPool) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.assetOutPoolID) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.minUsdValueLeft) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.assetIn != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetIn, fieldNumber: 2)
    }
    if self.assetOut != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetOut, fieldNumber: 3)
    }
    if self.isInterPool != false {
      try visitor.visitSingularBoolField(value: self.isInterPool, fieldNumber: 4)
    }
    if self.assetOutPoolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetOutPoolID, fieldNumber: 5)
    }
    if self.minUsdValueLeft != 0 {
      try visitor.visitSingularUInt64Field(value: self.minUsdValueLeft, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_Extended_Pair, rhs: Comdex_Lend_V1beta1_Extended_Pair) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.assetIn != rhs.assetIn {return false}
    if lhs.assetOut != rhs.assetOut {return false}
    if lhs.isInterPool != rhs.isInterPool {return false}
    if lhs.assetOutPoolID != rhs.assetOutPoolID {return false}
    if lhs.minUsdValueLeft != rhs.minUsdValueLeft {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_AssetToPairMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssetToPairMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "asset_id"),
    3: .standard(proto: "pair_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 3: try { try decoder.decodeRepeatedUInt64Field(value: &self.pairID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 2)
    }
    if !self.pairID.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.pairID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_AssetToPairMapping, rhs: Comdex_Lend_V1beta1_AssetToPairMapping) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.pairID != rhs.pairID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_PoolAssetLBMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolAssetLBMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "asset_id"),
    3: .standard(proto: "lend_ids"),
    4: .standard(proto: "borrow_ids"),
    5: .standard(proto: "total_borrowed"),
    6: .standard(proto: "total_stable_borrowed"),
    7: .standard(proto: "total_lend"),
    8: .standard(proto: "total_interest_accumulated"),
    9: .standard(proto: "lend_apr"),
    10: .standard(proto: "borrow_apr"),
    11: .standard(proto: "stable_borrow_apr"),
    12: .standard(proto: "utilisation_ratio"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 3: try { try decoder.decodeRepeatedUInt64Field(value: &self.lendIds) }()
      case 4: try { try decoder.decodeRepeatedUInt64Field(value: &self.borrowIds) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.totalBorrowed) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.totalStableBorrowed) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.totalLend) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.totalInterestAccumulated) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.lendApr) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.borrowApr) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.stableBorrowApr) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.utilisationRatio) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 2)
    }
    if !self.lendIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.lendIds, fieldNumber: 3)
    }
    if !self.borrowIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.borrowIds, fieldNumber: 4)
    }
    if !self.totalBorrowed.isEmpty {
      try visitor.visitSingularStringField(value: self.totalBorrowed, fieldNumber: 5)
    }
    if !self.totalStableBorrowed.isEmpty {
      try visitor.visitSingularStringField(value: self.totalStableBorrowed, fieldNumber: 6)
    }
    if !self.totalLend.isEmpty {
      try visitor.visitSingularStringField(value: self.totalLend, fieldNumber: 7)
    }
    if !self.totalInterestAccumulated.isEmpty {
      try visitor.visitSingularStringField(value: self.totalInterestAccumulated, fieldNumber: 8)
    }
    if !self.lendApr.isEmpty {
      try visitor.visitSingularStringField(value: self.lendApr, fieldNumber: 9)
    }
    if !self.borrowApr.isEmpty {
      try visitor.visitSingularStringField(value: self.borrowApr, fieldNumber: 10)
    }
    if !self.stableBorrowApr.isEmpty {
      try visitor.visitSingularStringField(value: self.stableBorrowApr, fieldNumber: 11)
    }
    if !self.utilisationRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.utilisationRatio, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_PoolAssetLBMapping, rhs: Comdex_Lend_V1beta1_PoolAssetLBMapping) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.lendIds != rhs.lendIds {return false}
    if lhs.borrowIds != rhs.borrowIds {return false}
    if lhs.totalBorrowed != rhs.totalBorrowed {return false}
    if lhs.totalStableBorrowed != rhs.totalStableBorrowed {return false}
    if lhs.totalLend != rhs.totalLend {return false}
    if lhs.totalInterestAccumulated != rhs.totalInterestAccumulated {return false}
    if lhs.lendApr != rhs.lendApr {return false}
    if lhs.borrowApr != rhs.borrowApr {return false}
    if lhs.stableBorrowApr != rhs.stableBorrowApr {return false}
    if lhs.utilisationRatio != rhs.utilisationRatio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_AssetRatesParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssetRatesParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .standard(proto: "u_optimal"),
    3: .same(proto: "base"),
    4: .same(proto: "slope1"),
    5: .same(proto: "slope2"),
    6: .standard(proto: "enable_stable_borrow"),
    7: .standard(proto: "stable_base"),
    8: .standard(proto: "stable_slope1"),
    9: .standard(proto: "stable_slope2"),
    10: .same(proto: "ltv"),
    11: .standard(proto: "liquidation_threshold"),
    12: .standard(proto: "liquidation_penalty"),
    13: .standard(proto: "liquidation_bonus"),
    14: .standard(proto: "reserve_factor"),
    15: .standard(proto: "c_asset_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uOptimal) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.base) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.slope1) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.slope2) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.enableStableBorrow) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.stableBase) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.stableSlope1) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.stableSlope2) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.ltv) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.liquidationThreshold) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.liquidationPenalty) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.liquidationBonus) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.reserveFactor) }()
      case 15: try { try decoder.decodeSingularUInt64Field(value: &self.cAssetID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 1)
    }
    if !self.uOptimal.isEmpty {
      try visitor.visitSingularStringField(value: self.uOptimal, fieldNumber: 2)
    }
    if !self.base.isEmpty {
      try visitor.visitSingularStringField(value: self.base, fieldNumber: 3)
    }
    if !self.slope1.isEmpty {
      try visitor.visitSingularStringField(value: self.slope1, fieldNumber: 4)
    }
    if !self.slope2.isEmpty {
      try visitor.visitSingularStringField(value: self.slope2, fieldNumber: 5)
    }
    if self.enableStableBorrow != false {
      try visitor.visitSingularBoolField(value: self.enableStableBorrow, fieldNumber: 6)
    }
    if !self.stableBase.isEmpty {
      try visitor.visitSingularStringField(value: self.stableBase, fieldNumber: 7)
    }
    if !self.stableSlope1.isEmpty {
      try visitor.visitSingularStringField(value: self.stableSlope1, fieldNumber: 8)
    }
    if !self.stableSlope2.isEmpty {
      try visitor.visitSingularStringField(value: self.stableSlope2, fieldNumber: 9)
    }
    if !self.ltv.isEmpty {
      try visitor.visitSingularStringField(value: self.ltv, fieldNumber: 10)
    }
    if !self.liquidationThreshold.isEmpty {
      try visitor.visitSingularStringField(value: self.liquidationThreshold, fieldNumber: 11)
    }
    if !self.liquidationPenalty.isEmpty {
      try visitor.visitSingularStringField(value: self.liquidationPenalty, fieldNumber: 12)
    }
    if !self.liquidationBonus.isEmpty {
      try visitor.visitSingularStringField(value: self.liquidationBonus, fieldNumber: 13)
    }
    if !self.reserveFactor.isEmpty {
      try visitor.visitSingularStringField(value: self.reserveFactor, fieldNumber: 14)
    }
    if self.cAssetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.cAssetID, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_AssetRatesParams, rhs: Comdex_Lend_V1beta1_AssetRatesParams) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.uOptimal != rhs.uOptimal {return false}
    if lhs.base != rhs.base {return false}
    if lhs.slope1 != rhs.slope1 {return false}
    if lhs.slope2 != rhs.slope2 {return false}
    if lhs.enableStableBorrow != rhs.enableStableBorrow {return false}
    if lhs.stableBase != rhs.stableBase {return false}
    if lhs.stableSlope1 != rhs.stableSlope1 {return false}
    if lhs.stableSlope2 != rhs.stableSlope2 {return false}
    if lhs.ltv != rhs.ltv {return false}
    if lhs.liquidationThreshold != rhs.liquidationThreshold {return false}
    if lhs.liquidationPenalty != rhs.liquidationPenalty {return false}
    if lhs.liquidationBonus != rhs.liquidationBonus {return false}
    if lhs.reserveFactor != rhs.reserveFactor {return false}
    if lhs.cAssetID != rhs.cAssetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_ReserveBuybackAssetData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReserveBuybackAssetData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .standard(proto: "reserve_amount"),
    3: .standard(proto: "buyback_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reserveAmount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.buybackAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 1)
    }
    if !self.reserveAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.reserveAmount, fieldNumber: 2)
    }
    if !self.buybackAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.buybackAmount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_ReserveBuybackAssetData, rhs: Comdex_Lend_V1beta1_ReserveBuybackAssetData) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.reserveAmount != rhs.reserveAmount {return false}
    if lhs.buybackAmount != rhs.buybackAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_AuctionParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuctionParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "auction_duration_seconds"),
    3: .same(proto: "buffer"),
    4: .same(proto: "cusp"),
    5: .same(proto: "step"),
    6: .standard(proto: "price_function_type"),
    7: .standard(proto: "dutch_id"),
    8: .standard(proto: "bid_duration_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.auctionDurationSeconds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.buffer) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cusp) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.step) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.priceFunctionType) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.dutchID) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.bidDurationSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.appID != 0 {
      try visitor.visitSingularUInt64Field(value: self.appID, fieldNumber: 1)
    }
    if self.auctionDurationSeconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.auctionDurationSeconds, fieldNumber: 2)
    }
    if !self.buffer.isEmpty {
      try visitor.visitSingularStringField(value: self.buffer, fieldNumber: 3)
    }
    if !self.cusp.isEmpty {
      try visitor.visitSingularStringField(value: self.cusp, fieldNumber: 4)
    }
    if !self.step.isEmpty {
      try visitor.visitSingularStringField(value: self.step, fieldNumber: 5)
    }
    if self.priceFunctionType != 0 {
      try visitor.visitSingularUInt64Field(value: self.priceFunctionType, fieldNumber: 6)
    }
    if self.dutchID != 0 {
      try visitor.visitSingularUInt64Field(value: self.dutchID, fieldNumber: 7)
    }
    if self.bidDurationSeconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.bidDurationSeconds, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_AuctionParams, rhs: Comdex_Lend_V1beta1_AuctionParams) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.auctionDurationSeconds != rhs.auctionDurationSeconds {return false}
    if lhs.buffer != rhs.buffer {return false}
    if lhs.cusp != rhs.cusp {return false}
    if lhs.step != rhs.step {return false}
    if lhs.priceFunctionType != rhs.priceFunctionType {return false}
    if lhs.dutchID != rhs.dutchID {return false}
    if lhs.bidDurationSeconds != rhs.bidDurationSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_Borrow_interest_tracker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Borrow_interest_tracker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "borrowing_id"),
    3: .standard(proto: "reserve_pool_interest"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.borrowingID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reservePoolInterest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.borrowingID != 0 {
      try visitor.visitSingularUInt64Field(value: self.borrowingID, fieldNumber: 1)
    }
    if !self.reservePoolInterest.isEmpty {
      try visitor.visitSingularStringField(value: self.reservePoolInterest, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_Borrow_interest_tracker, rhs: Comdex_Lend_V1beta1_Borrow_interest_tracker) -> Bool {
    if lhs.borrowingID != rhs.borrowingID {return false}
    if lhs.reservePoolInterest != rhs.reservePoolInterest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_Lend_rewards_tracker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Lend_rewards_tracker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lending_id"),
    2: .standard(proto: "rewards_accumulated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.lendingID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rewardsAccumulated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lendingID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lendingID, fieldNumber: 1)
    }
    if !self.rewardsAccumulated.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardsAccumulated, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_Lend_rewards_tracker, rhs: Comdex_Lend_V1beta1_Lend_rewards_tracker) -> Bool {
    if lhs.lendingID != rhs.lendingID {return false}
    if lhs.rewardsAccumulated != rhs.rewardsAccumulated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_ModuleBalance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModuleBalance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "module_balance_stats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.moduleBalanceStats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if !self.moduleBalanceStats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moduleBalanceStats, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_ModuleBalance, rhs: Comdex_Lend_V1beta1_ModuleBalance) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.moduleBalanceStats != rhs.moduleBalanceStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_ModuleBalanceStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModuleBalanceStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .same(proto: "balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._balance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 1)
    }
    try { if let v = self._balance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_ModuleBalanceStats, rhs: Comdex_Lend_V1beta1_ModuleBalanceStats) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs._balance != rhs._balance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_ModBal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModBal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fund_module_balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fundModuleBalance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fundModuleBalance.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fundModuleBalance, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_ModBal, rhs: Comdex_Lend_V1beta1_ModBal) -> Bool {
    if lhs.fundModuleBalance != rhs.fundModuleBalance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_ReserveBal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReserveBal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fund_reserve_balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fundReserveBalance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fundReserveBalance.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fundReserveBalance, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_ReserveBal, rhs: Comdex_Lend_V1beta1_ReserveBal) -> Bool {
    if lhs.fundReserveBalance != rhs.fundReserveBalance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_FundModBal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundModBal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .standard(proto: "pool_id"),
    3: .standard(proto: "amount_in"),
    4: .standard(proto: "deposit_time"),
    5: .same(proto: "funder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amountIn) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._depositTime) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.funder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 1)
    }
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 2)
    }
    try { if let v = self._amountIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._depositTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.funder.isEmpty {
      try visitor.visitSingularStringField(value: self.funder, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_FundModBal, rhs: Comdex_Lend_V1beta1_FundModBal) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs._amountIn != rhs._amountIn {return false}
    if lhs._depositTime != rhs._depositTime {return false}
    if lhs.funder != rhs.funder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_FundReserveBal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundReserveBal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .standard(proto: "amount_in"),
    3: .standard(proto: "deposit_time"),
    4: .same(proto: "funder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amountIn) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._depositTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.funder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 1)
    }
    try { if let v = self._amountIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._depositTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.funder.isEmpty {
      try visitor.visitSingularStringField(value: self.funder, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_FundReserveBal, rhs: Comdex_Lend_V1beta1_FundReserveBal) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs._amountIn != rhs._amountIn {return false}
    if lhs._depositTime != rhs._depositTime {return false}
    if lhs.funder != rhs.funder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_AllReserveStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllReserveStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .standard(proto: "amount_out_from_reserve_to_lenders"),
    3: .standard(proto: "amount_out_from_reserve_for_auction"),
    4: .standard(proto: "amount_in_from_liq_penalty"),
    5: .standard(proto: "amount_in_from_repayments"),
    6: .standard(proto: "total_amount_out_to_lenders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amountOutFromReserveToLenders) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.amountOutFromReserveForAuction) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.amountInFromLiqPenalty) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.amountInFromRepayments) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.totalAmountOutToLenders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 1)
    }
    if !self.amountOutFromReserveToLenders.isEmpty {
      try visitor.visitSingularStringField(value: self.amountOutFromReserveToLenders, fieldNumber: 2)
    }
    if !self.amountOutFromReserveForAuction.isEmpty {
      try visitor.visitSingularStringField(value: self.amountOutFromReserveForAuction, fieldNumber: 3)
    }
    if !self.amountInFromLiqPenalty.isEmpty {
      try visitor.visitSingularStringField(value: self.amountInFromLiqPenalty, fieldNumber: 4)
    }
    if !self.amountInFromRepayments.isEmpty {
      try visitor.visitSingularStringField(value: self.amountInFromRepayments, fieldNumber: 5)
    }
    if !self.totalAmountOutToLenders.isEmpty {
      try visitor.visitSingularStringField(value: self.totalAmountOutToLenders, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_AllReserveStats, rhs: Comdex_Lend_V1beta1_AllReserveStats) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.amountOutFromReserveToLenders != rhs.amountOutFromReserveToLenders {return false}
    if lhs.amountOutFromReserveForAuction != rhs.amountOutFromReserveForAuction {return false}
    if lhs.amountInFromLiqPenalty != rhs.amountInFromLiqPenalty {return false}
    if lhs.amountInFromRepayments != rhs.amountInFromRepayments {return false}
    if lhs.totalAmountOutToLenders != rhs.totalAmountOutToLenders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_AssetToPairSingleMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssetToPairSingleMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "asset_id"),
    3: .standard(proto: "pair_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.pairID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 2)
    }
    if self.pairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pairID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_AssetToPairSingleMapping, rhs: Comdex_Lend_V1beta1_AssetToPairSingleMapping) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.pairID != rhs.pairID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_PoolPairs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolPairs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "module_name"),
    3: .standard(proto: "cpool_name"),
    4: .standard(proto: "asset_data"),
    5: .standard(proto: "min_usd_value_left"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cpoolName) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.assetData) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.minUsdValueLeft) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if !self.moduleName.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleName, fieldNumber: 2)
    }
    if !self.cpoolName.isEmpty {
      try visitor.visitSingularStringField(value: self.cpoolName, fieldNumber: 3)
    }
    if !self.assetData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assetData, fieldNumber: 4)
    }
    if self.minUsdValueLeft != 0 {
      try visitor.visitSingularUInt64Field(value: self.minUsdValueLeft, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_PoolPairs, rhs: Comdex_Lend_V1beta1_PoolPairs) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.moduleName != rhs.moduleName {return false}
    if lhs.cpoolName != rhs.cpoolName {return false}
    if lhs.assetData != rhs.assetData {return false}
    if lhs.minUsdValueLeft != rhs.minUsdValueLeft {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_PoolInterestData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolInterestData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .standard(proto: "lend_interest"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lendInterest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 1)
    }
    if !self.lendInterest.isEmpty {
      try visitor.visitSingularStringField(value: self.lendInterest, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_PoolInterestData, rhs: Comdex_Lend_V1beta1_PoolInterestData) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.lendInterest != rhs.lendInterest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_PoolInterest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolInterest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "pool_interest_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.poolInterestData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if !self.poolInterestData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.poolInterestData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_PoolInterest, rhs: Comdex_Lend_V1beta1_PoolInterest) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.poolInterestData != rhs.poolInterestData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_PoolInterestDataB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolInterestDataB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .standard(proto: "borrow_interest"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.borrowInterest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.assetID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assetID, fieldNumber: 1)
    }
    if !self.borrowInterest.isEmpty {
      try visitor.visitSingularStringField(value: self.borrowInterest, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_PoolInterestDataB, rhs: Comdex_Lend_V1beta1_PoolInterestDataB) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.borrowInterest != rhs.borrowInterest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_PoolInterestB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolInterestB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "pool_interest_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.poolInterestData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if !self.poolInterestData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.poolInterestData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_PoolInterestB, rhs: Comdex_Lend_V1beta1_PoolInterestB) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.poolInterestData != rhs.poolInterestData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Comdex_Lend_V1beta1_AssetRatesPoolPairs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssetRatesPoolPairs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .standard(proto: "u_optimal"),
    3: .same(proto: "base"),
    4: .same(proto: "slope1"),
    5: .same(proto: "slope2"),
    6: .standard(proto: "enable_stable_borrow"),
    7: .standard(proto: "stable_base"),
    8: .standard(proto: "stable_slope1"),
    9: .standard(proto: "stable_slope2"),
    10: .same(proto: "ltv"),
    11: .standard(proto: "liquidation_threshold"),
    12: .standard(proto: "liquidation_penalty"),
    13: .standard(proto: "liquidation_bonus"),
    14: .standard(proto: "reserve_factor"),
    15: .standard(proto: "c_asset_id"),
    16: .standard(proto: "module_name"),
    17: .standard(proto: "cpool_name"),
    18: .standard(proto: "asset_data"),
    19: .standard(proto: "min_usd_value_left"),
  ]

  fileprivate class _StorageClass {
    var _assetID: UInt64 = 0
    var _uOptimal: String = String()
    var _base: String = String()
    var _slope1: String = String()
    var _slope2: String = String()
    var _enableStableBorrow: Bool = false
    var _stableBase: String = String()
    var _stableSlope1: String = String()
    var _stableSlope2: String = String()
    var _ltv: String = String()
    var _liquidationThreshold: String = String()
    var _liquidationPenalty: String = String()
    var _liquidationBonus: String = String()
    var _reserveFactor: String = String()
    var _cAssetID: UInt64 = 0
    var _moduleName: String = String()
    var _cpoolName: String = String()
    var _assetData: [Comdex_Lend_V1beta1_AssetDataPoolMapping] = []
    var _minUsdValueLeft: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _assetID = source._assetID
      _uOptimal = source._uOptimal
      _base = source._base
      _slope1 = source._slope1
      _slope2 = source._slope2
      _enableStableBorrow = source._enableStableBorrow
      _stableBase = source._stableBase
      _stableSlope1 = source._stableSlope1
      _stableSlope2 = source._stableSlope2
      _ltv = source._ltv
      _liquidationThreshold = source._liquidationThreshold
      _liquidationPenalty = source._liquidationPenalty
      _liquidationBonus = source._liquidationBonus
      _reserveFactor = source._reserveFactor
      _cAssetID = source._cAssetID
      _moduleName = source._moduleName
      _cpoolName = source._cpoolName
      _assetData = source._assetData
      _minUsdValueLeft = source._minUsdValueLeft
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._assetID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._uOptimal) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._base) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._slope1) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._slope2) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._enableStableBorrow) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._stableBase) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._stableSlope1) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._stableSlope2) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._ltv) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._liquidationThreshold) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._liquidationPenalty) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._liquidationBonus) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._reserveFactor) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._cAssetID) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._moduleName) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._cpoolName) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._assetData) }()
        case 19: try { try decoder.decodeSingularUInt64Field(value: &_storage._minUsdValueLeft) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._assetID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._assetID, fieldNumber: 1)
      }
      if !_storage._uOptimal.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uOptimal, fieldNumber: 2)
      }
      if !_storage._base.isEmpty {
        try visitor.visitSingularStringField(value: _storage._base, fieldNumber: 3)
      }
      if !_storage._slope1.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slope1, fieldNumber: 4)
      }
      if !_storage._slope2.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slope2, fieldNumber: 5)
      }
      if _storage._enableStableBorrow != false {
        try visitor.visitSingularBoolField(value: _storage._enableStableBorrow, fieldNumber: 6)
      }
      if !_storage._stableBase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stableBase, fieldNumber: 7)
      }
      if !_storage._stableSlope1.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stableSlope1, fieldNumber: 8)
      }
      if !_storage._stableSlope2.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stableSlope2, fieldNumber: 9)
      }
      if !_storage._ltv.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ltv, fieldNumber: 10)
      }
      if !_storage._liquidationThreshold.isEmpty {
        try visitor.visitSingularStringField(value: _storage._liquidationThreshold, fieldNumber: 11)
      }
      if !_storage._liquidationPenalty.isEmpty {
        try visitor.visitSingularStringField(value: _storage._liquidationPenalty, fieldNumber: 12)
      }
      if !_storage._liquidationBonus.isEmpty {
        try visitor.visitSingularStringField(value: _storage._liquidationBonus, fieldNumber: 13)
      }
      if !_storage._reserveFactor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reserveFactor, fieldNumber: 14)
      }
      if _storage._cAssetID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._cAssetID, fieldNumber: 15)
      }
      if !_storage._moduleName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moduleName, fieldNumber: 16)
      }
      if !_storage._cpoolName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cpoolName, fieldNumber: 17)
      }
      if !_storage._assetData.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._assetData, fieldNumber: 18)
      }
      if _storage._minUsdValueLeft != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._minUsdValueLeft, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Comdex_Lend_V1beta1_AssetRatesPoolPairs, rhs: Comdex_Lend_V1beta1_AssetRatesPoolPairs) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._assetID != rhs_storage._assetID {return false}
        if _storage._uOptimal != rhs_storage._uOptimal {return false}
        if _storage._base != rhs_storage._base {return false}
        if _storage._slope1 != rhs_storage._slope1 {return false}
        if _storage._slope2 != rhs_storage._slope2 {return false}
        if _storage._enableStableBorrow != rhs_storage._enableStableBorrow {return false}
        if _storage._stableBase != rhs_storage._stableBase {return false}
        if _storage._stableSlope1 != rhs_storage._stableSlope1 {return false}
        if _storage._stableSlope2 != rhs_storage._stableSlope2 {return false}
        if _storage._ltv != rhs_storage._ltv {return false}
        if _storage._liquidationThreshold != rhs_storage._liquidationThreshold {return false}
        if _storage._liquidationPenalty != rhs_storage._liquidationPenalty {return false}
        if _storage._liquidationBonus != rhs_storage._liquidationBonus {return false}
        if _storage._reserveFactor != rhs_storage._reserveFactor {return false}
        if _storage._cAssetID != rhs_storage._cAssetID {return false}
        if _storage._moduleName != rhs_storage._moduleName {return false}
        if _storage._cpoolName != rhs_storage._cpoolName {return false}
        if _storage._assetData != rhs_storage._assetData {return false}
        if _storage._minUsdValueLeft != rhs_storage._minUsdValueLeft {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
