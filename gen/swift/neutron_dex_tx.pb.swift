// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: neutron/dex/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Neutron_Dex_LimitOrderType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case goodTilCancelled // = 0
  case fillOrKill // = 1
  case immediateOrCancel // = 2
  case justInTime // = 3
  case goodTilTime // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .goodTilCancelled
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .goodTilCancelled
    case 1: self = .fillOrKill
    case 2: self = .immediateOrCancel
    case 3: self = .justInTime
    case 4: self = .goodTilTime
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .goodTilCancelled: return 0
    case .fillOrKill: return 1
    case .immediateOrCancel: return 2
    case .justInTime: return 3
    case .goodTilTime: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Neutron_Dex_LimitOrderType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Neutron_Dex_LimitOrderType] = [
    .goodTilCancelled,
    .fillOrKill,
    .immediateOrCancel,
    .justInTime,
    .goodTilTime,
  ]
}

#endif  // swift(>=4.2)

struct Neutron_Dex_DepositOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var disableAutoswap: Bool = false

  var failTxOnBel: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_MsgDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var receiver: String = String()

  var tokenA: String = String()

  var tokenB: String = String()

  var amountsA: [String] = []

  var amountsB: [String] = []

  var tickIndexesAToB: [Int64] = []

  var fees: [UInt64] = []

  var options: [Neutron_Dex_DepositOptions] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_FailedDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var depositIdx: UInt64 = 0

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_MsgDepositResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reserve0Deposited: [String] = []

  var reserve1Deposited: [String] = []

  var failedDeposits: [Neutron_Dex_FailedDeposit] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_MsgWithdrawal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var receiver: String = String()

  var tokenA: String = String()

  var tokenB: String = String()

  var sharesToRemove: [String] = []

  var tickIndexesAToB: [Int64] = []

  var fees: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_MsgWithdrawalResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_MsgPlaceLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var receiver: String = String()

  var tokenIn: String = String()

  var tokenOut: String = String()

  /// DEPRECATED: tick_index_in_to_out will be removed in future release; limit_sell_price should be used instead.
  var tickIndexInToOut: Int64 = 0

  var amountIn: String = String()

  var orderType: Neutron_Dex_LimitOrderType = .goodTilCancelled

  /// expirationTime is only valid iff orderType == GOOD_TIL_TIME.
  var expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expirationTime = newValue}
  }
  /// Returns true if `expirationTime` has been explicitly set.
  var hasExpirationTime: Bool {return self._expirationTime != nil}
  /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
  mutating func clearExpirationTime() {self._expirationTime = nil}

  var maxAmountOut: String = String()

  var limitSellPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Neutron_Dex_MsgPlaceLimitOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trancheKey: String = String()

  /// Total amount of coin used for the limit order
  var coinIn: Cosmos_Base_V1beta1_Coin {
    get {return _coinIn ?? Cosmos_Base_V1beta1_Coin()}
    set {_coinIn = newValue}
  }
  /// Returns true if `coinIn` has been explicitly set.
  var hasCoinIn: Bool {return self._coinIn != nil}
  /// Clears the value of `coinIn`. Subsequent reads from it will return its default value.
  mutating func clearCoinIn() {self._coinIn = nil}

  /// Total amount of coin received from the taker portion of the limit order
  /// This is the amount of coin immediately available in the users account after
  /// executing the limit order. It does not include any future proceeds from the
  /// maker portion which will have withdrawn in the future
  var takerCoinOut: Cosmos_Base_V1beta1_Coin {
    get {return _takerCoinOut ?? Cosmos_Base_V1beta1_Coin()}
    set {_takerCoinOut = newValue}
  }
  /// Returns true if `takerCoinOut` has been explicitly set.
  var hasTakerCoinOut: Bool {return self._takerCoinOut != nil}
  /// Clears the value of `takerCoinOut`. Subsequent reads from it will return its default value.
  mutating func clearTakerCoinOut() {self._takerCoinOut = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _coinIn: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _takerCoinOut: Cosmos_Base_V1beta1_Coin? = nil
}

struct Neutron_Dex_MsgWithdrawFilledLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var trancheKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_MsgWithdrawFilledLimitOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_MsgCancelLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var trancheKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_MsgCancelLimitOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_MultiHopRoute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hops: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_MsgMultiHopSwap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creator: String = String()

  var receiver: String = String()

  var routes: [Neutron_Dex_MultiHopRoute] = []

  var amountIn: String = String()

  var exitLimitPrice: String = String()

  /// If pickBestRoute == true then all routes are run and the route with the
  /// best price is chosen otherwise, the first succesful route is used.
  var pickBestRoute: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Neutron_Dex_MsgMultiHopSwapResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var coinOut: Cosmos_Base_V1beta1_Coin {
    get {return _coinOut ?? Cosmos_Base_V1beta1_Coin()}
    set {_coinOut = newValue}
  }
  /// Returns true if `coinOut` has been explicitly set.
  var hasCoinOut: Bool {return self._coinOut != nil}
  /// Clears the value of `coinOut`. Subsequent reads from it will return its default value.
  mutating func clearCoinOut() {self._coinOut = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _coinOut: Cosmos_Base_V1beta1_Coin? = nil
}

struct Neutron_Dex_MsgUpdateParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authority is the address of the governance account.
  var authority: String = String()

  /// NOTE: All parameters must be supplied.
  var params: Neutron_Dex_Params {
    get {return _params ?? Neutron_Dex_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Neutron_Dex_Params? = nil
}

/// MsgUpdateParamsResponse defines the response structure for executing a
/// MsgUpdateParams message.
///
/// Since: 0.47
struct Neutron_Dex_MsgUpdateParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Neutron_Dex_LimitOrderType: @unchecked Sendable {}
extension Neutron_Dex_DepositOptions: @unchecked Sendable {}
extension Neutron_Dex_MsgDeposit: @unchecked Sendable {}
extension Neutron_Dex_FailedDeposit: @unchecked Sendable {}
extension Neutron_Dex_MsgDepositResponse: @unchecked Sendable {}
extension Neutron_Dex_MsgWithdrawal: @unchecked Sendable {}
extension Neutron_Dex_MsgWithdrawalResponse: @unchecked Sendable {}
extension Neutron_Dex_MsgPlaceLimitOrder: @unchecked Sendable {}
extension Neutron_Dex_MsgPlaceLimitOrderResponse: @unchecked Sendable {}
extension Neutron_Dex_MsgWithdrawFilledLimitOrder: @unchecked Sendable {}
extension Neutron_Dex_MsgWithdrawFilledLimitOrderResponse: @unchecked Sendable {}
extension Neutron_Dex_MsgCancelLimitOrder: @unchecked Sendable {}
extension Neutron_Dex_MsgCancelLimitOrderResponse: @unchecked Sendable {}
extension Neutron_Dex_MultiHopRoute: @unchecked Sendable {}
extension Neutron_Dex_MsgMultiHopSwap: @unchecked Sendable {}
extension Neutron_Dex_MsgMultiHopSwapResponse: @unchecked Sendable {}
extension Neutron_Dex_MsgUpdateParams: @unchecked Sendable {}
extension Neutron_Dex_MsgUpdateParamsResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "neutron.dex"

extension Neutron_Dex_LimitOrderType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GOOD_TIL_CANCELLED"),
    1: .same(proto: "FILL_OR_KILL"),
    2: .same(proto: "IMMEDIATE_OR_CANCEL"),
    3: .same(proto: "JUST_IN_TIME"),
    4: .same(proto: "GOOD_TIL_TIME"),
  ]
}

extension Neutron_Dex_DepositOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DepositOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "disable_autoswap"),
    2: .standard(proto: "fail_tx_on_bel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disableAutoswap) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.failTxOnBel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disableAutoswap != false {
      try visitor.visitSingularBoolField(value: self.disableAutoswap, fieldNumber: 1)
    }
    if self.failTxOnBel != false {
      try visitor.visitSingularBoolField(value: self.failTxOnBel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_DepositOptions, rhs: Neutron_Dex_DepositOptions) -> Bool {
    if lhs.disableAutoswap != rhs.disableAutoswap {return false}
    if lhs.failTxOnBel != rhs.failTxOnBel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "receiver"),
    3: .standard(proto: "token_a"),
    4: .standard(proto: "token_b"),
    5: .standard(proto: "amounts_a"),
    6: .standard(proto: "amounts_b"),
    7: .standard(proto: "tick_indexes_a_to_b"),
    8: .same(proto: "fees"),
    9: .same(proto: "options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.receiver) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tokenA) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tokenB) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.amountsA) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.amountsB) }()
      case 7: try { try decoder.decodeRepeatedInt64Field(value: &self.tickIndexesAToB) }()
      case 8: try { try decoder.decodeRepeatedUInt64Field(value: &self.fees) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 2)
    }
    if !self.tokenA.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenA, fieldNumber: 3)
    }
    if !self.tokenB.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenB, fieldNumber: 4)
    }
    if !self.amountsA.isEmpty {
      try visitor.visitRepeatedStringField(value: self.amountsA, fieldNumber: 5)
    }
    if !self.amountsB.isEmpty {
      try visitor.visitRepeatedStringField(value: self.amountsB, fieldNumber: 6)
    }
    if !self.tickIndexesAToB.isEmpty {
      try visitor.visitPackedInt64Field(value: self.tickIndexesAToB, fieldNumber: 7)
    }
    if !self.fees.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.fees, fieldNumber: 8)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgDeposit, rhs: Neutron_Dex_MsgDeposit) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.receiver != rhs.receiver {return false}
    if lhs.tokenA != rhs.tokenA {return false}
    if lhs.tokenB != rhs.tokenB {return false}
    if lhs.amountsA != rhs.amountsA {return false}
    if lhs.amountsB != rhs.amountsB {return false}
    if lhs.tickIndexesAToB != rhs.tickIndexesAToB {return false}
    if lhs.fees != rhs.fees {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_FailedDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FailedDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deposit_idx"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.depositIdx) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.depositIdx != 0 {
      try visitor.visitSingularUInt64Field(value: self.depositIdx, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_FailedDeposit, rhs: Neutron_Dex_FailedDeposit) -> Bool {
    if lhs.depositIdx != rhs.depositIdx {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgDepositResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDepositResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reserve0_deposited"),
    2: .standard(proto: "reserve1_deposited"),
    3: .standard(proto: "failed_deposits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.reserve0Deposited) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.reserve1Deposited) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.failedDeposits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reserve0Deposited.isEmpty {
      try visitor.visitRepeatedStringField(value: self.reserve0Deposited, fieldNumber: 1)
    }
    if !self.reserve1Deposited.isEmpty {
      try visitor.visitRepeatedStringField(value: self.reserve1Deposited, fieldNumber: 2)
    }
    if !self.failedDeposits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failedDeposits, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgDepositResponse, rhs: Neutron_Dex_MsgDepositResponse) -> Bool {
    if lhs.reserve0Deposited != rhs.reserve0Deposited {return false}
    if lhs.reserve1Deposited != rhs.reserve1Deposited {return false}
    if lhs.failedDeposits != rhs.failedDeposits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgWithdrawal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "receiver"),
    3: .standard(proto: "token_a"),
    4: .standard(proto: "token_b"),
    5: .standard(proto: "shares_to_remove"),
    6: .standard(proto: "tick_indexes_a_to_b"),
    7: .same(proto: "fees"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.receiver) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tokenA) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tokenB) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.sharesToRemove) }()
      case 6: try { try decoder.decodeRepeatedInt64Field(value: &self.tickIndexesAToB) }()
      case 7: try { try decoder.decodeRepeatedUInt64Field(value: &self.fees) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 2)
    }
    if !self.tokenA.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenA, fieldNumber: 3)
    }
    if !self.tokenB.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenB, fieldNumber: 4)
    }
    if !self.sharesToRemove.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sharesToRemove, fieldNumber: 5)
    }
    if !self.tickIndexesAToB.isEmpty {
      try visitor.visitPackedInt64Field(value: self.tickIndexesAToB, fieldNumber: 6)
    }
    if !self.fees.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.fees, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgWithdrawal, rhs: Neutron_Dex_MsgWithdrawal) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.receiver != rhs.receiver {return false}
    if lhs.tokenA != rhs.tokenA {return false}
    if lhs.tokenB != rhs.tokenB {return false}
    if lhs.sharesToRemove != rhs.sharesToRemove {return false}
    if lhs.tickIndexesAToB != rhs.tickIndexesAToB {return false}
    if lhs.fees != rhs.fees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgWithdrawalResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawalResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgWithdrawalResponse, rhs: Neutron_Dex_MsgWithdrawalResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgPlaceLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPlaceLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "receiver"),
    3: .standard(proto: "token_in"),
    4: .standard(proto: "token_out"),
    5: .standard(proto: "tick_index_in_to_out"),
    7: .standard(proto: "amount_in"),
    8: .standard(proto: "order_type"),
    9: .standard(proto: "expiration_time"),
    10: .standard(proto: "max_amount_out"),
    11: .standard(proto: "limit_sell_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.receiver) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tokenIn) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tokenOut) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.tickIndexInToOut) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.amountIn) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._expirationTime) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.maxAmountOut) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.limitSellPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 2)
    }
    if !self.tokenIn.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenIn, fieldNumber: 3)
    }
    if !self.tokenOut.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenOut, fieldNumber: 4)
    }
    if self.tickIndexInToOut != 0 {
      try visitor.visitSingularInt64Field(value: self.tickIndexInToOut, fieldNumber: 5)
    }
    if !self.amountIn.isEmpty {
      try visitor.visitSingularStringField(value: self.amountIn, fieldNumber: 7)
    }
    if self.orderType != .goodTilCancelled {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 8)
    }
    try { if let v = self._expirationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.maxAmountOut.isEmpty {
      try visitor.visitSingularStringField(value: self.maxAmountOut, fieldNumber: 10)
    }
    if !self.limitSellPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.limitSellPrice, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgPlaceLimitOrder, rhs: Neutron_Dex_MsgPlaceLimitOrder) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.receiver != rhs.receiver {return false}
    if lhs.tokenIn != rhs.tokenIn {return false}
    if lhs.tokenOut != rhs.tokenOut {return false}
    if lhs.tickIndexInToOut != rhs.tickIndexInToOut {return false}
    if lhs.amountIn != rhs.amountIn {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs._expirationTime != rhs._expirationTime {return false}
    if lhs.maxAmountOut != rhs.maxAmountOut {return false}
    if lhs.limitSellPrice != rhs.limitSellPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgPlaceLimitOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPlaceLimitOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trancheKey"),
    2: .standard(proto: "coin_in"),
    3: .standard(proto: "taker_coin_out"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trancheKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coinIn) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._takerCoinOut) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.trancheKey.isEmpty {
      try visitor.visitSingularStringField(value: self.trancheKey, fieldNumber: 1)
    }
    try { if let v = self._coinIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._takerCoinOut {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgPlaceLimitOrderResponse, rhs: Neutron_Dex_MsgPlaceLimitOrderResponse) -> Bool {
    if lhs.trancheKey != rhs.trancheKey {return false}
    if lhs._coinIn != rhs._coinIn {return false}
    if lhs._takerCoinOut != rhs._takerCoinOut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgWithdrawFilledLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawFilledLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "tranche_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.trancheKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.trancheKey.isEmpty {
      try visitor.visitSingularStringField(value: self.trancheKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgWithdrawFilledLimitOrder, rhs: Neutron_Dex_MsgWithdrawFilledLimitOrder) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.trancheKey != rhs.trancheKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgWithdrawFilledLimitOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawFilledLimitOrderResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgWithdrawFilledLimitOrderResponse, rhs: Neutron_Dex_MsgWithdrawFilledLimitOrderResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgCancelLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .standard(proto: "tranche_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.trancheKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.trancheKey.isEmpty {
      try visitor.visitSingularStringField(value: self.trancheKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgCancelLimitOrder, rhs: Neutron_Dex_MsgCancelLimitOrder) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.trancheKey != rhs.trancheKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgCancelLimitOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelLimitOrderResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgCancelLimitOrderResponse, rhs: Neutron_Dex_MsgCancelLimitOrderResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MultiHopRoute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MultiHopRoute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hops"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.hops) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hops.isEmpty {
      try visitor.visitRepeatedStringField(value: self.hops, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MultiHopRoute, rhs: Neutron_Dex_MultiHopRoute) -> Bool {
    if lhs.hops != rhs.hops {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgMultiHopSwap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMultiHopSwap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "receiver"),
    3: .same(proto: "routes"),
    4: .standard(proto: "amount_in"),
    5: .standard(proto: "exit_limit_price"),
    6: .standard(proto: "pick_best_route"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.creator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.receiver) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.routes) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.amountIn) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.exitLimitPrice) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.pickBestRoute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creator.isEmpty {
      try visitor.visitSingularStringField(value: self.creator, fieldNumber: 1)
    }
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 2)
    }
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 3)
    }
    if !self.amountIn.isEmpty {
      try visitor.visitSingularStringField(value: self.amountIn, fieldNumber: 4)
    }
    if !self.exitLimitPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.exitLimitPrice, fieldNumber: 5)
    }
    if self.pickBestRoute != false {
      try visitor.visitSingularBoolField(value: self.pickBestRoute, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgMultiHopSwap, rhs: Neutron_Dex_MsgMultiHopSwap) -> Bool {
    if lhs.creator != rhs.creator {return false}
    if lhs.receiver != rhs.receiver {return false}
    if lhs.routes != rhs.routes {return false}
    if lhs.amountIn != rhs.amountIn {return false}
    if lhs.exitLimitPrice != rhs.exitLimitPrice {return false}
    if lhs.pickBestRoute != rhs.pickBestRoute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgMultiHopSwapResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMultiHopSwapResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coin_out"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coinOut) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coinOut {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgMultiHopSwapResponse, rhs: Neutron_Dex_MsgMultiHopSwapResponse) -> Bool {
    if lhs._coinOut != rhs._coinOut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgUpdateParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgUpdateParams, rhs: Neutron_Dex_MsgUpdateParams) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Neutron_Dex_MsgUpdateParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParamsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Neutron_Dex_MsgUpdateParamsResponse, rhs: Neutron_Dex_MsgUpdateParamsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
