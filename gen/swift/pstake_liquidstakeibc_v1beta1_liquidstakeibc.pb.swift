// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pstake/liquidstakeibc/v1beta1/liquidstakeibc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Pstake_Liquidstakeibc_V1beta1_HostChain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// host chain id
  var chainID: String {
    get {return _storage._chainID}
    set {_uniqueStorage()._chainID = newValue}
  }

  /// ibc connection id
  var connectionID: String {
    get {return _storage._connectionID}
    set {_uniqueStorage()._connectionID = newValue}
  }

  /// module params
  var params: Pstake_Liquidstakeibc_V1beta1_HostChainLSParams {
    get {return _storage._params ?? Pstake_Liquidstakeibc_V1beta1_HostChainLSParams()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {_uniqueStorage()._params = nil}

  /// native token denom
  var hostDenom: String {
    get {return _storage._hostDenom}
    set {_uniqueStorage()._hostDenom = newValue}
  }

  /// ibc connection channel id
  var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// ibc connection port id
  var portID: String {
    get {return _storage._portID}
    set {_uniqueStorage()._portID = newValue}
  }

  /// delegation host account
  var delegationAccount: Pstake_Liquidstakeibc_V1beta1_ICAAccount {
    get {return _storage._delegationAccount ?? Pstake_Liquidstakeibc_V1beta1_ICAAccount()}
    set {_uniqueStorage()._delegationAccount = newValue}
  }
  /// Returns true if `delegationAccount` has been explicitly set.
  var hasDelegationAccount: Bool {return _storage._delegationAccount != nil}
  /// Clears the value of `delegationAccount`. Subsequent reads from it will return its default value.
  mutating func clearDelegationAccount() {_uniqueStorage()._delegationAccount = nil}

  /// reward host account
  var rewardsAccount: Pstake_Liquidstakeibc_V1beta1_ICAAccount {
    get {return _storage._rewardsAccount ?? Pstake_Liquidstakeibc_V1beta1_ICAAccount()}
    set {_uniqueStorage()._rewardsAccount = newValue}
  }
  /// Returns true if `rewardsAccount` has been explicitly set.
  var hasRewardsAccount: Bool {return _storage._rewardsAccount != nil}
  /// Clears the value of `rewardsAccount`. Subsequent reads from it will return its default value.
  mutating func clearRewardsAccount() {_uniqueStorage()._rewardsAccount = nil}

  /// validator set
  var validators: [Pstake_Liquidstakeibc_V1beta1_Validator] {
    get {return _storage._validators}
    set {_uniqueStorage()._validators = newValue}
  }

  /// minimum ls amount
  var minimumDeposit: String {
    get {return _storage._minimumDeposit}
    set {_uniqueStorage()._minimumDeposit = newValue}
  }

  /// redemption rate
  var cValue: String {
    get {return _storage._cValue}
    set {_uniqueStorage()._cValue = newValue}
  }

  /// the hash of the next validator set
  var nextValsetHash: Data {
    get {return _storage._nextValsetHash}
    set {_uniqueStorage()._nextValsetHash = newValue}
  }

  /// undelegation epoch factor
  var unbondingFactor: Int64 {
    get {return _storage._unbondingFactor}
    set {_uniqueStorage()._unbondingFactor = newValue}
  }

  /// whether the chain is ready to accept delegations or not
  var active: Bool {
    get {return _storage._active}
    set {_uniqueStorage()._active = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Pstake_Liquidstakeibc_V1beta1_HostChainLSParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// protocol fee in percentage
  var depositFee: String = String()

  /// protocol fee in percentage
  var restakeFee: String = String()

  /// protocol fee in percentage
  var unstakeFee: String = String()

  /// protocol fee in percentage
  var redemptionFee: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pstake_Liquidstakeibc_V1beta1_ICAAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address of the ica on the controller chain
  var address: String = String()

  /// token balance of the ica
  var balance: Cosmos_Base_V1beta1_Coin {
    get {return _balance ?? Cosmos_Base_V1beta1_Coin()}
    set {_balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  var hasBalance: Bool {return self._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  mutating func clearBalance() {self._balance = nil}

  /// owner string
  var owner: String = String()

  var channelState: Pstake_Liquidstakeibc_V1beta1_ICAAccount.ChannelState = .icaChannelCreating

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ChannelState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// ICA channel is being created
    case icaChannelCreating // = 0

    /// ICA is established and the account can be used
    case icaChannelCreated // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .icaChannelCreating
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .icaChannelCreating
      case 1: self = .icaChannelCreated
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .icaChannelCreating: return 0
      case .icaChannelCreated: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _balance: Cosmos_Base_V1beta1_Coin? = nil
}

#if swift(>=4.2)

extension Pstake_Liquidstakeibc_V1beta1_ICAAccount.ChannelState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Pstake_Liquidstakeibc_V1beta1_ICAAccount.ChannelState] = [
    .icaChannelCreating,
    .icaChannelCreated,
  ]
}

#endif  // swift(>=4.2)

struct Pstake_Liquidstakeibc_V1beta1_Validator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// valoper address
  var operatorAddress: String = String()

  /// validator status
  var status: String = String()

  /// validator weight in the set
  var weight: String = String()

  /// amount delegated by the module
  var delegatedAmount: String = String()

  /// total amount delegated to the validator (including amount not delegated by the module)
  var totalAmount: String = String()

  /// the unbonding epoch number when the validator transistioned into the state
  var unbondingEpoch: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pstake_Liquidstakeibc_V1beta1_Deposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// deposit target chain
  var chainID: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// epoch number of the deposit
  var epoch: String = String()

  /// state
  var state: Pstake_Liquidstakeibc_V1beta1_Deposit.DepositState = .depositPending

  /// sequence id of the ibc transaction
  var ibcSequenceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DepositState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// no action has been initiated on the deposit
    case depositPending // = 0

    /// deposit sent to the host chain delegator address
    case depositSent // = 1

    /// deposit received by the host chain delegator address
    case depositReceived // = 2

    /// delegation submitted for the deposit on the host chain
    case depositDelegating // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .depositPending
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .depositPending
      case 1: self = .depositSent
      case 2: self = .depositReceived
      case 3: self = .depositDelegating
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .depositPending: return 0
      case .depositSent: return 1
      case .depositReceived: return 2
      case .depositDelegating: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

#if swift(>=4.2)

extension Pstake_Liquidstakeibc_V1beta1_Deposit.DepositState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Pstake_Liquidstakeibc_V1beta1_Deposit.DepositState] = [
    .depositPending,
    .depositSent,
    .depositReceived,
    .depositDelegating,
  ]
}

#endif  // swift(>=4.2)

struct Pstake_Liquidstakeibc_V1beta1_Unbonding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unbonding target chain
  var chainID: String = String()

  /// epoch number of the unbonding record
  var epochNumber: Int64 = 0

  /// time when the unbonding matures and can be collected
  var matureTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _matureTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_matureTime = newValue}
  }
  /// Returns true if `matureTime` has been explicitly set.
  var hasMatureTime: Bool {return self._matureTime != nil}
  /// Clears the value of `matureTime`. Subsequent reads from it will return its default value.
  mutating func clearMatureTime() {self._matureTime = nil}

  /// stk token amount that is burned with the unbonding
  var burnAmount: Cosmos_Base_V1beta1_Coin {
    get {return _burnAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_burnAmount = newValue}
  }
  /// Returns true if `burnAmount` has been explicitly set.
  var hasBurnAmount: Bool {return self._burnAmount != nil}
  /// Clears the value of `burnAmount`. Subsequent reads from it will return its default value.
  mutating func clearBurnAmount() {self._burnAmount = nil}

  /// host token amount that is being unbonded
  var unbondAmount: Cosmos_Base_V1beta1_Coin {
    get {return _unbondAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_unbondAmount = newValue}
  }
  /// Returns true if `unbondAmount` has been explicitly set.
  var hasUnbondAmount: Bool {return self._unbondAmount != nil}
  /// Clears the value of `unbondAmount`. Subsequent reads from it will return its default value.
  mutating func clearUnbondAmount() {self._unbondAmount = nil}

  /// sequence id of the ibc transaction
  var ibcSequenceID: String = String()

  /// state of the unbonding during the process
  var state: Pstake_Liquidstakeibc_V1beta1_Unbonding.UnbondingState = .unbondingPending

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum UnbondingState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// no action has been initiated on the unbonding
    case unbondingPending // = 0

    /// unbonding action has been sent to the host chain
    case unbondingInitiated // = 1

    /// unbonding is waiting for the maturing period of the host chain
    case unbondingMaturing // = 2

    /// unbonding has matured and is ready to transfer from the host chain
    case unbondingMatured // = 3

    /// unbonding is on the persistence chain and can be claimed
    case unbondingClaimable // = 4

    /// unbonding has failed
    case unbondingFailed // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unbondingPending
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unbondingPending
      case 1: self = .unbondingInitiated
      case 2: self = .unbondingMaturing
      case 3: self = .unbondingMatured
      case 4: self = .unbondingClaimable
      case 5: self = .unbondingFailed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unbondingPending: return 0
      case .unbondingInitiated: return 1
      case .unbondingMaturing: return 2
      case .unbondingMatured: return 3
      case .unbondingClaimable: return 4
      case .unbondingFailed: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _matureTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _burnAmount: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _unbondAmount: Cosmos_Base_V1beta1_Coin? = nil
}

#if swift(>=4.2)

extension Pstake_Liquidstakeibc_V1beta1_Unbonding.UnbondingState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Pstake_Liquidstakeibc_V1beta1_Unbonding.UnbondingState] = [
    .unbondingPending,
    .unbondingInitiated,
    .unbondingMaturing,
    .unbondingMatured,
    .unbondingClaimable,
    .unbondingFailed,
  ]
}

#endif  // swift(>=4.2)

struct Pstake_Liquidstakeibc_V1beta1_UserUnbonding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unbonding target chain
  var chainID: String = String()

  /// epoch when the unbonding started
  var epochNumber: Int64 = 0

  /// address which requested the unbonding
  var address: String = String()

  /// stk token amount that is being unbonded
  var stkAmount: Cosmos_Base_V1beta1_Coin {
    get {return _stkAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_stkAmount = newValue}
  }
  /// Returns true if `stkAmount` has been explicitly set.
  var hasStkAmount: Bool {return self._stkAmount != nil}
  /// Clears the value of `stkAmount`. Subsequent reads from it will return its default value.
  mutating func clearStkAmount() {self._stkAmount = nil}

  /// host token amount that is being unbonded
  var unbondAmount: Cosmos_Base_V1beta1_Coin {
    get {return _unbondAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_unbondAmount = newValue}
  }
  /// Returns true if `unbondAmount` has been explicitly set.
  var hasUnbondAmount: Bool {return self._unbondAmount != nil}
  /// Clears the value of `unbondAmount`. Subsequent reads from it will return its default value.
  mutating func clearUnbondAmount() {self._unbondAmount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stkAmount: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _unbondAmount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Pstake_Liquidstakeibc_V1beta1_ValidatorUnbonding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unbonding target chain
  var chainID: String = String()

  /// epoch when the unbonding started
  var epochNumber: Int64 = 0

  /// time when the unbonding matures and can be collected
  var matureTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _matureTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_matureTime = newValue}
  }
  /// Returns true if `matureTime` has been explicitly set.
  var hasMatureTime: Bool {return self._matureTime != nil}
  /// Clears the value of `matureTime`. Subsequent reads from it will return its default value.
  mutating func clearMatureTime() {self._matureTime = nil}

  /// address of the validator that is being unbonded
  var validatorAddress: String = String()

  /// amount unbonded from the validator
  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// sequence id of the ibc transaction
  var ibcSequenceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _matureTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Pstake_Liquidstakeibc_V1beta1_KVUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Pstake_Liquidstakeibc_V1beta1_HostChain: @unchecked Sendable {}
extension Pstake_Liquidstakeibc_V1beta1_HostChainLSParams: @unchecked Sendable {}
extension Pstake_Liquidstakeibc_V1beta1_ICAAccount: @unchecked Sendable {}
extension Pstake_Liquidstakeibc_V1beta1_ICAAccount.ChannelState: @unchecked Sendable {}
extension Pstake_Liquidstakeibc_V1beta1_Validator: @unchecked Sendable {}
extension Pstake_Liquidstakeibc_V1beta1_Deposit: @unchecked Sendable {}
extension Pstake_Liquidstakeibc_V1beta1_Deposit.DepositState: @unchecked Sendable {}
extension Pstake_Liquidstakeibc_V1beta1_Unbonding: @unchecked Sendable {}
extension Pstake_Liquidstakeibc_V1beta1_Unbonding.UnbondingState: @unchecked Sendable {}
extension Pstake_Liquidstakeibc_V1beta1_UserUnbonding: @unchecked Sendable {}
extension Pstake_Liquidstakeibc_V1beta1_ValidatorUnbonding: @unchecked Sendable {}
extension Pstake_Liquidstakeibc_V1beta1_KVUpdate: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pstake.liquidstakeibc.v1beta1"

extension Pstake_Liquidstakeibc_V1beta1_HostChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HostChain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    2: .standard(proto: "connection_id"),
    3: .same(proto: "params"),
    4: .standard(proto: "host_denom"),
    5: .standard(proto: "channel_id"),
    6: .standard(proto: "port_id"),
    7: .standard(proto: "delegation_account"),
    8: .standard(proto: "rewards_account"),
    9: .same(proto: "validators"),
    11: .standard(proto: "minimum_deposit"),
    12: .standard(proto: "c_value"),
    13: .standard(proto: "next_valset_hash"),
    14: .standard(proto: "unbonding_factor"),
    15: .same(proto: "active"),
  ]

  fileprivate class _StorageClass {
    var _chainID: String = String()
    var _connectionID: String = String()
    var _params: Pstake_Liquidstakeibc_V1beta1_HostChainLSParams? = nil
    var _hostDenom: String = String()
    var _channelID: String = String()
    var _portID: String = String()
    var _delegationAccount: Pstake_Liquidstakeibc_V1beta1_ICAAccount? = nil
    var _rewardsAccount: Pstake_Liquidstakeibc_V1beta1_ICAAccount? = nil
    var _validators: [Pstake_Liquidstakeibc_V1beta1_Validator] = []
    var _minimumDeposit: String = String()
    var _cValue: String = String()
    var _nextValsetHash: Data = Data()
    var _unbondingFactor: Int64 = 0
    var _active: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chainID = source._chainID
      _connectionID = source._connectionID
      _params = source._params
      _hostDenom = source._hostDenom
      _channelID = source._channelID
      _portID = source._portID
      _delegationAccount = source._delegationAccount
      _rewardsAccount = source._rewardsAccount
      _validators = source._validators
      _minimumDeposit = source._minimumDeposit
      _cValue = source._cValue
      _nextValsetHash = source._nextValsetHash
      _unbondingFactor = source._unbondingFactor
      _active = source._active
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._chainID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._connectionID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._hostDenom) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._portID) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._delegationAccount) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._rewardsAccount) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._validators) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._minimumDeposit) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._cValue) }()
        case 13: try { try decoder.decodeSingularBytesField(value: &_storage._nextValsetHash) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._unbondingFactor) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._active) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._chainID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chainID, fieldNumber: 1)
      }
      if !_storage._connectionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectionID, fieldNumber: 2)
      }
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._hostDenom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostDenom, fieldNumber: 4)
      }
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 5)
      }
      if !_storage._portID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._portID, fieldNumber: 6)
      }
      try { if let v = _storage._delegationAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._rewardsAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._validators.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._validators, fieldNumber: 9)
      }
      if !_storage._minimumDeposit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minimumDeposit, fieldNumber: 11)
      }
      if !_storage._cValue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cValue, fieldNumber: 12)
      }
      if !_storage._nextValsetHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._nextValsetHash, fieldNumber: 13)
      }
      if _storage._unbondingFactor != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unbondingFactor, fieldNumber: 14)
      }
      if _storage._active != false {
        try visitor.visitSingularBoolField(value: _storage._active, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pstake_Liquidstakeibc_V1beta1_HostChain, rhs: Pstake_Liquidstakeibc_V1beta1_HostChain) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chainID != rhs_storage._chainID {return false}
        if _storage._connectionID != rhs_storage._connectionID {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._hostDenom != rhs_storage._hostDenom {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._portID != rhs_storage._portID {return false}
        if _storage._delegationAccount != rhs_storage._delegationAccount {return false}
        if _storage._rewardsAccount != rhs_storage._rewardsAccount {return false}
        if _storage._validators != rhs_storage._validators {return false}
        if _storage._minimumDeposit != rhs_storage._minimumDeposit {return false}
        if _storage._cValue != rhs_storage._cValue {return false}
        if _storage._nextValsetHash != rhs_storage._nextValsetHash {return false}
        if _storage._unbondingFactor != rhs_storage._unbondingFactor {return false}
        if _storage._active != rhs_storage._active {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pstake_Liquidstakeibc_V1beta1_HostChainLSParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HostChainLSParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deposit_fee"),
    2: .standard(proto: "restake_fee"),
    3: .standard(proto: "unstake_fee"),
    4: .standard(proto: "redemption_fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.depositFee) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.restakeFee) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.unstakeFee) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.redemptionFee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.depositFee.isEmpty {
      try visitor.visitSingularStringField(value: self.depositFee, fieldNumber: 1)
    }
    if !self.restakeFee.isEmpty {
      try visitor.visitSingularStringField(value: self.restakeFee, fieldNumber: 2)
    }
    if !self.unstakeFee.isEmpty {
      try visitor.visitSingularStringField(value: self.unstakeFee, fieldNumber: 3)
    }
    if !self.redemptionFee.isEmpty {
      try visitor.visitSingularStringField(value: self.redemptionFee, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pstake_Liquidstakeibc_V1beta1_HostChainLSParams, rhs: Pstake_Liquidstakeibc_V1beta1_HostChainLSParams) -> Bool {
    if lhs.depositFee != rhs.depositFee {return false}
    if lhs.restakeFee != rhs.restakeFee {return false}
    if lhs.unstakeFee != rhs.unstakeFee {return false}
    if lhs.redemptionFee != rhs.redemptionFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pstake_Liquidstakeibc_V1beta1_ICAAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ICAAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "balance"),
    3: .same(proto: "owner"),
    4: .standard(proto: "channel_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._balance) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.channelState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try { if let v = self._balance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 3)
    }
    if self.channelState != .icaChannelCreating {
      try visitor.visitSingularEnumField(value: self.channelState, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pstake_Liquidstakeibc_V1beta1_ICAAccount, rhs: Pstake_Liquidstakeibc_V1beta1_ICAAccount) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._balance != rhs._balance {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.channelState != rhs.channelState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pstake_Liquidstakeibc_V1beta1_ICAAccount.ChannelState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ICA_CHANNEL_CREATING"),
    1: .same(proto: "ICA_CHANNEL_CREATED"),
  ]
}

extension Pstake_Liquidstakeibc_V1beta1_Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Validator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operator_address"),
    2: .same(proto: "status"),
    3: .same(proto: "weight"),
    4: .standard(proto: "delegated_amount"),
    5: .standard(proto: "total_amount"),
    6: .standard(proto: "unbonding_epoch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.operatorAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.weight) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.delegatedAmount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.totalAmount) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.unbondingEpoch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.operatorAddress, fieldNumber: 1)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 2)
    }
    if !self.weight.isEmpty {
      try visitor.visitSingularStringField(value: self.weight, fieldNumber: 3)
    }
    if !self.delegatedAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.delegatedAmount, fieldNumber: 4)
    }
    if !self.totalAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.totalAmount, fieldNumber: 5)
    }
    if self.unbondingEpoch != 0 {
      try visitor.visitSingularInt64Field(value: self.unbondingEpoch, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pstake_Liquidstakeibc_V1beta1_Validator, rhs: Pstake_Liquidstakeibc_V1beta1_Validator) -> Bool {
    if lhs.operatorAddress != rhs.operatorAddress {return false}
    if lhs.status != rhs.status {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.delegatedAmount != rhs.delegatedAmount {return false}
    if lhs.totalAmount != rhs.totalAmount {return false}
    if lhs.unbondingEpoch != rhs.unbondingEpoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pstake_Liquidstakeibc_V1beta1_Deposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Deposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    2: .same(proto: "amount"),
    3: .same(proto: "epoch"),
    4: .same(proto: "state"),
    5: .standard(proto: "ibc_sequence_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.epoch) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ibcSequenceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 1)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.epoch.isEmpty {
      try visitor.visitSingularStringField(value: self.epoch, fieldNumber: 3)
    }
    if self.state != .depositPending {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if !self.ibcSequenceID.isEmpty {
      try visitor.visitSingularStringField(value: self.ibcSequenceID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pstake_Liquidstakeibc_V1beta1_Deposit, rhs: Pstake_Liquidstakeibc_V1beta1_Deposit) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.state != rhs.state {return false}
    if lhs.ibcSequenceID != rhs.ibcSequenceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pstake_Liquidstakeibc_V1beta1_Deposit.DepositState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEPOSIT_PENDING"),
    1: .same(proto: "DEPOSIT_SENT"),
    2: .same(proto: "DEPOSIT_RECEIVED"),
    3: .same(proto: "DEPOSIT_DELEGATING"),
  ]
}

extension Pstake_Liquidstakeibc_V1beta1_Unbonding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Unbonding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    2: .standard(proto: "epoch_number"),
    3: .standard(proto: "mature_time"),
    4: .standard(proto: "burn_amount"),
    5: .standard(proto: "unbond_amount"),
    6: .standard(proto: "ibc_sequence_id"),
    7: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.epochNumber) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._matureTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._burnAmount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._unbondAmount) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.ibcSequenceID) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 1)
    }
    if self.epochNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.epochNumber, fieldNumber: 2)
    }
    try { if let v = self._matureTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._burnAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._unbondAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.ibcSequenceID.isEmpty {
      try visitor.visitSingularStringField(value: self.ibcSequenceID, fieldNumber: 6)
    }
    if self.state != .unbondingPending {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pstake_Liquidstakeibc_V1beta1_Unbonding, rhs: Pstake_Liquidstakeibc_V1beta1_Unbonding) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.epochNumber != rhs.epochNumber {return false}
    if lhs._matureTime != rhs._matureTime {return false}
    if lhs._burnAmount != rhs._burnAmount {return false}
    if lhs._unbondAmount != rhs._unbondAmount {return false}
    if lhs.ibcSequenceID != rhs.ibcSequenceID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pstake_Liquidstakeibc_V1beta1_Unbonding.UnbondingState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNBONDING_PENDING"),
    1: .same(proto: "UNBONDING_INITIATED"),
    2: .same(proto: "UNBONDING_MATURING"),
    3: .same(proto: "UNBONDING_MATURED"),
    4: .same(proto: "UNBONDING_CLAIMABLE"),
    5: .same(proto: "UNBONDING_FAILED"),
  ]
}

extension Pstake_Liquidstakeibc_V1beta1_UserUnbonding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserUnbonding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    2: .standard(proto: "epoch_number"),
    3: .same(proto: "address"),
    4: .standard(proto: "stk_amount"),
    5: .standard(proto: "unbond_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.epochNumber) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._stkAmount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._unbondAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 1)
    }
    if self.epochNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.epochNumber, fieldNumber: 2)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    try { if let v = self._stkAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._unbondAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pstake_Liquidstakeibc_V1beta1_UserUnbonding, rhs: Pstake_Liquidstakeibc_V1beta1_UserUnbonding) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.epochNumber != rhs.epochNumber {return false}
    if lhs.address != rhs.address {return false}
    if lhs._stkAmount != rhs._stkAmount {return false}
    if lhs._unbondAmount != rhs._unbondAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pstake_Liquidstakeibc_V1beta1_ValidatorUnbonding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatorUnbonding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    2: .standard(proto: "epoch_number"),
    3: .standard(proto: "mature_time"),
    4: .standard(proto: "validator_address"),
    5: .same(proto: "amount"),
    6: .standard(proto: "ibc_sequence_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.epochNumber) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._matureTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.ibcSequenceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 1)
    }
    if self.epochNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.epochNumber, fieldNumber: 2)
    }
    try { if let v = self._matureTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 4)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.ibcSequenceID.isEmpty {
      try visitor.visitSingularStringField(value: self.ibcSequenceID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pstake_Liquidstakeibc_V1beta1_ValidatorUnbonding, rhs: Pstake_Liquidstakeibc_V1beta1_ValidatorUnbonding) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.epochNumber != rhs.epochNumber {return false}
    if lhs._matureTime != rhs._matureTime {return false}
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.ibcSequenceID != rhs.ibcSequenceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pstake_Liquidstakeibc_V1beta1_KVUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KVUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pstake_Liquidstakeibc_V1beta1_KVUpdate, rhs: Pstake_Liquidstakeibc_V1beta1_KVUpdate) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
