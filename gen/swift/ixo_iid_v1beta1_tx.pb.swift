// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ixo/iid/v1beta1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Verification is a message that allows to assign a verification method
/// to one or more verification relationships
struct Ixo_Iid_V1beta1_Verification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// verificationRelationships defines which relationships
  /// are allowed to use the verification method
  var relationships: [String] = []

  /// public key associated with the did document.
  var method: Ixo_Iid_V1beta1_VerificationMethod {
    get {return _method ?? Ixo_Iid_V1beta1_VerificationMethod()}
    set {_method = newValue}
  }
  /// Returns true if `method` has been explicitly set.
  var hasMethod: Bool {return self._method != nil}
  /// Clears the value of `method`. Subsequent reads from it will return its default value.
  mutating func clearMethod() {self._method = nil}

  /// additional contexts (json ld schemas)
  var context: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _method: Ixo_Iid_V1beta1_VerificationMethod? = nil
}

/// MsgCreateDidDocument defines a SDK message for creating a new did.
struct Ixo_Iid_V1beta1_MsgCreateIidDocument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the list of controller DIDs
  var controllers: [String] = []

  var context: [Ixo_Iid_V1beta1_Context] = []

  /// the list of verification methods and relationships
  var verifications: [Ixo_Iid_V1beta1_Verification] = []

  var services: [Ixo_Iid_V1beta1_Service] = []

  var accordedRight: [Ixo_Iid_V1beta1_AccordedRight] = []

  var linkedResource: [Ixo_Iid_V1beta1_LinkedResource] = []

  var linkedEntity: [Ixo_Iid_V1beta1_LinkedEntity] = []

  var alsoKnownAs: String = String()

  /// address of the account signing the message
  var signer: String = String()

  var linkedClaim: [Ixo_Iid_V1beta1_LinkedClaim] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgCreateIidDocumentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Updates the entity with all the fields, so if field empty will be updated
/// with default go type, aka never null
struct Ixo_Iid_V1beta1_MsgUpdateIidDocument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the list of controller DIDs
  var controllers: [String] = []

  var context: [Ixo_Iid_V1beta1_Context] = []

  /// the list of verification methods and relationships
  var verifications: [Ixo_Iid_V1beta1_Verification] = []

  var services: [Ixo_Iid_V1beta1_Service] = []

  var accordedRight: [Ixo_Iid_V1beta1_AccordedRight] = []

  var linkedResource: [Ixo_Iid_V1beta1_LinkedResource] = []

  var linkedEntity: [Ixo_Iid_V1beta1_LinkedEntity] = []

  var alsoKnownAs: String = String()

  /// address of the account signing the message
  var signer: String = String()

  var linkedClaim: [Ixo_Iid_V1beta1_LinkedClaim] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgUpdateIidDocumentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddVerification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the verification to add
  var verification: Ixo_Iid_V1beta1_Verification {
    get {return _verification ?? Ixo_Iid_V1beta1_Verification()}
    set {_verification = newValue}
  }
  /// Returns true if `verification` has been explicitly set.
  var hasVerification: Bool {return self._verification != nil}
  /// Clears the value of `verification`. Subsequent reads from it will return its default value.
  mutating func clearVerification() {self._verification = nil}

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _verification: Ixo_Iid_V1beta1_Verification? = nil
}

struct Ixo_Iid_V1beta1_MsgAddVerificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgSetVerificationRelationships {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the verification method id
  var methodID: String = String()

  /// the list of relationships to set
  var relationships: [String] = []

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgSetVerificationRelationshipsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgRevokeVerification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the verification method id
  var methodID: String = String()

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgRevokeVerificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the service data to add
  var serviceData: Ixo_Iid_V1beta1_Service {
    get {return _serviceData ?? Ixo_Iid_V1beta1_Service()}
    set {_serviceData = newValue}
  }
  /// Returns true if `serviceData` has been explicitly set.
  var hasServiceData: Bool {return self._serviceData != nil}
  /// Clears the value of `serviceData`. Subsequent reads from it will return its default value.
  mutating func clearServiceData() {self._serviceData = nil}

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serviceData: Ixo_Iid_V1beta1_Service? = nil
}

struct Ixo_Iid_V1beta1_MsgAddServiceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgDeleteService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the service id
  var serviceID: String = String()

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgDeleteServiceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddController {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did of the document
  var id: String = String()

  /// the did to add as a controller of the did document
  var controllerDid: String = String()

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddControllerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgDeleteController {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did of the document
  var id: String = String()

  /// the did to remove from the list of controllers of the did document
  var controllerDid: String = String()

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgDeleteControllerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddLinkedResource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the verification to add
  var linkedResource: Ixo_Iid_V1beta1_LinkedResource {
    get {return _linkedResource ?? Ixo_Iid_V1beta1_LinkedResource()}
    set {_linkedResource = newValue}
  }
  /// Returns true if `linkedResource` has been explicitly set.
  var hasLinkedResource: Bool {return self._linkedResource != nil}
  /// Clears the value of `linkedResource`. Subsequent reads from it will return its default value.
  mutating func clearLinkedResource() {self._linkedResource = nil}

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _linkedResource: Ixo_Iid_V1beta1_LinkedResource? = nil
}

struct Ixo_Iid_V1beta1_MsgDeleteLinkedResource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the service id
  var resourceID: String = String()

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddLinkedClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the claim to add
  var linkedClaim: Ixo_Iid_V1beta1_LinkedClaim {
    get {return _linkedClaim ?? Ixo_Iid_V1beta1_LinkedClaim()}
    set {_linkedClaim = newValue}
  }
  /// Returns true if `linkedClaim` has been explicitly set.
  var hasLinkedClaim: Bool {return self._linkedClaim != nil}
  /// Clears the value of `linkedClaim`. Subsequent reads from it will return its default value.
  mutating func clearLinkedClaim() {self._linkedClaim = nil}

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _linkedClaim: Ixo_Iid_V1beta1_LinkedClaim? = nil
}

struct Ixo_Iid_V1beta1_MsgDeleteLinkedClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the claim id
  var claimID: String = String()

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddLinkedEntity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the iid
  var id: String = String()

  /// the entity to add
  var linkedEntity: Ixo_Iid_V1beta1_LinkedEntity {
    get {return _linkedEntity ?? Ixo_Iid_V1beta1_LinkedEntity()}
    set {_linkedEntity = newValue}
  }
  /// Returns true if `linkedEntity` has been explicitly set.
  var hasLinkedEntity: Bool {return self._linkedEntity != nil}
  /// Clears the value of `linkedEntity`. Subsequent reads from it will return its default value.
  mutating func clearLinkedEntity() {self._linkedEntity = nil}

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _linkedEntity: Ixo_Iid_V1beta1_LinkedEntity? = nil
}

struct Ixo_Iid_V1beta1_MsgDeleteLinkedEntity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the iid
  var id: String = String()

  /// the entity id
  var entityID: String = String()

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddAccordedRight {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the Accorded right to add
  var accordedRight: Ixo_Iid_V1beta1_AccordedRight {
    get {return _accordedRight ?? Ixo_Iid_V1beta1_AccordedRight()}
    set {_accordedRight = newValue}
  }
  /// Returns true if `accordedRight` has been explicitly set.
  var hasAccordedRight: Bool {return self._accordedRight != nil}
  /// Clears the value of `accordedRight`. Subsequent reads from it will return its default value.
  mutating func clearAccordedRight() {self._accordedRight = nil}

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accordedRight: Ixo_Iid_V1beta1_AccordedRight? = nil
}

struct Ixo_Iid_V1beta1_MsgDeleteAccordedRight {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the Accorded right id
  var rightID: String = String()

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddIidContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the context to add
  var context: Ixo_Iid_V1beta1_Context {
    get {return _context ?? Ixo_Iid_V1beta1_Context()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  mutating func clearContext() {self._context = nil}

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _context: Ixo_Iid_V1beta1_Context? = nil
}

struct Ixo_Iid_V1beta1_MsgDeactivateIID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  var state: Bool = false

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgDeleteIidContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the did
  var id: String = String()

  /// the context key
  var contextKey: String = String()

  /// address of the account signing the message
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddLinkedResourceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgDeleteLinkedResourceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddLinkedClaimResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgDeleteLinkedClaimResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddLinkedEntityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgDeleteLinkedEntityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddAccordedRightResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgDeleteAccordedRightResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgAddIidContextResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgDeleteIidContextResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_MsgDeactivateIIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Ixo_Iid_V1beta1_Verification: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgCreateIidDocument: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgCreateIidDocumentResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgUpdateIidDocument: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgUpdateIidDocumentResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddVerification: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddVerificationResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgSetVerificationRelationships: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgSetVerificationRelationshipsResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgRevokeVerification: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgRevokeVerificationResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddService: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddServiceResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteService: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteServiceResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddController: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddControllerResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteController: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteControllerResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddLinkedResource: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteLinkedResource: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddLinkedClaim: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteLinkedClaim: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddLinkedEntity: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteLinkedEntity: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddAccordedRight: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteAccordedRight: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddIidContext: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeactivateIID: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteIidContext: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddLinkedResourceResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteLinkedResourceResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddLinkedClaimResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteLinkedClaimResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddLinkedEntityResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteLinkedEntityResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddAccordedRightResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteAccordedRightResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgAddIidContextResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeleteIidContextResponse: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_MsgDeactivateIIDResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ixo.iid.v1beta1"

extension Ixo_Iid_V1beta1_Verification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Verification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "relationships"),
    2: .same(proto: "method"),
    3: .same(proto: "context"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.relationships) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._method) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.context) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.relationships.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relationships, fieldNumber: 1)
    }
    try { if let v = self._method {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.context.isEmpty {
      try visitor.visitRepeatedStringField(value: self.context, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_Verification, rhs: Ixo_Iid_V1beta1_Verification) -> Bool {
    if lhs.relationships != rhs.relationships {return false}
    if lhs._method != rhs._method {return false}
    if lhs.context != rhs.context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgCreateIidDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateIidDocument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "controllers"),
    3: .same(proto: "context"),
    4: .same(proto: "verifications"),
    5: .same(proto: "services"),
    6: .same(proto: "accordedRight"),
    7: .same(proto: "linkedResource"),
    8: .same(proto: "linkedEntity"),
    9: .same(proto: "alsoKnownAs"),
    10: .same(proto: "signer"),
    11: .same(proto: "linkedClaim"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.controllers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.context) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.verifications) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.accordedRight) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.linkedResource) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.linkedEntity) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.alsoKnownAs) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.linkedClaim) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.controllers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.controllers, fieldNumber: 2)
    }
    if !self.context.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.context, fieldNumber: 3)
    }
    if !self.verifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.verifications, fieldNumber: 4)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 5)
    }
    if !self.accordedRight.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accordedRight, fieldNumber: 6)
    }
    if !self.linkedResource.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkedResource, fieldNumber: 7)
    }
    if !self.linkedEntity.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkedEntity, fieldNumber: 8)
    }
    if !self.alsoKnownAs.isEmpty {
      try visitor.visitSingularStringField(value: self.alsoKnownAs, fieldNumber: 9)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 10)
    }
    if !self.linkedClaim.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkedClaim, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgCreateIidDocument, rhs: Ixo_Iid_V1beta1_MsgCreateIidDocument) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.controllers != rhs.controllers {return false}
    if lhs.context != rhs.context {return false}
    if lhs.verifications != rhs.verifications {return false}
    if lhs.services != rhs.services {return false}
    if lhs.accordedRight != rhs.accordedRight {return false}
    if lhs.linkedResource != rhs.linkedResource {return false}
    if lhs.linkedEntity != rhs.linkedEntity {return false}
    if lhs.alsoKnownAs != rhs.alsoKnownAs {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.linkedClaim != rhs.linkedClaim {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgCreateIidDocumentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateIidDocumentResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgCreateIidDocumentResponse, rhs: Ixo_Iid_V1beta1_MsgCreateIidDocumentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgUpdateIidDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateIidDocument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "controllers"),
    3: .same(proto: "context"),
    4: .same(proto: "verifications"),
    5: .same(proto: "services"),
    6: .same(proto: "accordedRight"),
    7: .same(proto: "linkedResource"),
    8: .same(proto: "linkedEntity"),
    9: .same(proto: "alsoKnownAs"),
    10: .same(proto: "signer"),
    11: .same(proto: "linkedClaim"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.controllers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.context) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.verifications) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.accordedRight) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.linkedResource) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.linkedEntity) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.alsoKnownAs) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.linkedClaim) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.controllers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.controllers, fieldNumber: 2)
    }
    if !self.context.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.context, fieldNumber: 3)
    }
    if !self.verifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.verifications, fieldNumber: 4)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 5)
    }
    if !self.accordedRight.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accordedRight, fieldNumber: 6)
    }
    if !self.linkedResource.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkedResource, fieldNumber: 7)
    }
    if !self.linkedEntity.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkedEntity, fieldNumber: 8)
    }
    if !self.alsoKnownAs.isEmpty {
      try visitor.visitSingularStringField(value: self.alsoKnownAs, fieldNumber: 9)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 10)
    }
    if !self.linkedClaim.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkedClaim, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgUpdateIidDocument, rhs: Ixo_Iid_V1beta1_MsgUpdateIidDocument) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.controllers != rhs.controllers {return false}
    if lhs.context != rhs.context {return false}
    if lhs.verifications != rhs.verifications {return false}
    if lhs.services != rhs.services {return false}
    if lhs.accordedRight != rhs.accordedRight {return false}
    if lhs.linkedResource != rhs.linkedResource {return false}
    if lhs.linkedEntity != rhs.linkedEntity {return false}
    if lhs.alsoKnownAs != rhs.alsoKnownAs {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.linkedClaim != rhs.linkedClaim {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgUpdateIidDocumentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateIidDocumentResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgUpdateIidDocumentResponse, rhs: Ixo_Iid_V1beta1_MsgUpdateIidDocumentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddVerification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddVerification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "verification"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._verification) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._verification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddVerification, rhs: Ixo_Iid_V1beta1_MsgAddVerification) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._verification != rhs._verification {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddVerificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddVerificationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddVerificationResponse, rhs: Ixo_Iid_V1beta1_MsgAddVerificationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgSetVerificationRelationships: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetVerificationRelationships"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "method_id"),
    3: .same(proto: "relationships"),
    4: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.methodID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.relationships) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.methodID.isEmpty {
      try visitor.visitSingularStringField(value: self.methodID, fieldNumber: 2)
    }
    if !self.relationships.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relationships, fieldNumber: 3)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgSetVerificationRelationships, rhs: Ixo_Iid_V1beta1_MsgSetVerificationRelationships) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.methodID != rhs.methodID {return false}
    if lhs.relationships != rhs.relationships {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgSetVerificationRelationshipsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetVerificationRelationshipsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgSetVerificationRelationshipsResponse, rhs: Ixo_Iid_V1beta1_MsgSetVerificationRelationshipsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgRevokeVerification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRevokeVerification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "method_id"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.methodID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.methodID.isEmpty {
      try visitor.visitSingularStringField(value: self.methodID, fieldNumber: 2)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgRevokeVerification, rhs: Ixo_Iid_V1beta1_MsgRevokeVerification) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.methodID != rhs.methodID {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgRevokeVerificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRevokeVerificationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgRevokeVerificationResponse, rhs: Ixo_Iid_V1beta1_MsgRevokeVerificationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddService"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "service_data"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._serviceData) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._serviceData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddService, rhs: Ixo_Iid_V1beta1_MsgAddService) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._serviceData != rhs._serviceData {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddServiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddServiceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddServiceResponse, rhs: Ixo_Iid_V1beta1_MsgAddServiceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteService"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "service_id"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.serviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceID, fieldNumber: 2)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteService, rhs: Ixo_Iid_V1beta1_MsgDeleteService) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.serviceID != rhs.serviceID {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteServiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteServiceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteServiceResponse, rhs: Ixo_Iid_V1beta1_MsgDeleteServiceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddController: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddController"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "controller_did"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.controllerDid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.controllerDid.isEmpty {
      try visitor.visitSingularStringField(value: self.controllerDid, fieldNumber: 2)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddController, rhs: Ixo_Iid_V1beta1_MsgAddController) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.controllerDid != rhs.controllerDid {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddControllerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddControllerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddControllerResponse, rhs: Ixo_Iid_V1beta1_MsgAddControllerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteController: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteController"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "controller_did"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.controllerDid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.controllerDid.isEmpty {
      try visitor.visitSingularStringField(value: self.controllerDid, fieldNumber: 2)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteController, rhs: Ixo_Iid_V1beta1_MsgDeleteController) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.controllerDid != rhs.controllerDid {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteControllerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteControllerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteControllerResponse, rhs: Ixo_Iid_V1beta1_MsgDeleteControllerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddLinkedResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddLinkedResource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "linkedResource"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._linkedResource) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._linkedResource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddLinkedResource, rhs: Ixo_Iid_V1beta1_MsgAddLinkedResource) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._linkedResource != rhs._linkedResource {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteLinkedResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteLinkedResource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "resource_id"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.resourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceID, fieldNumber: 2)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteLinkedResource, rhs: Ixo_Iid_V1beta1_MsgDeleteLinkedResource) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddLinkedClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddLinkedClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "linkedClaim"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._linkedClaim) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._linkedClaim {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddLinkedClaim, rhs: Ixo_Iid_V1beta1_MsgAddLinkedClaim) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._linkedClaim != rhs._linkedClaim {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteLinkedClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteLinkedClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "claim_id"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.claimID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.claimID.isEmpty {
      try visitor.visitSingularStringField(value: self.claimID, fieldNumber: 2)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteLinkedClaim, rhs: Ixo_Iid_V1beta1_MsgDeleteLinkedClaim) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.claimID != rhs.claimID {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddLinkedEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddLinkedEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "linkedEntity"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._linkedEntity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._linkedEntity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddLinkedEntity, rhs: Ixo_Iid_V1beta1_MsgAddLinkedEntity) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._linkedEntity != rhs._linkedEntity {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteLinkedEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteLinkedEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "entity_id"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.entityID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.entityID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityID, fieldNumber: 2)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteLinkedEntity, rhs: Ixo_Iid_V1beta1_MsgDeleteLinkedEntity) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.entityID != rhs.entityID {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddAccordedRight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddAccordedRight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "accordedRight"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accordedRight) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._accordedRight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddAccordedRight, rhs: Ixo_Iid_V1beta1_MsgAddAccordedRight) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._accordedRight != rhs._accordedRight {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteAccordedRight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteAccordedRight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "right_id"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rightID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.rightID.isEmpty {
      try visitor.visitSingularStringField(value: self.rightID, fieldNumber: 2)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteAccordedRight, rhs: Ixo_Iid_V1beta1_MsgDeleteAccordedRight) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.rightID != rhs.rightID {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddIidContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddIidContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "context"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddIidContext, rhs: Ixo_Iid_V1beta1_MsgAddIidContext) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._context != rhs._context {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeactivateIID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeactivateIID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "state"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.state != false {
      try visitor.visitSingularBoolField(value: self.state, fieldNumber: 2)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeactivateIID, rhs: Ixo_Iid_V1beta1_MsgDeactivateIID) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.state != rhs.state {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteIidContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteIidContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "contextKey"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contextKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.contextKey.isEmpty {
      try visitor.visitSingularStringField(value: self.contextKey, fieldNumber: 2)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteIidContext, rhs: Ixo_Iid_V1beta1_MsgDeleteIidContext) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.contextKey != rhs.contextKey {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddLinkedResourceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddLinkedResourceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddLinkedResourceResponse, rhs: Ixo_Iid_V1beta1_MsgAddLinkedResourceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteLinkedResourceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteLinkedResourceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteLinkedResourceResponse, rhs: Ixo_Iid_V1beta1_MsgDeleteLinkedResourceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddLinkedClaimResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddLinkedClaimResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddLinkedClaimResponse, rhs: Ixo_Iid_V1beta1_MsgAddLinkedClaimResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteLinkedClaimResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteLinkedClaimResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteLinkedClaimResponse, rhs: Ixo_Iid_V1beta1_MsgDeleteLinkedClaimResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddLinkedEntityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddLinkedEntityResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddLinkedEntityResponse, rhs: Ixo_Iid_V1beta1_MsgAddLinkedEntityResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteLinkedEntityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteLinkedEntityResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteLinkedEntityResponse, rhs: Ixo_Iid_V1beta1_MsgDeleteLinkedEntityResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddAccordedRightResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddAccordedRightResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddAccordedRightResponse, rhs: Ixo_Iid_V1beta1_MsgAddAccordedRightResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteAccordedRightResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteAccordedRightResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteAccordedRightResponse, rhs: Ixo_Iid_V1beta1_MsgDeleteAccordedRightResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgAddIidContextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddIidContextResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgAddIidContextResponse, rhs: Ixo_Iid_V1beta1_MsgAddIidContextResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeleteIidContextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteIidContextResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeleteIidContextResponse, rhs: Ixo_Iid_V1beta1_MsgDeleteIidContextResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_MsgDeactivateIIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeactivateIIDResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_MsgDeactivateIIDResponse, rhs: Ixo_Iid_V1beta1_MsgDeactivateIIDResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
