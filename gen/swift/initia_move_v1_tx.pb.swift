// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: initia/move/v1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgPublish is the message to store compiled Move module
struct Initia_Move_V1_MsgPublish {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// CodeBytes is raw move module bytes code
  var codeBytes: [Data] = []

  /// UpgradePolicy defines upgrade rules which will be applied
  /// at next publish message.
  /// Upgrades in the direction of enhancing security are permitted.
  /// `ARBITRARY` => `COMPATIBLE`
  /// `ARBITRARY` => `IMMUTABLE`
  /// `COMPATIBLE` => `IMMUTABLE`
  /// but reverse ways are not allowed (ignored).
  var upgradePolicy: Initia_Move_V1_UpgradePolicy = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgPublishResponse returns store result data.
struct Initia_Move_V1_MsgPublishResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgExecute is the message to execute the given module function
struct Initia_Move_V1_MsgExecute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// ModuleAddr is the address of the module deployer
  var moduleAddress: String = String()

  /// ModuleName is the name of module to execute
  var moduleName: String = String()

  /// FunctionName is the name of a function to execute
  var functionName: String = String()

  /// TypeArgs is the type arguments of a function to execute
  /// ex) "0x1::BasicCoin::Initia", "bool", "u8", "u64"
  var typeArgs: [String] = []

  /// Args is the arguments of a function to execute
  /// - number: little endian
  /// - string: base64 bytes
  var args: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgExecuteResponse returns execution result data.
struct Initia_Move_V1_MsgExecuteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgExecuteJSON is the message to execute the given module function
struct Initia_Move_V1_MsgExecuteJSON {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// ModuleAddr is the address of the module deployer
  var moduleAddress: String = String()

  /// ModuleName is the name of module to execute
  var moduleName: String = String()

  /// FunctionName is the name of a function to execute
  var functionName: String = String()

  /// TypeArgs is the type arguments of a function to execute
  /// ex) "0x1::BasicCoin::Initia", "bool", "u8", "u64"
  var typeArgs: [String] = []

  /// Args is the arguments of a function to execute in json stringify format
  var args: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgExecuteJSONResponse returns execution result data.
struct Initia_Move_V1_MsgExecuteJSONResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgScript is the message to execute script code with sender as signer
struct Initia_Move_V1_MsgScript {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// CodeBytes is the script bytes code to execute
  var codeBytes: Data = Data()

  /// TypeArgs is the type arguments of a function to execute
  /// ex) "0x1::BasicCoin::Initia", "bool", "u8", "u64"
  var typeArgs: [String] = []

  /// Args is the arguments of a function to execute
  /// - number: little endian
  /// - string: base64 bytes
  var args: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgScriptResponse returns execution result data.
struct Initia_Move_V1_MsgScriptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgScriptJSON is the message to execute script code with sender as signer
struct Initia_Move_V1_MsgScriptJSON {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// CodeBytes is the script bytes code to execute
  var codeBytes: Data = Data()

  /// TypeArgs is the type arguments of a function to execute
  /// ex) "0x1::BasicCoin::Initia", "bool", "u8", "u64"
  var typeArgs: [String] = []

  /// Args is the arguments of a function to execute in json stringify format
  var args: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgScriptJSONResponse returns execution result data.
struct Initia_Move_V1_MsgScriptJSONResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgGovPublish is the message to store compiled Move module via gov proposal
struct Initia_Move_V1_MsgGovPublish {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authority is the address that controls the module
  /// (defaults to x/gov unless overwritten).
  var authority: String = String()

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// CodeBytes is raw move module bytes code
  var codeBytes: [Data] = []

  /// UpgradePolicy defines upgrade rules which will be applied
  /// at next publish message.
  /// Upgrades in the direction of enhancing security are permitted.
  /// `ARBITRARY` => `COMPATIBLE`
  /// `ARBITRARY` => `IMMUTABLE`
  /// `COMPATIBLE` => `IMMUTABLE`
  /// but reverse ways are not allowed (ignored).
  var upgradePolicy: Initia_Move_V1_UpgradePolicy = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgGovPublishResponse returns execution result data.
struct Initia_Move_V1_MsgGovPublishResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgGovExecute is the message to execute the given module
/// function via gov proposal
struct Initia_Move_V1_MsgGovExecute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authority is the address that controls the module
  /// (defaults to x/gov unless overwritten).
  var authority: String = String()

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// ModuleAddr is the address of the module deployer
  var moduleAddress: String = String()

  /// ModuleName is the name of module to execute
  var moduleName: String = String()

  /// FunctionName is the name of a function to execute
  var functionName: String = String()

  /// TypeArgs is the type arguments of a function to execute
  /// ex) "0x1::BasicCoin::Initia", "bool", "u8", "u64"
  var typeArgs: [String] = []

  /// Args is the arguments of a function to execute
  /// - number: little endian
  /// - string: base64 bytes
  var args: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgGovExecuteResponse returns execution result data.
struct Initia_Move_V1_MsgGovExecuteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgGovExecuteJSON is the message to execute the given module
/// function via gov proposal
struct Initia_Move_V1_MsgGovExecuteJSON {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authority is the address that controls the module
  /// (defaults to x/gov unless overwritten).
  var authority: String = String()

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// ModuleAddr is the address of the module deployer
  var moduleAddress: String = String()

  /// ModuleName is the name of module to execute
  var moduleName: String = String()

  /// FunctionName is the name of a function to execute
  var functionName: String = String()

  /// TypeArgs is the type arguments of a function to execute
  /// ex) "0x1::BasicCoin::Initia", "bool", "u8", "u64"
  var typeArgs: [String] = []

  /// Args is the arguments of a function to execute in json stringify format
  var args: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgGovExecuteJSONResponse returns execution result data.
struct Initia_Move_V1_MsgGovExecuteJSONResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgGovScript is the message to execute script code with sender as signer via gov
struct Initia_Move_V1_MsgGovScript {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authority is the address that controls the module
  /// (defaults to x/gov unless overwritten).
  var authority: String = String()

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// CodeBytes is the script bytes code to execute
  var codeBytes: Data = Data()

  /// TypeArgs is the type arguments of a function to execute
  /// ex) "0x1::BasicCoin::Initia", "bool", "u8", "u64"
  var typeArgs: [String] = []

  /// Args is the arguments of a function to execute
  /// - number: little endian
  /// - string: base64 bytes
  var args: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgGovScriptResponse returns execution result data.
struct Initia_Move_V1_MsgGovScriptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgGovScriptJSON is the message to execute script code with sender as signer via gov
struct Initia_Move_V1_MsgGovScriptJSON {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authority is the address that controls the module
  /// (defaults to x/gov unless overwritten).
  var authority: String = String()

  /// Sender is the that actor that signed the messages
  var sender: String = String()

  /// CodeBytes is the script bytes code to execute
  var codeBytes: Data = Data()

  /// TypeArgs is the type arguments of a function to execute
  /// ex) "0x1::BasicCoin::Initia", "bool", "u8", "u64"
  var typeArgs: [String] = []

  /// Args is the arguments of a function to execute in json stringify format
  var args: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgGovScriptJSONResponse returns execution result data.
struct Initia_Move_V1_MsgGovScriptJSONResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWhitelist is a message to register a dex pair to
/// whitelist of various features.
/// - whitelist from coin register operation
/// - allow counter party denom can be used as gas fee
/// - register lp denom as staking denom
struct Initia_Move_V1_MsgWhitelist {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authority is the address that controls the module
  /// (defaults to x/gov unless overwritten).
  var authority: String = String()

  /// Dex coin LP metadata address
  var metadataLp: String = String()

  /// RewardWeight is registered to distribution's Params
  var rewardWeight: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWhitelistResponse returns result data.
struct Initia_Move_V1_MsgWhitelistResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDelist is a message to unregister a dex pair
/// from the whitelist of various features.
struct Initia_Move_V1_MsgDelist {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authority is the address that controls the module
  /// (defaults to x/gov unless overwritten).
  var authority: String = String()

  /// Dex coin LP metadata address
  var metadataLp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDelistResponse returns result data.
struct Initia_Move_V1_MsgDelistResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateParams is the Msg/UpdateParams request type.
struct Initia_Move_V1_MsgUpdateParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authority is the address that controls the module
  /// (defaults to x/gov unless overwritten).
  var authority: String = String()

  /// params defines the x/staking parameters to update.
  ///
  /// NOTE: All parameters must be supplied.
  var params: Initia_Move_V1_Params {
    get {return _params ?? Initia_Move_V1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Initia_Move_V1_Params? = nil
}

/// MsgUpdateParamsResponse defines the response structure for executing a
/// MsgUpdateParams message.
struct Initia_Move_V1_MsgUpdateParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Initia_Move_V1_MsgPublish: @unchecked Sendable {}
extension Initia_Move_V1_MsgPublishResponse: @unchecked Sendable {}
extension Initia_Move_V1_MsgExecute: @unchecked Sendable {}
extension Initia_Move_V1_MsgExecuteResponse: @unchecked Sendable {}
extension Initia_Move_V1_MsgExecuteJSON: @unchecked Sendable {}
extension Initia_Move_V1_MsgExecuteJSONResponse: @unchecked Sendable {}
extension Initia_Move_V1_MsgScript: @unchecked Sendable {}
extension Initia_Move_V1_MsgScriptResponse: @unchecked Sendable {}
extension Initia_Move_V1_MsgScriptJSON: @unchecked Sendable {}
extension Initia_Move_V1_MsgScriptJSONResponse: @unchecked Sendable {}
extension Initia_Move_V1_MsgGovPublish: @unchecked Sendable {}
extension Initia_Move_V1_MsgGovPublishResponse: @unchecked Sendable {}
extension Initia_Move_V1_MsgGovExecute: @unchecked Sendable {}
extension Initia_Move_V1_MsgGovExecuteResponse: @unchecked Sendable {}
extension Initia_Move_V1_MsgGovExecuteJSON: @unchecked Sendable {}
extension Initia_Move_V1_MsgGovExecuteJSONResponse: @unchecked Sendable {}
extension Initia_Move_V1_MsgGovScript: @unchecked Sendable {}
extension Initia_Move_V1_MsgGovScriptResponse: @unchecked Sendable {}
extension Initia_Move_V1_MsgGovScriptJSON: @unchecked Sendable {}
extension Initia_Move_V1_MsgGovScriptJSONResponse: @unchecked Sendable {}
extension Initia_Move_V1_MsgWhitelist: @unchecked Sendable {}
extension Initia_Move_V1_MsgWhitelistResponse: @unchecked Sendable {}
extension Initia_Move_V1_MsgDelist: @unchecked Sendable {}
extension Initia_Move_V1_MsgDelistResponse: @unchecked Sendable {}
extension Initia_Move_V1_MsgUpdateParams: @unchecked Sendable {}
extension Initia_Move_V1_MsgUpdateParamsResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "initia.move.v1"

extension Initia_Move_V1_MsgPublish: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPublish"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "code_bytes"),
    3: .standard(proto: "upgrade_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.codeBytes) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.upgradePolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.codeBytes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.codeBytes, fieldNumber: 2)
    }
    if self.upgradePolicy != .unspecified {
      try visitor.visitSingularEnumField(value: self.upgradePolicy, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgPublish, rhs: Initia_Move_V1_MsgPublish) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.codeBytes != rhs.codeBytes {return false}
    if lhs.upgradePolicy != rhs.upgradePolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgPublishResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPublishResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgPublishResponse, rhs: Initia_Move_V1_MsgPublishResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgExecute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgExecute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "module_address"),
    3: .standard(proto: "module_name"),
    4: .standard(proto: "function_name"),
    5: .standard(proto: "type_args"),
    6: .same(proto: "args"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.moduleName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.functionName) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.typeArgs) }()
      case 6: try { try decoder.decodeRepeatedBytesField(value: &self.args) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.moduleAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleAddress, fieldNumber: 2)
    }
    if !self.moduleName.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleName, fieldNumber: 3)
    }
    if !self.functionName.isEmpty {
      try visitor.visitSingularStringField(value: self.functionName, fieldNumber: 4)
    }
    if !self.typeArgs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.typeArgs, fieldNumber: 5)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.args, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgExecute, rhs: Initia_Move_V1_MsgExecute) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.moduleAddress != rhs.moduleAddress {return false}
    if lhs.moduleName != rhs.moduleName {return false}
    if lhs.functionName != rhs.functionName {return false}
    if lhs.typeArgs != rhs.typeArgs {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgExecuteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgExecuteResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgExecuteResponse, rhs: Initia_Move_V1_MsgExecuteResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgExecuteJSON: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgExecuteJSON"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "module_address"),
    3: .standard(proto: "module_name"),
    4: .standard(proto: "function_name"),
    5: .standard(proto: "type_args"),
    6: .same(proto: "args"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.moduleName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.functionName) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.typeArgs) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.moduleAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleAddress, fieldNumber: 2)
    }
    if !self.moduleName.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleName, fieldNumber: 3)
    }
    if !self.functionName.isEmpty {
      try visitor.visitSingularStringField(value: self.functionName, fieldNumber: 4)
    }
    if !self.typeArgs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.typeArgs, fieldNumber: 5)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgExecuteJSON, rhs: Initia_Move_V1_MsgExecuteJSON) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.moduleAddress != rhs.moduleAddress {return false}
    if lhs.moduleName != rhs.moduleName {return false}
    if lhs.functionName != rhs.functionName {return false}
    if lhs.typeArgs != rhs.typeArgs {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgExecuteJSONResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgExecuteJSONResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgExecuteJSONResponse, rhs: Initia_Move_V1_MsgExecuteJSONResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgScript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgScript"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "code_bytes"),
    3: .standard(proto: "type_args"),
    4: .same(proto: "args"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.codeBytes) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.typeArgs) }()
      case 4: try { try decoder.decodeRepeatedBytesField(value: &self.args) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.codeBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.codeBytes, fieldNumber: 2)
    }
    if !self.typeArgs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.typeArgs, fieldNumber: 3)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.args, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgScript, rhs: Initia_Move_V1_MsgScript) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.codeBytes != rhs.codeBytes {return false}
    if lhs.typeArgs != rhs.typeArgs {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgScriptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgScriptResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgScriptResponse, rhs: Initia_Move_V1_MsgScriptResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgScriptJSON: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgScriptJSON"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "code_bytes"),
    3: .standard(proto: "type_args"),
    4: .same(proto: "args"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.codeBytes) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.typeArgs) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.codeBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.codeBytes, fieldNumber: 2)
    }
    if !self.typeArgs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.typeArgs, fieldNumber: 3)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgScriptJSON, rhs: Initia_Move_V1_MsgScriptJSON) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.codeBytes != rhs.codeBytes {return false}
    if lhs.typeArgs != rhs.typeArgs {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgScriptJSONResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgScriptJSONResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgScriptJSONResponse, rhs: Initia_Move_V1_MsgScriptJSONResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgGovPublish: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGovPublish"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "sender"),
    3: .standard(proto: "code_bytes"),
    4: .standard(proto: "upgrade_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.codeBytes) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.upgradePolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 2)
    }
    if !self.codeBytes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.codeBytes, fieldNumber: 3)
    }
    if self.upgradePolicy != .unspecified {
      try visitor.visitSingularEnumField(value: self.upgradePolicy, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgGovPublish, rhs: Initia_Move_V1_MsgGovPublish) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.codeBytes != rhs.codeBytes {return false}
    if lhs.upgradePolicy != rhs.upgradePolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgGovPublishResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGovPublishResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgGovPublishResponse, rhs: Initia_Move_V1_MsgGovPublishResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgGovExecute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGovExecute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "sender"),
    3: .standard(proto: "module_address"),
    4: .standard(proto: "module_name"),
    5: .standard(proto: "function_name"),
    6: .standard(proto: "type_args"),
    7: .same(proto: "args"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.moduleAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.moduleName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.functionName) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.typeArgs) }()
      case 7: try { try decoder.decodeRepeatedBytesField(value: &self.args) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 2)
    }
    if !self.moduleAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleAddress, fieldNumber: 3)
    }
    if !self.moduleName.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleName, fieldNumber: 4)
    }
    if !self.functionName.isEmpty {
      try visitor.visitSingularStringField(value: self.functionName, fieldNumber: 5)
    }
    if !self.typeArgs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.typeArgs, fieldNumber: 6)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.args, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgGovExecute, rhs: Initia_Move_V1_MsgGovExecute) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.moduleAddress != rhs.moduleAddress {return false}
    if lhs.moduleName != rhs.moduleName {return false}
    if lhs.functionName != rhs.functionName {return false}
    if lhs.typeArgs != rhs.typeArgs {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgGovExecuteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGovExecuteResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgGovExecuteResponse, rhs: Initia_Move_V1_MsgGovExecuteResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgGovExecuteJSON: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGovExecuteJSON"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "sender"),
    3: .standard(proto: "module_address"),
    4: .standard(proto: "module_name"),
    5: .standard(proto: "function_name"),
    6: .standard(proto: "type_args"),
    7: .same(proto: "args"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.moduleAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.moduleName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.functionName) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.typeArgs) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 2)
    }
    if !self.moduleAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleAddress, fieldNumber: 3)
    }
    if !self.moduleName.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleName, fieldNumber: 4)
    }
    if !self.functionName.isEmpty {
      try visitor.visitSingularStringField(value: self.functionName, fieldNumber: 5)
    }
    if !self.typeArgs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.typeArgs, fieldNumber: 6)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgGovExecuteJSON, rhs: Initia_Move_V1_MsgGovExecuteJSON) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.moduleAddress != rhs.moduleAddress {return false}
    if lhs.moduleName != rhs.moduleName {return false}
    if lhs.functionName != rhs.functionName {return false}
    if lhs.typeArgs != rhs.typeArgs {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgGovExecuteJSONResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGovExecuteJSONResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgGovExecuteJSONResponse, rhs: Initia_Move_V1_MsgGovExecuteJSONResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgGovScript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGovScript"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "sender"),
    3: .standard(proto: "code_bytes"),
    4: .standard(proto: "type_args"),
    5: .same(proto: "args"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.codeBytes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.typeArgs) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.args) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 2)
    }
    if !self.codeBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.codeBytes, fieldNumber: 3)
    }
    if !self.typeArgs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.typeArgs, fieldNumber: 4)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.args, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgGovScript, rhs: Initia_Move_V1_MsgGovScript) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.codeBytes != rhs.codeBytes {return false}
    if lhs.typeArgs != rhs.typeArgs {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgGovScriptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGovScriptResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgGovScriptResponse, rhs: Initia_Move_V1_MsgGovScriptResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgGovScriptJSON: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGovScriptJSON"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "sender"),
    3: .standard(proto: "code_bytes"),
    4: .standard(proto: "type_args"),
    5: .same(proto: "args"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.codeBytes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.typeArgs) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 2)
    }
    if !self.codeBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.codeBytes, fieldNumber: 3)
    }
    if !self.typeArgs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.typeArgs, fieldNumber: 4)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgGovScriptJSON, rhs: Initia_Move_V1_MsgGovScriptJSON) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.codeBytes != rhs.codeBytes {return false}
    if lhs.typeArgs != rhs.typeArgs {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgGovScriptJSONResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGovScriptJSONResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgGovScriptJSONResponse, rhs: Initia_Move_V1_MsgGovScriptJSONResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgWhitelist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWhitelist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .standard(proto: "metadata_lp"),
    3: .standard(proto: "reward_weight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.metadataLp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rewardWeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.metadataLp.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataLp, fieldNumber: 2)
    }
    if !self.rewardWeight.isEmpty {
      try visitor.visitSingularStringField(value: self.rewardWeight, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgWhitelist, rhs: Initia_Move_V1_MsgWhitelist) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.metadataLp != rhs.metadataLp {return false}
    if lhs.rewardWeight != rhs.rewardWeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgWhitelistResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWhitelistResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgWhitelistResponse, rhs: Initia_Move_V1_MsgWhitelistResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgDelist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDelist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .standard(proto: "metadata_lp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.metadataLp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    if !self.metadataLp.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataLp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgDelist, rhs: Initia_Move_V1_MsgDelist) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs.metadataLp != rhs.metadataLp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgDelistResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDelistResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgDelistResponse, rhs: Initia_Move_V1_MsgDelistResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgUpdateParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authority"),
    2: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 1)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgUpdateParams, rhs: Initia_Move_V1_MsgUpdateParams) -> Bool {
    if lhs.authority != rhs.authority {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Initia_Move_V1_MsgUpdateParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateParamsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Initia_Move_V1_MsgUpdateParamsResponse, rhs: Initia_Move_V1_MsgUpdateParamsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
