// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: injective/exchange/v1beta1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Injective_Exchange_V1beta1_OrderSide: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// will return both
  case sideUnspecified // = 0
  case buy // = 1
  case sell // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .sideUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sideUnspecified
    case 1: self = .buy
    case 2: self = .sell
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .sideUnspecified: return 0
    case .buy: return 1
    case .sell: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Exchange_V1beta1_OrderSide: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Exchange_V1beta1_OrderSide] = [
    .sideUnspecified,
    .buy,
    .sell,
  ]
}

#endif  // swift(>=4.2)

/// CancellationStrategy is the list of cancellation strategies.
enum Injective_Exchange_V1beta1_CancellationStrategy: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// just cancelling in random order in most efficient way
  case unspecifiedOrder // = 0

  /// e.g. for buy orders from lowest to highest price
  case fromWorstToBest // = 1

  /// e.g. for buy orders from higest to lowest price
  case fromBestToWorst // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecifiedOrder
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedOrder
    case 1: self = .fromWorstToBest
    case 2: self = .fromBestToWorst
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecifiedOrder: return 0
    case .fromWorstToBest: return 1
    case .fromBestToWorst: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Exchange_V1beta1_CancellationStrategy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Exchange_V1beta1_CancellationStrategy] = [
    .unspecifiedOrder,
    .fromWorstToBest,
    .fromBestToWorst,
  ]
}

#endif  // swift(>=4.2)

struct Injective_Exchange_V1beta1_Subaccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trader: String = String()

  var subaccountNonce: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_QuerySubaccountOrdersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_QuerySubaccountOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var buyOrders: [Injective_Exchange_V1beta1_SubaccountOrderData] = []

  var sellOrders: [Injective_Exchange_V1beta1_SubaccountOrderData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_SubaccountOrderbookMetadataWithMarket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Injective_Exchange_V1beta1_SubaccountOrderbookMetadata {
    get {return _metadata ?? Injective_Exchange_V1beta1_SubaccountOrderbookMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var marketID: String = String()

  var isBuy: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Injective_Exchange_V1beta1_SubaccountOrderbookMetadata? = nil
}

/// QueryExchangeParamsRequest is the request type for the Query/ExchangeParams
/// RPC method.
struct Injective_Exchange_V1beta1_QueryExchangeParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryExchangeParamsRequest is the response type for the Query/ExchangeParams
/// RPC method.
struct Injective_Exchange_V1beta1_QueryExchangeParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Injective_Exchange_V1beta1_Params {
    get {return _params ?? Injective_Exchange_V1beta1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Injective_Exchange_V1beta1_Params? = nil
}

/// QuerySubaccountDepositsRequest is the request type for the
/// Query/SubaccountDeposits RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountDepositsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var subaccount: Injective_Exchange_V1beta1_Subaccount {
    get {return _subaccount ?? Injective_Exchange_V1beta1_Subaccount()}
    set {_subaccount = newValue}
  }
  /// Returns true if `subaccount` has been explicitly set.
  var hasSubaccount: Bool {return self._subaccount != nil}
  /// Clears the value of `subaccount`. Subsequent reads from it will return its default value.
  mutating func clearSubaccount() {self._subaccount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _subaccount: Injective_Exchange_V1beta1_Subaccount? = nil
}

/// QuerySubaccountDepositsResponse is the response type for the
/// Query/SubaccountDeposits RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountDepositsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deposits: Dictionary<String,Injective_Exchange_V1beta1_Deposit> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryExchangeBalancesRequest is the request type for the
/// Query/ExchangeBalances RPC method.
struct Injective_Exchange_V1beta1_QueryExchangeBalancesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySubaccountDepositsResponse is the response type for the
/// Query/SubaccountDeposits RPC method.
struct Injective_Exchange_V1beta1_QueryExchangeBalancesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var balances: [Injective_Exchange_V1beta1_Balance] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAggregateVolumeRequest is the request type for the Query/AggregateVolume
/// RPC method.
struct Injective_Exchange_V1beta1_QueryAggregateVolumeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// can either be an address or a subaccount
  var account: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAggregateVolumeResponse is the response type for the
/// Query/AggregateVolume RPC method.
struct Injective_Exchange_V1beta1_QueryAggregateVolumeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// if an address is specified, then the aggregate_volumes will aggregate the
  /// volumes across all subaccounts for the address
  var aggregateVolumes: [Injective_Exchange_V1beta1_MarketVolume] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAggregateVolumesRequest is the request type for the
/// Query/AggregateVolumes RPC method.
struct Injective_Exchange_V1beta1_QueryAggregateVolumesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accounts: [String] = []

  var marketIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAggregateVolumesResponse is the response type for the
/// Query/AggregateVolumes RPC method.
struct Injective_Exchange_V1beta1_QueryAggregateVolumesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the aggregate volume records for the accounts specified
  var aggregateAccountVolumes: [Injective_Exchange_V1beta1_AggregateAccountVolumeRecord] = []

  /// the aggregate volumes for the markets specified
  var aggregateMarketVolumes: [Injective_Exchange_V1beta1_MarketVolume] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAggregateMarketVolumeRequest is the request type for the
/// Query/AggregateMarketVolume RPC method.
struct Injective_Exchange_V1beta1_QueryAggregateMarketVolumeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAggregateMarketVolumeResponse is the response type for the
/// Query/AggregateMarketVolume RPC method.
struct Injective_Exchange_V1beta1_QueryAggregateMarketVolumeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var volume: Injective_Exchange_V1beta1_VolumeRecord {
    get {return _volume ?? Injective_Exchange_V1beta1_VolumeRecord()}
    set {_volume = newValue}
  }
  /// Returns true if `volume` has been explicitly set.
  var hasVolume: Bool {return self._volume != nil}
  /// Clears the value of `volume`. Subsequent reads from it will return its default value.
  mutating func clearVolume() {self._volume = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _volume: Injective_Exchange_V1beta1_VolumeRecord? = nil
}

/// QueryDenomDecimalRequest is the request type for the Query/DenomDecimal RPC
/// method.
struct Injective_Exchange_V1beta1_QueryDenomDecimalRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDenomDecimalResponse is the response type for the Query/DenomDecimal RPC
/// method.
struct Injective_Exchange_V1beta1_QueryDenomDecimalResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var decimal: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDenomDecimalsRequest is the request type for the Query/DenomDecimals RPC
/// method.
struct Injective_Exchange_V1beta1_QueryDenomDecimalsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// denoms can be empty to query all denom decimals
  var denoms: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDenomDecimalsRequest is the response type for the Query/DenomDecimals
/// RPC method.
struct Injective_Exchange_V1beta1_QueryDenomDecimalsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denomDecimals: [Injective_Exchange_V1beta1_DenomDecimals] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAggregateMarketVolumesRequest is the request type for the
/// Query/AggregateMarketVolumes RPC method.
struct Injective_Exchange_V1beta1_QueryAggregateMarketVolumesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAggregateMarketVolumesResponse is the response type for the
/// Query/AggregateMarketVolumes RPC method.
struct Injective_Exchange_V1beta1_QueryAggregateMarketVolumesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the aggregate volumes for the entire market
  var volumes: [Injective_Exchange_V1beta1_MarketVolume] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySubaccountDepositsRequest is the request type for the
/// Query/SubaccountDeposits RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountDepositRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySubaccountDepositsResponse is the response type for the
/// Query/SubaccountDeposits RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountDepositResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deposits: Injective_Exchange_V1beta1_Deposit {
    get {return _deposits ?? Injective_Exchange_V1beta1_Deposit()}
    set {_deposits = newValue}
  }
  /// Returns true if `deposits` has been explicitly set.
  var hasDeposits: Bool {return self._deposits != nil}
  /// Clears the value of `deposits`. Subsequent reads from it will return its default value.
  mutating func clearDeposits() {self._deposits = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deposits: Injective_Exchange_V1beta1_Deposit? = nil
}

/// QuerySpotMarketsRequest is the request type for the Query/SpotMarkets RPC
/// method.
struct Injective_Exchange_V1beta1_QuerySpotMarketsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the market, for convenience it is set to string - not enum
  var status: String = String()

  /// Filter by market IDs
  var marketIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySpotMarketsResponse is the response type for the Query/SpotMarkets RPC
/// method.
struct Injective_Exchange_V1beta1_QuerySpotMarketsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var markets: [Injective_Exchange_V1beta1_SpotMarket] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySpotMarketRequest is the request type for the Query/SpotMarket RPC
/// method.
struct Injective_Exchange_V1beta1_QuerySpotMarketRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySpotMarketResponse is the response type for the Query/SpotMarket RPC
/// method.
struct Injective_Exchange_V1beta1_QuerySpotMarketResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var market: Injective_Exchange_V1beta1_SpotMarket {
    get {return _market ?? Injective_Exchange_V1beta1_SpotMarket()}
    set {_market = newValue}
  }
  /// Returns true if `market` has been explicitly set.
  var hasMarket: Bool {return self._market != nil}
  /// Clears the value of `market`. Subsequent reads from it will return its default value.
  mutating func clearMarket() {self._market = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _market: Injective_Exchange_V1beta1_SpotMarket? = nil
}

/// QuerySpotOrderbookRequest is the request type for the Query/SpotOrderbook RPC
/// method.
struct Injective_Exchange_V1beta1_QuerySpotOrderbookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  var limit: UInt64 = 0

  var orderSide: Injective_Exchange_V1beta1_OrderSide = .sideUnspecified

  var limitCumulativeNotional: String = String()

  var limitCumulativeQuantity: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySpotOrderbookResponse is the response type for the Query/SpotOrderbook
/// RPC method.
struct Injective_Exchange_V1beta1_QuerySpotOrderbookResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var buysPriceLevel: [Injective_Exchange_V1beta1_Level] = []

  var sellsPriceLevel: [Injective_Exchange_V1beta1_Level] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_FullSpotMarket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var market: Injective_Exchange_V1beta1_SpotMarket {
    get {return _market ?? Injective_Exchange_V1beta1_SpotMarket()}
    set {_market = newValue}
  }
  /// Returns true if `market` has been explicitly set.
  var hasMarket: Bool {return self._market != nil}
  /// Clears the value of `market`. Subsequent reads from it will return its default value.
  mutating func clearMarket() {self._market = nil}

  /// mid_price_and_tob defines the mid price for this market and the best ask
  /// and bid orders
  var midPriceAndTob: Injective_Exchange_V1beta1_MidPriceAndTOB {
    get {return _midPriceAndTob ?? Injective_Exchange_V1beta1_MidPriceAndTOB()}
    set {_midPriceAndTob = newValue}
  }
  /// Returns true if `midPriceAndTob` has been explicitly set.
  var hasMidPriceAndTob: Bool {return self._midPriceAndTob != nil}
  /// Clears the value of `midPriceAndTob`. Subsequent reads from it will return its default value.
  mutating func clearMidPriceAndTob() {self._midPriceAndTob = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _market: Injective_Exchange_V1beta1_SpotMarket? = nil
  fileprivate var _midPriceAndTob: Injective_Exchange_V1beta1_MidPriceAndTOB? = nil
}

/// QueryFullSpotMarketsRequest is the request type for the Query/FullSpotMarkets
/// RPC method.
struct Injective_Exchange_V1beta1_QueryFullSpotMarketsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the market, for convenience it is set to string - not enum
  var status: String = String()

  /// Filter by market IDs
  var marketIds: [String] = []

  /// Flag to return the markets mid price and top of the book buy and sell
  /// orders.
  var withMidPriceAndTob: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryFullSpotMarketsResponse is the response type for the
/// Query/FullSpotMarkets RPC method.
struct Injective_Exchange_V1beta1_QueryFullSpotMarketsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var markets: [Injective_Exchange_V1beta1_FullSpotMarket] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySpotMarketRequest is the request type for the Query/SpotMarket RPC
/// method.
struct Injective_Exchange_V1beta1_QueryFullSpotMarketRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  /// Flag to return the markets mid price and top of the book buy and sell
  /// orders.
  var withMidPriceAndTob: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySpotMarketResponse is the response type for the Query/SpotMarket RPC
/// method.
struct Injective_Exchange_V1beta1_QueryFullSpotMarketResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var market: Injective_Exchange_V1beta1_FullSpotMarket {
    get {return _market ?? Injective_Exchange_V1beta1_FullSpotMarket()}
    set {_market = newValue}
  }
  /// Returns true if `market` has been explicitly set.
  var hasMarket: Bool {return self._market != nil}
  /// Clears the value of `market`. Subsequent reads from it will return its default value.
  mutating func clearMarket() {self._market = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _market: Injective_Exchange_V1beta1_FullSpotMarket? = nil
}

/// QuerySpotOrdersByHashesRequest is the request type for the
/// Query/SpotOrdersByHashes RPC method.
struct Injective_Exchange_V1beta1_QuerySpotOrdersByHashesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  /// SubaccountID of the trader
  var subaccountID: String = String()

  /// the order hashes
  var orderHashes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySpotOrdersByHashesResponse is the response type for the
/// Query/SpotOrdersByHashes RPC method.
struct Injective_Exchange_V1beta1_QuerySpotOrdersByHashesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orders: [Injective_Exchange_V1beta1_TrimmedSpotLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTraderSpotOrdersRequest is the request type for the
/// Query/TraderSpotOrders RPC method.
struct Injective_Exchange_V1beta1_QueryTraderSpotOrdersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  /// SubaccountID of the trader
  var subaccountID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountAddressSpotOrdersRequest is the request type for the
/// Query/AccountAddressSpotOrders RPC method.
struct Injective_Exchange_V1beta1_QueryAccountAddressSpotOrdersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  /// Account address of the trader
  var accountAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TrimmedSpotLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// price of the order
  var price: String = String()

  /// quantity of the order
  var quantity: String = String()

  /// the amount of the quantity remaining fillable
  var fillable: String = String()

  /// true if the order is a buy
  var isBuy: Bool = false

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTraderSpotOrdersResponse is the response type for the
/// Query/TraderSpotOrders RPC method.
struct Injective_Exchange_V1beta1_QueryTraderSpotOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orders: [Injective_Exchange_V1beta1_TrimmedSpotLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountAddressSpotOrdersResponse is the response type for the
/// Query/AccountAddressSpotOrders RPC method.
struct Injective_Exchange_V1beta1_QueryAccountAddressSpotOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orders: [Injective_Exchange_V1beta1_TrimmedSpotLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySpotMidPriceAndTOBRequest is the request type for the
/// Query/SpotMidPriceAndTOB RPC method.
struct Injective_Exchange_V1beta1_QuerySpotMidPriceAndTOBRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySpotMidPriceAndTOBResponse is the response type for the
/// Query/SpotMidPriceAndTOB RPC method.
struct Injective_Exchange_V1beta1_QuerySpotMidPriceAndTOBResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// mid price of the market
  var midPrice: String = String()

  /// best buy price of the market
  var bestBuyPrice: String = String()

  /// best sell price of the market
  var bestSellPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDerivativeMidPriceAndTOBRequest is the request type for the
/// Query/GetDerivativeMidPriceAndTOB RPC method.
struct Injective_Exchange_V1beta1_QueryDerivativeMidPriceAndTOBRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDerivativeMidPriceAndTOBResponse is the response type for the
/// Query/GetDerivativeMidPriceAndTOB RPC method.
struct Injective_Exchange_V1beta1_QueryDerivativeMidPriceAndTOBResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// mid price of the market
  var midPrice: String = String()

  /// best buy price of the market
  var bestBuyPrice: String = String()

  /// best sell price of the market
  var bestSellPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDerivativeOrderbookRequest is the request type for the
/// Query/DerivativeOrderbook RPC method.
struct Injective_Exchange_V1beta1_QueryDerivativeOrderbookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  var limit: UInt64 = 0

  var limitCumulativeNotional: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDerivativeOrderbookResponse is the response type for the
/// Query/DerivativeOrderbook RPC method.
struct Injective_Exchange_V1beta1_QueryDerivativeOrderbookResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var buysPriceLevel: [Injective_Exchange_V1beta1_Level] = []

  var sellsPriceLevel: [Injective_Exchange_V1beta1_Level] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTraderSpotOrdersToCancelUpToAmountRequest is the request type for the
/// Query/TraderSpotOrdersToCancelUpToAmountRequest RPC method.
struct Injective_Exchange_V1beta1_QueryTraderSpotOrdersToCancelUpToAmountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  /// SubaccountID of the trader
  var subaccountID: String = String()

  /// the base amount to cancel (free up)
  var baseAmount: String = String()

  /// the quote amount to cancel (free up)
  var quoteAmount: String = String()

  /// The cancellation strategy
  var strategy: Injective_Exchange_V1beta1_CancellationStrategy = .unspecifiedOrder

  /// The reference price for the cancellation strategy, e.g. mid price or mark
  /// price
  var referencePrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTraderDerivativeOrdersToCancelUpToAmountRequest is the request type for
/// the Query/TraderDerivativeOrdersToCancelUpToAmountRequest RPC method.
struct Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  /// SubaccountID of the trader
  var subaccountID: String = String()

  /// the quote amount to cancel (free up)
  var quoteAmount: String = String()

  /// The cancellation strategy
  var strategy: Injective_Exchange_V1beta1_CancellationStrategy = .unspecifiedOrder

  /// The reference price for the cancellation strategy, e.g. mid price or mark
  /// price
  var referencePrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTraderDerivativeOrdersRequest is the request type for the
/// Query/TraderDerivativeOrders RPC method.
struct Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  /// SubaccountID of the trader
  var subaccountID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountAddressSpotOrdersRequest is the request type for the
/// Query/AccountAddressDerivativeOrders RPC method.
struct Injective_Exchange_V1beta1_QueryAccountAddressDerivativeOrdersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  /// Account address of the trader
  var accountAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TrimmedDerivativeLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// price of the order
  var price: String = String()

  /// quantity of the order
  var quantity: String = String()

  /// margin of the order
  var margin: String = String()

  /// the amount of the quantity remaining fillable
  var fillable: String = String()

  /// true if the order is a buy
  var isBuy: Bool = false

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTraderDerivativeOrdersResponse is the response type for the
/// Query/TraderDerivativeOrders RPC method.
struct Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orders: [Injective_Exchange_V1beta1_TrimmedDerivativeLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountAddressDerivativeOrdersResponse is the response type for the
/// Query/AccountAddressDerivativeOrders RPC method.
struct Injective_Exchange_V1beta1_QueryAccountAddressDerivativeOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orders: [Injective_Exchange_V1beta1_TrimmedDerivativeLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTraderDerivativeOrdersRequest is the request type for the
/// Query/TraderDerivativeOrders RPC method.
struct Injective_Exchange_V1beta1_QueryDerivativeOrdersByHashesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  /// SubaccountID of the trader
  var subaccountID: String = String()

  /// the order hashes
  var orderHashes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDerivativeOrdersByHashesResponse is the response type for the
/// Query/DerivativeOrdersByHashes RPC method.
struct Injective_Exchange_V1beta1_QueryDerivativeOrdersByHashesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orders: [Injective_Exchange_V1beta1_TrimmedDerivativeLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDerivativeMarketsRequest is the request type for the
/// Query/DerivativeMarkets RPC method.
struct Injective_Exchange_V1beta1_QueryDerivativeMarketsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the market, for convenience it is set to string - not enum
  var status: String = String()

  /// Filter by market IDs
  var marketIds: [String] = []

  /// Flag to return the markets mid price and top of the book buy and sell
  /// orders.
  var withMidPriceAndTob: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_PriceLevel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var price: String = String()

  /// quantity
  var quantity: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_PerpetualMarketState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketInfo: Injective_Exchange_V1beta1_PerpetualMarketInfo {
    get {return _marketInfo ?? Injective_Exchange_V1beta1_PerpetualMarketInfo()}
    set {_marketInfo = newValue}
  }
  /// Returns true if `marketInfo` has been explicitly set.
  var hasMarketInfo: Bool {return self._marketInfo != nil}
  /// Clears the value of `marketInfo`. Subsequent reads from it will return its default value.
  mutating func clearMarketInfo() {self._marketInfo = nil}

  var fundingInfo: Injective_Exchange_V1beta1_PerpetualMarketFunding {
    get {return _fundingInfo ?? Injective_Exchange_V1beta1_PerpetualMarketFunding()}
    set {_fundingInfo = newValue}
  }
  /// Returns true if `fundingInfo` has been explicitly set.
  var hasFundingInfo: Bool {return self._fundingInfo != nil}
  /// Clears the value of `fundingInfo`. Subsequent reads from it will return its default value.
  mutating func clearFundingInfo() {self._fundingInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _marketInfo: Injective_Exchange_V1beta1_PerpetualMarketInfo? = nil
  fileprivate var _fundingInfo: Injective_Exchange_V1beta1_PerpetualMarketFunding? = nil
}

struct Injective_Exchange_V1beta1_FullDerivativeMarket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var market: Injective_Exchange_V1beta1_DerivativeMarket {
    get {return _storage._market ?? Injective_Exchange_V1beta1_DerivativeMarket()}
    set {_uniqueStorage()._market = newValue}
  }
  /// Returns true if `market` has been explicitly set.
  var hasMarket: Bool {return _storage._market != nil}
  /// Clears the value of `market`. Subsequent reads from it will return its default value.
  mutating func clearMarket() {_uniqueStorage()._market = nil}

  var info: OneOf_Info? {
    get {return _storage._info}
    set {_uniqueStorage()._info = newValue}
  }

  var perpetualInfo: Injective_Exchange_V1beta1_PerpetualMarketState {
    get {
      if case .perpetualInfo(let v)? = _storage._info {return v}
      return Injective_Exchange_V1beta1_PerpetualMarketState()
    }
    set {_uniqueStorage()._info = .perpetualInfo(newValue)}
  }

  var futuresInfo: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo {
    get {
      if case .futuresInfo(let v)? = _storage._info {return v}
      return Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo()
    }
    set {_uniqueStorage()._info = .futuresInfo(newValue)}
  }

  var markPrice: String {
    get {return _storage._markPrice}
    set {_uniqueStorage()._markPrice = newValue}
  }

  /// mid_price_and_tob defines the mid price for this market and the best ask
  /// and bid orders
  var midPriceAndTob: Injective_Exchange_V1beta1_MidPriceAndTOB {
    get {return _storage._midPriceAndTob ?? Injective_Exchange_V1beta1_MidPriceAndTOB()}
    set {_uniqueStorage()._midPriceAndTob = newValue}
  }
  /// Returns true if `midPriceAndTob` has been explicitly set.
  var hasMidPriceAndTob: Bool {return _storage._midPriceAndTob != nil}
  /// Clears the value of `midPriceAndTob`. Subsequent reads from it will return its default value.
  mutating func clearMidPriceAndTob() {_uniqueStorage()._midPriceAndTob = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Info: Equatable {
    case perpetualInfo(Injective_Exchange_V1beta1_PerpetualMarketState)
    case futuresInfo(Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo)

  #if !swift(>=4.1)
    static func ==(lhs: Injective_Exchange_V1beta1_FullDerivativeMarket.OneOf_Info, rhs: Injective_Exchange_V1beta1_FullDerivativeMarket.OneOf_Info) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.perpetualInfo, .perpetualInfo): return {
        guard case .perpetualInfo(let l) = lhs, case .perpetualInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.futuresInfo, .futuresInfo): return {
        guard case .futuresInfo(let l) = lhs, case .futuresInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// QueryDerivativeMarketsResponse is the response type for the
/// Query/DerivativeMarkets RPC method.
struct Injective_Exchange_V1beta1_QueryDerivativeMarketsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var markets: [Injective_Exchange_V1beta1_FullDerivativeMarket] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDerivativeMarketRequest is the request type for the
/// Query/DerivativeMarket RPC method.
struct Injective_Exchange_V1beta1_QueryDerivativeMarketRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDerivativeMarketResponse is the response type for the
/// Query/DerivativeMarket RPC method.
struct Injective_Exchange_V1beta1_QueryDerivativeMarketResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var market: Injective_Exchange_V1beta1_FullDerivativeMarket {
    get {return _market ?? Injective_Exchange_V1beta1_FullDerivativeMarket()}
    set {_market = newValue}
  }
  /// Returns true if `market` has been explicitly set.
  var hasMarket: Bool {return self._market != nil}
  /// Clears the value of `market`. Subsequent reads from it will return its default value.
  mutating func clearMarket() {self._market = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _market: Injective_Exchange_V1beta1_FullDerivativeMarket? = nil
}

/// QueryDerivativeMarketAddressRequest is the request type for the
/// Query/DerivativeMarketAddress RPC method.
struct Injective_Exchange_V1beta1_QueryDerivativeMarketAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Market ID for the market
  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDerivativeMarketAddressResponse is the response type for the
/// Query/DerivativeMarketAddress RPC method.
struct Injective_Exchange_V1beta1_QueryDerivativeMarketAddressResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address for the market
  var address: String = String()

  /// subaccountID for the market
  var subaccountID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySubaccountTradeNonceRequest is the request type for the
/// Query/SubaccountTradeNonce RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountTradeNonceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySubaccountPositionsRequest is the request type for the
/// Query/SubaccountPositions RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountPositionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySubaccountPositionInMarketRequest is the request type for the
/// Query/SubaccountPositionInMarket RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountPositionInMarketRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySubaccountEffectivePositionInMarketRequest is the request type for the
/// Query/SubaccountEffectivePositionInMarket RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountEffectivePositionInMarketRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySubaccountOrderMetadataRequest is the request type for the
/// Query/SubaccountOrderMetadata RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountOrderMetadataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySubaccountPositionsResponse is the response type for the
/// Query/SubaccountPositions RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountPositionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: [Injective_Exchange_V1beta1_DerivativePosition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySubaccountPositionInMarketResponse is the response type for the
/// Query/SubaccountPositionInMarket RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountPositionInMarketResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Injective_Exchange_V1beta1_Position {
    get {return _state ?? Injective_Exchange_V1beta1_Position()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _state: Injective_Exchange_V1beta1_Position? = nil
}

struct Injective_Exchange_V1beta1_EffectivePosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isLong: Bool = false

  var quantity: String = String()

  var entryPrice: String = String()

  var effectiveMargin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySubaccountEffectivePositionInMarketResponse is the response type for the
/// Query/SubaccountEffectivePositionInMarket RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountEffectivePositionInMarketResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Injective_Exchange_V1beta1_EffectivePosition {
    get {return _state ?? Injective_Exchange_V1beta1_EffectivePosition()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _state: Injective_Exchange_V1beta1_EffectivePosition? = nil
}

/// QueryPerpetualMarketInfoRequest is the request type for the
/// Query/PerpetualMarketInfo RPC method.
struct Injective_Exchange_V1beta1_QueryPerpetualMarketInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryPerpetualMarketInfoResponse is the response type for the
/// Query/PerpetualMarketInfo RPC method.
struct Injective_Exchange_V1beta1_QueryPerpetualMarketInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var info: Injective_Exchange_V1beta1_PerpetualMarketInfo {
    get {return _info ?? Injective_Exchange_V1beta1_PerpetualMarketInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Injective_Exchange_V1beta1_PerpetualMarketInfo? = nil
}

/// QueryExpiryFuturesMarketInfoRequest is the request type for the Query/
/// ExpiryFuturesMarketInfo RPC method.
struct Injective_Exchange_V1beta1_QueryExpiryFuturesMarketInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryExpiryFuturesMarketInfoResponse is the response type for the Query/
/// ExpiryFuturesMarketInfo RPC method.
struct Injective_Exchange_V1beta1_QueryExpiryFuturesMarketInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var info: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo {
    get {return _info ?? Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo? = nil
}

/// QueryPerpetualMarketFundingRequest is the request type for the
/// Query/PerpetualMarketFunding RPC method.
struct Injective_Exchange_V1beta1_QueryPerpetualMarketFundingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryPerpetualMarketFundingResponse is the response type for the
/// Query/PerpetualMarketFunding RPC method.
struct Injective_Exchange_V1beta1_QueryPerpetualMarketFundingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Injective_Exchange_V1beta1_PerpetualMarketFunding {
    get {return _state ?? Injective_Exchange_V1beta1_PerpetualMarketFunding()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _state: Injective_Exchange_V1beta1_PerpetualMarketFunding? = nil
}

/// QuerySubaccountOrderMetadataResponse is the response type for the
/// Query/SubaccountOrderMetadata RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountOrderMetadataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: [Injective_Exchange_V1beta1_SubaccountOrderbookMetadataWithMarket] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySubaccountTradeNonceResponse is the response type for the
/// Query/SubaccountTradeNonce RPC method.
struct Injective_Exchange_V1beta1_QuerySubaccountTradeNonceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryModuleStateRequest is the request type for the Query/ExchangeModuleState
/// RPC method.
struct Injective_Exchange_V1beta1_QueryModuleStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryModuleStateResponse is the response type for the
/// Query/ExchangeModuleState RPC method.
struct Injective_Exchange_V1beta1_QueryModuleStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Injective_Exchange_V1beta1_GenesisState {
    get {return _state ?? Injective_Exchange_V1beta1_GenesisState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _state: Injective_Exchange_V1beta1_GenesisState? = nil
}

/// QueryPositionsRequest is the request type for the Query/Positions RPC method.
struct Injective_Exchange_V1beta1_QueryPositionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryPositionsResponse is the response type for the Query/Positions RPC
/// method.
struct Injective_Exchange_V1beta1_QueryPositionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: [Injective_Exchange_V1beta1_DerivativePosition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTradeRewardPointsRequest is the request type for the
/// Query/TradeRewardPoints RPC method.
struct Injective_Exchange_V1beta1_QueryTradeRewardPointsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accounts: [String] = []

  var pendingPoolTimestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTradeRewardPointsResponse is the response type for the
/// Query/TradeRewardPoints RPC method.
struct Injective_Exchange_V1beta1_QueryTradeRewardPointsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountTradeRewardPoints: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTradeRewardCampaignRequest is the request type for the
/// Query/TradeRewardCampaign RPC method.
struct Injective_Exchange_V1beta1_QueryTradeRewardCampaignRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTradeRewardCampaignResponse is the response type for the
/// Query/TradeRewardCampaign RPC method.
struct Injective_Exchange_V1beta1_QueryTradeRewardCampaignResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tradingRewardCampaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo {
    get {return _tradingRewardCampaignInfo ?? Injective_Exchange_V1beta1_TradingRewardCampaignInfo()}
    set {_tradingRewardCampaignInfo = newValue}
  }
  /// Returns true if `tradingRewardCampaignInfo` has been explicitly set.
  var hasTradingRewardCampaignInfo: Bool {return self._tradingRewardCampaignInfo != nil}
  /// Clears the value of `tradingRewardCampaignInfo`. Subsequent reads from it will return its default value.
  mutating func clearTradingRewardCampaignInfo() {self._tradingRewardCampaignInfo = nil}

  var tradingRewardPoolCampaignSchedule: [Injective_Exchange_V1beta1_CampaignRewardPool] = []

  var totalTradeRewardPoints: String = String()

  var pendingTradingRewardPoolCampaignSchedule: [Injective_Exchange_V1beta1_CampaignRewardPool] = []

  var pendingTotalTradeRewardPoints: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tradingRewardCampaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo? = nil
}

/// QueryIsRegisteredDMMRequest is the request type for the Query/IsRegisteredDMM
/// RPC method.
struct Injective_Exchange_V1beta1_QueryIsOptedOutOfRewardsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryIsRegisteredDMMResponse is the response type for the
/// Query/IsRegisteredDMM RPC method.
struct Injective_Exchange_V1beta1_QueryIsOptedOutOfRewardsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isOptedOut: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryRegisteredDMMsRequest is the request type for the Query/RegisteredDMMs
/// RPC method.
struct Injective_Exchange_V1beta1_QueryOptedOutOfRewardsAccountsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryRegisteredDMMsResponse is the response type for the Query/RegisteredDMMs
/// RPC method.
struct Injective_Exchange_V1beta1_QueryOptedOutOfRewardsAccountsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accounts: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryFeeDiscountAccountInfoRequest is the request type for the
/// Query/FeeDiscountAccountInfo RPC method.
struct Injective_Exchange_V1beta1_QueryFeeDiscountAccountInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryFeeDiscountAccountInfoResponse is the response type for the
/// Query/FeeDiscountAccountInfo RPC method.
struct Injective_Exchange_V1beta1_QueryFeeDiscountAccountInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tierLevel: UInt64 = 0

  var accountInfo: Injective_Exchange_V1beta1_FeeDiscountTierInfo {
    get {return _accountInfo ?? Injective_Exchange_V1beta1_FeeDiscountTierInfo()}
    set {_accountInfo = newValue}
  }
  /// Returns true if `accountInfo` has been explicitly set.
  var hasAccountInfo: Bool {return self._accountInfo != nil}
  /// Clears the value of `accountInfo`. Subsequent reads from it will return its default value.
  mutating func clearAccountInfo() {self._accountInfo = nil}

  var accountTtl: Injective_Exchange_V1beta1_FeeDiscountTierTTL {
    get {return _accountTtl ?? Injective_Exchange_V1beta1_FeeDiscountTierTTL()}
    set {_accountTtl = newValue}
  }
  /// Returns true if `accountTtl` has been explicitly set.
  var hasAccountTtl: Bool {return self._accountTtl != nil}
  /// Clears the value of `accountTtl`. Subsequent reads from it will return its default value.
  mutating func clearAccountTtl() {self._accountTtl = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accountInfo: Injective_Exchange_V1beta1_FeeDiscountTierInfo? = nil
  fileprivate var _accountTtl: Injective_Exchange_V1beta1_FeeDiscountTierTTL? = nil
}

/// QueryFeeDiscountScheduleRequest is the request type for the
/// Query/FeeDiscountSchedule RPC method.
struct Injective_Exchange_V1beta1_QueryFeeDiscountScheduleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryFeeDiscountScheduleResponse is the response type for the
/// Query/FeeDiscountSchedule RPC method.
struct Injective_Exchange_V1beta1_QueryFeeDiscountScheduleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var feeDiscountSchedule: Injective_Exchange_V1beta1_FeeDiscountSchedule {
    get {return _feeDiscountSchedule ?? Injective_Exchange_V1beta1_FeeDiscountSchedule()}
    set {_feeDiscountSchedule = newValue}
  }
  /// Returns true if `feeDiscountSchedule` has been explicitly set.
  var hasFeeDiscountSchedule: Bool {return self._feeDiscountSchedule != nil}
  /// Clears the value of `feeDiscountSchedule`. Subsequent reads from it will return its default value.
  mutating func clearFeeDiscountSchedule() {self._feeDiscountSchedule = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _feeDiscountSchedule: Injective_Exchange_V1beta1_FeeDiscountSchedule? = nil
}

/// QueryBalanceMismatchesRequest is the request type for the
/// Query/QueryBalanceMismatches RPC method.
struct Injective_Exchange_V1beta1_QueryBalanceMismatchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dustFactor: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_BalanceMismatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var denom: String = String()

  var available: String = String()

  var total: String = String()

  var balanceHold: String = String()

  var expectedTotal: String = String()

  var difference: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBalanceMismatchesResponse is the response type for the
/// Query/QueryBalanceMismatches RPC method.
struct Injective_Exchange_V1beta1_QueryBalanceMismatchesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var balanceMismatches: [Injective_Exchange_V1beta1_BalanceMismatch] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBalanceWithBalanceHoldsRequest is the request type for the
/// Query/QueryBalanceWithBalanceHolds RPC method.
struct Injective_Exchange_V1beta1_QueryBalanceWithBalanceHoldsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_BalanceWithMarginHold {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var denom: String = String()

  var available: String = String()

  var total: String = String()

  var balanceHold: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBalanceWithBalanceHoldsResponse is the response type for the
/// Query/QueryBalanceWithBalanceHolds RPC method.
struct Injective_Exchange_V1beta1_QueryBalanceWithBalanceHoldsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var balanceWithBalanceHolds: [Injective_Exchange_V1beta1_BalanceWithMarginHold] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryFeeDiscountTierStatisticsRequest is the request type for the
/// Query/QueryFeeDiscountTierStatistics RPC method.
struct Injective_Exchange_V1beta1_QueryFeeDiscountTierStatisticsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TierStatistic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tier: UInt64 = 0

  var count: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryFeeDiscountTierStatisticsResponse is the response type for the
/// Query/QueryFeeDiscountTierStatistics RPC method.
struct Injective_Exchange_V1beta1_QueryFeeDiscountTierStatisticsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var statistics: [Injective_Exchange_V1beta1_TierStatistic] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MitoVaultInfosRequest is the request type for the Query/MitoVaultInfos RPC
/// method.
struct Injective_Exchange_V1beta1_MitoVaultInfosRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MitoVaultInfosResponse is the response type for the Query/MitoVaultInfos RPC
/// method.
struct Injective_Exchange_V1beta1_MitoVaultInfosResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var masterAddresses: [String] = []

  var derivativeAddresses: [String] = []

  var spotAddresses: [String] = []

  var cw20Addresses: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryMarketIDFromVaultRequest is the request type for the Query/QueryMarketIDFromVault RPC method.
struct Injective_Exchange_V1beta1_QueryMarketIDFromVaultRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vaultAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryMarketIDFromVaultResponse is the response type for the
/// Query/QueryMarketIDFromVault RPC method.
struct Injective_Exchange_V1beta1_QueryMarketIDFromVaultResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_QueryHistoricalTradeRecordsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_QueryHistoricalTradeRecordsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tradeRecords: [Injective_Exchange_V1beta1_TradeRecords] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TradeHistoryOptions are the optional params for Query/MarketVolatility RPC
/// method.
struct Injective_Exchange_V1beta1_TradeHistoryOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TradeGroupingSec of 0 means use the chain's default grouping
  var tradeGroupingSec: UInt64 = 0

  /// MaxAge restricts the trade records oldest age in seconds from the current block time to consider.
  /// A value of 0 means use all the records present on the chain.
  var maxAge: UInt64 = 0

  /// If IncludeRawHistory is true, the raw underlying data used for the
  /// computation is included in the response
  var includeRawHistory: Bool = false

  /// If IncludeMetadata is true, metadata on the computation is included in the
  /// response
  var includeMetadata: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryMarketVolatilityRequest are the request params for the
/// Query/MarketVolatility RPC method.
struct Injective_Exchange_V1beta1_QueryMarketVolatilityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var tradeHistoryOptions: Injective_Exchange_V1beta1_TradeHistoryOptions {
    get {return _tradeHistoryOptions ?? Injective_Exchange_V1beta1_TradeHistoryOptions()}
    set {_tradeHistoryOptions = newValue}
  }
  /// Returns true if `tradeHistoryOptions` has been explicitly set.
  var hasTradeHistoryOptions: Bool {return self._tradeHistoryOptions != nil}
  /// Clears the value of `tradeHistoryOptions`. Subsequent reads from it will return its default value.
  mutating func clearTradeHistoryOptions() {self._tradeHistoryOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tradeHistoryOptions: Injective_Exchange_V1beta1_TradeHistoryOptions? = nil
}

/// QueryMarketVolatilityResponse is the response type for the
/// Query/MarketVolatility RPC method.
struct Injective_Exchange_V1beta1_QueryMarketVolatilityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var volatility: String = String()

  var historyMetadata: Injective_Oracle_V1beta1_MetadataStatistics {
    get {return _historyMetadata ?? Injective_Oracle_V1beta1_MetadataStatistics()}
    set {_historyMetadata = newValue}
  }
  /// Returns true if `historyMetadata` has been explicitly set.
  var hasHistoryMetadata: Bool {return self._historyMetadata != nil}
  /// Clears the value of `historyMetadata`. Subsequent reads from it will return its default value.
  mutating func clearHistoryMetadata() {self._historyMetadata = nil}

  var rawHistory: [Injective_Exchange_V1beta1_TradeRecord] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _historyMetadata: Injective_Oracle_V1beta1_MetadataStatistics? = nil
}

/// QuerBinaryMarketsRequest is the request type for the Query/BinaryMarkets RPC
/// method.
struct Injective_Exchange_V1beta1_QueryBinaryMarketsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the market, for convenience it is set to string - not enum
  var status: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBinaryMarketsResponse is the response type for the Query/BinaryMarkets
/// RPC method.
struct Injective_Exchange_V1beta1_QueryBinaryMarketsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var markets: [Injective_Exchange_V1beta1_BinaryOptionsMarket] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryConditionalOrdersRequest is the request type for the
/// Query/ConditionalOrders RPC method.
struct Injective_Exchange_V1beta1_QueryTraderDerivativeConditionalOrdersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TrimmedDerivativeConditionalOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// price of the order
  var price: String = String()

  /// quantity of the order
  var quantity: String = String()

  /// margin of the order
  var margin: String = String()

  /// price to trigger the order
  var triggerPrice: String = String()

  /// true if the order is a buy
  var isBuy: Bool = false

  var isLimit: Bool = false

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTraderDerivativeOrdersResponse is the response type for the
/// Query/TraderDerivativeOrders RPC method.
struct Injective_Exchange_V1beta1_QueryTraderDerivativeConditionalOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orders: [Injective_Exchange_V1beta1_TrimmedDerivativeConditionalOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_QueryMarketAtomicExecutionFeeMultiplierRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_QueryMarketAtomicExecutionFeeMultiplierResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var multiplier: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Injective_Exchange_V1beta1_OrderSide: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_CancellationStrategy: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_Subaccount: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountOrdersRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountOrdersResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SubaccountOrderbookMetadataWithMarket: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryExchangeParamsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryExchangeParamsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountDepositsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountDepositsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryExchangeBalancesRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryExchangeBalancesResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryAggregateVolumeRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryAggregateVolumeResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryAggregateVolumesRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryAggregateVolumesResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryAggregateMarketVolumeRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryAggregateMarketVolumeResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDenomDecimalRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDenomDecimalResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDenomDecimalsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDenomDecimalsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryAggregateMarketVolumesRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryAggregateMarketVolumesResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountDepositRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountDepositResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySpotMarketsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySpotMarketsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySpotMarketRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySpotMarketResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySpotOrderbookRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySpotOrderbookResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_FullSpotMarket: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryFullSpotMarketsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryFullSpotMarketsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryFullSpotMarketRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryFullSpotMarketResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySpotOrdersByHashesRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySpotOrdersByHashesResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryTraderSpotOrdersRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryAccountAddressSpotOrdersRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TrimmedSpotLimitOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryTraderSpotOrdersResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryAccountAddressSpotOrdersResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySpotMidPriceAndTOBRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySpotMidPriceAndTOBResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDerivativeMidPriceAndTOBRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDerivativeMidPriceAndTOBResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDerivativeOrderbookRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDerivativeOrderbookResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryTraderSpotOrdersToCancelUpToAmountRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersToCancelUpToAmountRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryAccountAddressDerivativeOrdersRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TrimmedDerivativeLimitOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryAccountAddressDerivativeOrdersResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDerivativeOrdersByHashesRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDerivativeOrdersByHashesResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDerivativeMarketsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_PriceLevel: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_PerpetualMarketState: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_FullDerivativeMarket: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_FullDerivativeMarket.OneOf_Info: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDerivativeMarketsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDerivativeMarketRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDerivativeMarketResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDerivativeMarketAddressRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryDerivativeMarketAddressResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountTradeNonceRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountPositionsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountPositionInMarketRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountEffectivePositionInMarketRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountOrderMetadataRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountPositionsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountPositionInMarketResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_EffectivePosition: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountEffectivePositionInMarketResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryPerpetualMarketInfoRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryPerpetualMarketInfoResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryExpiryFuturesMarketInfoRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryExpiryFuturesMarketInfoResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryPerpetualMarketFundingRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryPerpetualMarketFundingResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountOrderMetadataResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QuerySubaccountTradeNonceResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryModuleStateRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryModuleStateResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryPositionsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryPositionsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryTradeRewardPointsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryTradeRewardPointsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryTradeRewardCampaignRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryTradeRewardCampaignResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryIsOptedOutOfRewardsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryIsOptedOutOfRewardsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryOptedOutOfRewardsAccountsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryOptedOutOfRewardsAccountsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryFeeDiscountAccountInfoRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryFeeDiscountAccountInfoResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryFeeDiscountScheduleRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryFeeDiscountScheduleResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryBalanceMismatchesRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_BalanceMismatch: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryBalanceMismatchesResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryBalanceWithBalanceHoldsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_BalanceWithMarginHold: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryBalanceWithBalanceHoldsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryFeeDiscountTierStatisticsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TierStatistic: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryFeeDiscountTierStatisticsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MitoVaultInfosRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MitoVaultInfosResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryMarketIDFromVaultRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryMarketIDFromVaultResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryHistoricalTradeRecordsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryHistoricalTradeRecordsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TradeHistoryOptions: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryMarketVolatilityRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryMarketVolatilityResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryBinaryMarketsRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryBinaryMarketsResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryTraderDerivativeConditionalOrdersRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TrimmedDerivativeConditionalOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryTraderDerivativeConditionalOrdersResponse: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryMarketAtomicExecutionFeeMultiplierRequest: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_QueryMarketAtomicExecutionFeeMultiplierResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "injective.exchange.v1beta1"

extension Injective_Exchange_V1beta1_OrderSide: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Side_Unspecified"),
    1: .same(proto: "Buy"),
    2: .same(proto: "Sell"),
  ]
}

extension Injective_Exchange_V1beta1_CancellationStrategy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnspecifiedOrder"),
    1: .same(proto: "FromWorstToBest"),
    2: .same(proto: "FromBestToWorst"),
  ]
}

extension Injective_Exchange_V1beta1_Subaccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Subaccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trader"),
    2: .standard(proto: "subaccount_nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trader) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.subaccountNonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trader.isEmpty {
      try visitor.visitSingularStringField(value: self.trader, fieldNumber: 1)
    }
    if self.subaccountNonce != 0 {
      try visitor.visitSingularUInt32Field(value: self.subaccountNonce, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_Subaccount, rhs: Injective_Exchange_V1beta1_Subaccount) -> Bool {
    if lhs.trader != rhs.trader {return false}
    if lhs.subaccountNonce != rhs.subaccountNonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountOrdersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountOrdersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountOrdersRequest, rhs: Injective_Exchange_V1beta1_QuerySubaccountOrdersRequest) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "buy_orders"),
    2: .standard(proto: "sell_orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.buyOrders) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sellOrders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buyOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buyOrders, fieldNumber: 1)
    }
    if !self.sellOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sellOrders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountOrdersResponse, rhs: Injective_Exchange_V1beta1_QuerySubaccountOrdersResponse) -> Bool {
    if lhs.buyOrders != rhs.buyOrders {return false}
    if lhs.sellOrders != rhs.sellOrders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountOrderbookMetadataWithMarket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountOrderbookMetadataWithMarket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .standard(proto: "market_id"),
    3: .same(proto: "isBuy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isBuy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    if self.isBuy != false {
      try visitor.visitSingularBoolField(value: self.isBuy, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountOrderbookMetadataWithMarket, rhs: Injective_Exchange_V1beta1_SubaccountOrderbookMetadataWithMarket) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.isBuy != rhs.isBuy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryExchangeParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryExchangeParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryExchangeParamsRequest, rhs: Injective_Exchange_V1beta1_QueryExchangeParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryExchangeParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryExchangeParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryExchangeParamsResponse, rhs: Injective_Exchange_V1beta1_QueryExchangeParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountDepositsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountDepositsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .same(proto: "subaccount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._subaccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    try { if let v = self._subaccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountDepositsRequest, rhs: Injective_Exchange_V1beta1_QuerySubaccountDepositsRequest) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs._subaccount != rhs._subaccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountDepositsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountDepositsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deposits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Injective_Exchange_V1beta1_Deposit>.self, value: &self.deposits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deposits.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Injective_Exchange_V1beta1_Deposit>.self, value: self.deposits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountDepositsResponse, rhs: Injective_Exchange_V1beta1_QuerySubaccountDepositsResponse) -> Bool {
    if lhs.deposits != rhs.deposits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryExchangeBalancesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryExchangeBalancesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryExchangeBalancesRequest, rhs: Injective_Exchange_V1beta1_QueryExchangeBalancesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryExchangeBalancesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryExchangeBalancesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "balances"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.balances) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.balances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.balances, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryExchangeBalancesResponse, rhs: Injective_Exchange_V1beta1_QueryExchangeBalancesResponse) -> Bool {
    if lhs.balances != rhs.balances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryAggregateVolumeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAggregateVolumeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryAggregateVolumeRequest, rhs: Injective_Exchange_V1beta1_QueryAggregateVolumeRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryAggregateVolumeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAggregateVolumeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aggregate_volumes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.aggregateVolumes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aggregateVolumes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregateVolumes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryAggregateVolumeResponse, rhs: Injective_Exchange_V1beta1_QueryAggregateVolumeResponse) -> Bool {
    if lhs.aggregateVolumes != rhs.aggregateVolumes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryAggregateVolumesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAggregateVolumesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
    2: .standard(proto: "market_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.accounts) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.marketIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accounts, fieldNumber: 1)
    }
    if !self.marketIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.marketIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryAggregateVolumesRequest, rhs: Injective_Exchange_V1beta1_QueryAggregateVolumesRequest) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.marketIds != rhs.marketIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryAggregateVolumesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAggregateVolumesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aggregate_account_volumes"),
    2: .standard(proto: "aggregate_market_volumes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.aggregateAccountVolumes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.aggregateMarketVolumes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aggregateAccountVolumes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregateAccountVolumes, fieldNumber: 1)
    }
    if !self.aggregateMarketVolumes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregateMarketVolumes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryAggregateVolumesResponse, rhs: Injective_Exchange_V1beta1_QueryAggregateVolumesResponse) -> Bool {
    if lhs.aggregateAccountVolumes != rhs.aggregateAccountVolumes {return false}
    if lhs.aggregateMarketVolumes != rhs.aggregateMarketVolumes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryAggregateMarketVolumeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAggregateMarketVolumeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryAggregateMarketVolumeRequest, rhs: Injective_Exchange_V1beta1_QueryAggregateMarketVolumeRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryAggregateMarketVolumeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAggregateMarketVolumeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._volume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._volume {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryAggregateMarketVolumeResponse, rhs: Injective_Exchange_V1beta1_QueryAggregateMarketVolumeResponse) -> Bool {
    if lhs._volume != rhs._volume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDenomDecimalRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDenomDecimalRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDenomDecimalRequest, rhs: Injective_Exchange_V1beta1_QueryDenomDecimalRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDenomDecimalResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDenomDecimalResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "decimal"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.decimal) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.decimal != 0 {
      try visitor.visitSingularUInt64Field(value: self.decimal, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDenomDecimalResponse, rhs: Injective_Exchange_V1beta1_QueryDenomDecimalResponse) -> Bool {
    if lhs.decimal != rhs.decimal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDenomDecimalsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDenomDecimalsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denoms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.denoms) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denoms.isEmpty {
      try visitor.visitRepeatedStringField(value: self.denoms, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDenomDecimalsRequest, rhs: Injective_Exchange_V1beta1_QueryDenomDecimalsRequest) -> Bool {
    if lhs.denoms != rhs.denoms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDenomDecimalsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDenomDecimalsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "denom_decimals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.denomDecimals) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denomDecimals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.denomDecimals, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDenomDecimalsResponse, rhs: Injective_Exchange_V1beta1_QueryDenomDecimalsResponse) -> Bool {
    if lhs.denomDecimals != rhs.denomDecimals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryAggregateMarketVolumesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAggregateMarketVolumesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.marketIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.marketIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryAggregateMarketVolumesRequest, rhs: Injective_Exchange_V1beta1_QueryAggregateMarketVolumesRequest) -> Bool {
    if lhs.marketIds != rhs.marketIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryAggregateMarketVolumesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAggregateMarketVolumesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volumes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.volumes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.volumes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.volumes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryAggregateMarketVolumesResponse, rhs: Injective_Exchange_V1beta1_QueryAggregateMarketVolumesResponse) -> Bool {
    if lhs.volumes != rhs.volumes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountDepositRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountDepositRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountDepositRequest, rhs: Injective_Exchange_V1beta1_QuerySubaccountDepositRequest) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountDepositResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountDepositResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deposits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deposits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deposits {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountDepositResponse, rhs: Injective_Exchange_V1beta1_QuerySubaccountDepositResponse) -> Bool {
    if lhs._deposits != rhs._deposits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySpotMarketsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySpotMarketsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "market_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.marketIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 1)
    }
    if !self.marketIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.marketIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySpotMarketsRequest, rhs: Injective_Exchange_V1beta1_QuerySpotMarketsRequest) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.marketIds != rhs.marketIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySpotMarketsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySpotMarketsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "markets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.markets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.markets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.markets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySpotMarketsResponse, rhs: Injective_Exchange_V1beta1_QuerySpotMarketsResponse) -> Bool {
    if lhs.markets != rhs.markets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySpotMarketRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySpotMarketRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySpotMarketRequest, rhs: Injective_Exchange_V1beta1_QuerySpotMarketRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySpotMarketResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySpotMarketResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "market"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._market) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._market {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySpotMarketResponse, rhs: Injective_Exchange_V1beta1_QuerySpotMarketResponse) -> Bool {
    if lhs._market != rhs._market {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySpotOrderbookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySpotOrderbookRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "limit"),
    3: .standard(proto: "order_side"),
    4: .standard(proto: "limit_cumulative_notional"),
    5: .standard(proto: "limit_cumulative_quantity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.limit) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.orderSide) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.limitCumulativeNotional) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.limitCumulativeQuantity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt64Field(value: self.limit, fieldNumber: 2)
    }
    if self.orderSide != .sideUnspecified {
      try visitor.visitSingularEnumField(value: self.orderSide, fieldNumber: 3)
    }
    if !self.limitCumulativeNotional.isEmpty {
      try visitor.visitSingularStringField(value: self.limitCumulativeNotional, fieldNumber: 4)
    }
    if !self.limitCumulativeQuantity.isEmpty {
      try visitor.visitSingularStringField(value: self.limitCumulativeQuantity, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySpotOrderbookRequest, rhs: Injective_Exchange_V1beta1_QuerySpotOrderbookRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.orderSide != rhs.orderSide {return false}
    if lhs.limitCumulativeNotional != rhs.limitCumulativeNotional {return false}
    if lhs.limitCumulativeQuantity != rhs.limitCumulativeQuantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySpotOrderbookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySpotOrderbookResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "buys_price_level"),
    2: .standard(proto: "sells_price_level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.buysPriceLevel) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sellsPriceLevel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buysPriceLevel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buysPriceLevel, fieldNumber: 1)
    }
    if !self.sellsPriceLevel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sellsPriceLevel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySpotOrderbookResponse, rhs: Injective_Exchange_V1beta1_QuerySpotOrderbookResponse) -> Bool {
    if lhs.buysPriceLevel != rhs.buysPriceLevel {return false}
    if lhs.sellsPriceLevel != rhs.sellsPriceLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FullSpotMarket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FullSpotMarket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "market"),
    2: .standard(proto: "mid_price_and_tob"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._market) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._midPriceAndTob) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._market {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._midPriceAndTob {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FullSpotMarket, rhs: Injective_Exchange_V1beta1_FullSpotMarket) -> Bool {
    if lhs._market != rhs._market {return false}
    if lhs._midPriceAndTob != rhs._midPriceAndTob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryFullSpotMarketsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFullSpotMarketsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "market_ids"),
    3: .standard(proto: "with_mid_price_and_tob"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.marketIds) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.withMidPriceAndTob) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 1)
    }
    if !self.marketIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.marketIds, fieldNumber: 2)
    }
    if self.withMidPriceAndTob != false {
      try visitor.visitSingularBoolField(value: self.withMidPriceAndTob, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryFullSpotMarketsRequest, rhs: Injective_Exchange_V1beta1_QueryFullSpotMarketsRequest) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.marketIds != rhs.marketIds {return false}
    if lhs.withMidPriceAndTob != rhs.withMidPriceAndTob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryFullSpotMarketsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFullSpotMarketsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "markets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.markets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.markets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.markets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryFullSpotMarketsResponse, rhs: Injective_Exchange_V1beta1_QueryFullSpotMarketsResponse) -> Bool {
    if lhs.markets != rhs.markets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryFullSpotMarketRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFullSpotMarketRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "with_mid_price_and_tob"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.withMidPriceAndTob) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.withMidPriceAndTob != false {
      try visitor.visitSingularBoolField(value: self.withMidPriceAndTob, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryFullSpotMarketRequest, rhs: Injective_Exchange_V1beta1_QueryFullSpotMarketRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.withMidPriceAndTob != rhs.withMidPriceAndTob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryFullSpotMarketResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFullSpotMarketResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "market"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._market) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._market {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryFullSpotMarketResponse, rhs: Injective_Exchange_V1beta1_QueryFullSpotMarketResponse) -> Bool {
    if lhs._market != rhs._market {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySpotOrdersByHashesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySpotOrdersByHashesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "subaccount_id"),
    3: .standard(proto: "order_hashes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.orderHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    if !self.orderHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.orderHashes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySpotOrdersByHashesRequest, rhs: Injective_Exchange_V1beta1_QuerySpotOrdersByHashesRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.orderHashes != rhs.orderHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySpotOrdersByHashesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySpotOrdersByHashesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySpotOrdersByHashesResponse, rhs: Injective_Exchange_V1beta1_QuerySpotOrdersByHashesResponse) -> Bool {
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryTraderSpotOrdersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTraderSpotOrdersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "subaccount_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryTraderSpotOrdersRequest, rhs: Injective_Exchange_V1beta1_QueryTraderSpotOrdersRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryAccountAddressSpotOrdersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountAddressSpotOrdersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "account_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accountAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.accountAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.accountAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryAccountAddressSpotOrdersRequest, rhs: Injective_Exchange_V1beta1_QueryAccountAddressSpotOrdersRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.accountAddress != rhs.accountAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TrimmedSpotLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrimmedSpotLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "quantity"),
    3: .same(proto: "fillable"),
    4: .same(proto: "isBuy"),
    5: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fillable) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isBuy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 1)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 2)
    }
    if !self.fillable.isEmpty {
      try visitor.visitSingularStringField(value: self.fillable, fieldNumber: 3)
    }
    if self.isBuy != false {
      try visitor.visitSingularBoolField(value: self.isBuy, fieldNumber: 4)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TrimmedSpotLimitOrder, rhs: Injective_Exchange_V1beta1_TrimmedSpotLimitOrder) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.fillable != rhs.fillable {return false}
    if lhs.isBuy != rhs.isBuy {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryTraderSpotOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTraderSpotOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryTraderSpotOrdersResponse, rhs: Injective_Exchange_V1beta1_QueryTraderSpotOrdersResponse) -> Bool {
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryAccountAddressSpotOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountAddressSpotOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryAccountAddressSpotOrdersResponse, rhs: Injective_Exchange_V1beta1_QueryAccountAddressSpotOrdersResponse) -> Bool {
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySpotMidPriceAndTOBRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySpotMidPriceAndTOBRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySpotMidPriceAndTOBRequest, rhs: Injective_Exchange_V1beta1_QuerySpotMidPriceAndTOBRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySpotMidPriceAndTOBResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySpotMidPriceAndTOBResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mid_price"),
    2: .standard(proto: "best_buy_price"),
    3: .standard(proto: "best_sell_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.midPrice) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bestBuyPrice) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bestSellPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.midPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.midPrice, fieldNumber: 1)
    }
    if !self.bestBuyPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.bestBuyPrice, fieldNumber: 2)
    }
    if !self.bestSellPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.bestSellPrice, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySpotMidPriceAndTOBResponse, rhs: Injective_Exchange_V1beta1_QuerySpotMidPriceAndTOBResponse) -> Bool {
    if lhs.midPrice != rhs.midPrice {return false}
    if lhs.bestBuyPrice != rhs.bestBuyPrice {return false}
    if lhs.bestSellPrice != rhs.bestSellPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDerivativeMidPriceAndTOBRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDerivativeMidPriceAndTOBRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDerivativeMidPriceAndTOBRequest, rhs: Injective_Exchange_V1beta1_QueryDerivativeMidPriceAndTOBRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDerivativeMidPriceAndTOBResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDerivativeMidPriceAndTOBResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mid_price"),
    2: .standard(proto: "best_buy_price"),
    3: .standard(proto: "best_sell_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.midPrice) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bestBuyPrice) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bestSellPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.midPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.midPrice, fieldNumber: 1)
    }
    if !self.bestBuyPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.bestBuyPrice, fieldNumber: 2)
    }
    if !self.bestSellPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.bestSellPrice, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDerivativeMidPriceAndTOBResponse, rhs: Injective_Exchange_V1beta1_QueryDerivativeMidPriceAndTOBResponse) -> Bool {
    if lhs.midPrice != rhs.midPrice {return false}
    if lhs.bestBuyPrice != rhs.bestBuyPrice {return false}
    if lhs.bestSellPrice != rhs.bestSellPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDerivativeOrderbookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDerivativeOrderbookRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "limit"),
    3: .standard(proto: "limit_cumulative_notional"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.limit) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.limitCumulativeNotional) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt64Field(value: self.limit, fieldNumber: 2)
    }
    if !self.limitCumulativeNotional.isEmpty {
      try visitor.visitSingularStringField(value: self.limitCumulativeNotional, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDerivativeOrderbookRequest, rhs: Injective_Exchange_V1beta1_QueryDerivativeOrderbookRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.limitCumulativeNotional != rhs.limitCumulativeNotional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDerivativeOrderbookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDerivativeOrderbookResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "buys_price_level"),
    2: .standard(proto: "sells_price_level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.buysPriceLevel) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sellsPriceLevel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buysPriceLevel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buysPriceLevel, fieldNumber: 1)
    }
    if !self.sellsPriceLevel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sellsPriceLevel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDerivativeOrderbookResponse, rhs: Injective_Exchange_V1beta1_QueryDerivativeOrderbookResponse) -> Bool {
    if lhs.buysPriceLevel != rhs.buysPriceLevel {return false}
    if lhs.sellsPriceLevel != rhs.sellsPriceLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryTraderSpotOrdersToCancelUpToAmountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTraderSpotOrdersToCancelUpToAmountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "subaccount_id"),
    3: .standard(proto: "base_amount"),
    4: .standard(proto: "quote_amount"),
    5: .same(proto: "strategy"),
    6: .standard(proto: "reference_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.baseAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quoteAmount) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.strategy) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.referencePrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    if !self.baseAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.baseAmount, fieldNumber: 3)
    }
    if !self.quoteAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteAmount, fieldNumber: 4)
    }
    if self.strategy != .unspecifiedOrder {
      try visitor.visitSingularEnumField(value: self.strategy, fieldNumber: 5)
    }
    if !self.referencePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.referencePrice, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryTraderSpotOrdersToCancelUpToAmountRequest, rhs: Injective_Exchange_V1beta1_QueryTraderSpotOrdersToCancelUpToAmountRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.baseAmount != rhs.baseAmount {return false}
    if lhs.quoteAmount != rhs.quoteAmount {return false}
    if lhs.strategy != rhs.strategy {return false}
    if lhs.referencePrice != rhs.referencePrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersToCancelUpToAmountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTraderDerivativeOrdersToCancelUpToAmountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "subaccount_id"),
    3: .standard(proto: "quote_amount"),
    4: .same(proto: "strategy"),
    5: .standard(proto: "reference_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quoteAmount) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.strategy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.referencePrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    if !self.quoteAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteAmount, fieldNumber: 3)
    }
    if self.strategy != .unspecifiedOrder {
      try visitor.visitSingularEnumField(value: self.strategy, fieldNumber: 4)
    }
    if !self.referencePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.referencePrice, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersToCancelUpToAmountRequest, rhs: Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersToCancelUpToAmountRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.quoteAmount != rhs.quoteAmount {return false}
    if lhs.strategy != rhs.strategy {return false}
    if lhs.referencePrice != rhs.referencePrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTraderDerivativeOrdersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "subaccount_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersRequest, rhs: Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryAccountAddressDerivativeOrdersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountAddressDerivativeOrdersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "account_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accountAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.accountAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.accountAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryAccountAddressDerivativeOrdersRequest, rhs: Injective_Exchange_V1beta1_QueryAccountAddressDerivativeOrdersRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.accountAddress != rhs.accountAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TrimmedDerivativeLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrimmedDerivativeLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "quantity"),
    3: .same(proto: "margin"),
    4: .same(proto: "fillable"),
    5: .same(proto: "isBuy"),
    6: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.margin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fillable) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isBuy) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 1)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 2)
    }
    if !self.margin.isEmpty {
      try visitor.visitSingularStringField(value: self.margin, fieldNumber: 3)
    }
    if !self.fillable.isEmpty {
      try visitor.visitSingularStringField(value: self.fillable, fieldNumber: 4)
    }
    if self.isBuy != false {
      try visitor.visitSingularBoolField(value: self.isBuy, fieldNumber: 5)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TrimmedDerivativeLimitOrder, rhs: Injective_Exchange_V1beta1_TrimmedDerivativeLimitOrder) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.margin != rhs.margin {return false}
    if lhs.fillable != rhs.fillable {return false}
    if lhs.isBuy != rhs.isBuy {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTraderDerivativeOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersResponse, rhs: Injective_Exchange_V1beta1_QueryTraderDerivativeOrdersResponse) -> Bool {
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryAccountAddressDerivativeOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountAddressDerivativeOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryAccountAddressDerivativeOrdersResponse, rhs: Injective_Exchange_V1beta1_QueryAccountAddressDerivativeOrdersResponse) -> Bool {
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDerivativeOrdersByHashesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDerivativeOrdersByHashesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "subaccount_id"),
    3: .standard(proto: "order_hashes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.orderHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    if !self.orderHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.orderHashes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDerivativeOrdersByHashesRequest, rhs: Injective_Exchange_V1beta1_QueryDerivativeOrdersByHashesRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.orderHashes != rhs.orderHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDerivativeOrdersByHashesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDerivativeOrdersByHashesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDerivativeOrdersByHashesResponse, rhs: Injective_Exchange_V1beta1_QueryDerivativeOrdersByHashesResponse) -> Bool {
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDerivativeMarketsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDerivativeMarketsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "market_ids"),
    3: .standard(proto: "with_mid_price_and_tob"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.marketIds) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.withMidPriceAndTob) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 1)
    }
    if !self.marketIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.marketIds, fieldNumber: 2)
    }
    if self.withMidPriceAndTob != false {
      try visitor.visitSingularBoolField(value: self.withMidPriceAndTob, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDerivativeMarketsRequest, rhs: Injective_Exchange_V1beta1_QueryDerivativeMarketsRequest) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.marketIds != rhs.marketIds {return false}
    if lhs.withMidPriceAndTob != rhs.withMidPriceAndTob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PriceLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceLevel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "quantity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 1)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PriceLevel, rhs: Injective_Exchange_V1beta1_PriceLevel) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PerpetualMarketState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PerpetualMarketState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_info"),
    2: .standard(proto: "funding_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._marketInfo) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fundingInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._marketInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fundingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PerpetualMarketState, rhs: Injective_Exchange_V1beta1_PerpetualMarketState) -> Bool {
    if lhs._marketInfo != rhs._marketInfo {return false}
    if lhs._fundingInfo != rhs._fundingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FullDerivativeMarket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FullDerivativeMarket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "market"),
    2: .standard(proto: "perpetual_info"),
    3: .standard(proto: "futures_info"),
    4: .standard(proto: "mark_price"),
    5: .standard(proto: "mid_price_and_tob"),
  ]

  fileprivate class _StorageClass {
    var _market: Injective_Exchange_V1beta1_DerivativeMarket? = nil
    var _info: Injective_Exchange_V1beta1_FullDerivativeMarket.OneOf_Info?
    var _markPrice: String = String()
    var _midPriceAndTob: Injective_Exchange_V1beta1_MidPriceAndTOB? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _market = source._market
      _info = source._info
      _markPrice = source._markPrice
      _midPriceAndTob = source._midPriceAndTob
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._market) }()
        case 2: try {
          var v: Injective_Exchange_V1beta1_PerpetualMarketState?
          var hadOneofValue = false
          if let current = _storage._info {
            hadOneofValue = true
            if case .perpetualInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._info = .perpetualInfo(v)
          }
        }()
        case 3: try {
          var v: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo?
          var hadOneofValue = false
          if let current = _storage._info {
            hadOneofValue = true
            if case .futuresInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._info = .futuresInfo(v)
          }
        }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._markPrice) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._midPriceAndTob) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._market {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      switch _storage._info {
      case .perpetualInfo?: try {
        guard case .perpetualInfo(let v)? = _storage._info else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .futuresInfo?: try {
        guard case .futuresInfo(let v)? = _storage._info else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case nil: break
      }
      if !_storage._markPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._markPrice, fieldNumber: 4)
      }
      try { if let v = _storage._midPriceAndTob {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FullDerivativeMarket, rhs: Injective_Exchange_V1beta1_FullDerivativeMarket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._market != rhs_storage._market {return false}
        if _storage._info != rhs_storage._info {return false}
        if _storage._markPrice != rhs_storage._markPrice {return false}
        if _storage._midPriceAndTob != rhs_storage._midPriceAndTob {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDerivativeMarketsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDerivativeMarketsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "markets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.markets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.markets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.markets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDerivativeMarketsResponse, rhs: Injective_Exchange_V1beta1_QueryDerivativeMarketsResponse) -> Bool {
    if lhs.markets != rhs.markets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDerivativeMarketRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDerivativeMarketRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDerivativeMarketRequest, rhs: Injective_Exchange_V1beta1_QueryDerivativeMarketRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDerivativeMarketResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDerivativeMarketResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "market"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._market) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._market {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDerivativeMarketResponse, rhs: Injective_Exchange_V1beta1_QueryDerivativeMarketResponse) -> Bool {
    if lhs._market != rhs._market {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDerivativeMarketAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDerivativeMarketAddressRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDerivativeMarketAddressRequest, rhs: Injective_Exchange_V1beta1_QueryDerivativeMarketAddressRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryDerivativeMarketAddressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDerivativeMarketAddressResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "subaccount_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryDerivativeMarketAddressResponse, rhs: Injective_Exchange_V1beta1_QueryDerivativeMarketAddressResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountTradeNonceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountTradeNonceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountTradeNonceRequest, rhs: Injective_Exchange_V1beta1_QuerySubaccountTradeNonceRequest) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountPositionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountPositionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountPositionsRequest, rhs: Injective_Exchange_V1beta1_QuerySubaccountPositionsRequest) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountPositionInMarketRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountPositionInMarketRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountPositionInMarketRequest, rhs: Injective_Exchange_V1beta1_QuerySubaccountPositionInMarketRequest) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountEffectivePositionInMarketRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountEffectivePositionInMarketRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountEffectivePositionInMarketRequest, rhs: Injective_Exchange_V1beta1_QuerySubaccountEffectivePositionInMarketRequest) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountOrderMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountOrderMetadataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountOrderMetadataRequest, rhs: Injective_Exchange_V1beta1_QuerySubaccountOrderMetadataRequest) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountPositionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountPositionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.state.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountPositionsResponse, rhs: Injective_Exchange_V1beta1_QuerySubaccountPositionsResponse) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountPositionInMarketResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountPositionInMarketResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountPositionInMarketResponse, rhs: Injective_Exchange_V1beta1_QuerySubaccountPositionInMarketResponse) -> Bool {
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EffectivePosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EffectivePosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_long"),
    2: .same(proto: "quantity"),
    3: .standard(proto: "entry_price"),
    4: .standard(proto: "effective_margin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isLong) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.entryPrice) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.effectiveMargin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isLong != false {
      try visitor.visitSingularBoolField(value: self.isLong, fieldNumber: 1)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 2)
    }
    if !self.entryPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.entryPrice, fieldNumber: 3)
    }
    if !self.effectiveMargin.isEmpty {
      try visitor.visitSingularStringField(value: self.effectiveMargin, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EffectivePosition, rhs: Injective_Exchange_V1beta1_EffectivePosition) -> Bool {
    if lhs.isLong != rhs.isLong {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.entryPrice != rhs.entryPrice {return false}
    if lhs.effectiveMargin != rhs.effectiveMargin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountEffectivePositionInMarketResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountEffectivePositionInMarketResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountEffectivePositionInMarketResponse, rhs: Injective_Exchange_V1beta1_QuerySubaccountEffectivePositionInMarketResponse) -> Bool {
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryPerpetualMarketInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPerpetualMarketInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryPerpetualMarketInfoRequest, rhs: Injective_Exchange_V1beta1_QueryPerpetualMarketInfoRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryPerpetualMarketInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPerpetualMarketInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryPerpetualMarketInfoResponse, rhs: Injective_Exchange_V1beta1_QueryPerpetualMarketInfoResponse) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryExpiryFuturesMarketInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryExpiryFuturesMarketInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryExpiryFuturesMarketInfoRequest, rhs: Injective_Exchange_V1beta1_QueryExpiryFuturesMarketInfoRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryExpiryFuturesMarketInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryExpiryFuturesMarketInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryExpiryFuturesMarketInfoResponse, rhs: Injective_Exchange_V1beta1_QueryExpiryFuturesMarketInfoResponse) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryPerpetualMarketFundingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPerpetualMarketFundingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryPerpetualMarketFundingRequest, rhs: Injective_Exchange_V1beta1_QueryPerpetualMarketFundingRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryPerpetualMarketFundingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPerpetualMarketFundingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryPerpetualMarketFundingResponse, rhs: Injective_Exchange_V1beta1_QueryPerpetualMarketFundingResponse) -> Bool {
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountOrderMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountOrderMetadataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountOrderMetadataResponse, rhs: Injective_Exchange_V1beta1_QuerySubaccountOrderMetadataResponse) -> Bool {
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QuerySubaccountTradeNonceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubaccountTradeNonceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonce != 0 {
      try visitor.visitSingularUInt32Field(value: self.nonce, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QuerySubaccountTradeNonceResponse, rhs: Injective_Exchange_V1beta1_QuerySubaccountTradeNonceResponse) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryModuleStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryModuleStateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryModuleStateRequest, rhs: Injective_Exchange_V1beta1_QueryModuleStateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryModuleStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryModuleStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryModuleStateResponse, rhs: Injective_Exchange_V1beta1_QueryModuleStateResponse) -> Bool {
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryPositionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPositionsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryPositionsRequest, rhs: Injective_Exchange_V1beta1_QueryPositionsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryPositionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPositionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.state.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryPositionsResponse, rhs: Injective_Exchange_V1beta1_QueryPositionsResponse) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryTradeRewardPointsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTradeRewardPointsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
    2: .standard(proto: "pending_pool_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.accounts) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.pendingPoolTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accounts, fieldNumber: 1)
    }
    if self.pendingPoolTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.pendingPoolTimestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryTradeRewardPointsRequest, rhs: Injective_Exchange_V1beta1_QueryTradeRewardPointsRequest) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.pendingPoolTimestamp != rhs.pendingPoolTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryTradeRewardPointsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTradeRewardPointsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_trade_reward_points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.accountTradeRewardPoints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountTradeRewardPoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accountTradeRewardPoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryTradeRewardPointsResponse, rhs: Injective_Exchange_V1beta1_QueryTradeRewardPointsResponse) -> Bool {
    if lhs.accountTradeRewardPoints != rhs.accountTradeRewardPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryTradeRewardCampaignRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTradeRewardCampaignRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryTradeRewardCampaignRequest, rhs: Injective_Exchange_V1beta1_QueryTradeRewardCampaignRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryTradeRewardCampaignResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTradeRewardCampaignResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trading_reward_campaign_info"),
    2: .standard(proto: "trading_reward_pool_campaign_schedule"),
    3: .standard(proto: "total_trade_reward_points"),
    4: .standard(proto: "pending_trading_reward_pool_campaign_schedule"),
    5: .standard(proto: "pending_total_trade_reward_points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tradingRewardCampaignInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tradingRewardPoolCampaignSchedule) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.totalTradeRewardPoints) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.pendingTradingRewardPoolCampaignSchedule) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.pendingTotalTradeRewardPoints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tradingRewardCampaignInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.tradingRewardPoolCampaignSchedule.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tradingRewardPoolCampaignSchedule, fieldNumber: 2)
    }
    if !self.totalTradeRewardPoints.isEmpty {
      try visitor.visitSingularStringField(value: self.totalTradeRewardPoints, fieldNumber: 3)
    }
    if !self.pendingTradingRewardPoolCampaignSchedule.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingTradingRewardPoolCampaignSchedule, fieldNumber: 4)
    }
    if !self.pendingTotalTradeRewardPoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pendingTotalTradeRewardPoints, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryTradeRewardCampaignResponse, rhs: Injective_Exchange_V1beta1_QueryTradeRewardCampaignResponse) -> Bool {
    if lhs._tradingRewardCampaignInfo != rhs._tradingRewardCampaignInfo {return false}
    if lhs.tradingRewardPoolCampaignSchedule != rhs.tradingRewardPoolCampaignSchedule {return false}
    if lhs.totalTradeRewardPoints != rhs.totalTradeRewardPoints {return false}
    if lhs.pendingTradingRewardPoolCampaignSchedule != rhs.pendingTradingRewardPoolCampaignSchedule {return false}
    if lhs.pendingTotalTradeRewardPoints != rhs.pendingTotalTradeRewardPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryIsOptedOutOfRewardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryIsOptedOutOfRewardsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryIsOptedOutOfRewardsRequest, rhs: Injective_Exchange_V1beta1_QueryIsOptedOutOfRewardsRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryIsOptedOutOfRewardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryIsOptedOutOfRewardsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_opted_out"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isOptedOut) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isOptedOut != false {
      try visitor.visitSingularBoolField(value: self.isOptedOut, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryIsOptedOutOfRewardsResponse, rhs: Injective_Exchange_V1beta1_QueryIsOptedOutOfRewardsResponse) -> Bool {
    if lhs.isOptedOut != rhs.isOptedOut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryOptedOutOfRewardsAccountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOptedOutOfRewardsAccountsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryOptedOutOfRewardsAccountsRequest, rhs: Injective_Exchange_V1beta1_QueryOptedOutOfRewardsAccountsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryOptedOutOfRewardsAccountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryOptedOutOfRewardsAccountsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.accounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryOptedOutOfRewardsAccountsResponse, rhs: Injective_Exchange_V1beta1_QueryOptedOutOfRewardsAccountsResponse) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryFeeDiscountAccountInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFeeDiscountAccountInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryFeeDiscountAccountInfoRequest, rhs: Injective_Exchange_V1beta1_QueryFeeDiscountAccountInfoRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryFeeDiscountAccountInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFeeDiscountAccountInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tier_level"),
    2: .standard(proto: "account_info"),
    3: .standard(proto: "account_ttl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.tierLevel) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._accountTtl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.tierLevel != 0 {
      try visitor.visitSingularUInt64Field(value: self.tierLevel, fieldNumber: 1)
    }
    try { if let v = self._accountInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._accountTtl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryFeeDiscountAccountInfoResponse, rhs: Injective_Exchange_V1beta1_QueryFeeDiscountAccountInfoResponse) -> Bool {
    if lhs.tierLevel != rhs.tierLevel {return false}
    if lhs._accountInfo != rhs._accountInfo {return false}
    if lhs._accountTtl != rhs._accountTtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryFeeDiscountScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFeeDiscountScheduleRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryFeeDiscountScheduleRequest, rhs: Injective_Exchange_V1beta1_QueryFeeDiscountScheduleRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryFeeDiscountScheduleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFeeDiscountScheduleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fee_discount_schedule"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._feeDiscountSchedule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._feeDiscountSchedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryFeeDiscountScheduleResponse, rhs: Injective_Exchange_V1beta1_QueryFeeDiscountScheduleResponse) -> Bool {
    if lhs._feeDiscountSchedule != rhs._feeDiscountSchedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryBalanceMismatchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBalanceMismatchesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dust_factor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.dustFactor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dustFactor != 0 {
      try visitor.visitSingularInt64Field(value: self.dustFactor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryBalanceMismatchesRequest, rhs: Injective_Exchange_V1beta1_QueryBalanceMismatchesRequest) -> Bool {
    if lhs.dustFactor != rhs.dustFactor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_BalanceMismatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BalanceMismatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subaccountId"),
    2: .same(proto: "denom"),
    3: .same(proto: "available"),
    4: .same(proto: "total"),
    5: .standard(proto: "balance_hold"),
    6: .standard(proto: "expected_total"),
    7: .same(proto: "difference"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.available) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.total) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.balanceHold) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.expectedTotal) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.difference) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    if !self.available.isEmpty {
      try visitor.visitSingularStringField(value: self.available, fieldNumber: 3)
    }
    if !self.total.isEmpty {
      try visitor.visitSingularStringField(value: self.total, fieldNumber: 4)
    }
    if !self.balanceHold.isEmpty {
      try visitor.visitSingularStringField(value: self.balanceHold, fieldNumber: 5)
    }
    if !self.expectedTotal.isEmpty {
      try visitor.visitSingularStringField(value: self.expectedTotal, fieldNumber: 6)
    }
    if !self.difference.isEmpty {
      try visitor.visitSingularStringField(value: self.difference, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_BalanceMismatch, rhs: Injective_Exchange_V1beta1_BalanceMismatch) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.available != rhs.available {return false}
    if lhs.total != rhs.total {return false}
    if lhs.balanceHold != rhs.balanceHold {return false}
    if lhs.expectedTotal != rhs.expectedTotal {return false}
    if lhs.difference != rhs.difference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryBalanceMismatchesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBalanceMismatchesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "balance_mismatches"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.balanceMismatches) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.balanceMismatches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.balanceMismatches, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryBalanceMismatchesResponse, rhs: Injective_Exchange_V1beta1_QueryBalanceMismatchesResponse) -> Bool {
    if lhs.balanceMismatches != rhs.balanceMismatches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryBalanceWithBalanceHoldsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBalanceWithBalanceHoldsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryBalanceWithBalanceHoldsRequest, rhs: Injective_Exchange_V1beta1_QueryBalanceWithBalanceHoldsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_BalanceWithMarginHold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BalanceWithMarginHold"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subaccountId"),
    2: .same(proto: "denom"),
    3: .same(proto: "available"),
    4: .same(proto: "total"),
    5: .standard(proto: "balance_hold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.available) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.total) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.balanceHold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    if !self.available.isEmpty {
      try visitor.visitSingularStringField(value: self.available, fieldNumber: 3)
    }
    if !self.total.isEmpty {
      try visitor.visitSingularStringField(value: self.total, fieldNumber: 4)
    }
    if !self.balanceHold.isEmpty {
      try visitor.visitSingularStringField(value: self.balanceHold, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_BalanceWithMarginHold, rhs: Injective_Exchange_V1beta1_BalanceWithMarginHold) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.available != rhs.available {return false}
    if lhs.total != rhs.total {return false}
    if lhs.balanceHold != rhs.balanceHold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryBalanceWithBalanceHoldsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBalanceWithBalanceHoldsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "balance_with_balance_holds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.balanceWithBalanceHolds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.balanceWithBalanceHolds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.balanceWithBalanceHolds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryBalanceWithBalanceHoldsResponse, rhs: Injective_Exchange_V1beta1_QueryBalanceWithBalanceHoldsResponse) -> Bool {
    if lhs.balanceWithBalanceHolds != rhs.balanceWithBalanceHolds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryFeeDiscountTierStatisticsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFeeDiscountTierStatisticsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryFeeDiscountTierStatisticsRequest, rhs: Injective_Exchange_V1beta1_QueryFeeDiscountTierStatisticsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TierStatistic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TierStatistic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tier"),
    2: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.tier) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tier != 0 {
      try visitor.visitSingularUInt64Field(value: self.tier, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TierStatistic, rhs: Injective_Exchange_V1beta1_TierStatistic) -> Bool {
    if lhs.tier != rhs.tier {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryFeeDiscountTierStatisticsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryFeeDiscountTierStatisticsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "statistics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.statistics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statistics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statistics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryFeeDiscountTierStatisticsResponse, rhs: Injective_Exchange_V1beta1_QueryFeeDiscountTierStatisticsResponse) -> Bool {
    if lhs.statistics != rhs.statistics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MitoVaultInfosRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MitoVaultInfosRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MitoVaultInfosRequest, rhs: Injective_Exchange_V1beta1_MitoVaultInfosRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MitoVaultInfosResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MitoVaultInfosResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "master_addresses"),
    2: .standard(proto: "derivative_addresses"),
    3: .standard(proto: "spot_addresses"),
    4: .standard(proto: "cw20_addresses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.masterAddresses) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.derivativeAddresses) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.spotAddresses) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.cw20Addresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.masterAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.masterAddresses, fieldNumber: 1)
    }
    if !self.derivativeAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.derivativeAddresses, fieldNumber: 2)
    }
    if !self.spotAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.spotAddresses, fieldNumber: 3)
    }
    if !self.cw20Addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cw20Addresses, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MitoVaultInfosResponse, rhs: Injective_Exchange_V1beta1_MitoVaultInfosResponse) -> Bool {
    if lhs.masterAddresses != rhs.masterAddresses {return false}
    if lhs.derivativeAddresses != rhs.derivativeAddresses {return false}
    if lhs.spotAddresses != rhs.spotAddresses {return false}
    if lhs.cw20Addresses != rhs.cw20Addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryMarketIDFromVaultRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMarketIDFromVaultRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vault_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vaultAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vaultAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.vaultAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryMarketIDFromVaultRequest, rhs: Injective_Exchange_V1beta1_QueryMarketIDFromVaultRequest) -> Bool {
    if lhs.vaultAddress != rhs.vaultAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryMarketIDFromVaultResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMarketIDFromVaultResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryMarketIDFromVaultResponse, rhs: Injective_Exchange_V1beta1_QueryMarketIDFromVaultResponse) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryHistoricalTradeRecordsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryHistoricalTradeRecordsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryHistoricalTradeRecordsRequest, rhs: Injective_Exchange_V1beta1_QueryHistoricalTradeRecordsRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryHistoricalTradeRecordsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryHistoricalTradeRecordsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trade_records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tradeRecords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tradeRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tradeRecords, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryHistoricalTradeRecordsResponse, rhs: Injective_Exchange_V1beta1_QueryHistoricalTradeRecordsResponse) -> Bool {
    if lhs.tradeRecords != rhs.tradeRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradeHistoryOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradeHistoryOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trade_grouping_sec"),
    2: .standard(proto: "max_age"),
    4: .standard(proto: "include_raw_history"),
    5: .standard(proto: "include_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.tradeGroupingSec) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.maxAge) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeRawHistory) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.includeMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tradeGroupingSec != 0 {
      try visitor.visitSingularUInt64Field(value: self.tradeGroupingSec, fieldNumber: 1)
    }
    if self.maxAge != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxAge, fieldNumber: 2)
    }
    if self.includeRawHistory != false {
      try visitor.visitSingularBoolField(value: self.includeRawHistory, fieldNumber: 4)
    }
    if self.includeMetadata != false {
      try visitor.visitSingularBoolField(value: self.includeMetadata, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradeHistoryOptions, rhs: Injective_Exchange_V1beta1_TradeHistoryOptions) -> Bool {
    if lhs.tradeGroupingSec != rhs.tradeGroupingSec {return false}
    if lhs.maxAge != rhs.maxAge {return false}
    if lhs.includeRawHistory != rhs.includeRawHistory {return false}
    if lhs.includeMetadata != rhs.includeMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryMarketVolatilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMarketVolatilityRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "trade_history_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tradeHistoryOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try { if let v = self._tradeHistoryOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryMarketVolatilityRequest, rhs: Injective_Exchange_V1beta1_QueryMarketVolatilityRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._tradeHistoryOptions != rhs._tradeHistoryOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryMarketVolatilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMarketVolatilityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volatility"),
    2: .standard(proto: "history_metadata"),
    3: .standard(proto: "raw_history"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.volatility) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._historyMetadata) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rawHistory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.volatility.isEmpty {
      try visitor.visitSingularStringField(value: self.volatility, fieldNumber: 1)
    }
    try { if let v = self._historyMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.rawHistory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rawHistory, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryMarketVolatilityResponse, rhs: Injective_Exchange_V1beta1_QueryMarketVolatilityResponse) -> Bool {
    if lhs.volatility != rhs.volatility {return false}
    if lhs._historyMetadata != rhs._historyMetadata {return false}
    if lhs.rawHistory != rhs.rawHistory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryBinaryMarketsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBinaryMarketsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryBinaryMarketsRequest, rhs: Injective_Exchange_V1beta1_QueryBinaryMarketsRequest) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryBinaryMarketsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBinaryMarketsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "markets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.markets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.markets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.markets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryBinaryMarketsResponse, rhs: Injective_Exchange_V1beta1_QueryBinaryMarketsResponse) -> Bool {
    if lhs.markets != rhs.markets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryTraderDerivativeConditionalOrdersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTraderDerivativeConditionalOrdersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryTraderDerivativeConditionalOrdersRequest, rhs: Injective_Exchange_V1beta1_QueryTraderDerivativeConditionalOrdersRequest) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TrimmedDerivativeConditionalOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrimmedDerivativeConditionalOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "quantity"),
    3: .same(proto: "margin"),
    4: .same(proto: "triggerPrice"),
    5: .same(proto: "isBuy"),
    6: .same(proto: "isLimit"),
    7: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.margin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.triggerPrice) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isBuy) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isLimit) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 1)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 2)
    }
    if !self.margin.isEmpty {
      try visitor.visitSingularStringField(value: self.margin, fieldNumber: 3)
    }
    if !self.triggerPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerPrice, fieldNumber: 4)
    }
    if self.isBuy != false {
      try visitor.visitSingularBoolField(value: self.isBuy, fieldNumber: 5)
    }
    if self.isLimit != false {
      try visitor.visitSingularBoolField(value: self.isLimit, fieldNumber: 6)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TrimmedDerivativeConditionalOrder, rhs: Injective_Exchange_V1beta1_TrimmedDerivativeConditionalOrder) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.margin != rhs.margin {return false}
    if lhs.triggerPrice != rhs.triggerPrice {return false}
    if lhs.isBuy != rhs.isBuy {return false}
    if lhs.isLimit != rhs.isLimit {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryTraderDerivativeConditionalOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTraderDerivativeConditionalOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryTraderDerivativeConditionalOrdersResponse, rhs: Injective_Exchange_V1beta1_QueryTraderDerivativeConditionalOrdersResponse) -> Bool {
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryMarketAtomicExecutionFeeMultiplierRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMarketAtomicExecutionFeeMultiplierRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryMarketAtomicExecutionFeeMultiplierRequest, rhs: Injective_Exchange_V1beta1_QueryMarketAtomicExecutionFeeMultiplierRequest) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_QueryMarketAtomicExecutionFeeMultiplierResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMarketAtomicExecutionFeeMultiplierResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "multiplier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.multiplier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.multiplier.isEmpty {
      try visitor.visitSingularStringField(value: self.multiplier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_QueryMarketAtomicExecutionFeeMultiplierResponse, rhs: Injective_Exchange_V1beta1_QueryMarketAtomicExecutionFeeMultiplierResponse) -> Bool {
    if lhs.multiplier != rhs.multiplier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
