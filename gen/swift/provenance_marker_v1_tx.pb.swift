// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: provenance/marker/v1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgGrantAllowanceRequest validates permission to create a fee grant based on marker admin access. If
/// successful a feegrant is recorded where the marker account itself is the grantor
struct Provenance_Marker_V1_MsgGrantAllowanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var administrator: String = String()

  /// grantee is the address of the user being granted an allowance of another user's funds.
  var grantee: String = String()

  /// allowance can be any of basic and filtered fee allowance (fee FeeGrant module).
  var allowance: SwiftProtobuf.Google_Protobuf_Any {
    get {return _allowance ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_allowance = newValue}
  }
  /// Returns true if `allowance` has been explicitly set.
  var hasAllowance: Bool {return self._allowance != nil}
  /// Clears the value of `allowance`. Subsequent reads from it will return its default value.
  mutating func clearAllowance() {self._allowance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _allowance: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// MsgGrantAllowanceResponse defines the Msg/GrantAllowanceResponse response type.
struct Provenance_Marker_V1_MsgGrantAllowanceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddMarkerRequest defines the Msg/AddMarker request type.
/// If being provided as a governance proposal, set the from_address to the gov module's account address.
struct Provenance_Marker_V1_MsgAddMarkerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var manager: String = String()

  var fromAddress: String = String()

  var status: Provenance_Marker_V1_MarkerStatus = .unspecified

  var markerType: Provenance_Marker_V1_MarkerType = .unspecified

  var accessList: [Provenance_Marker_V1_AccessGrant] = []

  var supplyFixed: Bool = false

  var allowGovernanceControl: Bool = false

  var allowForcedTransfer: Bool = false

  var requiredAttributes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgAddMarkerResponse defines the Msg/AddMarker response type
struct Provenance_Marker_V1_MsgAddMarkerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddAccessRequest defines the Msg/AddAccess request type
struct Provenance_Marker_V1_MsgAddAccessRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var administrator: String = String()

  var access: [Provenance_Marker_V1_AccessGrant] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddAccessResponse defines the Msg/AddAccess response type
struct Provenance_Marker_V1_MsgAddAccessResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteAccessRequest defines the Msg/DeleteAccess request type
struct Provenance_Marker_V1_MsgDeleteAccessRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var administrator: String = String()

  var removedAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteAccessResponse defines the Msg/DeleteAccess response type
struct Provenance_Marker_V1_MsgDeleteAccessResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgFinalizeRequest defines the Msg/Finalize request type
struct Provenance_Marker_V1_MsgFinalizeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgFinalizeResponse defines the Msg/Finalize response type
struct Provenance_Marker_V1_MsgFinalizeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgActivateRequest defines the Msg/Activate request type
struct Provenance_Marker_V1_MsgActivateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgActivateResponse defines the Msg/Activate response type
struct Provenance_Marker_V1_MsgActivateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCancelRequest defines the Msg/Cancel request type
struct Provenance_Marker_V1_MsgCancelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCancelResponse defines the Msg/Cancel response type
struct Provenance_Marker_V1_MsgCancelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteRequest defines the Msg/Delete request type
struct Provenance_Marker_V1_MsgDeleteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteResponse defines the Msg/Delete response type
struct Provenance_Marker_V1_MsgDeleteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgMintRequest defines the Msg/Mint request type
struct Provenance_Marker_V1_MsgMintRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgMintResponse defines the Msg/Mint response type
struct Provenance_Marker_V1_MsgMintResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBurnRequest defines the Msg/Burn request type
struct Provenance_Marker_V1_MsgBurnRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgBurnResponse defines the Msg/Burn response type
struct Provenance_Marker_V1_MsgBurnResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWithdrawRequest defines the Msg/Withdraw request type
struct Provenance_Marker_V1_MsgWithdrawRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var administrator: String = String()

  var toAddress: String = String()

  var amount: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWithdrawResponse defines the Msg/Withdraw response type
struct Provenance_Marker_V1_MsgWithdrawResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgTransferRequest defines the Msg/Transfer request type
struct Provenance_Marker_V1_MsgTransferRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var administrator: String = String()

  var fromAddress: String = String()

  var toAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgTransferResponse defines the Msg/Transfer response type
struct Provenance_Marker_V1_MsgTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgIbcTransferRequest defines the Msg/IbcTransfer request type for markers.
struct Provenance_Marker_V1_MsgIbcTransferRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transfer: Ibc_Applications_Transfer_V1_MsgTransfer {
    get {return _transfer ?? Ibc_Applications_Transfer_V1_MsgTransfer()}
    set {_transfer = newValue}
  }
  /// Returns true if `transfer` has been explicitly set.
  var hasTransfer: Bool {return self._transfer != nil}
  /// Clears the value of `transfer`. Subsequent reads from it will return its default value.
  mutating func clearTransfer() {self._transfer = nil}

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transfer: Ibc_Applications_Transfer_V1_MsgTransfer? = nil
}

/// MsgIbcTransferResponse defines the Msg/IbcTransfer response type
struct Provenance_Marker_V1_MsgIbcTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSetDenomMetadataRequest defines the Msg/SetDenomMetadata request type
struct Provenance_Marker_V1_MsgSetDenomMetadataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Cosmos_Bank_V1beta1_Metadata {
    get {return _metadata ?? Cosmos_Bank_V1beta1_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Cosmos_Bank_V1beta1_Metadata? = nil
}

/// MsgSetDenomMetadataResponse defines the Msg/SetDenomMetadata response type
struct Provenance_Marker_V1_MsgSetDenomMetadataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddFinalizeActivateMarkerRequest defines the Msg/AddFinalizeActivateMarker request type
struct Provenance_Marker_V1_MsgAddFinalizeActivateMarkerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var manager: String = String()

  var fromAddress: String = String()

  var markerType: Provenance_Marker_V1_MarkerType = .unspecified

  var accessList: [Provenance_Marker_V1_AccessGrant] = []

  var supplyFixed: Bool = false

  var allowGovernanceControl: Bool = false

  var allowForcedTransfer: Bool = false

  var requiredAttributes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgAddFinalizeActivateMarkerResponse defines the Msg/AddFinalizeActivateMarker response type
struct Provenance_Marker_V1_MsgAddFinalizeActivateMarkerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSupplyIncreaseProposalRequest defines a governance proposal to administer a marker and increase total supply of
/// the marker through minting coin and placing it within the marker or assigning it directly to an account
struct Provenance_Marker_V1_MsgSupplyIncreaseProposalRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// an optional target address for the minted coin from this request
  var targetAddress: String = String()

  /// signer of the proposal
  var authority: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgSupplyIncreaseProposalResponse defines the Msg/SupplyIncreaseProposal response type
struct Provenance_Marker_V1_MsgSupplyIncreaseProposalResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateRequiredAttributesRequest defines a msg to update/add/remove required attributes from a resticted marker
/// signer must have transfer authority to change attributes, to update attribute add current to remove list and new to
/// add list
struct Provenance_Marker_V1_MsgUpdateRequiredAttributesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var removeRequiredAttributes: [String] = []

  var addRequiredAttributes: [String] = []

  /// signer of the proposal
  var transferAuthority: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateRequiredAttributesResponse defines the Msg/UpdateRequiredAttributes response type
struct Provenance_Marker_V1_MsgUpdateRequiredAttributesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateForcedTransferRequest defines a msg to update the allow_forced_transfer field of a marker.
/// It is only usable via governance proposal.
struct Provenance_Marker_V1_MsgUpdateForcedTransferRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The denomination of the marker to update.
  var denom: String = String()

  /// Whether an admin can transfer restricted coins from a 3rd-party account without their signature.
  var allowForcedTransfer: Bool = false

  /// The signer of this message. Must be the governance module account address.
  var authority: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateForcedTransferResponse defines the Msg/UpdateForcedTransfer response type
struct Provenance_Marker_V1_MsgUpdateForcedTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSetAccountDataRequest defines a msg to set/update/delete the account data for a marker.
/// Signer must have deposit authority or be a gov proposal.
struct Provenance_Marker_V1_MsgSetAccountDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The denomination of the marker to update.
  var denom: String = String()

  /// The desired accountdata value.
  var value: String = String()

  /// The signer of this message. Must have deposit authority or be the governance module account address.
  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSetAccountDataResponse defines the Msg/SetAccountData response type
struct Provenance_Marker_V1_MsgSetAccountDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Provenance_Marker_V1_MsgGrantAllowanceRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgGrantAllowanceResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgAddMarkerRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgAddMarkerResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgAddAccessRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgAddAccessResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgDeleteAccessRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgDeleteAccessResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgFinalizeRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgFinalizeResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgActivateRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgActivateResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgCancelRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgCancelResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgDeleteRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgDeleteResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgMintRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgMintResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgBurnRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgBurnResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgWithdrawRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgWithdrawResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgTransferRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgTransferResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgIbcTransferRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgIbcTransferResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgSetDenomMetadataRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgSetDenomMetadataResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgAddFinalizeActivateMarkerRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgAddFinalizeActivateMarkerResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgSupplyIncreaseProposalRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgSupplyIncreaseProposalResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgUpdateRequiredAttributesRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgUpdateRequiredAttributesResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgUpdateForcedTransferRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgUpdateForcedTransferResponse: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgSetAccountDataRequest: @unchecked Sendable {}
extension Provenance_Marker_V1_MsgSetAccountDataResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "provenance.marker.v1"

extension Provenance_Marker_V1_MsgGrantAllowanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGrantAllowanceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "administrator"),
    3: .same(proto: "grantee"),
    4: .same(proto: "allowance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.grantee) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._allowance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    if !self.grantee.isEmpty {
      try visitor.visitSingularStringField(value: self.grantee, fieldNumber: 3)
    }
    try { if let v = self._allowance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgGrantAllowanceRequest, rhs: Provenance_Marker_V1_MsgGrantAllowanceRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.grantee != rhs.grantee {return false}
    if lhs._allowance != rhs._allowance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgGrantAllowanceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgGrantAllowanceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgGrantAllowanceResponse, rhs: Provenance_Marker_V1_MsgGrantAllowanceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgAddMarkerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddMarkerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    3: .same(proto: "manager"),
    4: .standard(proto: "from_address"),
    5: .same(proto: "status"),
    6: .standard(proto: "marker_type"),
    7: .standard(proto: "access_list"),
    8: .standard(proto: "supply_fixed"),
    9: .standard(proto: "allow_governance_control"),
    10: .standard(proto: "allow_forced_transfer"),
    11: .standard(proto: "required_attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.manager) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fromAddress) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.markerType) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.accessList) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.supplyFixed) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.allowGovernanceControl) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.allowForcedTransfer) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.requiredAttributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.manager.isEmpty {
      try visitor.visitSingularStringField(value: self.manager, fieldNumber: 3)
    }
    if !self.fromAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.fromAddress, fieldNumber: 4)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    if self.markerType != .unspecified {
      try visitor.visitSingularEnumField(value: self.markerType, fieldNumber: 6)
    }
    if !self.accessList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessList, fieldNumber: 7)
    }
    if self.supplyFixed != false {
      try visitor.visitSingularBoolField(value: self.supplyFixed, fieldNumber: 8)
    }
    if self.allowGovernanceControl != false {
      try visitor.visitSingularBoolField(value: self.allowGovernanceControl, fieldNumber: 9)
    }
    if self.allowForcedTransfer != false {
      try visitor.visitSingularBoolField(value: self.allowForcedTransfer, fieldNumber: 10)
    }
    if !self.requiredAttributes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requiredAttributes, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgAddMarkerRequest, rhs: Provenance_Marker_V1_MsgAddMarkerRequest) -> Bool {
    if lhs._amount != rhs._amount {return false}
    if lhs.manager != rhs.manager {return false}
    if lhs.fromAddress != rhs.fromAddress {return false}
    if lhs.status != rhs.status {return false}
    if lhs.markerType != rhs.markerType {return false}
    if lhs.accessList != rhs.accessList {return false}
    if lhs.supplyFixed != rhs.supplyFixed {return false}
    if lhs.allowGovernanceControl != rhs.allowGovernanceControl {return false}
    if lhs.allowForcedTransfer != rhs.allowForcedTransfer {return false}
    if lhs.requiredAttributes != rhs.requiredAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgAddMarkerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddMarkerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgAddMarkerResponse, rhs: Provenance_Marker_V1_MsgAddMarkerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgAddAccessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddAccessRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "administrator"),
    3: .same(proto: "access"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.access) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    if !self.access.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.access, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgAddAccessRequest, rhs: Provenance_Marker_V1_MsgAddAccessRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.access != rhs.access {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgAddAccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddAccessResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgAddAccessResponse, rhs: Provenance_Marker_V1_MsgAddAccessResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgDeleteAccessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteAccessRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "administrator"),
    3: .standard(proto: "removed_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.removedAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    if !self.removedAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.removedAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgDeleteAccessRequest, rhs: Provenance_Marker_V1_MsgDeleteAccessRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.removedAddress != rhs.removedAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgDeleteAccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteAccessResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgDeleteAccessResponse, rhs: Provenance_Marker_V1_MsgDeleteAccessResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgFinalizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgFinalizeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgFinalizeRequest, rhs: Provenance_Marker_V1_MsgFinalizeRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgFinalizeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgFinalizeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgFinalizeResponse, rhs: Provenance_Marker_V1_MsgFinalizeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgActivateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgActivateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgActivateRequest, rhs: Provenance_Marker_V1_MsgActivateRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgActivateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgActivateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgActivateResponse, rhs: Provenance_Marker_V1_MsgActivateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgCancelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgCancelRequest, rhs: Provenance_Marker_V1_MsgCancelRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgCancelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgCancelResponse, rhs: Provenance_Marker_V1_MsgCancelResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgDeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgDeleteRequest, rhs: Provenance_Marker_V1_MsgDeleteRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgDeleteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgDeleteResponse, rhs: Provenance_Marker_V1_MsgDeleteResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgMintRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMintRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgMintRequest, rhs: Provenance_Marker_V1_MsgMintRequest) -> Bool {
    if lhs._amount != rhs._amount {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgMintResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMintResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgMintResponse, rhs: Provenance_Marker_V1_MsgMintResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgBurnRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBurnRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgBurnRequest, rhs: Provenance_Marker_V1_MsgBurnRequest) -> Bool {
    if lhs._amount != rhs._amount {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgBurnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBurnResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgBurnResponse, rhs: Provenance_Marker_V1_MsgBurnResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgWithdrawRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "administrator"),
    3: .standard(proto: "to_address"),
    4: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.toAddress) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.toAddress, fieldNumber: 3)
    }
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgWithdrawRequest, rhs: Provenance_Marker_V1_MsgWithdrawRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgWithdrawResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgWithdrawResponse, rhs: Provenance_Marker_V1_MsgWithdrawResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgTransferRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgTransferRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    3: .same(proto: "administrator"),
    4: .standard(proto: "from_address"),
    5: .standard(proto: "to_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fromAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.toAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 3)
    }
    if !self.fromAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.fromAddress, fieldNumber: 4)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.toAddress, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgTransferRequest, rhs: Provenance_Marker_V1_MsgTransferRequest) -> Bool {
    if lhs._amount != rhs._amount {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.fromAddress != rhs.fromAddress {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgTransferResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgTransferResponse, rhs: Provenance_Marker_V1_MsgTransferResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgIbcTransferRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgIbcTransferRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transfer"),
    2: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transfer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transfer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgIbcTransferRequest, rhs: Provenance_Marker_V1_MsgIbcTransferRequest) -> Bool {
    if lhs._transfer != rhs._transfer {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgIbcTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgIbcTransferResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgIbcTransferResponse, rhs: Provenance_Marker_V1_MsgIbcTransferResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgSetDenomMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetDenomMetadataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgSetDenomMetadataRequest, rhs: Provenance_Marker_V1_MsgSetDenomMetadataRequest) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgSetDenomMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetDenomMetadataResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgSetDenomMetadataResponse, rhs: Provenance_Marker_V1_MsgSetDenomMetadataResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgAddFinalizeActivateMarkerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddFinalizeActivateMarkerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    3: .same(proto: "manager"),
    4: .standard(proto: "from_address"),
    5: .standard(proto: "marker_type"),
    6: .standard(proto: "access_list"),
    7: .standard(proto: "supply_fixed"),
    8: .standard(proto: "allow_governance_control"),
    9: .standard(proto: "allow_forced_transfer"),
    10: .standard(proto: "required_attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.manager) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fromAddress) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.markerType) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.accessList) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.supplyFixed) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.allowGovernanceControl) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.allowForcedTransfer) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.requiredAttributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.manager.isEmpty {
      try visitor.visitSingularStringField(value: self.manager, fieldNumber: 3)
    }
    if !self.fromAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.fromAddress, fieldNumber: 4)
    }
    if self.markerType != .unspecified {
      try visitor.visitSingularEnumField(value: self.markerType, fieldNumber: 5)
    }
    if !self.accessList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessList, fieldNumber: 6)
    }
    if self.supplyFixed != false {
      try visitor.visitSingularBoolField(value: self.supplyFixed, fieldNumber: 7)
    }
    if self.allowGovernanceControl != false {
      try visitor.visitSingularBoolField(value: self.allowGovernanceControl, fieldNumber: 8)
    }
    if self.allowForcedTransfer != false {
      try visitor.visitSingularBoolField(value: self.allowForcedTransfer, fieldNumber: 9)
    }
    if !self.requiredAttributes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requiredAttributes, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgAddFinalizeActivateMarkerRequest, rhs: Provenance_Marker_V1_MsgAddFinalizeActivateMarkerRequest) -> Bool {
    if lhs._amount != rhs._amount {return false}
    if lhs.manager != rhs.manager {return false}
    if lhs.fromAddress != rhs.fromAddress {return false}
    if lhs.markerType != rhs.markerType {return false}
    if lhs.accessList != rhs.accessList {return false}
    if lhs.supplyFixed != rhs.supplyFixed {return false}
    if lhs.allowGovernanceControl != rhs.allowGovernanceControl {return false}
    if lhs.allowForcedTransfer != rhs.allowForcedTransfer {return false}
    if lhs.requiredAttributes != rhs.requiredAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgAddFinalizeActivateMarkerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddFinalizeActivateMarkerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgAddFinalizeActivateMarkerResponse, rhs: Provenance_Marker_V1_MsgAddFinalizeActivateMarkerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgSupplyIncreaseProposalRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSupplyIncreaseProposalRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .standard(proto: "target_address"),
    3: .same(proto: "authority"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.targetAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.targetAddress, fieldNumber: 2)
    }
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgSupplyIncreaseProposalRequest, rhs: Provenance_Marker_V1_MsgSupplyIncreaseProposalRequest) -> Bool {
    if lhs._amount != rhs._amount {return false}
    if lhs.targetAddress != rhs.targetAddress {return false}
    if lhs.authority != rhs.authority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgSupplyIncreaseProposalResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSupplyIncreaseProposalResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgSupplyIncreaseProposalResponse, rhs: Provenance_Marker_V1_MsgSupplyIncreaseProposalResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgUpdateRequiredAttributesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateRequiredAttributesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .standard(proto: "remove_required_attributes"),
    3: .standard(proto: "add_required_attributes"),
    4: .standard(proto: "transfer_authority"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.removeRequiredAttributes) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.addRequiredAttributes) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.transferAuthority) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.removeRequiredAttributes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.removeRequiredAttributes, fieldNumber: 2)
    }
    if !self.addRequiredAttributes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addRequiredAttributes, fieldNumber: 3)
    }
    if !self.transferAuthority.isEmpty {
      try visitor.visitSingularStringField(value: self.transferAuthority, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgUpdateRequiredAttributesRequest, rhs: Provenance_Marker_V1_MsgUpdateRequiredAttributesRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.removeRequiredAttributes != rhs.removeRequiredAttributes {return false}
    if lhs.addRequiredAttributes != rhs.addRequiredAttributes {return false}
    if lhs.transferAuthority != rhs.transferAuthority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgUpdateRequiredAttributesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateRequiredAttributesResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgUpdateRequiredAttributesResponse, rhs: Provenance_Marker_V1_MsgUpdateRequiredAttributesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgUpdateForcedTransferRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateForcedTransferRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .standard(proto: "allow_forced_transfer"),
    3: .same(proto: "authority"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowForcedTransfer) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.allowForcedTransfer != false {
      try visitor.visitSingularBoolField(value: self.allowForcedTransfer, fieldNumber: 2)
    }
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgUpdateForcedTransferRequest, rhs: Provenance_Marker_V1_MsgUpdateForcedTransferRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.allowForcedTransfer != rhs.allowForcedTransfer {return false}
    if lhs.authority != rhs.authority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgUpdateForcedTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateForcedTransferResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgUpdateForcedTransferResponse, rhs: Provenance_Marker_V1_MsgUpdateForcedTransferResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgSetAccountDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetAccountDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "value"),
    3: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgSetAccountDataRequest, rhs: Provenance_Marker_V1_MsgSetAccountDataRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.value != rhs.value {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MsgSetAccountDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetAccountDataResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MsgSetAccountDataResponse, rhs: Provenance_Marker_V1_MsgSetAccountDataResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
