// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: injective/exchange/v1beta1/exchange.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Injective_Exchange_V1beta1_AtomicMarketOrderAccessLevel: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nobody // = 0

  /// currently unsupported
  case beginBlockerSmartContractsOnly // = 1
  case smartContractsOnly // = 2
  case everyone // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .nobody
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nobody
    case 1: self = .beginBlockerSmartContractsOnly
    case 2: self = .smartContractsOnly
    case 3: self = .everyone
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nobody: return 0
    case .beginBlockerSmartContractsOnly: return 1
    case .smartContractsOnly: return 2
    case .everyone: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Exchange_V1beta1_AtomicMarketOrderAccessLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Exchange_V1beta1_AtomicMarketOrderAccessLevel] = [
    .nobody,
    .beginBlockerSmartContractsOnly,
    .smartContractsOnly,
    .everyone,
  ]
}

#endif  // swift(>=4.2)

enum Injective_Exchange_V1beta1_MarketStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case active // = 1
  case paused // = 2
  case demolished // = 3
  case expired // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .active
    case 2: self = .paused
    case 3: self = .demolished
    case 4: self = .expired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .active: return 1
    case .paused: return 2
    case .demolished: return 3
    case .expired: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Exchange_V1beta1_MarketStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Exchange_V1beta1_MarketStatus] = [
    .unspecified,
    .active,
    .paused,
    .demolished,
    .expired,
  ]
}

#endif  // swift(>=4.2)

enum Injective_Exchange_V1beta1_OrderType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case buy // = 1
  case sell // = 2
  case stopBuy // = 3
  case stopSell // = 4
  case takeBuy // = 5
  case takeSell // = 6
  case buyPo // = 7
  case sellPo // = 8
  case buyAtomic // = 9
  case sellAtomic // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .buy
    case 2: self = .sell
    case 3: self = .stopBuy
    case 4: self = .stopSell
    case 5: self = .takeBuy
    case 6: self = .takeSell
    case 7: self = .buyPo
    case 8: self = .sellPo
    case 9: self = .buyAtomic
    case 10: self = .sellAtomic
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .buy: return 1
    case .sell: return 2
    case .stopBuy: return 3
    case .stopSell: return 4
    case .takeBuy: return 5
    case .takeSell: return 6
    case .buyPo: return 7
    case .sellPo: return 8
    case .buyAtomic: return 9
    case .sellAtomic: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Exchange_V1beta1_OrderType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Exchange_V1beta1_OrderType] = [
    .unspecified,
    .buy,
    .sell,
    .stopBuy,
    .stopSell,
    .takeBuy,
    .takeSell,
    .buyPo,
    .sellPo,
    .buyAtomic,
    .sellAtomic,
  ]
}

#endif  // swift(>=4.2)

enum Injective_Exchange_V1beta1_ExecutionType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecifiedExecutionType // = 0
  case market // = 1
  case limitFill // = 2
  case limitMatchRestingOrder // = 3
  case limitMatchNewOrder // = 4
  case marketLiquidation // = 5
  case expiryMarketSettlement // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecifiedExecutionType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedExecutionType
    case 1: self = .market
    case 2: self = .limitFill
    case 3: self = .limitMatchRestingOrder
    case 4: self = .limitMatchNewOrder
    case 5: self = .marketLiquidation
    case 6: self = .expiryMarketSettlement
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecifiedExecutionType: return 0
    case .market: return 1
    case .limitFill: return 2
    case .limitMatchRestingOrder: return 3
    case .limitMatchNewOrder: return 4
    case .marketLiquidation: return 5
    case .expiryMarketSettlement: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Exchange_V1beta1_ExecutionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Exchange_V1beta1_ExecutionType] = [
    .unspecifiedExecutionType,
    .market,
    .limitFill,
    .limitMatchRestingOrder,
    .limitMatchNewOrder,
    .marketLiquidation,
    .expiryMarketSettlement,
  ]
}

#endif  // swift(>=4.2)

enum Injective_Exchange_V1beta1_OrderMask: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unused // = 0
  case any // = 1
  case regular // = 2
  case conditional // = 4

  /// for conditional orders means HIGHER
  case directionBuyOrHigher // = 8

  /// for conditional orders means LOWER
  case directionSellOrLower // = 16
  case typeMarket // = 32
  case typeLimit // = 64
  case UNRECOGNIZED(Int)

  init() {
    self = .unused
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unused
    case 1: self = .any
    case 2: self = .regular
    case 4: self = .conditional
    case 8: self = .directionBuyOrHigher
    case 16: self = .directionSellOrLower
    case 32: self = .typeMarket
    case 64: self = .typeLimit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unused: return 0
    case .any: return 1
    case .regular: return 2
    case .conditional: return 4
    case .directionBuyOrHigher: return 8
    case .directionSellOrLower: return 16
    case .typeMarket: return 32
    case .typeLimit: return 64
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Exchange_V1beta1_OrderMask: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Exchange_V1beta1_OrderMask] = [
    .unused,
    .any,
    .regular,
    .conditional,
    .directionBuyOrHigher,
    .directionSellOrLower,
    .typeMarket,
    .typeLimit,
  ]
}

#endif  // swift(>=4.2)

struct Injective_Exchange_V1beta1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// spot_market_instant_listing_fee defines the expedited fee in INJ required
  /// to create a spot market by bypassing governance
  var spotMarketInstantListingFee: Cosmos_Base_V1beta1_Coin {
    get {return _storage._spotMarketInstantListingFee ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._spotMarketInstantListingFee = newValue}
  }
  /// Returns true if `spotMarketInstantListingFee` has been explicitly set.
  var hasSpotMarketInstantListingFee: Bool {return _storage._spotMarketInstantListingFee != nil}
  /// Clears the value of `spotMarketInstantListingFee`. Subsequent reads from it will return its default value.
  mutating func clearSpotMarketInstantListingFee() {_uniqueStorage()._spotMarketInstantListingFee = nil}

  /// derivative_market_instant_listing_fee defines the expedited fee in INJ
  /// required to create a derivative market by bypassing governance
  var derivativeMarketInstantListingFee: Cosmos_Base_V1beta1_Coin {
    get {return _storage._derivativeMarketInstantListingFee ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._derivativeMarketInstantListingFee = newValue}
  }
  /// Returns true if `derivativeMarketInstantListingFee` has been explicitly set.
  var hasDerivativeMarketInstantListingFee: Bool {return _storage._derivativeMarketInstantListingFee != nil}
  /// Clears the value of `derivativeMarketInstantListingFee`. Subsequent reads from it will return its default value.
  mutating func clearDerivativeMarketInstantListingFee() {_uniqueStorage()._derivativeMarketInstantListingFee = nil}

  /// default_spot_maker_fee defines the default exchange trade fee for makers on
  /// a spot market
  var defaultSpotMakerFeeRate: String {
    get {return _storage._defaultSpotMakerFeeRate}
    set {_uniqueStorage()._defaultSpotMakerFeeRate = newValue}
  }

  /// default_spot_taker_fee_rate defines the default exchange trade fee rate for
  /// takers on a new spot market
  var defaultSpotTakerFeeRate: String {
    get {return _storage._defaultSpotTakerFeeRate}
    set {_uniqueStorage()._defaultSpotTakerFeeRate = newValue}
  }

  /// default_derivative_maker_fee defines the default exchange trade fee for
  /// makers on a new derivative market
  var defaultDerivativeMakerFeeRate: String {
    get {return _storage._defaultDerivativeMakerFeeRate}
    set {_uniqueStorage()._defaultDerivativeMakerFeeRate = newValue}
  }

  /// default_derivative_taker_fee defines the default exchange trade fee for
  /// takers on a new derivative market
  var defaultDerivativeTakerFeeRate: String {
    get {return _storage._defaultDerivativeTakerFeeRate}
    set {_uniqueStorage()._defaultDerivativeTakerFeeRate = newValue}
  }

  /// default_initial_margin_ratio defines the default initial margin ratio on a
  /// new derivative market
  var defaultInitialMarginRatio: String {
    get {return _storage._defaultInitialMarginRatio}
    set {_uniqueStorage()._defaultInitialMarginRatio = newValue}
  }

  /// default_maintenance_margin_ratio defines the default maintenance margin
  /// ratio on a new derivative market
  var defaultMaintenanceMarginRatio: String {
    get {return _storage._defaultMaintenanceMarginRatio}
    set {_uniqueStorage()._defaultMaintenanceMarginRatio = newValue}
  }

  /// default_funding_interval defines the default funding interval on a
  /// derivative market
  var defaultFundingInterval: Int64 {
    get {return _storage._defaultFundingInterval}
    set {_uniqueStorage()._defaultFundingInterval = newValue}
  }

  /// funding_multiple defines the timestamp multiple that the funding timestamp
  /// should be a multiple of
  var fundingMultiple: Int64 {
    get {return _storage._fundingMultiple}
    set {_uniqueStorage()._fundingMultiple = newValue}
  }

  /// relayer_fee_share_rate defines the trade fee share percentage that goes to
  /// relayers
  var relayerFeeShareRate: String {
    get {return _storage._relayerFeeShareRate}
    set {_uniqueStorage()._relayerFeeShareRate = newValue}
  }

  /// default_hourly_funding_rate_cap defines the default maximum absolute value
  /// of the hourly funding rate
  var defaultHourlyFundingRateCap: String {
    get {return _storage._defaultHourlyFundingRateCap}
    set {_uniqueStorage()._defaultHourlyFundingRateCap = newValue}
  }

  /// hourly_interest_rate defines the hourly interest rate
  var defaultHourlyInterestRate: String {
    get {return _storage._defaultHourlyInterestRate}
    set {_uniqueStorage()._defaultHourlyInterestRate = newValue}
  }

  /// max_derivative_order_side_count defines the maximum number of derivative
  /// active orders a subaccount can have for a given orderbook side
  var maxDerivativeOrderSideCount: UInt32 {
    get {return _storage._maxDerivativeOrderSideCount}
    set {_uniqueStorage()._maxDerivativeOrderSideCount = newValue}
  }

  /// inj_reward_staked_requirement_threshold defines the threshold on INJ
  /// rewards after which one also needs staked INJ to receive more
  var injRewardStakedRequirementThreshold: String {
    get {return _storage._injRewardStakedRequirementThreshold}
    set {_uniqueStorage()._injRewardStakedRequirementThreshold = newValue}
  }

  /// the trading_rewards_vesting_duration defines the vesting times for trading
  /// rewards
  var tradingRewardsVestingDuration: Int64 {
    get {return _storage._tradingRewardsVestingDuration}
    set {_uniqueStorage()._tradingRewardsVestingDuration = newValue}
  }

  /// liquidator_reward_share_rate defines the ratio of the split of the surplus
  /// collateral that goes to the liquidator
  var liquidatorRewardShareRate: String {
    get {return _storage._liquidatorRewardShareRate}
    set {_uniqueStorage()._liquidatorRewardShareRate = newValue}
  }

  /// binary_options_market_instant_listing_fee defines the expedited fee in INJ
  /// required to create a derivative market by bypassing governance
  var binaryOptionsMarketInstantListingFee: Cosmos_Base_V1beta1_Coin {
    get {return _storage._binaryOptionsMarketInstantListingFee ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._binaryOptionsMarketInstantListingFee = newValue}
  }
  /// Returns true if `binaryOptionsMarketInstantListingFee` has been explicitly set.
  var hasBinaryOptionsMarketInstantListingFee: Bool {return _storage._binaryOptionsMarketInstantListingFee != nil}
  /// Clears the value of `binaryOptionsMarketInstantListingFee`. Subsequent reads from it will return its default value.
  mutating func clearBinaryOptionsMarketInstantListingFee() {_uniqueStorage()._binaryOptionsMarketInstantListingFee = nil}

  /// atomic_market_order_access_level defines the required access permissions
  /// for executing atomic market orders
  var atomicMarketOrderAccessLevel: Injective_Exchange_V1beta1_AtomicMarketOrderAccessLevel {
    get {return _storage._atomicMarketOrderAccessLevel}
    set {_uniqueStorage()._atomicMarketOrderAccessLevel = newValue}
  }

  /// spot_atomic_market_order_fee_multiplier defines the default multiplier for
  /// executing atomic market orders in spot markets
  var spotAtomicMarketOrderFeeMultiplier: String {
    get {return _storage._spotAtomicMarketOrderFeeMultiplier}
    set {_uniqueStorage()._spotAtomicMarketOrderFeeMultiplier = newValue}
  }

  /// derivative_atomic_market_order_fee_multiplier defines the default
  /// multiplier for executing atomic market orders in derivative markets
  var derivativeAtomicMarketOrderFeeMultiplier: String {
    get {return _storage._derivativeAtomicMarketOrderFeeMultiplier}
    set {_uniqueStorage()._derivativeAtomicMarketOrderFeeMultiplier = newValue}
  }

  /// binary_options_atomic_market_order_fee_multiplier defines the default
  /// multiplier for executing atomic market orders in binary markets
  var binaryOptionsAtomicMarketOrderFeeMultiplier: String {
    get {return _storage._binaryOptionsAtomicMarketOrderFeeMultiplier}
    set {_uniqueStorage()._binaryOptionsAtomicMarketOrderFeeMultiplier = newValue}
  }

  /// minimal_protocol_fee_rate defines the minimal protocol fee rate
  var minimalProtocolFeeRate: String {
    get {return _storage._minimalProtocolFeeRate}
    set {_uniqueStorage()._minimalProtocolFeeRate = newValue}
  }

  /// is_instant_derivative_market_launch_enabled defines whether instant
  /// derivative market launch is enabled
  var isInstantDerivativeMarketLaunchEnabled: Bool {
    get {return _storage._isInstantDerivativeMarketLaunchEnabled}
    set {_uniqueStorage()._isInstantDerivativeMarketLaunchEnabled = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_MarketFeeMultiplier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var feeMultiplier: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An object describing a derivative market in the Injective Futures Protocol.
struct Injective_Exchange_V1beta1_DerivativeMarket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ticker for the derivative contract.
  var ticker: String = String()

  /// Oracle base currency
  var oracleBase: String = String()

  /// Oracle quote currency
  var oracleQuote: String = String()

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// Address of the quote currency denomination for the derivative contract
  var quoteDenom: String = String()

  /// Unique market ID.
  var marketID: String = String()

  /// initial_margin_ratio defines the initial margin ratio of a derivative
  /// market
  var initialMarginRatio: String = String()

  /// maintenance_margin_ratio defines the maintenance margin ratio of a
  /// derivative market
  var maintenanceMarginRatio: String = String()

  /// maker_fee_rate defines the maker fee rate of a derivative market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the taker fee rate of a derivative market
  var takerFeeRate: String = String()

  /// relayer_fee_share_rate defines the percentage of the transaction fee shared
  /// with the relayer in a derivative market
  var relayerFeeShareRate: String = String()

  /// true if the market is a perpetual market. false if the market is an expiry
  /// futures market
  var isPerpetual: Bool = false

  /// Status of the market
  var status: Injective_Exchange_V1beta1_MarketStatus = .unspecified

  /// min_price_tick_size defines the minimum tick size that the price and margin
  /// required for orders in the market
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the quantity
  /// required for orders in the market
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An object describing a binary options market in Injective Protocol.
struct Injective_Exchange_V1beta1_BinaryOptionsMarket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ticker for the derivative contract.
  var ticker: String {
    get {return _storage._ticker}
    set {_uniqueStorage()._ticker = newValue}
  }

  /// Oracle symbol
  var oracleSymbol: String {
    get {return _storage._oracleSymbol}
    set {_uniqueStorage()._oracleSymbol = newValue}
  }

  /// Oracle Provider
  var oracleProvider: String {
    get {return _storage._oracleProvider}
    set {_uniqueStorage()._oracleProvider = newValue}
  }

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType {
    get {return _storage._oracleType}
    set {_uniqueStorage()._oracleType = newValue}
  }

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 {
    get {return _storage._oracleScaleFactor}
    set {_uniqueStorage()._oracleScaleFactor = newValue}
  }

  /// expiration timestamp
  var expirationTimestamp: Int64 {
    get {return _storage._expirationTimestamp}
    set {_uniqueStorage()._expirationTimestamp = newValue}
  }

  /// expiration timestamp
  var settlementTimestamp: Int64 {
    get {return _storage._settlementTimestamp}
    set {_uniqueStorage()._settlementTimestamp = newValue}
  }

  /// admin of the market
  var admin: String {
    get {return _storage._admin}
    set {_uniqueStorage()._admin = newValue}
  }

  /// Address of the quote currency denomination for the binary options contract
  var quoteDenom: String {
    get {return _storage._quoteDenom}
    set {_uniqueStorage()._quoteDenom = newValue}
  }

  /// Unique market ID.
  var marketID: String {
    get {return _storage._marketID}
    set {_uniqueStorage()._marketID = newValue}
  }

  /// maker_fee_rate defines the maker fee rate of a binary options market
  var makerFeeRate: String {
    get {return _storage._makerFeeRate}
    set {_uniqueStorage()._makerFeeRate = newValue}
  }

  /// taker_fee_rate defines the taker fee rate of a derivative market
  var takerFeeRate: String {
    get {return _storage._takerFeeRate}
    set {_uniqueStorage()._takerFeeRate = newValue}
  }

  /// relayer_fee_share_rate defines the percentage of the transaction fee shared
  /// with the relayer in a derivative market
  var relayerFeeShareRate: String {
    get {return _storage._relayerFeeShareRate}
    set {_uniqueStorage()._relayerFeeShareRate = newValue}
  }

  /// Status of the market
  var status: Injective_Exchange_V1beta1_MarketStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// min_price_tick_size defines the minimum tick size that the price and margin
  /// required for orders in the market
  var minPriceTickSize: String {
    get {return _storage._minPriceTickSize}
    set {_uniqueStorage()._minPriceTickSize = newValue}
  }

  /// min_quantity_tick_size defines the minimum tick size of the quantity
  /// required for orders in the market
  var minQuantityTickSize: String {
    get {return _storage._minQuantityTickSize}
    set {_uniqueStorage()._minQuantityTickSize = newValue}
  }

  var settlementPrice: String {
    get {return _storage._settlementPrice}
    set {_uniqueStorage()._settlementPrice = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// market ID.
  var marketID: String = String()

  /// expiration_timestamp defines the expiration time for a time expiry futures
  /// market.
  var expirationTimestamp: Int64 = 0

  /// expiration_twap_start_timestamp defines the start time of the TWAP
  /// calculation window
  var twapStartTimestamp: Int64 = 0

  /// expiration_twap_start_price_cumulative defines the cumulative price for the
  /// start of the TWAP window
  var expirationTwapStartPriceCumulative: String = String()

  /// settlement_price defines the settlement price for a time expiry futures
  /// market.
  var settlementPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_PerpetualMarketInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// market ID.
  var marketID: String = String()

  /// hourly_funding_rate_cap defines the maximum absolute value of the hourly
  /// funding rate
  var hourlyFundingRateCap: String = String()

  /// hourly_interest_rate defines the hourly interest rate
  var hourlyInterestRate: String = String()

  /// next_funding_timestamp defines the next funding timestamp in seconds of a
  /// perpetual market
  var nextFundingTimestamp: Int64 = 0

  /// funding_interval defines the next funding interval in seconds of a
  /// perpetual market.
  var fundingInterval: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_PerpetualMarketFunding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// cumulative_funding defines the cumulative funding of a perpetual market.
  var cumulativeFunding: String = String()

  /// cumulative_price defines the cumulative price for the current hour up to
  /// the last timestamp
  var cumulativePrice: String = String()

  var lastTimestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_DerivativeMarketSettlementInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// market ID.
  var marketID: String = String()

  /// settlement_price defines the settlement price
  var settlementPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_NextFundingTimestamp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nextTimestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_MidPriceAndTOB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// mid price of the market
  var midPrice: String = String()

  /// best buy price of the market
  var bestBuyPrice: String = String()

  /// best sell price of the market
  var bestSellPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An object describing trade pair of two assets.
struct Injective_Exchange_V1beta1_SpotMarket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
  /// asset.
  var ticker: String = String()

  /// Coin denom used for the base asset
  var baseDenom: String = String()

  /// Coin used for the quote asset
  var quoteDenom: String = String()

  /// maker_fee_rate defines the fee percentage makers pay when trading
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the fee percentage takers pay when trading
  var takerFeeRate: String = String()

  /// relayer_fee_share_rate defines the percentage of the transaction fee shared
  /// with the relayer in a derivative market
  var relayerFeeShareRate: String = String()

  /// Unique market ID.
  var marketID: String = String()

  /// Status of the market
  var status: Injective_Exchange_V1beta1_MarketStatus = .unspecified

  /// min_price_tick_size defines the minimum tick size that the price required
  /// for orders in the market
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the quantity
  /// required for orders in the market
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A subaccount's deposit for a given base currency
struct Injective_Exchange_V1beta1_Deposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var availableBalance: String = String()

  var totalBalance: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_SubaccountTradeNonce {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_OrderInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// bytes32 subaccount ID that created the order
  var subaccountID: String = String()

  /// address fee_recipient address that will receive fees for the order
  var feeRecipient: String = String()

  /// price of the order
  var price: String = String()

  /// quantity of the order
  var quantity: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_SpotOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// market_id represents the unique ID of the market
  var marketID: String = String()

  /// order_info contains the information of the order
  var orderInfo: Injective_Exchange_V1beta1_OrderInfo {
    get {return _orderInfo ?? Injective_Exchange_V1beta1_OrderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  /// order types
  var orderType: Injective_Exchange_V1beta1_OrderType = .unspecified

  /// trigger_price is the trigger price used by stop/take orders
  var triggerPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _orderInfo: Injective_Exchange_V1beta1_OrderInfo? = nil
}

/// A valid Spot limit order with Metadata.
struct Injective_Exchange_V1beta1_SpotLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// order_info contains the information of the order
  var orderInfo: Injective_Exchange_V1beta1_OrderInfo {
    get {return _orderInfo ?? Injective_Exchange_V1beta1_OrderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  /// order types
  var orderType: Injective_Exchange_V1beta1_OrderType = .unspecified

  /// the amount of the quantity remaining fillable
  var fillable: String = String()

  /// trigger_price is the trigger price used by stop/take orders
  var triggerPrice: String = String()

  var orderHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _orderInfo: Injective_Exchange_V1beta1_OrderInfo? = nil
}

/// A valid Spot market order with Metadata.
struct Injective_Exchange_V1beta1_SpotMarketOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// order_info contains the information of the order
  var orderInfo: Injective_Exchange_V1beta1_OrderInfo {
    get {return _orderInfo ?? Injective_Exchange_V1beta1_OrderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  var balanceHold: String = String()

  var orderHash: Data = Data()

  /// order types
  var orderType: Injective_Exchange_V1beta1_OrderType = .unspecified

  /// trigger_price is the trigger price used by stop/take orders
  var triggerPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _orderInfo: Injective_Exchange_V1beta1_OrderInfo? = nil
}

struct Injective_Exchange_V1beta1_DerivativeOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// market_id represents the unique ID of the market
  var marketID: String = String()

  /// order_info contains the information of the order
  var orderInfo: Injective_Exchange_V1beta1_OrderInfo {
    get {return _orderInfo ?? Injective_Exchange_V1beta1_OrderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  /// order types
  var orderType: Injective_Exchange_V1beta1_OrderType = .unspecified

  /// margin is the margin used by the limit order
  var margin: String = String()

  /// trigger_price is the trigger price used by stop/take orders
  var triggerPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _orderInfo: Injective_Exchange_V1beta1_OrderInfo? = nil
}

struct Injective_Exchange_V1beta1_SubaccountOrderbookMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vanillaLimitOrderCount: UInt32 = 0

  var reduceOnlyLimitOrderCount: UInt32 = 0

  /// AggregateReduceOnlyQuantity is the aggregate fillable quantity of the
  /// subaccount's reduce-only limit orders in the given direction.
  var aggregateReduceOnlyQuantity: String = String()

  /// AggregateVanillaQuantity is the aggregate fillable quantity of the
  /// subaccount's vanilla limit orders in the given direction.
  var aggregateVanillaQuantity: String = String()

  var vanillaConditionalOrderCount: UInt32 = 0

  var reduceOnlyConditionalOrderCount: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_SubaccountOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// price of the order
  var price: String = String()

  /// the amount of the quantity remaining fillable
  var quantity: String = String()

  var isReduceOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_SubaccountOrderData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var order: Injective_Exchange_V1beta1_SubaccountOrder {
    get {return _order ?? Injective_Exchange_V1beta1_SubaccountOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var orderHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_SubaccountOrder? = nil
}

/// A valid Derivative limit order with Metadata.
struct Injective_Exchange_V1beta1_DerivativeLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// order_info contains the information of the order
  var orderInfo: Injective_Exchange_V1beta1_OrderInfo {
    get {return _orderInfo ?? Injective_Exchange_V1beta1_OrderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  /// order types
  var orderType: Injective_Exchange_V1beta1_OrderType = .unspecified

  /// margin is the margin used by the limit order
  var margin: String = String()

  /// the amount of the quantity remaining fillable
  var fillable: String = String()

  /// trigger_price is the trigger price used by stop/take orders
  var triggerPrice: String = String()

  var orderHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _orderInfo: Injective_Exchange_V1beta1_OrderInfo? = nil
}

/// A valid Derivative market order with Metadata.
struct Injective_Exchange_V1beta1_DerivativeMarketOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// order_info contains the information of the order
  var orderInfo: Injective_Exchange_V1beta1_OrderInfo {
    get {return _orderInfo ?? Injective_Exchange_V1beta1_OrderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  /// order types
  var orderType: Injective_Exchange_V1beta1_OrderType = .unspecified

  var margin: String = String()

  var marginHold: String = String()

  /// trigger_price is the trigger price used by stop/take orders
  var triggerPrice: String = String()

  var orderHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _orderInfo: Injective_Exchange_V1beta1_OrderInfo? = nil
}

struct Injective_Exchange_V1beta1_Position {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isLong: Bool = false

  var quantity: String = String()

  var entryPrice: String = String()

  var margin: String = String()

  var cumulativeFundingEntry: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_MarketOrderIndicator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// market_id represents the unique ID of the market
  var marketID: String = String()

  var isBuy: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradeLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var quantity: String = String()

  var price: String = String()

  /// bytes32 subaccount ID that executed the trade
  var subaccountID: Data = Data()

  var fee: String = String()

  var orderHash: Data = Data()

  var feeRecipientAddress: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_PositionDelta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isLong: Bool = false

  var executionQuantity: String = String()

  var executionMargin: String = String()

  var executionPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_DerivativeTradeLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: Data = Data()

  var positionDelta: Injective_Exchange_V1beta1_PositionDelta {
    get {return _positionDelta ?? Injective_Exchange_V1beta1_PositionDelta()}
    set {_positionDelta = newValue}
  }
  /// Returns true if `positionDelta` has been explicitly set.
  var hasPositionDelta: Bool {return self._positionDelta != nil}
  /// Clears the value of `positionDelta`. Subsequent reads from it will return its default value.
  mutating func clearPositionDelta() {self._positionDelta = nil}

  var payout: String = String()

  var fee: String = String()

  var orderHash: Data = Data()

  var feeRecipientAddress: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _positionDelta: Injective_Exchange_V1beta1_PositionDelta? = nil
}

struct Injective_Exchange_V1beta1_SubaccountPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var position: Injective_Exchange_V1beta1_Position {
    get {return _position ?? Injective_Exchange_V1beta1_Position()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var subaccountID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: Injective_Exchange_V1beta1_Position? = nil
}

struct Injective_Exchange_V1beta1_SubaccountDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: Data = Data()

  var deposit: Injective_Exchange_V1beta1_Deposit {
    get {return _deposit ?? Injective_Exchange_V1beta1_Deposit()}
    set {_deposit = newValue}
  }
  /// Returns true if `deposit` has been explicitly set.
  var hasDeposit: Bool {return self._deposit != nil}
  /// Clears the value of `deposit`. Subsequent reads from it will return its default value.
  mutating func clearDeposit() {self._deposit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deposit: Injective_Exchange_V1beta1_Deposit? = nil
}

struct Injective_Exchange_V1beta1_DepositUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var deposits: [Injective_Exchange_V1beta1_SubaccountDeposit] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_PointsMultiplier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var makerPointsMultiplier: String = String()

  var takerPointsMultiplier: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var boostedSpotMarketIds: [String] = []

  var spotMarketMultipliers: [Injective_Exchange_V1beta1_PointsMultiplier] = []

  var boostedDerivativeMarketIds: [String] = []

  var derivativeMarketMultipliers: [Injective_Exchange_V1beta1_PointsMultiplier] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_CampaignRewardPool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startTimestamp: Int64 = 0

  /// max_campaign_rewards are the maximum reward amounts to be disbursed at the
  /// end of the campaign
  var maxCampaignRewards: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradingRewardCampaignInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// number of seconds of the duration of each campaign
  var campaignDurationSeconds: Int64 = 0

  /// the trading fee quote denoms which will be counted for the rewards
  var quoteDenoms: [String] = []

  /// the optional boost info for markets
  var tradingRewardBoostInfo: Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo {
    get {return _tradingRewardBoostInfo ?? Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo()}
    set {_tradingRewardBoostInfo = newValue}
  }
  /// Returns true if `tradingRewardBoostInfo` has been explicitly set.
  var hasTradingRewardBoostInfo: Bool {return self._tradingRewardBoostInfo != nil}
  /// Clears the value of `tradingRewardBoostInfo`. Subsequent reads from it will return its default value.
  mutating func clearTradingRewardBoostInfo() {self._tradingRewardBoostInfo = nil}

  /// the marketIDs which are disqualified from being rewarded
  var disqualifiedMarketIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tradingRewardBoostInfo: Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo? = nil
}

struct Injective_Exchange_V1beta1_FeeDiscountTierInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var makerDiscountRate: String = String()

  var takerDiscountRate: String = String()

  var stakedAmount: String = String()

  var volume: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_FeeDiscountSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bucketCount: UInt64 = 0

  var bucketDuration: Int64 = 0

  /// the trading fee quote denoms which will be counted for the fee paid
  /// contribution
  var quoteDenoms: [String] = []

  /// the fee discount tiers
  var tierInfos: [Injective_Exchange_V1beta1_FeeDiscountTierInfo] = []

  /// the marketIDs which are disqualified from contributing to the fee paid
  /// amount
  var disqualifiedMarketIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_FeeDiscountTierTTL {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tier: UInt64 = 0

  var ttlTimestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_VolumeRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var makerVolume: String = String()

  var takerVolume: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_AccountRewards {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: String = String()

  var rewards: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradeRecords {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var latestTradeRecords: [Injective_Exchange_V1beta1_TradeRecord] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_SubaccountIDs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountIds: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradeRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: Int64 = 0

  var price: String = String()

  var quantity: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_Level {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// price
  var p: String = String()

  /// quantity
  var q: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_AggregateSubaccountVolumeRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var marketVolumes: [Injective_Exchange_V1beta1_MarketVolume] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_AggregateAccountVolumeRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: String = String()

  var marketVolumes: [Injective_Exchange_V1beta1_MarketVolume] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_MarketVolume {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var volume: Injective_Exchange_V1beta1_VolumeRecord {
    get {return _volume ?? Injective_Exchange_V1beta1_VolumeRecord()}
    set {_volume = newValue}
  }
  /// Returns true if `volume` has been explicitly set.
  var hasVolume: Bool {return self._volume != nil}
  /// Clears the value of `volume`. Subsequent reads from it will return its default value.
  mutating func clearVolume() {self._volume = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _volume: Injective_Exchange_V1beta1_VolumeRecord? = nil
}

struct Injective_Exchange_V1beta1_DenomDecimals {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var decimals: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Injective_Exchange_V1beta1_AtomicMarketOrderAccessLevel: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MarketStatus: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_OrderType: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_ExecutionType: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_OrderMask: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_Params: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MarketFeeMultiplier: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_DerivativeMarket: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_BinaryOptionsMarket: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_PerpetualMarketInfo: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_PerpetualMarketFunding: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_DerivativeMarketSettlementInfo: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_NextFundingTimestamp: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MidPriceAndTOB: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SpotMarket: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_Deposit: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SubaccountTradeNonce: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_OrderInfo: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SpotOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SpotLimitOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SpotMarketOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_DerivativeOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SubaccountOrderbookMetadata: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SubaccountOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SubaccountOrderData: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_DerivativeLimitOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_DerivativeMarketOrder: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_Position: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MarketOrderIndicator: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TradeLog: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_PositionDelta: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_DerivativeTradeLog: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SubaccountPosition: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SubaccountDeposit: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_DepositUpdate: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_PointsMultiplier: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_CampaignRewardPool: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TradingRewardCampaignInfo: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_FeeDiscountTierInfo: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_FeeDiscountSchedule: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_FeeDiscountTierTTL: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_VolumeRecord: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_AccountRewards: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TradeRecords: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_SubaccountIDs: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_TradeRecord: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_Level: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_AggregateSubaccountVolumeRecord: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_AggregateAccountVolumeRecord: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_MarketVolume: @unchecked Sendable {}
extension Injective_Exchange_V1beta1_DenomDecimals: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "injective.exchange.v1beta1"

extension Injective_Exchange_V1beta1_AtomicMarketOrderAccessLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Nobody"),
    1: .same(proto: "BeginBlockerSmartContractsOnly"),
    2: .same(proto: "SmartContractsOnly"),
    3: .same(proto: "Everyone"),
  ]
}

extension Injective_Exchange_V1beta1_MarketStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unspecified"),
    1: .same(proto: "Active"),
    2: .same(proto: "Paused"),
    3: .same(proto: "Demolished"),
    4: .same(proto: "Expired"),
  ]
}

extension Injective_Exchange_V1beta1_OrderType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "BUY"),
    2: .same(proto: "SELL"),
    3: .same(proto: "STOP_BUY"),
    4: .same(proto: "STOP_SELL"),
    5: .same(proto: "TAKE_BUY"),
    6: .same(proto: "TAKE_SELL"),
    7: .same(proto: "BUY_PO"),
    8: .same(proto: "SELL_PO"),
    9: .same(proto: "BUY_ATOMIC"),
    10: .same(proto: "SELL_ATOMIC"),
  ]
}

extension Injective_Exchange_V1beta1_ExecutionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnspecifiedExecutionType"),
    1: .same(proto: "Market"),
    2: .same(proto: "LimitFill"),
    3: .same(proto: "LimitMatchRestingOrder"),
    4: .same(proto: "LimitMatchNewOrder"),
    5: .same(proto: "MarketLiquidation"),
    6: .same(proto: "ExpiryMarketSettlement"),
  ]
}

extension Injective_Exchange_V1beta1_OrderMask: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNUSED"),
    1: .same(proto: "ANY"),
    2: .same(proto: "REGULAR"),
    4: .same(proto: "CONDITIONAL"),
    8: .same(proto: "DIRECTION_BUY_OR_HIGHER"),
    16: .same(proto: "DIRECTION_SELL_OR_LOWER"),
    32: .same(proto: "TYPE_MARKET"),
    64: .same(proto: "TYPE_LIMIT"),
  ]
}

extension Injective_Exchange_V1beta1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "spot_market_instant_listing_fee"),
    2: .standard(proto: "derivative_market_instant_listing_fee"),
    3: .standard(proto: "default_spot_maker_fee_rate"),
    4: .standard(proto: "default_spot_taker_fee_rate"),
    5: .standard(proto: "default_derivative_maker_fee_rate"),
    6: .standard(proto: "default_derivative_taker_fee_rate"),
    7: .standard(proto: "default_initial_margin_ratio"),
    8: .standard(proto: "default_maintenance_margin_ratio"),
    9: .standard(proto: "default_funding_interval"),
    10: .standard(proto: "funding_multiple"),
    11: .standard(proto: "relayer_fee_share_rate"),
    12: .standard(proto: "default_hourly_funding_rate_cap"),
    13: .standard(proto: "default_hourly_interest_rate"),
    14: .standard(proto: "max_derivative_order_side_count"),
    15: .standard(proto: "inj_reward_staked_requirement_threshold"),
    16: .standard(proto: "trading_rewards_vesting_duration"),
    17: .standard(proto: "liquidator_reward_share_rate"),
    18: .standard(proto: "binary_options_market_instant_listing_fee"),
    19: .standard(proto: "atomic_market_order_access_level"),
    20: .standard(proto: "spot_atomic_market_order_fee_multiplier"),
    21: .standard(proto: "derivative_atomic_market_order_fee_multiplier"),
    22: .standard(proto: "binary_options_atomic_market_order_fee_multiplier"),
    23: .standard(proto: "minimal_protocol_fee_rate"),
    24: .standard(proto: "is_instant_derivative_market_launch_enabled"),
  ]

  fileprivate class _StorageClass {
    var _spotMarketInstantListingFee: Cosmos_Base_V1beta1_Coin? = nil
    var _derivativeMarketInstantListingFee: Cosmos_Base_V1beta1_Coin? = nil
    var _defaultSpotMakerFeeRate: String = String()
    var _defaultSpotTakerFeeRate: String = String()
    var _defaultDerivativeMakerFeeRate: String = String()
    var _defaultDerivativeTakerFeeRate: String = String()
    var _defaultInitialMarginRatio: String = String()
    var _defaultMaintenanceMarginRatio: String = String()
    var _defaultFundingInterval: Int64 = 0
    var _fundingMultiple: Int64 = 0
    var _relayerFeeShareRate: String = String()
    var _defaultHourlyFundingRateCap: String = String()
    var _defaultHourlyInterestRate: String = String()
    var _maxDerivativeOrderSideCount: UInt32 = 0
    var _injRewardStakedRequirementThreshold: String = String()
    var _tradingRewardsVestingDuration: Int64 = 0
    var _liquidatorRewardShareRate: String = String()
    var _binaryOptionsMarketInstantListingFee: Cosmos_Base_V1beta1_Coin? = nil
    var _atomicMarketOrderAccessLevel: Injective_Exchange_V1beta1_AtomicMarketOrderAccessLevel = .nobody
    var _spotAtomicMarketOrderFeeMultiplier: String = String()
    var _derivativeAtomicMarketOrderFeeMultiplier: String = String()
    var _binaryOptionsAtomicMarketOrderFeeMultiplier: String = String()
    var _minimalProtocolFeeRate: String = String()
    var _isInstantDerivativeMarketLaunchEnabled: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _spotMarketInstantListingFee = source._spotMarketInstantListingFee
      _derivativeMarketInstantListingFee = source._derivativeMarketInstantListingFee
      _defaultSpotMakerFeeRate = source._defaultSpotMakerFeeRate
      _defaultSpotTakerFeeRate = source._defaultSpotTakerFeeRate
      _defaultDerivativeMakerFeeRate = source._defaultDerivativeMakerFeeRate
      _defaultDerivativeTakerFeeRate = source._defaultDerivativeTakerFeeRate
      _defaultInitialMarginRatio = source._defaultInitialMarginRatio
      _defaultMaintenanceMarginRatio = source._defaultMaintenanceMarginRatio
      _defaultFundingInterval = source._defaultFundingInterval
      _fundingMultiple = source._fundingMultiple
      _relayerFeeShareRate = source._relayerFeeShareRate
      _defaultHourlyFundingRateCap = source._defaultHourlyFundingRateCap
      _defaultHourlyInterestRate = source._defaultHourlyInterestRate
      _maxDerivativeOrderSideCount = source._maxDerivativeOrderSideCount
      _injRewardStakedRequirementThreshold = source._injRewardStakedRequirementThreshold
      _tradingRewardsVestingDuration = source._tradingRewardsVestingDuration
      _liquidatorRewardShareRate = source._liquidatorRewardShareRate
      _binaryOptionsMarketInstantListingFee = source._binaryOptionsMarketInstantListingFee
      _atomicMarketOrderAccessLevel = source._atomicMarketOrderAccessLevel
      _spotAtomicMarketOrderFeeMultiplier = source._spotAtomicMarketOrderFeeMultiplier
      _derivativeAtomicMarketOrderFeeMultiplier = source._derivativeAtomicMarketOrderFeeMultiplier
      _binaryOptionsAtomicMarketOrderFeeMultiplier = source._binaryOptionsAtomicMarketOrderFeeMultiplier
      _minimalProtocolFeeRate = source._minimalProtocolFeeRate
      _isInstantDerivativeMarketLaunchEnabled = source._isInstantDerivativeMarketLaunchEnabled
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._spotMarketInstantListingFee) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._derivativeMarketInstantListingFee) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._defaultSpotMakerFeeRate) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._defaultSpotTakerFeeRate) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._defaultDerivativeMakerFeeRate) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._defaultDerivativeTakerFeeRate) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._defaultInitialMarginRatio) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._defaultMaintenanceMarginRatio) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._defaultFundingInterval) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._fundingMultiple) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._relayerFeeShareRate) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._defaultHourlyFundingRateCap) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._defaultHourlyInterestRate) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxDerivativeOrderSideCount) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._injRewardStakedRequirementThreshold) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._tradingRewardsVestingDuration) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._liquidatorRewardShareRate) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._binaryOptionsMarketInstantListingFee) }()
        case 19: try { try decoder.decodeSingularEnumField(value: &_storage._atomicMarketOrderAccessLevel) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._spotAtomicMarketOrderFeeMultiplier) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._derivativeAtomicMarketOrderFeeMultiplier) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._binaryOptionsAtomicMarketOrderFeeMultiplier) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._minimalProtocolFeeRate) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._isInstantDerivativeMarketLaunchEnabled) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._spotMarketInstantListingFee {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._derivativeMarketInstantListingFee {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._defaultSpotMakerFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultSpotMakerFeeRate, fieldNumber: 3)
      }
      if !_storage._defaultSpotTakerFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultSpotTakerFeeRate, fieldNumber: 4)
      }
      if !_storage._defaultDerivativeMakerFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultDerivativeMakerFeeRate, fieldNumber: 5)
      }
      if !_storage._defaultDerivativeTakerFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultDerivativeTakerFeeRate, fieldNumber: 6)
      }
      if !_storage._defaultInitialMarginRatio.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultInitialMarginRatio, fieldNumber: 7)
      }
      if !_storage._defaultMaintenanceMarginRatio.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultMaintenanceMarginRatio, fieldNumber: 8)
      }
      if _storage._defaultFundingInterval != 0 {
        try visitor.visitSingularInt64Field(value: _storage._defaultFundingInterval, fieldNumber: 9)
      }
      if _storage._fundingMultiple != 0 {
        try visitor.visitSingularInt64Field(value: _storage._fundingMultiple, fieldNumber: 10)
      }
      if !_storage._relayerFeeShareRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._relayerFeeShareRate, fieldNumber: 11)
      }
      if !_storage._defaultHourlyFundingRateCap.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultHourlyFundingRateCap, fieldNumber: 12)
      }
      if !_storage._defaultHourlyInterestRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultHourlyInterestRate, fieldNumber: 13)
      }
      if _storage._maxDerivativeOrderSideCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxDerivativeOrderSideCount, fieldNumber: 14)
      }
      if !_storage._injRewardStakedRequirementThreshold.isEmpty {
        try visitor.visitSingularStringField(value: _storage._injRewardStakedRequirementThreshold, fieldNumber: 15)
      }
      if _storage._tradingRewardsVestingDuration != 0 {
        try visitor.visitSingularInt64Field(value: _storage._tradingRewardsVestingDuration, fieldNumber: 16)
      }
      if !_storage._liquidatorRewardShareRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._liquidatorRewardShareRate, fieldNumber: 17)
      }
      try { if let v = _storage._binaryOptionsMarketInstantListingFee {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if _storage._atomicMarketOrderAccessLevel != .nobody {
        try visitor.visitSingularEnumField(value: _storage._atomicMarketOrderAccessLevel, fieldNumber: 19)
      }
      if !_storage._spotAtomicMarketOrderFeeMultiplier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._spotAtomicMarketOrderFeeMultiplier, fieldNumber: 20)
      }
      if !_storage._derivativeAtomicMarketOrderFeeMultiplier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._derivativeAtomicMarketOrderFeeMultiplier, fieldNumber: 21)
      }
      if !_storage._binaryOptionsAtomicMarketOrderFeeMultiplier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._binaryOptionsAtomicMarketOrderFeeMultiplier, fieldNumber: 22)
      }
      if !_storage._minimalProtocolFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minimalProtocolFeeRate, fieldNumber: 23)
      }
      if _storage._isInstantDerivativeMarketLaunchEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._isInstantDerivativeMarketLaunchEnabled, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_Params, rhs: Injective_Exchange_V1beta1_Params) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._spotMarketInstantListingFee != rhs_storage._spotMarketInstantListingFee {return false}
        if _storage._derivativeMarketInstantListingFee != rhs_storage._derivativeMarketInstantListingFee {return false}
        if _storage._defaultSpotMakerFeeRate != rhs_storage._defaultSpotMakerFeeRate {return false}
        if _storage._defaultSpotTakerFeeRate != rhs_storage._defaultSpotTakerFeeRate {return false}
        if _storage._defaultDerivativeMakerFeeRate != rhs_storage._defaultDerivativeMakerFeeRate {return false}
        if _storage._defaultDerivativeTakerFeeRate != rhs_storage._defaultDerivativeTakerFeeRate {return false}
        if _storage._defaultInitialMarginRatio != rhs_storage._defaultInitialMarginRatio {return false}
        if _storage._defaultMaintenanceMarginRatio != rhs_storage._defaultMaintenanceMarginRatio {return false}
        if _storage._defaultFundingInterval != rhs_storage._defaultFundingInterval {return false}
        if _storage._fundingMultiple != rhs_storage._fundingMultiple {return false}
        if _storage._relayerFeeShareRate != rhs_storage._relayerFeeShareRate {return false}
        if _storage._defaultHourlyFundingRateCap != rhs_storage._defaultHourlyFundingRateCap {return false}
        if _storage._defaultHourlyInterestRate != rhs_storage._defaultHourlyInterestRate {return false}
        if _storage._maxDerivativeOrderSideCount != rhs_storage._maxDerivativeOrderSideCount {return false}
        if _storage._injRewardStakedRequirementThreshold != rhs_storage._injRewardStakedRequirementThreshold {return false}
        if _storage._tradingRewardsVestingDuration != rhs_storage._tradingRewardsVestingDuration {return false}
        if _storage._liquidatorRewardShareRate != rhs_storage._liquidatorRewardShareRate {return false}
        if _storage._binaryOptionsMarketInstantListingFee != rhs_storage._binaryOptionsMarketInstantListingFee {return false}
        if _storage._atomicMarketOrderAccessLevel != rhs_storage._atomicMarketOrderAccessLevel {return false}
        if _storage._spotAtomicMarketOrderFeeMultiplier != rhs_storage._spotAtomicMarketOrderFeeMultiplier {return false}
        if _storage._derivativeAtomicMarketOrderFeeMultiplier != rhs_storage._derivativeAtomicMarketOrderFeeMultiplier {return false}
        if _storage._binaryOptionsAtomicMarketOrderFeeMultiplier != rhs_storage._binaryOptionsAtomicMarketOrderFeeMultiplier {return false}
        if _storage._minimalProtocolFeeRate != rhs_storage._minimalProtocolFeeRate {return false}
        if _storage._isInstantDerivativeMarketLaunchEnabled != rhs_storage._isInstantDerivativeMarketLaunchEnabled {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MarketFeeMultiplier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MarketFeeMultiplier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "fee_multiplier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.feeMultiplier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.feeMultiplier.isEmpty {
      try visitor.visitSingularStringField(value: self.feeMultiplier, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MarketFeeMultiplier, rhs: Injective_Exchange_V1beta1_MarketFeeMultiplier) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.feeMultiplier != rhs.feeMultiplier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeMarket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeMarket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticker"),
    2: .standard(proto: "oracle_base"),
    3: .standard(proto: "oracle_quote"),
    4: .standard(proto: "oracle_type"),
    5: .standard(proto: "oracle_scale_factor"),
    6: .standard(proto: "quote_denom"),
    7: .standard(proto: "market_id"),
    8: .standard(proto: "initial_margin_ratio"),
    9: .standard(proto: "maintenance_margin_ratio"),
    10: .standard(proto: "maker_fee_rate"),
    11: .standard(proto: "taker_fee_rate"),
    12: .standard(proto: "relayer_fee_share_rate"),
    13: .same(proto: "isPerpetual"),
    14: .same(proto: "status"),
    15: .standard(proto: "min_price_tick_size"),
    16: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.oracleBase) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.oracleQuote) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.initialMarginRatio) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.maintenanceMarginRatio) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.relayerFeeShareRate) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.isPerpetual) }()
      case 14: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 1)
    }
    if !self.oracleBase.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleBase, fieldNumber: 2)
    }
    if !self.oracleQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleQuote, fieldNumber: 3)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 4)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 5)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 6)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 7)
    }
    if !self.initialMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.initialMarginRatio, fieldNumber: 8)
    }
    if !self.maintenanceMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.maintenanceMarginRatio, fieldNumber: 9)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 10)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 11)
    }
    if !self.relayerFeeShareRate.isEmpty {
      try visitor.visitSingularStringField(value: self.relayerFeeShareRate, fieldNumber: 12)
    }
    if self.isPerpetual != false {
      try visitor.visitSingularBoolField(value: self.isPerpetual, fieldNumber: 13)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 14)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 15)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeMarket, rhs: Injective_Exchange_V1beta1_DerivativeMarket) -> Bool {
    if lhs.ticker != rhs.ticker {return false}
    if lhs.oracleBase != rhs.oracleBase {return false}
    if lhs.oracleQuote != rhs.oracleQuote {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.initialMarginRatio != rhs.initialMarginRatio {return false}
    if lhs.maintenanceMarginRatio != rhs.maintenanceMarginRatio {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.relayerFeeShareRate != rhs.relayerFeeShareRate {return false}
    if lhs.isPerpetual != rhs.isPerpetual {return false}
    if lhs.status != rhs.status {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_BinaryOptionsMarket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BinaryOptionsMarket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticker"),
    2: .standard(proto: "oracle_symbol"),
    3: .standard(proto: "oracle_provider"),
    4: .standard(proto: "oracle_type"),
    5: .standard(proto: "oracle_scale_factor"),
    6: .standard(proto: "expiration_timestamp"),
    7: .standard(proto: "settlement_timestamp"),
    8: .same(proto: "admin"),
    9: .standard(proto: "quote_denom"),
    10: .standard(proto: "market_id"),
    11: .standard(proto: "maker_fee_rate"),
    12: .standard(proto: "taker_fee_rate"),
    13: .standard(proto: "relayer_fee_share_rate"),
    14: .same(proto: "status"),
    15: .standard(proto: "min_price_tick_size"),
    16: .standard(proto: "min_quantity_tick_size"),
    17: .standard(proto: "settlement_price"),
  ]

  fileprivate class _StorageClass {
    var _ticker: String = String()
    var _oracleSymbol: String = String()
    var _oracleProvider: String = String()
    var _oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified
    var _oracleScaleFactor: UInt32 = 0
    var _expirationTimestamp: Int64 = 0
    var _settlementTimestamp: Int64 = 0
    var _admin: String = String()
    var _quoteDenom: String = String()
    var _marketID: String = String()
    var _makerFeeRate: String = String()
    var _takerFeeRate: String = String()
    var _relayerFeeShareRate: String = String()
    var _status: Injective_Exchange_V1beta1_MarketStatus = .unspecified
    var _minPriceTickSize: String = String()
    var _minQuantityTickSize: String = String()
    var _settlementPrice: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ticker = source._ticker
      _oracleSymbol = source._oracleSymbol
      _oracleProvider = source._oracleProvider
      _oracleType = source._oracleType
      _oracleScaleFactor = source._oracleScaleFactor
      _expirationTimestamp = source._expirationTimestamp
      _settlementTimestamp = source._settlementTimestamp
      _admin = source._admin
      _quoteDenom = source._quoteDenom
      _marketID = source._marketID
      _makerFeeRate = source._makerFeeRate
      _takerFeeRate = source._takerFeeRate
      _relayerFeeShareRate = source._relayerFeeShareRate
      _status = source._status
      _minPriceTickSize = source._minPriceTickSize
      _minQuantityTickSize = source._minQuantityTickSize
      _settlementPrice = source._settlementPrice
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._ticker) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._oracleSymbol) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._oracleProvider) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._oracleType) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._oracleScaleFactor) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._expirationTimestamp) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._settlementTimestamp) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._admin) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._quoteDenom) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._marketID) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._makerFeeRate) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._takerFeeRate) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._relayerFeeShareRate) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._minPriceTickSize) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._minQuantityTickSize) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._settlementPrice) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._ticker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticker, fieldNumber: 1)
      }
      if !_storage._oracleSymbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._oracleSymbol, fieldNumber: 2)
      }
      if !_storage._oracleProvider.isEmpty {
        try visitor.visitSingularStringField(value: _storage._oracleProvider, fieldNumber: 3)
      }
      if _storage._oracleType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._oracleType, fieldNumber: 4)
      }
      if _storage._oracleScaleFactor != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._oracleScaleFactor, fieldNumber: 5)
      }
      if _storage._expirationTimestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._expirationTimestamp, fieldNumber: 6)
      }
      if _storage._settlementTimestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._settlementTimestamp, fieldNumber: 7)
      }
      if !_storage._admin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._admin, fieldNumber: 8)
      }
      if !_storage._quoteDenom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._quoteDenom, fieldNumber: 9)
      }
      if !_storage._marketID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._marketID, fieldNumber: 10)
      }
      if !_storage._makerFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._makerFeeRate, fieldNumber: 11)
      }
      if !_storage._takerFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._takerFeeRate, fieldNumber: 12)
      }
      if !_storage._relayerFeeShareRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._relayerFeeShareRate, fieldNumber: 13)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 14)
      }
      if !_storage._minPriceTickSize.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minPriceTickSize, fieldNumber: 15)
      }
      if !_storage._minQuantityTickSize.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minQuantityTickSize, fieldNumber: 16)
      }
      if !_storage._settlementPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._settlementPrice, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_BinaryOptionsMarket, rhs: Injective_Exchange_V1beta1_BinaryOptionsMarket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ticker != rhs_storage._ticker {return false}
        if _storage._oracleSymbol != rhs_storage._oracleSymbol {return false}
        if _storage._oracleProvider != rhs_storage._oracleProvider {return false}
        if _storage._oracleType != rhs_storage._oracleType {return false}
        if _storage._oracleScaleFactor != rhs_storage._oracleScaleFactor {return false}
        if _storage._expirationTimestamp != rhs_storage._expirationTimestamp {return false}
        if _storage._settlementTimestamp != rhs_storage._settlementTimestamp {return false}
        if _storage._admin != rhs_storage._admin {return false}
        if _storage._quoteDenom != rhs_storage._quoteDenom {return false}
        if _storage._marketID != rhs_storage._marketID {return false}
        if _storage._makerFeeRate != rhs_storage._makerFeeRate {return false}
        if _storage._takerFeeRate != rhs_storage._takerFeeRate {return false}
        if _storage._relayerFeeShareRate != rhs_storage._relayerFeeShareRate {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._minPriceTickSize != rhs_storage._minPriceTickSize {return false}
        if _storage._minQuantityTickSize != rhs_storage._minQuantityTickSize {return false}
        if _storage._settlementPrice != rhs_storage._settlementPrice {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpiryFuturesMarketInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "expiration_timestamp"),
    3: .standard(proto: "twap_start_timestamp"),
    4: .standard(proto: "expiration_twap_start_price_cumulative"),
    5: .standard(proto: "settlement_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expirationTimestamp) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.twapStartTimestamp) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.expirationTwapStartPriceCumulative) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.settlementPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.expirationTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationTimestamp, fieldNumber: 2)
    }
    if self.twapStartTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.twapStartTimestamp, fieldNumber: 3)
    }
    if !self.expirationTwapStartPriceCumulative.isEmpty {
      try visitor.visitSingularStringField(value: self.expirationTwapStartPriceCumulative, fieldNumber: 4)
    }
    if !self.settlementPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.settlementPrice, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo, rhs: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.expirationTimestamp != rhs.expirationTimestamp {return false}
    if lhs.twapStartTimestamp != rhs.twapStartTimestamp {return false}
    if lhs.expirationTwapStartPriceCumulative != rhs.expirationTwapStartPriceCumulative {return false}
    if lhs.settlementPrice != rhs.settlementPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PerpetualMarketInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PerpetualMarketInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "hourly_funding_rate_cap"),
    3: .standard(proto: "hourly_interest_rate"),
    4: .standard(proto: "next_funding_timestamp"),
    5: .standard(proto: "funding_interval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hourlyFundingRateCap) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hourlyInterestRate) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.nextFundingTimestamp) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.fundingInterval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.hourlyFundingRateCap.isEmpty {
      try visitor.visitSingularStringField(value: self.hourlyFundingRateCap, fieldNumber: 2)
    }
    if !self.hourlyInterestRate.isEmpty {
      try visitor.visitSingularStringField(value: self.hourlyInterestRate, fieldNumber: 3)
    }
    if self.nextFundingTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.nextFundingTimestamp, fieldNumber: 4)
    }
    if self.fundingInterval != 0 {
      try visitor.visitSingularInt64Field(value: self.fundingInterval, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PerpetualMarketInfo, rhs: Injective_Exchange_V1beta1_PerpetualMarketInfo) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.hourlyFundingRateCap != rhs.hourlyFundingRateCap {return false}
    if lhs.hourlyInterestRate != rhs.hourlyInterestRate {return false}
    if lhs.nextFundingTimestamp != rhs.nextFundingTimestamp {return false}
    if lhs.fundingInterval != rhs.fundingInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PerpetualMarketFunding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PerpetualMarketFunding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cumulative_funding"),
    2: .standard(proto: "cumulative_price"),
    3: .standard(proto: "last_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cumulativeFunding) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cumulativePrice) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.lastTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cumulativeFunding.isEmpty {
      try visitor.visitSingularStringField(value: self.cumulativeFunding, fieldNumber: 1)
    }
    if !self.cumulativePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.cumulativePrice, fieldNumber: 2)
    }
    if self.lastTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.lastTimestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PerpetualMarketFunding, rhs: Injective_Exchange_V1beta1_PerpetualMarketFunding) -> Bool {
    if lhs.cumulativeFunding != rhs.cumulativeFunding {return false}
    if lhs.cumulativePrice != rhs.cumulativePrice {return false}
    if lhs.lastTimestamp != rhs.lastTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeMarketSettlementInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeMarketSettlementInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "settlement_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.settlementPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.settlementPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.settlementPrice, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeMarketSettlementInfo, rhs: Injective_Exchange_V1beta1_DerivativeMarketSettlementInfo) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.settlementPrice != rhs.settlementPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_NextFundingTimestamp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NextFundingTimestamp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "next_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.nextTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nextTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.nextTimestamp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_NextFundingTimestamp, rhs: Injective_Exchange_V1beta1_NextFundingTimestamp) -> Bool {
    if lhs.nextTimestamp != rhs.nextTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MidPriceAndTOB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MidPriceAndTOB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mid_price"),
    2: .standard(proto: "best_buy_price"),
    3: .standard(proto: "best_sell_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.midPrice) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bestBuyPrice) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bestSellPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.midPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.midPrice, fieldNumber: 1)
    }
    if !self.bestBuyPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.bestBuyPrice, fieldNumber: 2)
    }
    if !self.bestSellPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.bestSellPrice, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MidPriceAndTOB, rhs: Injective_Exchange_V1beta1_MidPriceAndTOB) -> Bool {
    if lhs.midPrice != rhs.midPrice {return false}
    if lhs.bestBuyPrice != rhs.bestBuyPrice {return false}
    if lhs.bestSellPrice != rhs.bestSellPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotMarket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotMarket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticker"),
    2: .standard(proto: "base_denom"),
    3: .standard(proto: "quote_denom"),
    4: .standard(proto: "maker_fee_rate"),
    5: .standard(proto: "taker_fee_rate"),
    6: .standard(proto: "relayer_fee_share_rate"),
    7: .standard(proto: "market_id"),
    8: .same(proto: "status"),
    9: .standard(proto: "min_price_tick_size"),
    10: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.baseDenom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.relayerFeeShareRate) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 1)
    }
    if !self.baseDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.baseDenom, fieldNumber: 2)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 3)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 4)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 5)
    }
    if !self.relayerFeeShareRate.isEmpty {
      try visitor.visitSingularStringField(value: self.relayerFeeShareRate, fieldNumber: 6)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 7)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 8)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 9)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotMarket, rhs: Injective_Exchange_V1beta1_SpotMarket) -> Bool {
    if lhs.ticker != rhs.ticker {return false}
    if lhs.baseDenom != rhs.baseDenom {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.relayerFeeShareRate != rhs.relayerFeeShareRate {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_Deposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Deposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "available_balance"),
    2: .standard(proto: "total_balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.availableBalance) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.totalBalance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.availableBalance.isEmpty {
      try visitor.visitSingularStringField(value: self.availableBalance, fieldNumber: 1)
    }
    if !self.totalBalance.isEmpty {
      try visitor.visitSingularStringField(value: self.totalBalance, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_Deposit, rhs: Injective_Exchange_V1beta1_Deposit) -> Bool {
    if lhs.availableBalance != rhs.availableBalance {return false}
    if lhs.totalBalance != rhs.totalBalance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountTradeNonce: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountTradeNonce"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonce != 0 {
      try visitor.visitSingularUInt32Field(value: self.nonce, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountTradeNonce, rhs: Injective_Exchange_V1beta1_SubaccountTradeNonce) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_OrderInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "fee_recipient"),
    3: .same(proto: "price"),
    4: .same(proto: "quantity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.feeRecipient) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.feeRecipient.isEmpty {
      try visitor.visitSingularStringField(value: self.feeRecipient, fieldNumber: 2)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 3)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_OrderInfo, rhs: Injective_Exchange_V1beta1_OrderInfo) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.feeRecipient != rhs.feeRecipient {return false}
    if lhs.price != rhs.price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "order_info"),
    3: .standard(proto: "order_type"),
    4: .standard(proto: "trigger_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.triggerPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try { if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.orderType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 3)
    }
    if !self.triggerPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerPrice, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotOrder, rhs: Injective_Exchange_V1beta1_SpotOrder) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs.triggerPrice != rhs.triggerPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_info"),
    2: .standard(proto: "order_type"),
    3: .same(proto: "fillable"),
    4: .standard(proto: "trigger_price"),
    5: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fillable) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.triggerPrice) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.orderType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 2)
    }
    if !self.fillable.isEmpty {
      try visitor.visitSingularStringField(value: self.fillable, fieldNumber: 3)
    }
    if !self.triggerPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerPrice, fieldNumber: 4)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderHash, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotLimitOrder, rhs: Injective_Exchange_V1beta1_SpotLimitOrder) -> Bool {
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs.fillable != rhs.fillable {return false}
    if lhs.triggerPrice != rhs.triggerPrice {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotMarketOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotMarketOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_info"),
    2: .standard(proto: "balance_hold"),
    3: .standard(proto: "order_hash"),
    4: .standard(proto: "order_type"),
    5: .standard(proto: "trigger_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.balanceHold) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.orderHash) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.triggerPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.balanceHold.isEmpty {
      try visitor.visitSingularStringField(value: self.balanceHold, fieldNumber: 2)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderHash, fieldNumber: 3)
    }
    if self.orderType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 4)
    }
    if !self.triggerPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerPrice, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotMarketOrder, rhs: Injective_Exchange_V1beta1_SpotMarketOrder) -> Bool {
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.balanceHold != rhs.balanceHold {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs.triggerPrice != rhs.triggerPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "order_info"),
    3: .standard(proto: "order_type"),
    4: .same(proto: "margin"),
    5: .standard(proto: "trigger_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.margin) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.triggerPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try { if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.orderType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 3)
    }
    if !self.margin.isEmpty {
      try visitor.visitSingularStringField(value: self.margin, fieldNumber: 4)
    }
    if !self.triggerPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerPrice, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeOrder, rhs: Injective_Exchange_V1beta1_DerivativeOrder) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs.margin != rhs.margin {return false}
    if lhs.triggerPrice != rhs.triggerPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountOrderbookMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountOrderbookMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vanilla_limit_order_count"),
    2: .standard(proto: "reduce_only_limit_order_count"),
    3: .standard(proto: "aggregate_reduce_only_quantity"),
    4: .standard(proto: "aggregate_vanilla_quantity"),
    5: .standard(proto: "vanilla_conditional_order_count"),
    6: .standard(proto: "reduce_only_conditional_order_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.vanillaLimitOrderCount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.reduceOnlyLimitOrderCount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.aggregateReduceOnlyQuantity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.aggregateVanillaQuantity) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.vanillaConditionalOrderCount) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.reduceOnlyConditionalOrderCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vanillaLimitOrderCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.vanillaLimitOrderCount, fieldNumber: 1)
    }
    if self.reduceOnlyLimitOrderCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.reduceOnlyLimitOrderCount, fieldNumber: 2)
    }
    if !self.aggregateReduceOnlyQuantity.isEmpty {
      try visitor.visitSingularStringField(value: self.aggregateReduceOnlyQuantity, fieldNumber: 3)
    }
    if !self.aggregateVanillaQuantity.isEmpty {
      try visitor.visitSingularStringField(value: self.aggregateVanillaQuantity, fieldNumber: 4)
    }
    if self.vanillaConditionalOrderCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.vanillaConditionalOrderCount, fieldNumber: 5)
    }
    if self.reduceOnlyConditionalOrderCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.reduceOnlyConditionalOrderCount, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountOrderbookMetadata, rhs: Injective_Exchange_V1beta1_SubaccountOrderbookMetadata) -> Bool {
    if lhs.vanillaLimitOrderCount != rhs.vanillaLimitOrderCount {return false}
    if lhs.reduceOnlyLimitOrderCount != rhs.reduceOnlyLimitOrderCount {return false}
    if lhs.aggregateReduceOnlyQuantity != rhs.aggregateReduceOnlyQuantity {return false}
    if lhs.aggregateVanillaQuantity != rhs.aggregateVanillaQuantity {return false}
    if lhs.vanillaConditionalOrderCount != rhs.vanillaConditionalOrderCount {return false}
    if lhs.reduceOnlyConditionalOrderCount != rhs.reduceOnlyConditionalOrderCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "quantity"),
    3: .same(proto: "isReduceOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isReduceOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 1)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 2)
    }
    if self.isReduceOnly != false {
      try visitor.visitSingularBoolField(value: self.isReduceOnly, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountOrder, rhs: Injective_Exchange_V1beta1_SubaccountOrder) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.isReduceOnly != rhs.isReduceOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountOrderData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountOrderData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "order"),
    2: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.orderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountOrderData, rhs: Injective_Exchange_V1beta1_SubaccountOrderData) -> Bool {
    if lhs._order != rhs._order {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_info"),
    2: .standard(proto: "order_type"),
    3: .same(proto: "margin"),
    4: .same(proto: "fillable"),
    5: .standard(proto: "trigger_price"),
    6: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.margin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fillable) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.triggerPrice) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.orderType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 2)
    }
    if !self.margin.isEmpty {
      try visitor.visitSingularStringField(value: self.margin, fieldNumber: 3)
    }
    if !self.fillable.isEmpty {
      try visitor.visitSingularStringField(value: self.fillable, fieldNumber: 4)
    }
    if !self.triggerPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerPrice, fieldNumber: 5)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderHash, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeLimitOrder, rhs: Injective_Exchange_V1beta1_DerivativeLimitOrder) -> Bool {
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs.margin != rhs.margin {return false}
    if lhs.fillable != rhs.fillable {return false}
    if lhs.triggerPrice != rhs.triggerPrice {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeMarketOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeMarketOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_info"),
    2: .standard(proto: "order_type"),
    3: .same(proto: "margin"),
    4: .standard(proto: "margin_hold"),
    5: .standard(proto: "trigger_price"),
    6: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.margin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.marginHold) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.triggerPrice) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.orderType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 2)
    }
    if !self.margin.isEmpty {
      try visitor.visitSingularStringField(value: self.margin, fieldNumber: 3)
    }
    if !self.marginHold.isEmpty {
      try visitor.visitSingularStringField(value: self.marginHold, fieldNumber: 4)
    }
    if !self.triggerPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerPrice, fieldNumber: 5)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderHash, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeMarketOrder, rhs: Injective_Exchange_V1beta1_DerivativeMarketOrder) -> Bool {
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs.margin != rhs.margin {return false}
    if lhs.marginHold != rhs.marginHold {return false}
    if lhs.triggerPrice != rhs.triggerPrice {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Position"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isLong"),
    2: .same(proto: "quantity"),
    3: .standard(proto: "entry_price"),
    4: .same(proto: "margin"),
    5: .standard(proto: "cumulative_funding_entry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isLong) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.entryPrice) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.margin) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.cumulativeFundingEntry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isLong != false {
      try visitor.visitSingularBoolField(value: self.isLong, fieldNumber: 1)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 2)
    }
    if !self.entryPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.entryPrice, fieldNumber: 3)
    }
    if !self.margin.isEmpty {
      try visitor.visitSingularStringField(value: self.margin, fieldNumber: 4)
    }
    if !self.cumulativeFundingEntry.isEmpty {
      try visitor.visitSingularStringField(value: self.cumulativeFundingEntry, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_Position, rhs: Injective_Exchange_V1beta1_Position) -> Bool {
    if lhs.isLong != rhs.isLong {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.entryPrice != rhs.entryPrice {return false}
    if lhs.margin != rhs.margin {return false}
    if lhs.cumulativeFundingEntry != rhs.cumulativeFundingEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MarketOrderIndicator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MarketOrderIndicator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "isBuy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isBuy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.isBuy != false {
      try visitor.visitSingularBoolField(value: self.isBuy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MarketOrderIndicator, rhs: Injective_Exchange_V1beta1_MarketOrderIndicator) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.isBuy != rhs.isBuy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradeLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradeLog"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quantity"),
    2: .same(proto: "price"),
    3: .standard(proto: "subaccount_id"),
    4: .same(proto: "fee"),
    5: .standard(proto: "order_hash"),
    6: .standard(proto: "fee_recipient_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.subaccountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fee) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.orderHash) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.feeRecipientAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 1)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 2)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subaccountID, fieldNumber: 3)
    }
    if !self.fee.isEmpty {
      try visitor.visitSingularStringField(value: self.fee, fieldNumber: 4)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderHash, fieldNumber: 5)
    }
    if !self.feeRecipientAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.feeRecipientAddress, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradeLog, rhs: Injective_Exchange_V1beta1_TradeLog) -> Bool {
    if lhs.quantity != rhs.quantity {return false}
    if lhs.price != rhs.price {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.feeRecipientAddress != rhs.feeRecipientAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PositionDelta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionDelta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_long"),
    2: .standard(proto: "execution_quantity"),
    3: .standard(proto: "execution_margin"),
    4: .standard(proto: "execution_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isLong) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.executionQuantity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.executionMargin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.executionPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isLong != false {
      try visitor.visitSingularBoolField(value: self.isLong, fieldNumber: 1)
    }
    if !self.executionQuantity.isEmpty {
      try visitor.visitSingularStringField(value: self.executionQuantity, fieldNumber: 2)
    }
    if !self.executionMargin.isEmpty {
      try visitor.visitSingularStringField(value: self.executionMargin, fieldNumber: 3)
    }
    if !self.executionPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.executionPrice, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PositionDelta, rhs: Injective_Exchange_V1beta1_PositionDelta) -> Bool {
    if lhs.isLong != rhs.isLong {return false}
    if lhs.executionQuantity != rhs.executionQuantity {return false}
    if lhs.executionMargin != rhs.executionMargin {return false}
    if lhs.executionPrice != rhs.executionPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeTradeLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeTradeLog"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "position_delta"),
    3: .same(proto: "payout"),
    4: .same(proto: "fee"),
    5: .standard(proto: "order_hash"),
    6: .standard(proto: "fee_recipient_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._positionDelta) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.payout) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fee) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.orderHash) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.feeRecipientAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subaccountID, fieldNumber: 1)
    }
    try { if let v = self._positionDelta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.payout.isEmpty {
      try visitor.visitSingularStringField(value: self.payout, fieldNumber: 3)
    }
    if !self.fee.isEmpty {
      try visitor.visitSingularStringField(value: self.fee, fieldNumber: 4)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderHash, fieldNumber: 5)
    }
    if !self.feeRecipientAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.feeRecipientAddress, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeTradeLog, rhs: Injective_Exchange_V1beta1_DerivativeTradeLog) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs._positionDelta != rhs._positionDelta {return false}
    if lhs.payout != rhs.payout {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.feeRecipientAddress != rhs.feeRecipientAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountPosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .standard(proto: "subaccount_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.subaccountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subaccountID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountPosition, rhs: Injective_Exchange_V1beta1_SubaccountPosition) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .same(proto: "deposit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deposit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subaccountID, fieldNumber: 1)
    }
    try { if let v = self._deposit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountDeposit, rhs: Injective_Exchange_V1beta1_SubaccountDeposit) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs._deposit != rhs._deposit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DepositUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DepositUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "deposits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.deposits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.deposits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deposits, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DepositUpdate, rhs: Injective_Exchange_V1beta1_DepositUpdate) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.deposits != rhs.deposits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PointsMultiplier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PointsMultiplier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "maker_points_multiplier"),
    2: .standard(proto: "taker_points_multiplier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.makerPointsMultiplier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.takerPointsMultiplier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.makerPointsMultiplier.isEmpty {
      try visitor.visitSingularStringField(value: self.makerPointsMultiplier, fieldNumber: 1)
    }
    if !self.takerPointsMultiplier.isEmpty {
      try visitor.visitSingularStringField(value: self.takerPointsMultiplier, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PointsMultiplier, rhs: Injective_Exchange_V1beta1_PointsMultiplier) -> Bool {
    if lhs.makerPointsMultiplier != rhs.makerPointsMultiplier {return false}
    if lhs.takerPointsMultiplier != rhs.takerPointsMultiplier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingRewardCampaignBoostInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "boosted_spot_market_ids"),
    2: .standard(proto: "spot_market_multipliers"),
    3: .standard(proto: "boosted_derivative_market_ids"),
    4: .standard(proto: "derivative_market_multipliers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.boostedSpotMarketIds) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.spotMarketMultipliers) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.boostedDerivativeMarketIds) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.derivativeMarketMultipliers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.boostedSpotMarketIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.boostedSpotMarketIds, fieldNumber: 1)
    }
    if !self.spotMarketMultipliers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spotMarketMultipliers, fieldNumber: 2)
    }
    if !self.boostedDerivativeMarketIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.boostedDerivativeMarketIds, fieldNumber: 3)
    }
    if !self.derivativeMarketMultipliers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.derivativeMarketMultipliers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo, rhs: Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo) -> Bool {
    if lhs.boostedSpotMarketIds != rhs.boostedSpotMarketIds {return false}
    if lhs.spotMarketMultipliers != rhs.spotMarketMultipliers {return false}
    if lhs.boostedDerivativeMarketIds != rhs.boostedDerivativeMarketIds {return false}
    if lhs.derivativeMarketMultipliers != rhs.derivativeMarketMultipliers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_CampaignRewardPool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CampaignRewardPool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_timestamp"),
    2: .standard(proto: "max_campaign_rewards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startTimestamp) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.maxCampaignRewards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimestamp, fieldNumber: 1)
    }
    if !self.maxCampaignRewards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.maxCampaignRewards, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_CampaignRewardPool, rhs: Injective_Exchange_V1beta1_CampaignRewardPool) -> Bool {
    if lhs.startTimestamp != rhs.startTimestamp {return false}
    if lhs.maxCampaignRewards != rhs.maxCampaignRewards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradingRewardCampaignInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingRewardCampaignInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "campaign_duration_seconds"),
    2: .standard(proto: "quote_denoms"),
    3: .standard(proto: "trading_reward_boost_info"),
    4: .standard(proto: "disqualified_market_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.campaignDurationSeconds) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.quoteDenoms) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tradingRewardBoostInfo) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.disqualifiedMarketIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.campaignDurationSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.campaignDurationSeconds, fieldNumber: 1)
    }
    if !self.quoteDenoms.isEmpty {
      try visitor.visitRepeatedStringField(value: self.quoteDenoms, fieldNumber: 2)
    }
    try { if let v = self._tradingRewardBoostInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.disqualifiedMarketIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.disqualifiedMarketIds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradingRewardCampaignInfo, rhs: Injective_Exchange_V1beta1_TradingRewardCampaignInfo) -> Bool {
    if lhs.campaignDurationSeconds != rhs.campaignDurationSeconds {return false}
    if lhs.quoteDenoms != rhs.quoteDenoms {return false}
    if lhs._tradingRewardBoostInfo != rhs._tradingRewardBoostInfo {return false}
    if lhs.disqualifiedMarketIds != rhs.disqualifiedMarketIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FeeDiscountTierInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeDiscountTierInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "maker_discount_rate"),
    2: .standard(proto: "taker_discount_rate"),
    3: .standard(proto: "staked_amount"),
    4: .same(proto: "volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.makerDiscountRate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.takerDiscountRate) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.stakedAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.volume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.makerDiscountRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerDiscountRate, fieldNumber: 1)
    }
    if !self.takerDiscountRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerDiscountRate, fieldNumber: 2)
    }
    if !self.stakedAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.stakedAmount, fieldNumber: 3)
    }
    if !self.volume.isEmpty {
      try visitor.visitSingularStringField(value: self.volume, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FeeDiscountTierInfo, rhs: Injective_Exchange_V1beta1_FeeDiscountTierInfo) -> Bool {
    if lhs.makerDiscountRate != rhs.makerDiscountRate {return false}
    if lhs.takerDiscountRate != rhs.takerDiscountRate {return false}
    if lhs.stakedAmount != rhs.stakedAmount {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FeeDiscountSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeDiscountSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bucket_count"),
    2: .standard(proto: "bucket_duration"),
    3: .standard(proto: "quote_denoms"),
    4: .standard(proto: "tier_infos"),
    5: .standard(proto: "disqualified_market_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.bucketCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.bucketDuration) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.quoteDenoms) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tierInfos) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.disqualifiedMarketIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bucketCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.bucketCount, fieldNumber: 1)
    }
    if self.bucketDuration != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketDuration, fieldNumber: 2)
    }
    if !self.quoteDenoms.isEmpty {
      try visitor.visitRepeatedStringField(value: self.quoteDenoms, fieldNumber: 3)
    }
    if !self.tierInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tierInfos, fieldNumber: 4)
    }
    if !self.disqualifiedMarketIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.disqualifiedMarketIds, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FeeDiscountSchedule, rhs: Injective_Exchange_V1beta1_FeeDiscountSchedule) -> Bool {
    if lhs.bucketCount != rhs.bucketCount {return false}
    if lhs.bucketDuration != rhs.bucketDuration {return false}
    if lhs.quoteDenoms != rhs.quoteDenoms {return false}
    if lhs.tierInfos != rhs.tierInfos {return false}
    if lhs.disqualifiedMarketIds != rhs.disqualifiedMarketIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FeeDiscountTierTTL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeDiscountTierTTL"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tier"),
    2: .standard(proto: "ttl_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.tier) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.ttlTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tier != 0 {
      try visitor.visitSingularUInt64Field(value: self.tier, fieldNumber: 1)
    }
    if self.ttlTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.ttlTimestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FeeDiscountTierTTL, rhs: Injective_Exchange_V1beta1_FeeDiscountTierTTL) -> Bool {
    if lhs.tier != rhs.tier {return false}
    if lhs.ttlTimestamp != rhs.ttlTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_VolumeRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VolumeRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "maker_volume"),
    2: .standard(proto: "taker_volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.makerVolume) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.takerVolume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.makerVolume.isEmpty {
      try visitor.visitSingularStringField(value: self.makerVolume, fieldNumber: 1)
    }
    if !self.takerVolume.isEmpty {
      try visitor.visitSingularStringField(value: self.takerVolume, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_VolumeRecord, rhs: Injective_Exchange_V1beta1_VolumeRecord) -> Bool {
    if lhs.makerVolume != rhs.makerVolume {return false}
    if lhs.takerVolume != rhs.takerVolume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_AccountRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "rewards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rewards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.rewards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rewards, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_AccountRewards, rhs: Injective_Exchange_V1beta1_AccountRewards) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.rewards != rhs.rewards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradeRecords: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradeRecords"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "latest_trade_records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.latestTradeRecords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.latestTradeRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.latestTradeRecords, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradeRecords, rhs: Injective_Exchange_V1beta1_TradeRecords) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.latestTradeRecords != rhs.latestTradeRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountIDs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountIDs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.subaccountIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountIds.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.subaccountIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountIDs, rhs: Injective_Exchange_V1beta1_SubaccountIDs) -> Bool {
    if lhs.subaccountIds != rhs.subaccountIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradeRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradeRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "price"),
    3: .same(proto: "quantity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 2)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradeRecord, rhs: Injective_Exchange_V1beta1_TradeRecord) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.price != rhs.price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_Level: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Level"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "p"),
    2: .same(proto: "q"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.p) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.q) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.p.isEmpty {
      try visitor.visitSingularStringField(value: self.p, fieldNumber: 1)
    }
    if !self.q.isEmpty {
      try visitor.visitSingularStringField(value: self.q, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_Level, rhs: Injective_Exchange_V1beta1_Level) -> Bool {
    if lhs.p != rhs.p {return false}
    if lhs.q != rhs.q {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_AggregateSubaccountVolumeRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AggregateSubaccountVolumeRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "market_volumes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.marketVolumes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.marketVolumes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.marketVolumes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_AggregateSubaccountVolumeRecord, rhs: Injective_Exchange_V1beta1_AggregateSubaccountVolumeRecord) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.marketVolumes != rhs.marketVolumes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_AggregateAccountVolumeRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AggregateAccountVolumeRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "market_volumes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.marketVolumes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.marketVolumes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.marketVolumes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_AggregateAccountVolumeRecord, rhs: Injective_Exchange_V1beta1_AggregateAccountVolumeRecord) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.marketVolumes != rhs.marketVolumes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MarketVolume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MarketVolume"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._volume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    try { if let v = self._volume {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MarketVolume, rhs: Injective_Exchange_V1beta1_MarketVolume) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._volume != rhs._volume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DenomDecimals: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DenomDecimals"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "decimals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.decimals) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.decimals != 0 {
      try visitor.visitSingularUInt64Field(value: self.decimals, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DenomDecimals, rhs: Injective_Exchange_V1beta1_DenomDecimals) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
