// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ethermint/evm/v1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryAccountRequest is the request type for the Query/Account RPC method.
struct Ethermint_Evm_V1_QueryAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the ethereum hex address to query the account for.
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountResponse is the response type for the Query/Account RPC method.
struct Ethermint_Evm_V1_QueryAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// balance is the balance of the EVM denomination.
  var balance: String = String()

  /// code_hash is the hex-formatted code bytes from the EOA.
  var codeHash: String = String()

  /// nonce is the account's sequence number.
  var nonce: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCosmosAccountRequest is the request type for the Query/CosmosAccount RPC
/// method.
struct Ethermint_Evm_V1_QueryCosmosAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the ethereum hex address to query the account for.
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCosmosAccountResponse is the response type for the Query/CosmosAccount
/// RPC method.
struct Ethermint_Evm_V1_QueryCosmosAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// cosmos_address is the cosmos address of the account.
  var cosmosAddress: String = String()

  /// sequence is the account's sequence number.
  var sequence: UInt64 = 0

  /// account_number is the account number
  var accountNumber: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryValidatorAccountRequest is the request type for the
/// Query/ValidatorAccount RPC method.
struct Ethermint_Evm_V1_QueryValidatorAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// cons_address is the validator cons address to query the account for.
  var consAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryValidatorAccountResponse is the response type for the
/// Query/ValidatorAccount RPC method.
struct Ethermint_Evm_V1_QueryValidatorAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// account_address is the cosmos address of the account in bech32 format.
  var accountAddress: String = String()

  /// sequence is the account's sequence number.
  var sequence: UInt64 = 0

  /// account_number is the account number
  var accountNumber: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBalanceRequest is the request type for the Query/Balance RPC method.
struct Ethermint_Evm_V1_QueryBalanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the ethereum hex address to query the balance for.
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBalanceResponse is the response type for the Query/Balance RPC method.
struct Ethermint_Evm_V1_QueryBalanceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// balance is the balance of the EVM denomination.
  var balance: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryStorageRequest is the request type for the Query/Storage RPC method.
struct Ethermint_Evm_V1_QueryStorageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the ethereum hex address to query the storage state for.
  var address: String = String()

  /// key defines the key of the storage state
  var key: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryStorageResponse is the response type for the Query/Storage RPC
/// method.
struct Ethermint_Evm_V1_QueryStorageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// value defines the storage state value hash associated with the given key.
  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCodeRequest is the request type for the Query/Code RPC method.
struct Ethermint_Evm_V1_QueryCodeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the ethereum hex address to query the code for.
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCodeResponse is the response type for the Query/Code RPC
/// method.
struct Ethermint_Evm_V1_QueryCodeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// code represents the code bytes from an ethereum address.
  var code: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTxLogsRequest is the request type for the Query/TxLogs RPC method.
struct Ethermint_Evm_V1_QueryTxLogsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// hash is the ethereum transaction hex hash to query the logs for.
  var hash: String = String()

  /// pagination defines an optional pagination for the request.
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryTxLogsResponse is the response type for the Query/TxLogs RPC method.
struct Ethermint_Evm_V1_QueryTxLogsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// logs represents the ethereum logs generated from the given transaction.
  var logs: [Ethermint_Evm_V1_Log] = []

  /// pagination defines the pagination in the response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryParamsRequest defines the request type for querying x/evm parameters.
struct Ethermint_Evm_V1_QueryParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryParamsResponse defines the response type for querying x/evm parameters.
struct Ethermint_Evm_V1_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// params define the evm module parameters.
  var params: Ethermint_Evm_V1_Params {
    get {return _params ?? Ethermint_Evm_V1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Ethermint_Evm_V1_Params? = nil
}

/// EthCallRequest defines EthCall request
struct Ethermint_Evm_V1_EthCallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// args uses the same json format as the json rpc api.
  var args: Data = Data()

  /// gas_cap defines the default gas cap to be used
  var gasCap: UInt64 = 0

  /// proposer_address of the requested block in hex format
  var proposerAddress: Data = Data()

  /// chain_id is the eip155 chain id parsed from the requested block header
  var chainID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EstimateGasResponse defines EstimateGas response
struct Ethermint_Evm_V1_EstimateGasResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// gas returns the estimated gas
  var gas: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTraceTxRequest defines TraceTx request
struct Ethermint_Evm_V1_QueryTraceTxRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// msg is the MsgEthereumTx for the requested transaction
  var msg: Ethermint_Evm_V1_MsgEthereumTx {
    get {return _storage._msg ?? Ethermint_Evm_V1_MsgEthereumTx()}
    set {_uniqueStorage()._msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  var hasMsg: Bool {return _storage._msg != nil}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  mutating func clearMsg() {_uniqueStorage()._msg = nil}

  /// trace_config holds extra parameters to trace functions.
  var traceConfig: Ethermint_Evm_V1_TraceConfig {
    get {return _storage._traceConfig ?? Ethermint_Evm_V1_TraceConfig()}
    set {_uniqueStorage()._traceConfig = newValue}
  }
  /// Returns true if `traceConfig` has been explicitly set.
  var hasTraceConfig: Bool {return _storage._traceConfig != nil}
  /// Clears the value of `traceConfig`. Subsequent reads from it will return its default value.
  mutating func clearTraceConfig() {_uniqueStorage()._traceConfig = nil}

  /// predecessors is an array of transactions included in the same block
  /// need to be replayed first to get correct context for tracing.
  var predecessors: [Ethermint_Evm_V1_MsgEthereumTx] {
    get {return _storage._predecessors}
    set {_uniqueStorage()._predecessors = newValue}
  }

  /// block_number of requested transaction
  var blockNumber: Int64 {
    get {return _storage._blockNumber}
    set {_uniqueStorage()._blockNumber = newValue}
  }

  /// block_hash of requested transaction
  var blockHash: String {
    get {return _storage._blockHash}
    set {_uniqueStorage()._blockHash = newValue}
  }

  /// block_time of requested transaction
  var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  var hasBlockTime: Bool {return _storage._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  mutating func clearBlockTime() {_uniqueStorage()._blockTime = nil}

  /// proposer_address is the proposer of the requested block
  var proposerAddress: Data {
    get {return _storage._proposerAddress}
    set {_uniqueStorage()._proposerAddress = newValue}
  }

  /// chain_id is the the eip155 chain id parsed from the requested block header
  var chainID: Int64 {
    get {return _storage._chainID}
    set {_uniqueStorage()._chainID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// QueryTraceTxResponse defines TraceTx response
struct Ethermint_Evm_V1_QueryTraceTxResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// data is the response serialized in bytes
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTraceBlockRequest defines TraceTx request
struct Ethermint_Evm_V1_QueryTraceBlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// txs is an array of messages in the block
  var txs: [Ethermint_Evm_V1_MsgEthereumTx] {
    get {return _storage._txs}
    set {_uniqueStorage()._txs = newValue}
  }

  /// trace_config holds extra parameters to trace functions.
  var traceConfig: Ethermint_Evm_V1_TraceConfig {
    get {return _storage._traceConfig ?? Ethermint_Evm_V1_TraceConfig()}
    set {_uniqueStorage()._traceConfig = newValue}
  }
  /// Returns true if `traceConfig` has been explicitly set.
  var hasTraceConfig: Bool {return _storage._traceConfig != nil}
  /// Clears the value of `traceConfig`. Subsequent reads from it will return its default value.
  mutating func clearTraceConfig() {_uniqueStorage()._traceConfig = nil}

  /// block_number of the traced block
  var blockNumber: Int64 {
    get {return _storage._blockNumber}
    set {_uniqueStorage()._blockNumber = newValue}
  }

  /// block_hash (hex) of the traced block
  var blockHash: String {
    get {return _storage._blockHash}
    set {_uniqueStorage()._blockHash = newValue}
  }

  /// block_time of the traced block
  var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  var hasBlockTime: Bool {return _storage._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  mutating func clearBlockTime() {_uniqueStorage()._blockTime = nil}

  /// proposer_address is the address of the requested block
  var proposerAddress: Data {
    get {return _storage._proposerAddress}
    set {_uniqueStorage()._proposerAddress = newValue}
  }

  /// chain_id is the eip155 chain id parsed from the requested block header
  var chainID: Int64 {
    get {return _storage._chainID}
    set {_uniqueStorage()._chainID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// QueryTraceBlockResponse defines TraceBlock response
struct Ethermint_Evm_V1_QueryTraceBlockResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// data is the response serialized in bytes
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBaseFeeRequest defines the request type for querying the EIP1559 base
/// fee.
struct Ethermint_Evm_V1_QueryBaseFeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBaseFeeResponse returns the EIP1559 base fee.
struct Ethermint_Evm_V1_QueryBaseFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// base_fee is the EIP1559 base fee
  var baseFee: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Ethermint_Evm_V1_QueryAccountRequest: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryAccountResponse: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryCosmosAccountRequest: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryCosmosAccountResponse: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryValidatorAccountRequest: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryValidatorAccountResponse: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryBalanceRequest: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryBalanceResponse: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryStorageRequest: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryStorageResponse: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryCodeRequest: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryCodeResponse: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryTxLogsRequest: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryTxLogsResponse: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryParamsRequest: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryParamsResponse: @unchecked Sendable {}
extension Ethermint_Evm_V1_EthCallRequest: @unchecked Sendable {}
extension Ethermint_Evm_V1_EstimateGasResponse: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryTraceTxRequest: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryTraceTxResponse: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryTraceBlockRequest: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryTraceBlockResponse: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryBaseFeeRequest: @unchecked Sendable {}
extension Ethermint_Evm_V1_QueryBaseFeeResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ethermint.evm.v1"

extension Ethermint_Evm_V1_QueryAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryAccountRequest, rhs: Ethermint_Evm_V1_QueryAccountRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "balance"),
    2: .standard(proto: "code_hash"),
    3: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.balance) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.codeHash) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.balance.isEmpty {
      try visitor.visitSingularStringField(value: self.balance, fieldNumber: 1)
    }
    if !self.codeHash.isEmpty {
      try visitor.visitSingularStringField(value: self.codeHash, fieldNumber: 2)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryAccountResponse, rhs: Ethermint_Evm_V1_QueryAccountResponse) -> Bool {
    if lhs.balance != rhs.balance {return false}
    if lhs.codeHash != rhs.codeHash {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryCosmosAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCosmosAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryCosmosAccountRequest, rhs: Ethermint_Evm_V1_QueryCosmosAccountRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryCosmosAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCosmosAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cosmos_address"),
    2: .same(proto: "sequence"),
    3: .standard(proto: "account_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cosmosAddress) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.accountNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cosmosAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.cosmosAddress, fieldNumber: 1)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 2)
    }
    if self.accountNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.accountNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryCosmosAccountResponse, rhs: Ethermint_Evm_V1_QueryCosmosAccountResponse) -> Bool {
    if lhs.cosmosAddress != rhs.cosmosAddress {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.accountNumber != rhs.accountNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryValidatorAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryValidatorAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cons_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.consAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.consAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.consAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryValidatorAccountRequest, rhs: Ethermint_Evm_V1_QueryValidatorAccountRequest) -> Bool {
    if lhs.consAddress != rhs.consAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryValidatorAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryValidatorAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_address"),
    2: .same(proto: "sequence"),
    3: .standard(proto: "account_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountAddress) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.accountNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.accountAddress, fieldNumber: 1)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 2)
    }
    if self.accountNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.accountNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryValidatorAccountResponse, rhs: Ethermint_Evm_V1_QueryValidatorAccountResponse) -> Bool {
    if lhs.accountAddress != rhs.accountAddress {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.accountNumber != rhs.accountNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryBalanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBalanceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryBalanceRequest, rhs: Ethermint_Evm_V1_QueryBalanceRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryBalanceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBalanceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.balance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.balance.isEmpty {
      try visitor.visitSingularStringField(value: self.balance, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryBalanceResponse, rhs: Ethermint_Evm_V1_QueryBalanceResponse) -> Bool {
    if lhs.balance != rhs.balance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryStorageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryStorageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryStorageRequest, rhs: Ethermint_Evm_V1_QueryStorageRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryStorageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryStorageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryStorageResponse, rhs: Ethermint_Evm_V1_QueryStorageResponse) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryCodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCodeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryCodeRequest, rhs: Ethermint_Evm_V1_QueryCodeRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryCodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCodeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.code) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularBytesField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryCodeResponse, rhs: Ethermint_Evm_V1_QueryCodeResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryTxLogsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTxLogsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryTxLogsRequest, rhs: Ethermint_Evm_V1_QueryTxLogsRequest) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryTxLogsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTxLogsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "logs"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.logs) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryTxLogsResponse, rhs: Ethermint_Evm_V1_QueryTxLogsResponse) -> Bool {
    if lhs.logs != rhs.logs {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryParamsRequest, rhs: Ethermint_Evm_V1_QueryParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryParamsResponse, rhs: Ethermint_Evm_V1_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_EthCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EthCallRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "args"),
    2: .standard(proto: "gas_cap"),
    3: .standard(proto: "proposer_address"),
    4: .standard(proto: "chain_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.args) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.gasCap) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.proposerAddress) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.chainID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.args.isEmpty {
      try visitor.visitSingularBytesField(value: self.args, fieldNumber: 1)
    }
    if self.gasCap != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasCap, fieldNumber: 2)
    }
    if !self.proposerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposerAddress, fieldNumber: 3)
    }
    if self.chainID != 0 {
      try visitor.visitSingularInt64Field(value: self.chainID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_EthCallRequest, rhs: Ethermint_Evm_V1_EthCallRequest) -> Bool {
    if lhs.args != rhs.args {return false}
    if lhs.gasCap != rhs.gasCap {return false}
    if lhs.proposerAddress != rhs.proposerAddress {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_EstimateGasResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateGasResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.gas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gas != 0 {
      try visitor.visitSingularUInt64Field(value: self.gas, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_EstimateGasResponse, rhs: Ethermint_Evm_V1_EstimateGasResponse) -> Bool {
    if lhs.gas != rhs.gas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryTraceTxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTraceTxRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    3: .standard(proto: "trace_config"),
    4: .same(proto: "predecessors"),
    5: .standard(proto: "block_number"),
    6: .standard(proto: "block_hash"),
    7: .standard(proto: "block_time"),
    8: .standard(proto: "proposer_address"),
    9: .standard(proto: "chain_id"),
  ]

  fileprivate class _StorageClass {
    var _msg: Ethermint_Evm_V1_MsgEthereumTx? = nil
    var _traceConfig: Ethermint_Evm_V1_TraceConfig? = nil
    var _predecessors: [Ethermint_Evm_V1_MsgEthereumTx] = []
    var _blockNumber: Int64 = 0
    var _blockHash: String = String()
    var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _proposerAddress: Data = Data()
    var _chainID: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _msg = source._msg
      _traceConfig = source._traceConfig
      _predecessors = source._predecessors
      _blockNumber = source._blockNumber
      _blockHash = source._blockHash
      _blockTime = source._blockTime
      _proposerAddress = source._proposerAddress
      _chainID = source._chainID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._msg) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._traceConfig) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._predecessors) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._blockNumber) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._blockHash) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._blockTime) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._proposerAddress) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._chainID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._msg {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._traceConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._predecessors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._predecessors, fieldNumber: 4)
      }
      if _storage._blockNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._blockNumber, fieldNumber: 5)
      }
      if !_storage._blockHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._blockHash, fieldNumber: 6)
      }
      try { if let v = _storage._blockTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._proposerAddress.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._proposerAddress, fieldNumber: 8)
      }
      if _storage._chainID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._chainID, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryTraceTxRequest, rhs: Ethermint_Evm_V1_QueryTraceTxRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._msg != rhs_storage._msg {return false}
        if _storage._traceConfig != rhs_storage._traceConfig {return false}
        if _storage._predecessors != rhs_storage._predecessors {return false}
        if _storage._blockNumber != rhs_storage._blockNumber {return false}
        if _storage._blockHash != rhs_storage._blockHash {return false}
        if _storage._blockTime != rhs_storage._blockTime {return false}
        if _storage._proposerAddress != rhs_storage._proposerAddress {return false}
        if _storage._chainID != rhs_storage._chainID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryTraceTxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTraceTxResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryTraceTxResponse, rhs: Ethermint_Evm_V1_QueryTraceTxResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryTraceBlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTraceBlockRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txs"),
    3: .standard(proto: "trace_config"),
    5: .standard(proto: "block_number"),
    6: .standard(proto: "block_hash"),
    7: .standard(proto: "block_time"),
    8: .standard(proto: "proposer_address"),
    9: .standard(proto: "chain_id"),
  ]

  fileprivate class _StorageClass {
    var _txs: [Ethermint_Evm_V1_MsgEthereumTx] = []
    var _traceConfig: Ethermint_Evm_V1_TraceConfig? = nil
    var _blockNumber: Int64 = 0
    var _blockHash: String = String()
    var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _proposerAddress: Data = Data()
    var _chainID: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _txs = source._txs
      _traceConfig = source._traceConfig
      _blockNumber = source._blockNumber
      _blockHash = source._blockHash
      _blockTime = source._blockTime
      _proposerAddress = source._proposerAddress
      _chainID = source._chainID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._txs) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._traceConfig) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._blockNumber) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._blockHash) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._blockTime) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._proposerAddress) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._chainID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._txs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._txs, fieldNumber: 1)
      }
      try { if let v = _storage._traceConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._blockNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._blockNumber, fieldNumber: 5)
      }
      if !_storage._blockHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._blockHash, fieldNumber: 6)
      }
      try { if let v = _storage._blockTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._proposerAddress.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._proposerAddress, fieldNumber: 8)
      }
      if _storage._chainID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._chainID, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryTraceBlockRequest, rhs: Ethermint_Evm_V1_QueryTraceBlockRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._txs != rhs_storage._txs {return false}
        if _storage._traceConfig != rhs_storage._traceConfig {return false}
        if _storage._blockNumber != rhs_storage._blockNumber {return false}
        if _storage._blockHash != rhs_storage._blockHash {return false}
        if _storage._blockTime != rhs_storage._blockTime {return false}
        if _storage._proposerAddress != rhs_storage._proposerAddress {return false}
        if _storage._chainID != rhs_storage._chainID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryTraceBlockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTraceBlockResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryTraceBlockResponse, rhs: Ethermint_Evm_V1_QueryTraceBlockResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryBaseFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBaseFeeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryBaseFeeRequest, rhs: Ethermint_Evm_V1_QueryBaseFeeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ethermint_Evm_V1_QueryBaseFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBaseFeeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.baseFee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.baseFee.isEmpty {
      try visitor.visitSingularStringField(value: self.baseFee, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ethermint_Evm_V1_QueryBaseFeeResponse, rhs: Ethermint_Evm_V1_QueryBaseFeeResponse) -> Bool {
    if lhs.baseFee != rhs.baseFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
