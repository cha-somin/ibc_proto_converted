// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ixo/iid/v1beta1/types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Ixo_Iid_V1beta1_Context {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var val: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_AccordedRight {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var id: String = String()

  var mechanism: String = String()

  var message: String = String()

  var service: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_LinkedResource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var id: String = String()

  var description_p: String = String()

  var mediaType: String = String()

  var serviceEndpoint: String = String()

  var proof: String = String()

  var encrypted: String = String()

  var right: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_LinkedClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var id: String = String()

  var description_p: String = String()

  var serviceEndpoint: String = String()

  var proof: String = String()

  var encrypted: String = String()

  var right: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_LinkedEntity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var id: String = String()

  var relationship: String = String()

  var service: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_VerificationMethod {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var type: String = String()

  var controller: String = String()

  var verificationMaterial: Ixo_Iid_V1beta1_VerificationMethod.OneOf_VerificationMaterial? = nil

  var blockchainAccountID: String {
    get {
      if case .blockchainAccountID(let v)? = verificationMaterial {return v}
      return String()
    }
    set {verificationMaterial = .blockchainAccountID(newValue)}
  }

  var publicKeyHex: String {
    get {
      if case .publicKeyHex(let v)? = verificationMaterial {return v}
      return String()
    }
    set {verificationMaterial = .publicKeyHex(newValue)}
  }

  var publicKeyMultibase: String {
    get {
      if case .publicKeyMultibase(let v)? = verificationMaterial {return v}
      return String()
    }
    set {verificationMaterial = .publicKeyMultibase(newValue)}
  }

  var publicKeyBase58: String {
    get {
      if case .publicKeyBase58(let v)? = verificationMaterial {return v}
      return String()
    }
    set {verificationMaterial = .publicKeyBase58(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_VerificationMaterial: Equatable {
    case blockchainAccountID(String)
    case publicKeyHex(String)
    case publicKeyMultibase(String)
    case publicKeyBase58(String)

  #if !swift(>=4.1)
    static func ==(lhs: Ixo_Iid_V1beta1_VerificationMethod.OneOf_VerificationMaterial, rhs: Ixo_Iid_V1beta1_VerificationMethod.OneOf_VerificationMaterial) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.blockchainAccountID, .blockchainAccountID): return {
        guard case .blockchainAccountID(let l) = lhs, case .blockchainAccountID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publicKeyHex, .publicKeyHex): return {
        guard case .publicKeyHex(let l) = lhs, case .publicKeyHex(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publicKeyMultibase, .publicKeyMultibase): return {
        guard case .publicKeyMultibase(let l) = lhs, case .publicKeyMultibase(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publicKeyBase58, .publicKeyBase58): return {
        guard case .publicKeyBase58(let l) = lhs, case .publicKeyBase58(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Ixo_Iid_V1beta1_Service {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var type: String = String()

  var serviceEndpoint: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ixo_Iid_V1beta1_IidMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var versionID: String = String()

  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return self._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {self._created = nil}

  var updated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updated = newValue}
  }
  /// Returns true if `updated` has been explicitly set.
  var hasUpdated: Bool {return self._updated != nil}
  /// Clears the value of `updated`. Subsequent reads from it will return its default value.
  mutating func clearUpdated() {self._updated = nil}

  var deactivated: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Ixo_Iid_V1beta1_Context: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_AccordedRight: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_LinkedResource: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_LinkedClaim: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_LinkedEntity: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_VerificationMethod: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_VerificationMethod.OneOf_VerificationMaterial: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_Service: @unchecked Sendable {}
extension Ixo_Iid_V1beta1_IidMetadata: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ixo.iid.v1beta1"

extension Ixo_Iid_V1beta1_Context: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Context"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "val"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.val) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.val.isEmpty {
      try visitor.visitSingularStringField(value: self.val, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_Context, rhs: Ixo_Iid_V1beta1_Context) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.val != rhs.val {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_AccordedRight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccordedRight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .same(proto: "mechanism"),
    4: .same(proto: "message"),
    5: .same(proto: "service"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mechanism) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.service) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.mechanism.isEmpty {
      try visitor.visitSingularStringField(value: self.mechanism, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 4)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_AccordedRight, rhs: Ixo_Iid_V1beta1_AccordedRight) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.mechanism != rhs.mechanism {return false}
    if lhs.message != rhs.message {return false}
    if lhs.service != rhs.service {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_LinkedResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinkedResource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .same(proto: "description"),
    4: .same(proto: "mediaType"),
    5: .same(proto: "serviceEndpoint"),
    6: .same(proto: "proof"),
    7: .same(proto: "encrypted"),
    8: .same(proto: "right"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mediaType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.serviceEndpoint) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.proof) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.encrypted) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.right) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.mediaType.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaType, fieldNumber: 4)
    }
    if !self.serviceEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceEndpoint, fieldNumber: 5)
    }
    if !self.proof.isEmpty {
      try visitor.visitSingularStringField(value: self.proof, fieldNumber: 6)
    }
    if !self.encrypted.isEmpty {
      try visitor.visitSingularStringField(value: self.encrypted, fieldNumber: 7)
    }
    if !self.right.isEmpty {
      try visitor.visitSingularStringField(value: self.right, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_LinkedResource, rhs: Ixo_Iid_V1beta1_LinkedResource) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.mediaType != rhs.mediaType {return false}
    if lhs.serviceEndpoint != rhs.serviceEndpoint {return false}
    if lhs.proof != rhs.proof {return false}
    if lhs.encrypted != rhs.encrypted {return false}
    if lhs.right != rhs.right {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_LinkedClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinkedClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .same(proto: "description"),
    4: .same(proto: "serviceEndpoint"),
    5: .same(proto: "proof"),
    6: .same(proto: "encrypted"),
    7: .same(proto: "right"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.serviceEndpoint) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.proof) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.encrypted) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.right) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.serviceEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceEndpoint, fieldNumber: 4)
    }
    if !self.proof.isEmpty {
      try visitor.visitSingularStringField(value: self.proof, fieldNumber: 5)
    }
    if !self.encrypted.isEmpty {
      try visitor.visitSingularStringField(value: self.encrypted, fieldNumber: 6)
    }
    if !self.right.isEmpty {
      try visitor.visitSingularStringField(value: self.right, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_LinkedClaim, rhs: Ixo_Iid_V1beta1_LinkedClaim) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.serviceEndpoint != rhs.serviceEndpoint {return false}
    if lhs.proof != rhs.proof {return false}
    if lhs.encrypted != rhs.encrypted {return false}
    if lhs.right != rhs.right {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_LinkedEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinkedEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .same(proto: "relationship"),
    4: .same(proto: "service"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.relationship) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.service) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.relationship.isEmpty {
      try visitor.visitSingularStringField(value: self.relationship, fieldNumber: 3)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_LinkedEntity, rhs: Ixo_Iid_V1beta1_LinkedEntity) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.relationship != rhs.relationship {return false}
    if lhs.service != rhs.service {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_VerificationMethod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerificationMethod"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "controller"),
    4: .same(proto: "blockchainAccountID"),
    5: .same(proto: "publicKeyHex"),
    6: .same(proto: "publicKeyMultibase"),
    7: .same(proto: "publicKeyBase58"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.controller) }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.verificationMaterial != nil {try decoder.handleConflictingOneOf()}
          self.verificationMaterial = .blockchainAccountID(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.verificationMaterial != nil {try decoder.handleConflictingOneOf()}
          self.verificationMaterial = .publicKeyHex(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.verificationMaterial != nil {try decoder.handleConflictingOneOf()}
          self.verificationMaterial = .publicKeyMultibase(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.verificationMaterial != nil {try decoder.handleConflictingOneOf()}
          self.verificationMaterial = .publicKeyBase58(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.controller.isEmpty {
      try visitor.visitSingularStringField(value: self.controller, fieldNumber: 3)
    }
    switch self.verificationMaterial {
    case .blockchainAccountID?: try {
      guard case .blockchainAccountID(let v)? = self.verificationMaterial else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .publicKeyHex?: try {
      guard case .publicKeyHex(let v)? = self.verificationMaterial else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .publicKeyMultibase?: try {
      guard case .publicKeyMultibase(let v)? = self.verificationMaterial else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .publicKeyBase58?: try {
      guard case .publicKeyBase58(let v)? = self.verificationMaterial else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_VerificationMethod, rhs: Ixo_Iid_V1beta1_VerificationMethod) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.controller != rhs.controller {return false}
    if lhs.verificationMaterial != rhs.verificationMaterial {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_Service: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Service"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "serviceEndpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.serviceEndpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.serviceEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceEndpoint, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_Service, rhs: Ixo_Iid_V1beta1_Service) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.serviceEndpoint != rhs.serviceEndpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ixo_Iid_V1beta1_IidMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IidMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "versionId"),
    2: .same(proto: "created"),
    3: .same(proto: "updated"),
    4: .same(proto: "deactivated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.versionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._created) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updated) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.deactivated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.versionID.isEmpty {
      try visitor.visitSingularStringField(value: self.versionID, fieldNumber: 1)
    }
    try { if let v = self._created {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updated {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.deactivated != false {
      try visitor.visitSingularBoolField(value: self.deactivated, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ixo_Iid_V1beta1_IidMetadata, rhs: Ixo_Iid_V1beta1_IidMetadata) -> Bool {
    if lhs.versionID != rhs.versionID {return false}
    if lhs._created != rhs._created {return false}
    if lhs._updated != rhs._updated {return false}
    if lhs.deactivated != rhs.deactivated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
