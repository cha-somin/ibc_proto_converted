// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: likechain/likenft/v1/event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Likechain_Likenft_V1_EventNewClass {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var parentIscnIDPrefix: String = String()

  var parentAccount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventUpdateClass {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var parentIscnIDPrefix: String = String()

  var parentAccount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventRevealClass {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var success: Bool = false

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventMintNFT {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var nftID: String = String()

  var owner: String = String()

  var classParentIscnIDPrefix: String = String()

  var classParentAccount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventBurnNFT {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var nftID: String = String()

  var owner: String = String()

  var classParentIscnIDPrefix: String = String()

  var classParentAccount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventCreateBlindBoxContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var contentID: String = String()

  var classParentIscnIDPrefix: String = String()

  var classParentAccount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventUpdateBlindBoxContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var contentID: String = String()

  var classParentIscnIDPrefix: String = String()

  var classParentAccount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventDeleteBlindBoxContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var contentID: String = String()

  var classParentIscnIDPrefix: String = String()

  var classParentAccount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventCreateOffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var nftID: String = String()

  var buyer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventUpdateOffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var nftID: String = String()

  var buyer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventDeleteOffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var nftID: String = String()

  var buyer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventCreateListing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var nftID: String = String()

  var seller: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventUpdateListing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var nftID: String = String()

  var seller: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventDeleteListing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var nftID: String = String()

  var seller: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventSellNFT {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var nftID: String = String()

  var seller: String = String()

  var buyer: String = String()

  var price: UInt64 = 0

  var fullPayToRoyalty: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventBuyNFT {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var nftID: String = String()

  var seller: String = String()

  var buyer: String = String()

  var price: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventExpireOffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var nftID: String = String()

  var buyer: String = String()

  var success: Bool = false

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventExpireListing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var nftID: String = String()

  var seller: String = String()

  var success: Bool = false

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventCreateRoyaltyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventUpdateRoyaltyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Likechain_Likenft_V1_EventDeleteRoyaltyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var classID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Likechain_Likenft_V1_EventNewClass: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventUpdateClass: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventRevealClass: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventMintNFT: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventBurnNFT: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventCreateBlindBoxContent: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventUpdateBlindBoxContent: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventDeleteBlindBoxContent: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventCreateOffer: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventUpdateOffer: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventDeleteOffer: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventCreateListing: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventUpdateListing: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventDeleteListing: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventSellNFT: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventBuyNFT: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventExpireOffer: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventExpireListing: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventCreateRoyaltyConfig: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventUpdateRoyaltyConfig: @unchecked Sendable {}
extension Likechain_Likenft_V1_EventDeleteRoyaltyConfig: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "likechain.likenft.v1"

extension Likechain_Likenft_V1_EventNewClass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventNewClass"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "parent_iscn_id_prefix"),
    3: .standard(proto: "parent_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.parentIscnIDPrefix) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.parentAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.parentIscnIDPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.parentIscnIDPrefix, fieldNumber: 2)
    }
    if !self.parentAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.parentAccount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventNewClass, rhs: Likechain_Likenft_V1_EventNewClass) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.parentIscnIDPrefix != rhs.parentIscnIDPrefix {return false}
    if lhs.parentAccount != rhs.parentAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventUpdateClass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventUpdateClass"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "parent_iscn_id_prefix"),
    3: .standard(proto: "parent_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.parentIscnIDPrefix) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.parentAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.parentIscnIDPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.parentIscnIDPrefix, fieldNumber: 2)
    }
    if !self.parentAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.parentAccount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventUpdateClass, rhs: Likechain_Likenft_V1_EventUpdateClass) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.parentIscnIDPrefix != rhs.parentIscnIDPrefix {return false}
    if lhs.parentAccount != rhs.parentAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventRevealClass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventRevealClass"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .same(proto: "success"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventRevealClass, rhs: Likechain_Likenft_V1_EventRevealClass) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventMintNFT: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMintNFT"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "nft_id"),
    3: .same(proto: "owner"),
    4: .standard(proto: "class_parent_iscn_id_prefix"),
    5: .standard(proto: "class_parent_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.classParentIscnIDPrefix) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.classParentAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 2)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 3)
    }
    if !self.classParentIscnIDPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.classParentIscnIDPrefix, fieldNumber: 4)
    }
    if !self.classParentAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.classParentAccount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventMintNFT, rhs: Likechain_Likenft_V1_EventMintNFT) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.classParentIscnIDPrefix != rhs.classParentIscnIDPrefix {return false}
    if lhs.classParentAccount != rhs.classParentAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventBurnNFT: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBurnNFT"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "nft_id"),
    3: .same(proto: "owner"),
    4: .standard(proto: "class_parent_iscn_id_prefix"),
    5: .standard(proto: "class_parent_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.classParentIscnIDPrefix) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.classParentAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 2)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 3)
    }
    if !self.classParentIscnIDPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.classParentIscnIDPrefix, fieldNumber: 4)
    }
    if !self.classParentAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.classParentAccount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventBurnNFT, rhs: Likechain_Likenft_V1_EventBurnNFT) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.classParentIscnIDPrefix != rhs.classParentIscnIDPrefix {return false}
    if lhs.classParentAccount != rhs.classParentAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventCreateBlindBoxContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCreateBlindBoxContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "content_id"),
    3: .standard(proto: "class_parent_iscn_id_prefix"),
    4: .standard(proto: "class_parent_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contentID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.classParentIscnIDPrefix) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.classParentAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.contentID.isEmpty {
      try visitor.visitSingularStringField(value: self.contentID, fieldNumber: 2)
    }
    if !self.classParentIscnIDPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.classParentIscnIDPrefix, fieldNumber: 3)
    }
    if !self.classParentAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.classParentAccount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventCreateBlindBoxContent, rhs: Likechain_Likenft_V1_EventCreateBlindBoxContent) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.classParentIscnIDPrefix != rhs.classParentIscnIDPrefix {return false}
    if lhs.classParentAccount != rhs.classParentAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventUpdateBlindBoxContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventUpdateBlindBoxContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "content_id"),
    3: .standard(proto: "class_parent_iscn_id_prefix"),
    4: .standard(proto: "class_parent_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contentID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.classParentIscnIDPrefix) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.classParentAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.contentID.isEmpty {
      try visitor.visitSingularStringField(value: self.contentID, fieldNumber: 2)
    }
    if !self.classParentIscnIDPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.classParentIscnIDPrefix, fieldNumber: 3)
    }
    if !self.classParentAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.classParentAccount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventUpdateBlindBoxContent, rhs: Likechain_Likenft_V1_EventUpdateBlindBoxContent) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.classParentIscnIDPrefix != rhs.classParentIscnIDPrefix {return false}
    if lhs.classParentAccount != rhs.classParentAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventDeleteBlindBoxContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventDeleteBlindBoxContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "content_id"),
    3: .standard(proto: "class_parent_iscn_id_prefix"),
    4: .standard(proto: "class_parent_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contentID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.classParentIscnIDPrefix) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.classParentAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.contentID.isEmpty {
      try visitor.visitSingularStringField(value: self.contentID, fieldNumber: 2)
    }
    if !self.classParentIscnIDPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.classParentIscnIDPrefix, fieldNumber: 3)
    }
    if !self.classParentAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.classParentAccount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventDeleteBlindBoxContent, rhs: Likechain_Likenft_V1_EventDeleteBlindBoxContent) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.classParentIscnIDPrefix != rhs.classParentIscnIDPrefix {return false}
    if lhs.classParentAccount != rhs.classParentAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventCreateOffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCreateOffer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "nft_id"),
    3: .same(proto: "buyer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.buyer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 2)
    }
    if !self.buyer.isEmpty {
      try visitor.visitSingularStringField(value: self.buyer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventCreateOffer, rhs: Likechain_Likenft_V1_EventCreateOffer) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.buyer != rhs.buyer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventUpdateOffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventUpdateOffer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "nft_id"),
    3: .same(proto: "buyer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.buyer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 2)
    }
    if !self.buyer.isEmpty {
      try visitor.visitSingularStringField(value: self.buyer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventUpdateOffer, rhs: Likechain_Likenft_V1_EventUpdateOffer) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.buyer != rhs.buyer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventDeleteOffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventDeleteOffer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "nft_id"),
    3: .same(proto: "buyer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.buyer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 2)
    }
    if !self.buyer.isEmpty {
      try visitor.visitSingularStringField(value: self.buyer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventDeleteOffer, rhs: Likechain_Likenft_V1_EventDeleteOffer) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.buyer != rhs.buyer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventCreateListing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCreateListing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "nft_id"),
    3: .same(proto: "seller"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.seller) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 2)
    }
    if !self.seller.isEmpty {
      try visitor.visitSingularStringField(value: self.seller, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventCreateListing, rhs: Likechain_Likenft_V1_EventCreateListing) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.seller != rhs.seller {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventUpdateListing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventUpdateListing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "nft_id"),
    3: .same(proto: "seller"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.seller) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 2)
    }
    if !self.seller.isEmpty {
      try visitor.visitSingularStringField(value: self.seller, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventUpdateListing, rhs: Likechain_Likenft_V1_EventUpdateListing) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.seller != rhs.seller {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventDeleteListing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventDeleteListing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "nft_id"),
    3: .same(proto: "seller"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.seller) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 2)
    }
    if !self.seller.isEmpty {
      try visitor.visitSingularStringField(value: self.seller, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventDeleteListing, rhs: Likechain_Likenft_V1_EventDeleteListing) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.seller != rhs.seller {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventSellNFT: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSellNFT"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "nft_id"),
    3: .same(proto: "seller"),
    4: .same(proto: "buyer"),
    5: .same(proto: "price"),
    6: .standard(proto: "full_pay_to_royalty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.seller) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.buyer) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.price) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.fullPayToRoyalty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 2)
    }
    if !self.seller.isEmpty {
      try visitor.visitSingularStringField(value: self.seller, fieldNumber: 3)
    }
    if !self.buyer.isEmpty {
      try visitor.visitSingularStringField(value: self.buyer, fieldNumber: 4)
    }
    if self.price != 0 {
      try visitor.visitSingularUInt64Field(value: self.price, fieldNumber: 5)
    }
    if self.fullPayToRoyalty != false {
      try visitor.visitSingularBoolField(value: self.fullPayToRoyalty, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventSellNFT, rhs: Likechain_Likenft_V1_EventSellNFT) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.seller != rhs.seller {return false}
    if lhs.buyer != rhs.buyer {return false}
    if lhs.price != rhs.price {return false}
    if lhs.fullPayToRoyalty != rhs.fullPayToRoyalty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventBuyNFT: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBuyNFT"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "nft_id"),
    3: .same(proto: "seller"),
    4: .same(proto: "buyer"),
    5: .same(proto: "price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.seller) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.buyer) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.price) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 2)
    }
    if !self.seller.isEmpty {
      try visitor.visitSingularStringField(value: self.seller, fieldNumber: 3)
    }
    if !self.buyer.isEmpty {
      try visitor.visitSingularStringField(value: self.buyer, fieldNumber: 4)
    }
    if self.price != 0 {
      try visitor.visitSingularUInt64Field(value: self.price, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventBuyNFT, rhs: Likechain_Likenft_V1_EventBuyNFT) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.seller != rhs.seller {return false}
    if lhs.buyer != rhs.buyer {return false}
    if lhs.price != rhs.price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventExpireOffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventExpireOffer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "nft_id"),
    3: .same(proto: "buyer"),
    4: .same(proto: "success"),
    5: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.buyer) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 2)
    }
    if !self.buyer.isEmpty {
      try visitor.visitSingularStringField(value: self.buyer, fieldNumber: 3)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 4)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventExpireOffer, rhs: Likechain_Likenft_V1_EventExpireOffer) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.buyer != rhs.buyer {return false}
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventExpireListing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventExpireListing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .standard(proto: "nft_id"),
    3: .same(proto: "seller"),
    4: .same(proto: "success"),
    5: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nftID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.seller) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.nftID.isEmpty {
      try visitor.visitSingularStringField(value: self.nftID, fieldNumber: 2)
    }
    if !self.seller.isEmpty {
      try visitor.visitSingularStringField(value: self.seller, fieldNumber: 3)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 4)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventExpireListing, rhs: Likechain_Likenft_V1_EventExpireListing) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.nftID != rhs.nftID {return false}
    if lhs.seller != rhs.seller {return false}
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventCreateRoyaltyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCreateRoyaltyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventCreateRoyaltyConfig, rhs: Likechain_Likenft_V1_EventCreateRoyaltyConfig) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventUpdateRoyaltyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventUpdateRoyaltyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventUpdateRoyaltyConfig, rhs: Likechain_Likenft_V1_EventUpdateRoyaltyConfig) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Likechain_Likenft_V1_EventDeleteRoyaltyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventDeleteRoyaltyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Likechain_Likenft_V1_EventDeleteRoyaltyConfig, rhs: Likechain_Likenft_V1_EventDeleteRoyaltyConfig) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
