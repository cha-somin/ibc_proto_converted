// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: babylon/epoching/v1/epoching.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// BondState is the bond state of a validator or delegation
enum Babylon_Epoching_V1_BondState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// CREATED is when the validator/delegation has been created
  case created // = 0

  /// CREATED is when the validator/delegation has become bonded
  case bonded // = 1

  /// CREATED is when the validator/delegation has become unbonding
  case unbonding // = 2

  /// CREATED is when the validator/delegation has become unbonded
  case unbonded // = 3

  /// CREATED is when the validator/delegation has been removed
  case removed // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .created
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .created
    case 1: self = .bonded
    case 2: self = .unbonding
    case 3: self = .unbonded
    case 4: self = .removed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .created: return 0
    case .bonded: return 1
    case .unbonding: return 2
    case .unbonded: return 3
    case .removed: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Babylon_Epoching_V1_BondState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Babylon_Epoching_V1_BondState] = [
    .created,
    .bonded,
    .unbonding,
    .unbonded,
    .removed,
  ]
}

#endif  // swift(>=4.2)

/// Epoch is a structure that contains the metadata of an epoch
struct Babylon_Epoching_V1_Epoch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// epoch_number is the number of this epoch
  var epochNumber: UInt64 = 0

  /// current_epoch_interval is the epoch interval at the time of this epoch
  var currentEpochInterval: UInt64 = 0

  /// first_block_height is the height of the first block in this epoch
  var firstBlockHeight: UInt64 = 0

  /// last_block_time is the time of the last block in this epoch.
  /// Babylon needs to remember the last header's time of each epoch to complete
  /// unbonding validators/delegations when a previous epoch's checkpoint is
  /// finalised. The last_block_time field is nil in the epoch's beginning, and
  /// is set upon the end of this epoch.
  var lastBlockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastBlockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastBlockTime = newValue}
  }
  /// Returns true if `lastBlockTime` has been explicitly set.
  var hasLastBlockTime: Bool {return self._lastBlockTime != nil}
  /// Clears the value of `lastBlockTime`. Subsequent reads from it will return its default value.
  mutating func clearLastBlockTime() {self._lastBlockTime = nil}

  /// sealer is the last block of the sealed epoch
  /// sealer_app_hash points to the sealer but stored in the 1st header
  /// of the next epoch
  var sealerAppHash: Data = Data()

  /// sealer_block_hash is the hash of the sealer
  /// the validator set has generated a BLS multisig on the hash,
  /// i.e., hash of the last block in the epoch
  var sealerBlockHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastBlockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// QueuedMessage is a message that can change the validator set and is delayed
/// to the end of an epoch
struct Babylon_Epoching_V1_QueuedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// tx_id is the ID of the tx that contains the message
  var txID: Data {
    get {return _storage._txID}
    set {_uniqueStorage()._txID = newValue}
  }

  /// msg_id is the original message ID, i.e., hash of the marshaled message
  var msgID: Data {
    get {return _storage._msgID}
    set {_uniqueStorage()._msgID = newValue}
  }

  /// block_height is the height when this msg is submitted to Babylon
  var blockHeight: UInt64 {
    get {return _storage._blockHeight}
    set {_uniqueStorage()._blockHeight = newValue}
  }

  /// block_time is the timestamp when this msg is submitted to Babylon
  var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  var hasBlockTime: Bool {return _storage._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  mutating func clearBlockTime() {_uniqueStorage()._blockTime = nil}

  /// msg is the actual message that is sent by a user and is queued by the
  /// epoching module
  var msg: OneOf_Msg? {
    get {return _storage._msg}
    set {_uniqueStorage()._msg = newValue}
  }

  var msgCreateValidator: Cosmos_Staking_V1beta1_MsgCreateValidator {
    get {
      if case .msgCreateValidator(let v)? = _storage._msg {return v}
      return Cosmos_Staking_V1beta1_MsgCreateValidator()
    }
    set {_uniqueStorage()._msg = .msgCreateValidator(newValue)}
  }

  var msgDelegate: Cosmos_Staking_V1beta1_MsgDelegate {
    get {
      if case .msgDelegate(let v)? = _storage._msg {return v}
      return Cosmos_Staking_V1beta1_MsgDelegate()
    }
    set {_uniqueStorage()._msg = .msgDelegate(newValue)}
  }

  var msgUndelegate: Cosmos_Staking_V1beta1_MsgUndelegate {
    get {
      if case .msgUndelegate(let v)? = _storage._msg {return v}
      return Cosmos_Staking_V1beta1_MsgUndelegate()
    }
    set {_uniqueStorage()._msg = .msgUndelegate(newValue)}
  }

  var msgBeginRedelegate: Cosmos_Staking_V1beta1_MsgBeginRedelegate {
    get {
      if case .msgBeginRedelegate(let v)? = _storage._msg {return v}
      return Cosmos_Staking_V1beta1_MsgBeginRedelegate()
    }
    set {_uniqueStorage()._msg = .msgBeginRedelegate(newValue)}
  }

  var msgCancelUnbondingDelegation: Cosmos_Staking_V1beta1_MsgCancelUnbondingDelegation {
    get {
      if case .msgCancelUnbondingDelegation(let v)? = _storage._msg {return v}
      return Cosmos_Staking_V1beta1_MsgCancelUnbondingDelegation()
    }
    set {_uniqueStorage()._msg = .msgCancelUnbondingDelegation(newValue)}
  }

  var msgEditValidator: Cosmos_Staking_V1beta1_MsgEditValidator {
    get {
      if case .msgEditValidator(let v)? = _storage._msg {return v}
      return Cosmos_Staking_V1beta1_MsgEditValidator()
    }
    set {_uniqueStorage()._msg = .msgEditValidator(newValue)}
  }

  var msgUpdateParams: Cosmos_Staking_V1beta1_MsgUpdateParams {
    get {
      if case .msgUpdateParams(let v)? = _storage._msg {return v}
      return Cosmos_Staking_V1beta1_MsgUpdateParams()
    }
    set {_uniqueStorage()._msg = .msgUpdateParams(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// msg is the actual message that is sent by a user and is queued by the
  /// epoching module
  enum OneOf_Msg: Equatable {
    case msgCreateValidator(Cosmos_Staking_V1beta1_MsgCreateValidator)
    case msgDelegate(Cosmos_Staking_V1beta1_MsgDelegate)
    case msgUndelegate(Cosmos_Staking_V1beta1_MsgUndelegate)
    case msgBeginRedelegate(Cosmos_Staking_V1beta1_MsgBeginRedelegate)
    case msgCancelUnbondingDelegation(Cosmos_Staking_V1beta1_MsgCancelUnbondingDelegation)
    case msgEditValidator(Cosmos_Staking_V1beta1_MsgEditValidator)
    case msgUpdateParams(Cosmos_Staking_V1beta1_MsgUpdateParams)

  #if !swift(>=4.1)
    static func ==(lhs: Babylon_Epoching_V1_QueuedMessage.OneOf_Msg, rhs: Babylon_Epoching_V1_QueuedMessage.OneOf_Msg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.msgCreateValidator, .msgCreateValidator): return {
        guard case .msgCreateValidator(let l) = lhs, case .msgCreateValidator(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.msgDelegate, .msgDelegate): return {
        guard case .msgDelegate(let l) = lhs, case .msgDelegate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.msgUndelegate, .msgUndelegate): return {
        guard case .msgUndelegate(let l) = lhs, case .msgUndelegate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.msgBeginRedelegate, .msgBeginRedelegate): return {
        guard case .msgBeginRedelegate(let l) = lhs, case .msgBeginRedelegate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.msgCancelUnbondingDelegation, .msgCancelUnbondingDelegation): return {
        guard case .msgCancelUnbondingDelegation(let l) = lhs, case .msgCancelUnbondingDelegation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.msgEditValidator, .msgEditValidator): return {
        guard case .msgEditValidator(let l) = lhs, case .msgEditValidator(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.msgUpdateParams, .msgUpdateParams): return {
        guard case .msgUpdateParams(let l) = lhs, case .msgUpdateParams(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ValStateUpdate is a message that records a state update of a validator
struct Babylon_Epoching_V1_ValStateUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Babylon_Epoching_V1_BondState = .created

  var blockHeight: UInt64 = 0

  var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  var hasBlockTime: Bool {return self._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  mutating func clearBlockTime() {self._blockTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// ValidatorLifecycle is a message that records the lifecycle of
/// a validator
struct Babylon_Epoching_V1_ValidatorLifecycle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valAddr: String = String()

  var valLife: [Babylon_Epoching_V1_ValStateUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DelegationStateUpdate is the message that records a state update of a
/// delegation
struct Babylon_Epoching_V1_DelegationStateUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Babylon_Epoching_V1_BondState = .created

  var valAddr: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var blockHeight: UInt64 = 0

  var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  var hasBlockTime: Bool {return self._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  mutating func clearBlockTime() {self._blockTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// ValidatorLifecycle is a message that records the lifecycle of
/// a delegation
struct Babylon_Epoching_V1_DelegationLifecycle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delAddr: String = String()

  var delLife: [Babylon_Epoching_V1_DelegationStateUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Validator is a message that denotes a validator
struct Babylon_Epoching_V1_Validator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// addr is the validator's address (in sdk.ValAddress)
  var addr: Data = Data()

  /// power is the validator's voting power
  var power: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Babylon_Epoching_V1_BondState: @unchecked Sendable {}
extension Babylon_Epoching_V1_Epoch: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueuedMessage: @unchecked Sendable {}
extension Babylon_Epoching_V1_QueuedMessage.OneOf_Msg: @unchecked Sendable {}
extension Babylon_Epoching_V1_ValStateUpdate: @unchecked Sendable {}
extension Babylon_Epoching_V1_ValidatorLifecycle: @unchecked Sendable {}
extension Babylon_Epoching_V1_DelegationStateUpdate: @unchecked Sendable {}
extension Babylon_Epoching_V1_DelegationLifecycle: @unchecked Sendable {}
extension Babylon_Epoching_V1_Validator: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "babylon.epoching.v1"

extension Babylon_Epoching_V1_BondState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CREATED"),
    1: .same(proto: "BONDED"),
    2: .same(proto: "UNBONDING"),
    3: .same(proto: "UNBONDED"),
    4: .same(proto: "REMOVED"),
  ]
}

extension Babylon_Epoching_V1_Epoch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Epoch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_number"),
    2: .standard(proto: "current_epoch_interval"),
    3: .standard(proto: "first_block_height"),
    4: .standard(proto: "last_block_time"),
    5: .standard(proto: "sealer_app_hash"),
    6: .standard(proto: "sealer_block_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNumber) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.currentEpochInterval) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.firstBlockHeight) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lastBlockTime) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.sealerAppHash) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.sealerBlockHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.epochNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNumber, fieldNumber: 1)
    }
    if self.currentEpochInterval != 0 {
      try visitor.visitSingularUInt64Field(value: self.currentEpochInterval, fieldNumber: 2)
    }
    if self.firstBlockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.firstBlockHeight, fieldNumber: 3)
    }
    try { if let v = self._lastBlockTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.sealerAppHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.sealerAppHash, fieldNumber: 5)
    }
    if !self.sealerBlockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.sealerBlockHash, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_Epoch, rhs: Babylon_Epoching_V1_Epoch) -> Bool {
    if lhs.epochNumber != rhs.epochNumber {return false}
    if lhs.currentEpochInterval != rhs.currentEpochInterval {return false}
    if lhs.firstBlockHeight != rhs.firstBlockHeight {return false}
    if lhs._lastBlockTime != rhs._lastBlockTime {return false}
    if lhs.sealerAppHash != rhs.sealerAppHash {return false}
    if lhs.sealerBlockHash != rhs.sealerBlockHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_QueuedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueuedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_id"),
    2: .standard(proto: "msg_id"),
    3: .standard(proto: "block_height"),
    4: .standard(proto: "block_time"),
    5: .standard(proto: "msg_create_validator"),
    6: .standard(proto: "msg_delegate"),
    7: .standard(proto: "msg_undelegate"),
    8: .standard(proto: "msg_begin_redelegate"),
    9: .standard(proto: "msg_cancel_unbonding_delegation"),
    10: .standard(proto: "msg_edit_validator"),
    11: .standard(proto: "msg_update_params"),
  ]

  fileprivate class _StorageClass {
    var _txID: Data = Data()
    var _msgID: Data = Data()
    var _blockHeight: UInt64 = 0
    var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _msg: Babylon_Epoching_V1_QueuedMessage.OneOf_Msg?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _txID = source._txID
      _msgID = source._msgID
      _blockHeight = source._blockHeight
      _blockTime = source._blockTime
      _msg = source._msg
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._txID) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._msgID) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._blockHeight) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._blockTime) }()
        case 5: try {
          var v: Cosmos_Staking_V1beta1_MsgCreateValidator?
          var hadOneofValue = false
          if let current = _storage._msg {
            hadOneofValue = true
            if case .msgCreateValidator(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._msg = .msgCreateValidator(v)
          }
        }()
        case 6: try {
          var v: Cosmos_Staking_V1beta1_MsgDelegate?
          var hadOneofValue = false
          if let current = _storage._msg {
            hadOneofValue = true
            if case .msgDelegate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._msg = .msgDelegate(v)
          }
        }()
        case 7: try {
          var v: Cosmos_Staking_V1beta1_MsgUndelegate?
          var hadOneofValue = false
          if let current = _storage._msg {
            hadOneofValue = true
            if case .msgUndelegate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._msg = .msgUndelegate(v)
          }
        }()
        case 8: try {
          var v: Cosmos_Staking_V1beta1_MsgBeginRedelegate?
          var hadOneofValue = false
          if let current = _storage._msg {
            hadOneofValue = true
            if case .msgBeginRedelegate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._msg = .msgBeginRedelegate(v)
          }
        }()
        case 9: try {
          var v: Cosmos_Staking_V1beta1_MsgCancelUnbondingDelegation?
          var hadOneofValue = false
          if let current = _storage._msg {
            hadOneofValue = true
            if case .msgCancelUnbondingDelegation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._msg = .msgCancelUnbondingDelegation(v)
          }
        }()
        case 10: try {
          var v: Cosmos_Staking_V1beta1_MsgEditValidator?
          var hadOneofValue = false
          if let current = _storage._msg {
            hadOneofValue = true
            if case .msgEditValidator(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._msg = .msgEditValidator(v)
          }
        }()
        case 11: try {
          var v: Cosmos_Staking_V1beta1_MsgUpdateParams?
          var hadOneofValue = false
          if let current = _storage._msg {
            hadOneofValue = true
            if case .msgUpdateParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._msg = .msgUpdateParams(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._txID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._txID, fieldNumber: 1)
      }
      if !_storage._msgID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._msgID, fieldNumber: 2)
      }
      if _storage._blockHeight != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._blockHeight, fieldNumber: 3)
      }
      try { if let v = _storage._blockTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      switch _storage._msg {
      case .msgCreateValidator?: try {
        guard case .msgCreateValidator(let v)? = _storage._msg else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .msgDelegate?: try {
        guard case .msgDelegate(let v)? = _storage._msg else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .msgUndelegate?: try {
        guard case .msgUndelegate(let v)? = _storage._msg else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .msgBeginRedelegate?: try {
        guard case .msgBeginRedelegate(let v)? = _storage._msg else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .msgCancelUnbondingDelegation?: try {
        guard case .msgCancelUnbondingDelegation(let v)? = _storage._msg else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .msgEditValidator?: try {
        guard case .msgEditValidator(let v)? = _storage._msg else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .msgUpdateParams?: try {
        guard case .msgUpdateParams(let v)? = _storage._msg else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_QueuedMessage, rhs: Babylon_Epoching_V1_QueuedMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._txID != rhs_storage._txID {return false}
        if _storage._msgID != rhs_storage._msgID {return false}
        if _storage._blockHeight != rhs_storage._blockHeight {return false}
        if _storage._blockTime != rhs_storage._blockTime {return false}
        if _storage._msg != rhs_storage._msg {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_ValStateUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValStateUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "block_height"),
    3: .standard(proto: "block_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.blockHeight) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blockTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.state != .created {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 2)
    }
    try { if let v = self._blockTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_ValStateUpdate, rhs: Babylon_Epoching_V1_ValStateUpdate) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs._blockTime != rhs._blockTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_ValidatorLifecycle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatorLifecycle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "val_addr"),
    2: .standard(proto: "val_life"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.valAddr) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.valLife) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.valAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.valAddr, fieldNumber: 1)
    }
    if !self.valLife.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.valLife, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_ValidatorLifecycle, rhs: Babylon_Epoching_V1_ValidatorLifecycle) -> Bool {
    if lhs.valAddr != rhs.valAddr {return false}
    if lhs.valLife != rhs.valLife {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_DelegationStateUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelegationStateUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "val_addr"),
    3: .same(proto: "amount"),
    4: .standard(proto: "block_height"),
    5: .standard(proto: "block_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.valAddr) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.blockHeight) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._blockTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.state != .created {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if !self.valAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.valAddr, fieldNumber: 2)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 4)
    }
    try { if let v = self._blockTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_DelegationStateUpdate, rhs: Babylon_Epoching_V1_DelegationStateUpdate) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.valAddr != rhs.valAddr {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs._blockTime != rhs._blockTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_DelegationLifecycle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelegationLifecycle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "del_addr"),
    2: .standard(proto: "del_life"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.delAddr) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.delLife) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.delAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.delAddr, fieldNumber: 1)
    }
    if !self.delLife.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.delLife, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_DelegationLifecycle, rhs: Babylon_Epoching_V1_DelegationLifecycle) -> Bool {
    if lhs.delAddr != rhs.delAddr {return false}
    if lhs.delLife != rhs.delLife {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Validator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
    2: .same(proto: "power"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.addr) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.power) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularBytesField(value: self.addr, fieldNumber: 1)
    }
    if self.power != 0 {
      try visitor.visitSingularInt64Field(value: self.power, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_Validator, rhs: Babylon_Epoching_V1_Validator) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.power != rhs.power {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
