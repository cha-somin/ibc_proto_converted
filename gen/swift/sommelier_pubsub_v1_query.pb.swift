// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sommelier/pubsub/v1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Pubsub_V1_QueryParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Pubsub_V1_Params {
    get {return _params ?? Pubsub_V1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Pubsub_V1_Params? = nil
}

struct Pubsub_V1_QueryPublisherRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publisherDomain: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QueryPublisherResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publisher: Pubsub_V1_Publisher {
    get {return _publisher ?? Pubsub_V1_Publisher()}
    set {_publisher = newValue}
  }
  /// Returns true if `publisher` has been explicitly set.
  var hasPublisher: Bool {return self._publisher != nil}
  /// Clears the value of `publisher`. Subsequent reads from it will return its default value.
  mutating func clearPublisher() {self._publisher = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publisher: Pubsub_V1_Publisher? = nil
}

struct Pubsub_V1_QueryPublishersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QueryPublishersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publishers: [Pubsub_V1_Publisher] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QuerySubscriberRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriberAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QuerySubscriberResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriber: Pubsub_V1_Subscriber {
    get {return _subscriber ?? Pubsub_V1_Subscriber()}
    set {_subscriber = newValue}
  }
  /// Returns true if `subscriber` has been explicitly set.
  var hasSubscriber: Bool {return self._subscriber != nil}
  /// Clears the value of `subscriber`. Subsequent reads from it will return its default value.
  mutating func clearSubscriber() {self._subscriber = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _subscriber: Pubsub_V1_Subscriber? = nil
}

struct Pubsub_V1_QuerySubscribersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QuerySubscribersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscribers: [Pubsub_V1_Subscriber] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QueryPublisherIntentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publisherDomain: String = String()

  var subscriptionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QueryPublisherIntentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publisherIntent: Pubsub_V1_PublisherIntent {
    get {return _publisherIntent ?? Pubsub_V1_PublisherIntent()}
    set {_publisherIntent = newValue}
  }
  /// Returns true if `publisherIntent` has been explicitly set.
  var hasPublisherIntent: Bool {return self._publisherIntent != nil}
  /// Clears the value of `publisherIntent`. Subsequent reads from it will return its default value.
  mutating func clearPublisherIntent() {self._publisherIntent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publisherIntent: Pubsub_V1_PublisherIntent? = nil
}

struct Pubsub_V1_QueryPublisherIntentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QueryPublisherIntentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publisherIntents: [Pubsub_V1_PublisherIntent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QueryPublisherIntentsByPublisherDomainRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publisherDomain: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QueryPublisherIntentsByPublisherDomainResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publisherIntents: [Pubsub_V1_PublisherIntent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QueryPublisherIntentsBySubscriptionIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriptionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QueryPublisherIntentsBySubscriptionIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publisherIntents: [Pubsub_V1_PublisherIntent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QuerySubscriberIntentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriberAddress: String = String()

  var subscriptionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QuerySubscriberIntentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriberIntent: Pubsub_V1_SubscriberIntent {
    get {return _subscriberIntent ?? Pubsub_V1_SubscriberIntent()}
    set {_subscriberIntent = newValue}
  }
  /// Returns true if `subscriberIntent` has been explicitly set.
  var hasSubscriberIntent: Bool {return self._subscriberIntent != nil}
  /// Clears the value of `subscriberIntent`. Subsequent reads from it will return its default value.
  mutating func clearSubscriberIntent() {self._subscriberIntent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _subscriberIntent: Pubsub_V1_SubscriberIntent? = nil
}

struct Pubsub_V1_QuerySubscriberIntentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QuerySubscriberIntentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriberIntents: [Pubsub_V1_SubscriberIntent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QuerySubscriberIntentsBySubscriberAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriberAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QuerySubscriberIntentsBySubscriberAddressResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriberIntents: [Pubsub_V1_SubscriberIntent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QuerySubscriberIntentsBySubscriptionIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriptionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QuerySubscriberIntentsBySubscriptionIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriberIntents: [Pubsub_V1_SubscriberIntent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QuerySubscriberIntentsByPublisherDomainRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publisherDomain: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QuerySubscriberIntentsByPublisherDomainResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriberIntents: [Pubsub_V1_SubscriberIntent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QueryDefaultSubscriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriptionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QueryDefaultSubscriptionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var defaultSubscription: Pubsub_V1_DefaultSubscription {
    get {return _defaultSubscription ?? Pubsub_V1_DefaultSubscription()}
    set {_defaultSubscription = newValue}
  }
  /// Returns true if `defaultSubscription` has been explicitly set.
  var hasDefaultSubscription: Bool {return self._defaultSubscription != nil}
  /// Clears the value of `defaultSubscription`. Subsequent reads from it will return its default value.
  mutating func clearDefaultSubscription() {self._defaultSubscription = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _defaultSubscription: Pubsub_V1_DefaultSubscription? = nil
}

struct Pubsub_V1_QueryDefaultSubscriptionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pubsub_V1_QueryDefaultSubscriptionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var defaultSubscriptions: [Pubsub_V1_DefaultSubscription] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Pubsub_V1_QueryParamsRequest: @unchecked Sendable {}
extension Pubsub_V1_QueryParamsResponse: @unchecked Sendable {}
extension Pubsub_V1_QueryPublisherRequest: @unchecked Sendable {}
extension Pubsub_V1_QueryPublisherResponse: @unchecked Sendable {}
extension Pubsub_V1_QueryPublishersRequest: @unchecked Sendable {}
extension Pubsub_V1_QueryPublishersResponse: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscriberRequest: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscriberResponse: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscribersRequest: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscribersResponse: @unchecked Sendable {}
extension Pubsub_V1_QueryPublisherIntentRequest: @unchecked Sendable {}
extension Pubsub_V1_QueryPublisherIntentResponse: @unchecked Sendable {}
extension Pubsub_V1_QueryPublisherIntentsRequest: @unchecked Sendable {}
extension Pubsub_V1_QueryPublisherIntentsResponse: @unchecked Sendable {}
extension Pubsub_V1_QueryPublisherIntentsByPublisherDomainRequest: @unchecked Sendable {}
extension Pubsub_V1_QueryPublisherIntentsByPublisherDomainResponse: @unchecked Sendable {}
extension Pubsub_V1_QueryPublisherIntentsBySubscriptionIDRequest: @unchecked Sendable {}
extension Pubsub_V1_QueryPublisherIntentsBySubscriptionIDResponse: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscriberIntentRequest: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscriberIntentResponse: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscriberIntentsRequest: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscriberIntentsResponse: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscriberIntentsBySubscriberAddressRequest: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscriberIntentsBySubscriberAddressResponse: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscriberIntentsBySubscriptionIDRequest: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscriberIntentsBySubscriptionIDResponse: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscriberIntentsByPublisherDomainRequest: @unchecked Sendable {}
extension Pubsub_V1_QuerySubscriberIntentsByPublisherDomainResponse: @unchecked Sendable {}
extension Pubsub_V1_QueryDefaultSubscriptionRequest: @unchecked Sendable {}
extension Pubsub_V1_QueryDefaultSubscriptionResponse: @unchecked Sendable {}
extension Pubsub_V1_QueryDefaultSubscriptionsRequest: @unchecked Sendable {}
extension Pubsub_V1_QueryDefaultSubscriptionsResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pubsub.v1"

extension Pubsub_V1_QueryParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryParamsRequest, rhs: Pubsub_V1_QueryParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryParamsResponse, rhs: Pubsub_V1_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryPublisherRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPublisherRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publisher_domain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publisherDomain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publisherDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherDomain, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryPublisherRequest, rhs: Pubsub_V1_QueryPublisherRequest) -> Bool {
    if lhs.publisherDomain != rhs.publisherDomain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryPublisherResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPublisherResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publisher"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publisher) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publisher {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryPublisherResponse, rhs: Pubsub_V1_QueryPublisherResponse) -> Bool {
    if lhs._publisher != rhs._publisher {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryPublishersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPublishersRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryPublishersRequest, rhs: Pubsub_V1_QueryPublishersRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryPublishersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPublishersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publishers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.publishers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publishers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publishers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryPublishersResponse, rhs: Pubsub_V1_QueryPublishersResponse) -> Bool {
    if lhs.publishers != rhs.publishers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscriberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscriberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscriber_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriberAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriberAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriberAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscriberRequest, rhs: Pubsub_V1_QuerySubscriberRequest) -> Bool {
    if lhs.subscriberAddress != rhs.subscriberAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscriberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscriberResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subscriber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._subscriber {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscriberResponse, rhs: Pubsub_V1_QuerySubscriberResponse) -> Bool {
    if lhs._subscriber != rhs._subscriber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscribersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscribersRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscribersRequest, rhs: Pubsub_V1_QuerySubscribersRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscribersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscribersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscribers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subscribers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscribers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscribers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscribersResponse, rhs: Pubsub_V1_QuerySubscribersResponse) -> Bool {
    if lhs.subscribers != rhs.subscribers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryPublisherIntentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPublisherIntentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publisher_domain"),
    2: .standard(proto: "subscription_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publisherDomain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publisherDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherDomain, fieldNumber: 1)
    }
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryPublisherIntentRequest, rhs: Pubsub_V1_QueryPublisherIntentRequest) -> Bool {
    if lhs.publisherDomain != rhs.publisherDomain {return false}
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryPublisherIntentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPublisherIntentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publisher_intent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publisherIntent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publisherIntent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryPublisherIntentResponse, rhs: Pubsub_V1_QueryPublisherIntentResponse) -> Bool {
    if lhs._publisherIntent != rhs._publisherIntent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryPublisherIntentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPublisherIntentsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryPublisherIntentsRequest, rhs: Pubsub_V1_QueryPublisherIntentsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryPublisherIntentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPublisherIntentsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publisher_intents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.publisherIntents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publisherIntents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publisherIntents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryPublisherIntentsResponse, rhs: Pubsub_V1_QueryPublisherIntentsResponse) -> Bool {
    if lhs.publisherIntents != rhs.publisherIntents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryPublisherIntentsByPublisherDomainRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPublisherIntentsByPublisherDomainRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publisher_domain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publisherDomain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publisherDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherDomain, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryPublisherIntentsByPublisherDomainRequest, rhs: Pubsub_V1_QueryPublisherIntentsByPublisherDomainRequest) -> Bool {
    if lhs.publisherDomain != rhs.publisherDomain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryPublisherIntentsByPublisherDomainResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPublisherIntentsByPublisherDomainResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publisher_intents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.publisherIntents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publisherIntents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publisherIntents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryPublisherIntentsByPublisherDomainResponse, rhs: Pubsub_V1_QueryPublisherIntentsByPublisherDomainResponse) -> Bool {
    if lhs.publisherIntents != rhs.publisherIntents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryPublisherIntentsBySubscriptionIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPublisherIntentsBySubscriptionIDRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryPublisherIntentsBySubscriptionIDRequest, rhs: Pubsub_V1_QueryPublisherIntentsBySubscriptionIDRequest) -> Bool {
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryPublisherIntentsBySubscriptionIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryPublisherIntentsBySubscriptionIDResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publisher_intents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.publisherIntents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publisherIntents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publisherIntents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryPublisherIntentsBySubscriptionIDResponse, rhs: Pubsub_V1_QueryPublisherIntentsBySubscriptionIDResponse) -> Bool {
    if lhs.publisherIntents != rhs.publisherIntents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscriberIntentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscriberIntentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscriber_address"),
    2: .standard(proto: "subscription_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriberAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriberAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriberAddress, fieldNumber: 1)
    }
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscriberIntentRequest, rhs: Pubsub_V1_QuerySubscriberIntentRequest) -> Bool {
    if lhs.subscriberAddress != rhs.subscriberAddress {return false}
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscriberIntentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscriberIntentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscriber_intent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subscriberIntent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._subscriberIntent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscriberIntentResponse, rhs: Pubsub_V1_QuerySubscriberIntentResponse) -> Bool {
    if lhs._subscriberIntent != rhs._subscriberIntent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscriberIntentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscriberIntentsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscriberIntentsRequest, rhs: Pubsub_V1_QuerySubscriberIntentsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscriberIntentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscriberIntentsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscriber_intents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subscriberIntents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriberIntents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscriberIntents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscriberIntentsResponse, rhs: Pubsub_V1_QuerySubscriberIntentsResponse) -> Bool {
    if lhs.subscriberIntents != rhs.subscriberIntents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscriberIntentsBySubscriberAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscriberIntentsBySubscriberAddressRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscriber_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriberAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriberAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriberAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscriberIntentsBySubscriberAddressRequest, rhs: Pubsub_V1_QuerySubscriberIntentsBySubscriberAddressRequest) -> Bool {
    if lhs.subscriberAddress != rhs.subscriberAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscriberIntentsBySubscriberAddressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscriberIntentsBySubscriberAddressResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscriber_intents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subscriberIntents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriberIntents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscriberIntents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscriberIntentsBySubscriberAddressResponse, rhs: Pubsub_V1_QuerySubscriberIntentsBySubscriberAddressResponse) -> Bool {
    if lhs.subscriberIntents != rhs.subscriberIntents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscriberIntentsBySubscriptionIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscriberIntentsBySubscriptionIDRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscriberIntentsBySubscriptionIDRequest, rhs: Pubsub_V1_QuerySubscriberIntentsBySubscriptionIDRequest) -> Bool {
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscriberIntentsBySubscriptionIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscriberIntentsBySubscriptionIDResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscriber_intents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subscriberIntents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriberIntents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscriberIntents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscriberIntentsBySubscriptionIDResponse, rhs: Pubsub_V1_QuerySubscriberIntentsBySubscriptionIDResponse) -> Bool {
    if lhs.subscriberIntents != rhs.subscriberIntents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscriberIntentsByPublisherDomainRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscriberIntentsByPublisherDomainRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publisher_domain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publisherDomain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publisherDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherDomain, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscriberIntentsByPublisherDomainRequest, rhs: Pubsub_V1_QuerySubscriberIntentsByPublisherDomainRequest) -> Bool {
    if lhs.publisherDomain != rhs.publisherDomain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QuerySubscriberIntentsByPublisherDomainResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySubscriberIntentsByPublisherDomainResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscriber_intents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subscriberIntents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriberIntents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscriberIntents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QuerySubscriberIntentsByPublisherDomainResponse, rhs: Pubsub_V1_QuerySubscriberIntentsByPublisherDomainResponse) -> Bool {
    if lhs.subscriberIntents != rhs.subscriberIntents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryDefaultSubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDefaultSubscriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryDefaultSubscriptionRequest, rhs: Pubsub_V1_QueryDefaultSubscriptionRequest) -> Bool {
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryDefaultSubscriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDefaultSubscriptionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_subscription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._defaultSubscription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._defaultSubscription {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryDefaultSubscriptionResponse, rhs: Pubsub_V1_QueryDefaultSubscriptionResponse) -> Bool {
    if lhs._defaultSubscription != rhs._defaultSubscription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryDefaultSubscriptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDefaultSubscriptionsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryDefaultSubscriptionsRequest, rhs: Pubsub_V1_QueryDefaultSubscriptionsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pubsub_V1_QueryDefaultSubscriptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDefaultSubscriptionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_subscriptions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.defaultSubscriptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.defaultSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.defaultSubscriptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pubsub_V1_QueryDefaultSubscriptionsResponse, rhs: Pubsub_V1_QueryDefaultSubscriptionsResponse) -> Bool {
    if lhs.defaultSubscriptions != rhs.defaultSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
