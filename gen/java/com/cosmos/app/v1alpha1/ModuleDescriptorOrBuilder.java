// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmos/app/v1alpha1/module.proto

package com.cosmos.app.v1alpha1;

public interface ModuleDescriptorOrBuilder extends
    // @@protoc_insertion_point(interface_extends:cosmos.app.v1alpha1.ModuleDescriptor)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * go_import names the package that should be imported by an app to load the
   * module in the runtime module registry. It is required to make debugging
   * of configuration errors easier for users.
   * </pre>
   *
   * <code>string go_import = 1 [json_name = "goImport"];</code>
   * @return The goImport.
   */
  java.lang.String getGoImport();
  /**
   * <pre>
   * go_import names the package that should be imported by an app to load the
   * module in the runtime module registry. It is required to make debugging
   * of configuration errors easier for users.
   * </pre>
   *
   * <code>string go_import = 1 [json_name = "goImport"];</code>
   * @return The bytes for goImport.
   */
  com.google.protobuf.ByteString
      getGoImportBytes();

  /**
   * <pre>
   * use_package refers to a protobuf package that this module
   * uses and exposes to the world. In an app, only one module should "use"
   * or own a single protobuf package. It is assumed that the module uses
   * all of the .proto files in a single package.
   * </pre>
   *
   * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2 [json_name = "usePackage"];</code>
   */
  java.util.List<com.cosmos.app.v1alpha1.PackageReference> 
      getUsePackageList();
  /**
   * <pre>
   * use_package refers to a protobuf package that this module
   * uses and exposes to the world. In an app, only one module should "use"
   * or own a single protobuf package. It is assumed that the module uses
   * all of the .proto files in a single package.
   * </pre>
   *
   * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2 [json_name = "usePackage"];</code>
   */
  com.cosmos.app.v1alpha1.PackageReference getUsePackage(int index);
  /**
   * <pre>
   * use_package refers to a protobuf package that this module
   * uses and exposes to the world. In an app, only one module should "use"
   * or own a single protobuf package. It is assumed that the module uses
   * all of the .proto files in a single package.
   * </pre>
   *
   * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2 [json_name = "usePackage"];</code>
   */
  int getUsePackageCount();
  /**
   * <pre>
   * use_package refers to a protobuf package that this module
   * uses and exposes to the world. In an app, only one module should "use"
   * or own a single protobuf package. It is assumed that the module uses
   * all of the .proto files in a single package.
   * </pre>
   *
   * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2 [json_name = "usePackage"];</code>
   */
  java.util.List<? extends com.cosmos.app.v1alpha1.PackageReferenceOrBuilder> 
      getUsePackageOrBuilderList();
  /**
   * <pre>
   * use_package refers to a protobuf package that this module
   * uses and exposes to the world. In an app, only one module should "use"
   * or own a single protobuf package. It is assumed that the module uses
   * all of the .proto files in a single package.
   * </pre>
   *
   * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2 [json_name = "usePackage"];</code>
   */
  com.cosmos.app.v1alpha1.PackageReferenceOrBuilder getUsePackageOrBuilder(
      int index);

  /**
   * <pre>
   * can_migrate_from defines which module versions this module can migrate
   * state from. The framework will check that one module version is able to
   * migrate from a previous module version before attempting to update its
   * config. It is assumed that modules can transitively migrate from earlier
   * versions. For instance if v3 declares it can migrate from v2, and v2
   * declares it can migrate from v1, the framework knows how to migrate
   * from v1 to v3, assuming all 3 module versions are registered at runtime.
   * </pre>
   *
   * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3 [json_name = "canMigrateFrom"];</code>
   */
  java.util.List<com.cosmos.app.v1alpha1.MigrateFromInfo> 
      getCanMigrateFromList();
  /**
   * <pre>
   * can_migrate_from defines which module versions this module can migrate
   * state from. The framework will check that one module version is able to
   * migrate from a previous module version before attempting to update its
   * config. It is assumed that modules can transitively migrate from earlier
   * versions. For instance if v3 declares it can migrate from v2, and v2
   * declares it can migrate from v1, the framework knows how to migrate
   * from v1 to v3, assuming all 3 module versions are registered at runtime.
   * </pre>
   *
   * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3 [json_name = "canMigrateFrom"];</code>
   */
  com.cosmos.app.v1alpha1.MigrateFromInfo getCanMigrateFrom(int index);
  /**
   * <pre>
   * can_migrate_from defines which module versions this module can migrate
   * state from. The framework will check that one module version is able to
   * migrate from a previous module version before attempting to update its
   * config. It is assumed that modules can transitively migrate from earlier
   * versions. For instance if v3 declares it can migrate from v2, and v2
   * declares it can migrate from v1, the framework knows how to migrate
   * from v1 to v3, assuming all 3 module versions are registered at runtime.
   * </pre>
   *
   * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3 [json_name = "canMigrateFrom"];</code>
   */
  int getCanMigrateFromCount();
  /**
   * <pre>
   * can_migrate_from defines which module versions this module can migrate
   * state from. The framework will check that one module version is able to
   * migrate from a previous module version before attempting to update its
   * config. It is assumed that modules can transitively migrate from earlier
   * versions. For instance if v3 declares it can migrate from v2, and v2
   * declares it can migrate from v1, the framework knows how to migrate
   * from v1 to v3, assuming all 3 module versions are registered at runtime.
   * </pre>
   *
   * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3 [json_name = "canMigrateFrom"];</code>
   */
  java.util.List<? extends com.cosmos.app.v1alpha1.MigrateFromInfoOrBuilder> 
      getCanMigrateFromOrBuilderList();
  /**
   * <pre>
   * can_migrate_from defines which module versions this module can migrate
   * state from. The framework will check that one module version is able to
   * migrate from a previous module version before attempting to update its
   * config. It is assumed that modules can transitively migrate from earlier
   * versions. For instance if v3 declares it can migrate from v2, and v2
   * declares it can migrate from v1, the framework knows how to migrate
   * from v1 to v3, assuming all 3 module versions are registered at runtime.
   * </pre>
   *
   * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3 [json_name = "canMigrateFrom"];</code>
   */
  com.cosmos.app.v1alpha1.MigrateFromInfoOrBuilder getCanMigrateFromOrBuilder(
      int index);
}
