// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: umee/leverage/v1/query.proto

package com.umee.leverage.v1;

/**
 * <pre>
 * QueryMarketSummaryResponse defines the response structure for the MarketSummary gRPC service handler.
 * </pre>
 *
 * Protobuf type {@code umee.leverage.v1.QueryMarketSummaryResponse}
 */
public final class QueryMarketSummaryResponse extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:umee.leverage.v1.QueryMarketSummaryResponse)
    QueryMarketSummaryResponseOrBuilder {
private static final long serialVersionUID = 0L;
  // Use QueryMarketSummaryResponse.newBuilder() to construct.
  private QueryMarketSummaryResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private QueryMarketSummaryResponse() {
    symbolDenom_ = "";
    oraclePrice_ = "";
    uTokenExchangeRate_ = "";
    supplyAPY_ = "";
    borrowAPY_ = "";
    supplied_ = "";
    reserved_ = "";
    collateral_ = "";
    borrowed_ = "";
    liquidity_ = "";
    maximumBorrow_ = "";
    maximumCollateral_ = "";
    minimumLiquidity_ = "";
    uTokenSupply_ = "";
    availableBorrow_ = "";
    availableWithdraw_ = "";
    availableCollateralize_ = "";
    oracleHistoricPrice_ = "";
    errors_ = "";
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new QueryMarketSummaryResponse();
  }

  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return com.umee.leverage.v1.QueryProto.internal_static_umee_leverage_v1_QueryMarketSummaryResponse_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.umee.leverage.v1.QueryProto.internal_static_umee_leverage_v1_QueryMarketSummaryResponse_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.umee.leverage.v1.QueryMarketSummaryResponse.class, com.umee.leverage.v1.QueryMarketSummaryResponse.Builder.class);
  }

  public static final int SYMBOL_DENOM_FIELD_NUMBER = 1;
  @SuppressWarnings("serial")
  private volatile java.lang.Object symbolDenom_ = "";
  /**
   * <pre>
   * Symbol Denom is the human-readable representation of a token denom, for example "UMEE" or "ATOM".
   * </pre>
   *
   * <code>string symbol_denom = 1 [json_name = "symbolDenom"];</code>
   * @return The symbolDenom.
   */
  @java.lang.Override
  public java.lang.String getSymbolDenom() {
    java.lang.Object ref = symbolDenom_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      symbolDenom_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Symbol Denom is the human-readable representation of a token denom, for example "UMEE" or "ATOM".
   * </pre>
   *
   * <code>string symbol_denom = 1 [json_name = "symbolDenom"];</code>
   * @return The bytes for symbolDenom.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getSymbolDenomBytes() {
    java.lang.Object ref = symbolDenom_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      symbolDenom_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int EXPONENT_FIELD_NUMBER = 2;
  private int exponent_ = 0;
  /**
   * <pre>
   * Exponent is the power of ten required to get from base denom to symbol denom. For example, an exponent of 6 means 10^6 uumee = 1 UMEE.
   * </pre>
   *
   * <code>uint32 exponent = 2 [json_name = "exponent"];</code>
   * @return The exponent.
   */
  @java.lang.Override
  public int getExponent() {
    return exponent_;
  }

  public static final int ORACLE_PRICE_FIELD_NUMBER = 3;
  @SuppressWarnings("serial")
  private volatile java.lang.Object oraclePrice_ = "";
  /**
   * <pre>
   * Oracle Price is the current USD value of a token. Oracle price is nil when the oracle is down.
   * </pre>
   *
   * <code>string oracle_price = 3 [json_name = "oraclePrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
   * @return The oraclePrice.
   */
  @java.lang.Override
  public java.lang.String getOraclePrice() {
    java.lang.Object ref = oraclePrice_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      oraclePrice_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Oracle Price is the current USD value of a token. Oracle price is nil when the oracle is down.
   * </pre>
   *
   * <code>string oracle_price = 3 [json_name = "oraclePrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
   * @return The bytes for oraclePrice.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getOraclePriceBytes() {
    java.lang.Object ref = oraclePrice_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      oraclePrice_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int UTOKEN_EXCHANGE_RATE_FIELD_NUMBER = 4;
  @SuppressWarnings("serial")
  private volatile java.lang.Object uTokenExchangeRate_ = "";
  /**
   * <pre>
   * uToken Exchange Rate is the amount of base tokens received when withdrawing 1 uToken. For example, a uToken exchange rate of 1.5 means a supplier receives 3 uumee for every 2 u/uumee they wish to withdraw. The same applies in reverse: supplying 3 uumee would award 2 u/uumee at that time.
   * </pre>
   *
   * <code>string uToken_exchange_rate = 4 [json_name = "uTokenExchangeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "utoken_exchange_rate"];</code>
   * @return The uTokenExchangeRate.
   */
  @java.lang.Override
  public java.lang.String getUTokenExchangeRate() {
    java.lang.Object ref = uTokenExchangeRate_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      uTokenExchangeRate_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * uToken Exchange Rate is the amount of base tokens received when withdrawing 1 uToken. For example, a uToken exchange rate of 1.5 means a supplier receives 3 uumee for every 2 u/uumee they wish to withdraw. The same applies in reverse: supplying 3 uumee would award 2 u/uumee at that time.
   * </pre>
   *
   * <code>string uToken_exchange_rate = 4 [json_name = "uTokenExchangeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "utoken_exchange_rate"];</code>
   * @return The bytes for uTokenExchangeRate.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getUTokenExchangeRateBytes() {
    java.lang.Object ref = uTokenExchangeRate_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      uTokenExchangeRate_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int SUPPLY_APY_FIELD_NUMBER = 5;
  @SuppressWarnings("serial")
  private volatile java.lang.Object supplyAPY_ = "";
  /**
   * <pre>
   * Supply APY is the current interest rate suppliers are receiving for their deposits. For example, 0.11 would mean 11% APY. Supply APY is always less than borrow APY.
   * </pre>
   *
   * <code>string supply_APY = 5 [json_name = "supplyAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "supply_apy"];</code>
   * @return The supplyAPY.
   */
  @java.lang.Override
  public java.lang.String getSupplyAPY() {
    java.lang.Object ref = supplyAPY_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      supplyAPY_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Supply APY is the current interest rate suppliers are receiving for their deposits. For example, 0.11 would mean 11% APY. Supply APY is always less than borrow APY.
   * </pre>
   *
   * <code>string supply_APY = 5 [json_name = "supplyAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "supply_apy"];</code>
   * @return The bytes for supplyAPY.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getSupplyAPYBytes() {
    java.lang.Object ref = supplyAPY_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      supplyAPY_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int BORROW_APY_FIELD_NUMBER = 6;
  @SuppressWarnings("serial")
  private volatile java.lang.Object borrowAPY_ = "";
  /**
   * <pre>
   * Borrow APY is the current interest rate borrowers are being charged on their loans. For example, 0.2 would mean 20% APY.
   * </pre>
   *
   * <code>string borrow_APY = 6 [json_name = "borrowAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "borrow_apy"];</code>
   * @return The borrowAPY.
   */
  @java.lang.Override
  public java.lang.String getBorrowAPY() {
    java.lang.Object ref = borrowAPY_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      borrowAPY_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Borrow APY is the current interest rate borrowers are being charged on their loans. For example, 0.2 would mean 20% APY.
   * </pre>
   *
   * <code>string borrow_APY = 6 [json_name = "borrowAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "borrow_apy"];</code>
   * @return The bytes for borrowAPY.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getBorrowAPYBytes() {
    java.lang.Object ref = borrowAPY_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      borrowAPY_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int SUPPLIED_FIELD_NUMBER = 7;
  @SuppressWarnings("serial")
  private volatile java.lang.Object supplied_ = "";
  /**
   * <pre>
   * Supplied is the total amount of tokens supplied to the the system by all suppliers, including any interest earned. This includes that tokens which have been borrowed out or enabled as collateral, but excludes reserves. Supplied is denominated in base tokens, so exponent must be applied to convert to symbol denom.
   * </pre>
   *
   * <code>string supplied = 7 [json_name = "supplied", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The supplied.
   */
  @java.lang.Override
  public java.lang.String getSupplied() {
    java.lang.Object ref = supplied_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      supplied_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Supplied is the total amount of tokens supplied to the the system by all suppliers, including any interest earned. This includes that tokens which have been borrowed out or enabled as collateral, but excludes reserves. Supplied is denominated in base tokens, so exponent must be applied to convert to symbol denom.
   * </pre>
   *
   * <code>string supplied = 7 [json_name = "supplied", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The bytes for supplied.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getSuppliedBytes() {
    java.lang.Object ref = supplied_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      supplied_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int RESERVED_FIELD_NUMBER = 8;
  @SuppressWarnings("serial")
  private volatile java.lang.Object reserved_ = "";
  /**
   * <pre>
   * Reserved is the total amount of tokens held in reserve by the module for emergencies. Reserves are always excluded from total supply, borrow, collateral, and liqduidity queries. Reserves are denominated in base tokens, so exponent must be applied to convert to symbol denom.
   * </pre>
   *
   * <code>string reserved = 8 [json_name = "reserved", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The reserved.
   */
  @java.lang.Override
  public java.lang.String getReserved() {
    java.lang.Object ref = reserved_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      reserved_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Reserved is the total amount of tokens held in reserve by the module for emergencies. Reserves are always excluded from total supply, borrow, collateral, and liqduidity queries. Reserves are denominated in base tokens, so exponent must be applied to convert to symbol denom.
   * </pre>
   *
   * <code>string reserved = 8 [json_name = "reserved", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The bytes for reserved.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getReservedBytes() {
    java.lang.Object ref = reserved_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      reserved_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int COLLATERAL_FIELD_NUMBER = 9;
  @SuppressWarnings("serial")
  private volatile java.lang.Object collateral_ = "";
  /**
   * <pre>
   * Collateral is the total amount of uTokens collateralized by all borrowers. Collateral is denominated in uTokenso, so both uToken exchange rate and exponent must also be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee and uToken exchange rate is 1.2, then 5 UMEE have been collateralized.
   * </pre>
   *
   * <code>string collateral = 9 [json_name = "collateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The collateral.
   */
  @java.lang.Override
  public java.lang.String getCollateral() {
    java.lang.Object ref = collateral_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      collateral_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Collateral is the total amount of uTokens collateralized by all borrowers. Collateral is denominated in uTokenso, so both uToken exchange rate and exponent must also be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee and uToken exchange rate is 1.2, then 5 UMEE have been collateralized.
   * </pre>
   *
   * <code>string collateral = 9 [json_name = "collateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The bytes for collateral.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getCollateralBytes() {
    java.lang.Object ref = collateral_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      collateral_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int BORROWED_FIELD_NUMBER = 10;
  @SuppressWarnings("serial")
  private volatile java.lang.Object borrowed_ = "";
  /**
   * <pre>
   * Borrowed is the total amount of debt in this token held across all borrowers. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
   * </pre>
   *
   * <code>string borrowed = 10 [json_name = "borrowed", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The borrowed.
   */
  @java.lang.Override
  public java.lang.String getBorrowed() {
    java.lang.Object ref = borrowed_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      borrowed_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Borrowed is the total amount of debt in this token held across all borrowers. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
   * </pre>
   *
   * <code>string borrowed = 10 [json_name = "borrowed", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The bytes for borrowed.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getBorrowedBytes() {
    java.lang.Object ref = borrowed_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      borrowed_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int LIQUIDITY_FIELD_NUMBER = 11;
  @SuppressWarnings("serial")
  private volatile java.lang.Object liquidity_ = "";
  /**
   * <pre>
   * Liquidity is the amount of a token that has been supplied but not yet borrowed or reserved. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
   * </pre>
   *
   * <code>string liquidity = 11 [json_name = "liquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The liquidity.
   */
  @java.lang.Override
  public java.lang.String getLiquidity() {
    java.lang.Object ref = liquidity_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      liquidity_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Liquidity is the amount of a token that has been supplied but not yet borrowed or reserved. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
   * </pre>
   *
   * <code>string liquidity = 11 [json_name = "liquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The bytes for liquidity.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getLiquidityBytes() {
    java.lang.Object ref = liquidity_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      liquidity_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int MAXIMUM_BORROW_FIELD_NUMBER = 12;
  @SuppressWarnings("serial")
  private volatile java.lang.Object maximumBorrow_ = "";
  /**
   * <pre>
   * Maximum Borrow is the amount of a token that is available for borrowing, including that which has already been borrowed out. This amount is less than total supply due to safety limits. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if borrowed is 3000000 uumee and maximum borrow is 4000000 uumee, then 1 UMEE is currently available for borrowing.
   * </pre>
   *
   * <code>string maximum_borrow = 12 [json_name = "maximumBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The maximumBorrow.
   */
  @java.lang.Override
  public java.lang.String getMaximumBorrow() {
    java.lang.Object ref = maximumBorrow_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      maximumBorrow_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Maximum Borrow is the amount of a token that is available for borrowing, including that which has already been borrowed out. This amount is less than total supply due to safety limits. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if borrowed is 3000000 uumee and maximum borrow is 4000000 uumee, then 1 UMEE is currently available for borrowing.
   * </pre>
   *
   * <code>string maximum_borrow = 12 [json_name = "maximumBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The bytes for maximumBorrow.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getMaximumBorrowBytes() {
    java.lang.Object ref = maximumBorrow_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      maximumBorrow_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int MAXIMUM_COLLATERAL_FIELD_NUMBER = 13;
  @SuppressWarnings("serial")
  private volatile java.lang.Object maximumCollateral_ = "";
  /**
   * <pre>
   * Maximum Collateral is the amount of a token that can be collateralized, including that which is already collateral. This amount is less than total supply due to safety limits. It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee, uToken exchange rate is 1.2, and maximum borrow is 7000000 uumee, then a maximum of 2 additional UMEE is permitted to be collateralized.
   * </pre>
   *
   * <code>string maximum_collateral = 13 [json_name = "maximumCollateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The maximumCollateral.
   */
  @java.lang.Override
  public java.lang.String getMaximumCollateral() {
    java.lang.Object ref = maximumCollateral_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      maximumCollateral_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Maximum Collateral is the amount of a token that can be collateralized, including that which is already collateral. This amount is less than total supply due to safety limits. It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee, uToken exchange rate is 1.2, and maximum borrow is 7000000 uumee, then a maximum of 2 additional UMEE is permitted to be collateralized.
   * </pre>
   *
   * <code>string maximum_collateral = 13 [json_name = "maximumCollateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The bytes for maximumCollateral.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getMaximumCollateralBytes() {
    java.lang.Object ref = maximumCollateral_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      maximumCollateral_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int MINIMUM_LIQUIDITY_FIELD_NUMBER = 14;
  @SuppressWarnings("serial")
  private volatile java.lang.Object minimumLiquidity_ = "";
  /**
   * <pre>
   * Minimum Liquidity is the minimum amount of liquidity in the module required by safety limits, based on the current collateral. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if liquidity is 9000000 uumee and minimum liquidity is 8000000 uumee, then a maximum of 1 additional UMEE is currently available for borrowing or withdrawal.
   * </pre>
   *
   * <code>string minimum_liquidity = 14 [json_name = "minimumLiquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The minimumLiquidity.
   */
  @java.lang.Override
  public java.lang.String getMinimumLiquidity() {
    java.lang.Object ref = minimumLiquidity_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      minimumLiquidity_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Minimum Liquidity is the minimum amount of liquidity in the module required by safety limits, based on the current collateral. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if liquidity is 9000000 uumee and minimum liquidity is 8000000 uumee, then a maximum of 1 additional UMEE is currently available for borrowing or withdrawal.
   * </pre>
   *
   * <code>string minimum_liquidity = 14 [json_name = "minimumLiquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The bytes for minimumLiquidity.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getMinimumLiquidityBytes() {
    java.lang.Object ref = minimumLiquidity_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      minimumLiquidity_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int UTOKEN_SUPPLY_FIELD_NUMBER = 15;
  @SuppressWarnings("serial")
  private volatile java.lang.Object uTokenSupply_ = "";
  /**
   * <pre>
   * uToken Supply is the total amount of a base token's associated uToken in circulation.
   * </pre>
   *
   * <code>string uToken_supply = 15 [json_name = "uTokenSupply", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.gogoproto.jsontag) = "utoken_supply"];</code>
   * @return The uTokenSupply.
   */
  @java.lang.Override
  public java.lang.String getUTokenSupply() {
    java.lang.Object ref = uTokenSupply_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      uTokenSupply_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * uToken Supply is the total amount of a base token's associated uToken in circulation.
   * </pre>
   *
   * <code>string uToken_supply = 15 [json_name = "uTokenSupply", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.gogoproto.jsontag) = "utoken_supply"];</code>
   * @return The bytes for uTokenSupply.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getUTokenSupplyBytes() {
    java.lang.Object ref = uTokenSupply_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      uTokenSupply_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int AVAILABLE_BORROW_FIELD_NUMBER = 16;
  @SuppressWarnings("serial")
  private volatile java.lang.Object availableBorrow_ = "";
  /**
   * <pre>
   * Available Borrow is the maximum additional amount of base tokens than can be borrowed based on current liquidity and system safety limits. It can also be calculated by MIN(maximum_borrow - borrowed, liquidity - minimum_liquidity). It is denominated in base tokens, so exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and borrowing is temporarily unavailable.
   * </pre>
   *
   * <code>string available_borrow = 16 [json_name = "availableBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The availableBorrow.
   */
  @java.lang.Override
  public java.lang.String getAvailableBorrow() {
    java.lang.Object ref = availableBorrow_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      availableBorrow_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Available Borrow is the maximum additional amount of base tokens than can be borrowed based on current liquidity and system safety limits. It can also be calculated by MIN(maximum_borrow - borrowed, liquidity - minimum_liquidity). It is denominated in base tokens, so exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and borrowing is temporarily unavailable.
   * </pre>
   *
   * <code>string available_borrow = 16 [json_name = "availableBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The bytes for availableBorrow.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getAvailableBorrowBytes() {
    java.lang.Object ref = availableBorrow_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      availableBorrow_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int AVAILABLE_WITHDRAW_FIELD_NUMBER = 17;
  @SuppressWarnings("serial")
  private volatile java.lang.Object availableWithdraw_ = "";
  /**
   * <pre>
   * Available Withdraw is the maximum amount of uTokens than can currently be withdrawn based on liquidity and system safety limits. It can also be calculated by (liquidity - minimum_liquidity). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and withdrawal is temporarily unavailable.
   * </pre>
   *
   * <code>string available_withdraw = 17 [json_name = "availableWithdraw", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The availableWithdraw.
   */
  @java.lang.Override
  public java.lang.String getAvailableWithdraw() {
    java.lang.Object ref = availableWithdraw_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      availableWithdraw_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Available Withdraw is the maximum amount of uTokens than can currently be withdrawn based on liquidity and system safety limits. It can also be calculated by (liquidity - minimum_liquidity). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and withdrawal is temporarily unavailable.
   * </pre>
   *
   * <code>string available_withdraw = 17 [json_name = "availableWithdraw", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The bytes for availableWithdraw.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getAvailableWithdrawBytes() {
    java.lang.Object ref = availableWithdraw_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      availableWithdraw_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int AVAILABLE_COLLATERALIZE_FIELD_NUMBER = 18;
  @SuppressWarnings("serial")
  private volatile java.lang.Object availableCollateralize_ = "";
  /**
   * <pre>
   * Available Collateralize is the maximum additional amount of uTokens than can be collateralized based on current liquidity and system safety limits. It can also be calculated by (maximum_collateral, - collateral). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and additional collateral cannot be created until more liquidity is present.
   * </pre>
   *
   * <code>string available_collateralize = 18 [json_name = "availableCollateralize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The availableCollateralize.
   */
  @java.lang.Override
  public java.lang.String getAvailableCollateralize() {
    java.lang.Object ref = availableCollateralize_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      availableCollateralize_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Available Collateralize is the maximum additional amount of uTokens than can be collateralized based on current liquidity and system safety limits. It can also be calculated by (maximum_collateral, - collateral). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and additional collateral cannot be created until more liquidity is present.
   * </pre>
   *
   * <code>string available_collateralize = 18 [json_name = "availableCollateralize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
   * @return The bytes for availableCollateralize.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getAvailableCollateralizeBytes() {
    java.lang.Object ref = availableCollateralize_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      availableCollateralize_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ORACLE_HISTORIC_PRICE_FIELD_NUMBER = 19;
  @SuppressWarnings("serial")
  private volatile java.lang.Object oracleHistoricPrice_ = "";
  /**
   * <pre>
   * Oracle Historic Price is the historic USD value of a token. Historic price is defined as the median of the last N historic median prices from the oracle module, with N being this token's HistoricMedians in the leverage registry. Current price is used if required medians is zero. Price is nil when the oracle is down or insufficient historic medians are available.
   * </pre>
   *
   * <code>string oracle_historic_price = 19 [json_name = "oracleHistoricPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
   * @return The oracleHistoricPrice.
   */
  @java.lang.Override
  public java.lang.String getOracleHistoricPrice() {
    java.lang.Object ref = oracleHistoricPrice_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      oracleHistoricPrice_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Oracle Historic Price is the historic USD value of a token. Historic price is defined as the median of the last N historic median prices from the oracle module, with N being this token's HistoricMedians in the leverage registry. Current price is used if required medians is zero. Price is nil when the oracle is down or insufficient historic medians are available.
   * </pre>
   *
   * <code>string oracle_historic_price = 19 [json_name = "oracleHistoricPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
   * @return The bytes for oracleHistoricPrice.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getOracleHistoricPriceBytes() {
    java.lang.Object ref = oracleHistoricPrice_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      oracleHistoricPrice_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ERRORS_FIELD_NUMBER = 20;
  @SuppressWarnings("serial")
  private volatile java.lang.Object errors_ = "";
  /**
   * <code>string errors = 20 [json_name = "errors"];</code>
   * @return The errors.
   */
  @java.lang.Override
  public java.lang.String getErrors() {
    java.lang.Object ref = errors_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      errors_ = s;
      return s;
    }
  }
  /**
   * <code>string errors = 20 [json_name = "errors"];</code>
   * @return The bytes for errors.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getErrorsBytes() {
    java.lang.Object ref = errors_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      errors_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbolDenom_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 1, symbolDenom_);
    }
    if (exponent_ != 0) {
      output.writeUInt32(2, exponent_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(oraclePrice_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3, oraclePrice_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(uTokenExchangeRate_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 4, uTokenExchangeRate_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(supplyAPY_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 5, supplyAPY_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(borrowAPY_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 6, borrowAPY_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(supplied_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 7, supplied_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(reserved_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 8, reserved_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(collateral_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 9, collateral_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(borrowed_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 10, borrowed_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(liquidity_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 11, liquidity_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(maximumBorrow_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 12, maximumBorrow_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(maximumCollateral_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 13, maximumCollateral_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(minimumLiquidity_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 14, minimumLiquidity_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(uTokenSupply_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 15, uTokenSupply_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(availableBorrow_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 16, availableBorrow_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(availableWithdraw_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 17, availableWithdraw_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(availableCollateralize_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 18, availableCollateralize_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(oracleHistoricPrice_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 19, oracleHistoricPrice_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errors_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 20, errors_);
    }
    getUnknownFields().writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(symbolDenom_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, symbolDenom_);
    }
    if (exponent_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt32Size(2, exponent_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(oraclePrice_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, oraclePrice_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(uTokenExchangeRate_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, uTokenExchangeRate_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(supplyAPY_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, supplyAPY_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(borrowAPY_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, borrowAPY_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(supplied_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, supplied_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(reserved_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, reserved_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(collateral_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, collateral_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(borrowed_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(10, borrowed_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(liquidity_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(11, liquidity_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(maximumBorrow_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, maximumBorrow_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(maximumCollateral_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(13, maximumCollateral_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(minimumLiquidity_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(14, minimumLiquidity_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(uTokenSupply_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(15, uTokenSupply_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(availableBorrow_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(16, availableBorrow_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(availableWithdraw_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(17, availableWithdraw_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(availableCollateralize_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(18, availableCollateralize_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(oracleHistoricPrice_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(19, oracleHistoricPrice_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errors_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(20, errors_);
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof com.umee.leverage.v1.QueryMarketSummaryResponse)) {
      return super.equals(obj);
    }
    com.umee.leverage.v1.QueryMarketSummaryResponse other = (com.umee.leverage.v1.QueryMarketSummaryResponse) obj;

    if (!getSymbolDenom()
        .equals(other.getSymbolDenom())) return false;
    if (getExponent()
        != other.getExponent()) return false;
    if (!getOraclePrice()
        .equals(other.getOraclePrice())) return false;
    if (!getUTokenExchangeRate()
        .equals(other.getUTokenExchangeRate())) return false;
    if (!getSupplyAPY()
        .equals(other.getSupplyAPY())) return false;
    if (!getBorrowAPY()
        .equals(other.getBorrowAPY())) return false;
    if (!getSupplied()
        .equals(other.getSupplied())) return false;
    if (!getReserved()
        .equals(other.getReserved())) return false;
    if (!getCollateral()
        .equals(other.getCollateral())) return false;
    if (!getBorrowed()
        .equals(other.getBorrowed())) return false;
    if (!getLiquidity()
        .equals(other.getLiquidity())) return false;
    if (!getMaximumBorrow()
        .equals(other.getMaximumBorrow())) return false;
    if (!getMaximumCollateral()
        .equals(other.getMaximumCollateral())) return false;
    if (!getMinimumLiquidity()
        .equals(other.getMinimumLiquidity())) return false;
    if (!getUTokenSupply()
        .equals(other.getUTokenSupply())) return false;
    if (!getAvailableBorrow()
        .equals(other.getAvailableBorrow())) return false;
    if (!getAvailableWithdraw()
        .equals(other.getAvailableWithdraw())) return false;
    if (!getAvailableCollateralize()
        .equals(other.getAvailableCollateralize())) return false;
    if (!getOracleHistoricPrice()
        .equals(other.getOracleHistoricPrice())) return false;
    if (!getErrors()
        .equals(other.getErrors())) return false;
    if (!getUnknownFields().equals(other.getUnknownFields())) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + SYMBOL_DENOM_FIELD_NUMBER;
    hash = (53 * hash) + getSymbolDenom().hashCode();
    hash = (37 * hash) + EXPONENT_FIELD_NUMBER;
    hash = (53 * hash) + getExponent();
    hash = (37 * hash) + ORACLE_PRICE_FIELD_NUMBER;
    hash = (53 * hash) + getOraclePrice().hashCode();
    hash = (37 * hash) + UTOKEN_EXCHANGE_RATE_FIELD_NUMBER;
    hash = (53 * hash) + getUTokenExchangeRate().hashCode();
    hash = (37 * hash) + SUPPLY_APY_FIELD_NUMBER;
    hash = (53 * hash) + getSupplyAPY().hashCode();
    hash = (37 * hash) + BORROW_APY_FIELD_NUMBER;
    hash = (53 * hash) + getBorrowAPY().hashCode();
    hash = (37 * hash) + SUPPLIED_FIELD_NUMBER;
    hash = (53 * hash) + getSupplied().hashCode();
    hash = (37 * hash) + RESERVED_FIELD_NUMBER;
    hash = (53 * hash) + getReserved().hashCode();
    hash = (37 * hash) + COLLATERAL_FIELD_NUMBER;
    hash = (53 * hash) + getCollateral().hashCode();
    hash = (37 * hash) + BORROWED_FIELD_NUMBER;
    hash = (53 * hash) + getBorrowed().hashCode();
    hash = (37 * hash) + LIQUIDITY_FIELD_NUMBER;
    hash = (53 * hash) + getLiquidity().hashCode();
    hash = (37 * hash) + MAXIMUM_BORROW_FIELD_NUMBER;
    hash = (53 * hash) + getMaximumBorrow().hashCode();
    hash = (37 * hash) + MAXIMUM_COLLATERAL_FIELD_NUMBER;
    hash = (53 * hash) + getMaximumCollateral().hashCode();
    hash = (37 * hash) + MINIMUM_LIQUIDITY_FIELD_NUMBER;
    hash = (53 * hash) + getMinimumLiquidity().hashCode();
    hash = (37 * hash) + UTOKEN_SUPPLY_FIELD_NUMBER;
    hash = (53 * hash) + getUTokenSupply().hashCode();
    hash = (37 * hash) + AVAILABLE_BORROW_FIELD_NUMBER;
    hash = (53 * hash) + getAvailableBorrow().hashCode();
    hash = (37 * hash) + AVAILABLE_WITHDRAW_FIELD_NUMBER;
    hash = (53 * hash) + getAvailableWithdraw().hashCode();
    hash = (37 * hash) + AVAILABLE_COLLATERALIZE_FIELD_NUMBER;
    hash = (53 * hash) + getAvailableCollateralize().hashCode();
    hash = (37 * hash) + ORACLE_HISTORIC_PRICE_FIELD_NUMBER;
    hash = (53 * hash) + getOracleHistoricPrice().hashCode();
    hash = (37 * hash) + ERRORS_FIELD_NUMBER;
    hash = (53 * hash) + getErrors().hashCode();
    hash = (29 * hash) + getUnknownFields().hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.umee.leverage.v1.QueryMarketSummaryResponse parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.umee.leverage.v1.QueryMarketSummaryResponse parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.umee.leverage.v1.QueryMarketSummaryResponse parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.umee.leverage.v1.QueryMarketSummaryResponse parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.umee.leverage.v1.QueryMarketSummaryResponse parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.umee.leverage.v1.QueryMarketSummaryResponse parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.umee.leverage.v1.QueryMarketSummaryResponse parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static com.umee.leverage.v1.QueryMarketSummaryResponse parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  public static com.umee.leverage.v1.QueryMarketSummaryResponse parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }

  public static com.umee.leverage.v1.QueryMarketSummaryResponse parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static com.umee.leverage.v1.QueryMarketSummaryResponse parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static com.umee.leverage.v1.QueryMarketSummaryResponse parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(com.umee.leverage.v1.QueryMarketSummaryResponse prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * QueryMarketSummaryResponse defines the response structure for the MarketSummary gRPC service handler.
   * </pre>
   *
   * Protobuf type {@code umee.leverage.v1.QueryMarketSummaryResponse}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:umee.leverage.v1.QueryMarketSummaryResponse)
      com.umee.leverage.v1.QueryMarketSummaryResponseOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.umee.leverage.v1.QueryProto.internal_static_umee_leverage_v1_QueryMarketSummaryResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.umee.leverage.v1.QueryProto.internal_static_umee_leverage_v1_QueryMarketSummaryResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.umee.leverage.v1.QueryMarketSummaryResponse.class, com.umee.leverage.v1.QueryMarketSummaryResponse.Builder.class);
    }

    // Construct using com.umee.leverage.v1.QueryMarketSummaryResponse.newBuilder()
    private Builder() {

    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);

    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      bitField0_ = 0;
      symbolDenom_ = "";
      exponent_ = 0;
      oraclePrice_ = "";
      uTokenExchangeRate_ = "";
      supplyAPY_ = "";
      borrowAPY_ = "";
      supplied_ = "";
      reserved_ = "";
      collateral_ = "";
      borrowed_ = "";
      liquidity_ = "";
      maximumBorrow_ = "";
      maximumCollateral_ = "";
      minimumLiquidity_ = "";
      uTokenSupply_ = "";
      availableBorrow_ = "";
      availableWithdraw_ = "";
      availableCollateralize_ = "";
      oracleHistoricPrice_ = "";
      errors_ = "";
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return com.umee.leverage.v1.QueryProto.internal_static_umee_leverage_v1_QueryMarketSummaryResponse_descriptor;
    }

    @java.lang.Override
    public com.umee.leverage.v1.QueryMarketSummaryResponse getDefaultInstanceForType() {
      return com.umee.leverage.v1.QueryMarketSummaryResponse.getDefaultInstance();
    }

    @java.lang.Override
    public com.umee.leverage.v1.QueryMarketSummaryResponse build() {
      com.umee.leverage.v1.QueryMarketSummaryResponse result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.umee.leverage.v1.QueryMarketSummaryResponse buildPartial() {
      com.umee.leverage.v1.QueryMarketSummaryResponse result = new com.umee.leverage.v1.QueryMarketSummaryResponse(this);
      if (bitField0_ != 0) { buildPartial0(result); }
      onBuilt();
      return result;
    }

    private void buildPartial0(com.umee.leverage.v1.QueryMarketSummaryResponse result) {
      int from_bitField0_ = bitField0_;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        result.symbolDenom_ = symbolDenom_;
      }
      if (((from_bitField0_ & 0x00000002) != 0)) {
        result.exponent_ = exponent_;
      }
      if (((from_bitField0_ & 0x00000004) != 0)) {
        result.oraclePrice_ = oraclePrice_;
      }
      if (((from_bitField0_ & 0x00000008) != 0)) {
        result.uTokenExchangeRate_ = uTokenExchangeRate_;
      }
      if (((from_bitField0_ & 0x00000010) != 0)) {
        result.supplyAPY_ = supplyAPY_;
      }
      if (((from_bitField0_ & 0x00000020) != 0)) {
        result.borrowAPY_ = borrowAPY_;
      }
      if (((from_bitField0_ & 0x00000040) != 0)) {
        result.supplied_ = supplied_;
      }
      if (((from_bitField0_ & 0x00000080) != 0)) {
        result.reserved_ = reserved_;
      }
      if (((from_bitField0_ & 0x00000100) != 0)) {
        result.collateral_ = collateral_;
      }
      if (((from_bitField0_ & 0x00000200) != 0)) {
        result.borrowed_ = borrowed_;
      }
      if (((from_bitField0_ & 0x00000400) != 0)) {
        result.liquidity_ = liquidity_;
      }
      if (((from_bitField0_ & 0x00000800) != 0)) {
        result.maximumBorrow_ = maximumBorrow_;
      }
      if (((from_bitField0_ & 0x00001000) != 0)) {
        result.maximumCollateral_ = maximumCollateral_;
      }
      if (((from_bitField0_ & 0x00002000) != 0)) {
        result.minimumLiquidity_ = minimumLiquidity_;
      }
      if (((from_bitField0_ & 0x00004000) != 0)) {
        result.uTokenSupply_ = uTokenSupply_;
      }
      if (((from_bitField0_ & 0x00008000) != 0)) {
        result.availableBorrow_ = availableBorrow_;
      }
      if (((from_bitField0_ & 0x00010000) != 0)) {
        result.availableWithdraw_ = availableWithdraw_;
      }
      if (((from_bitField0_ & 0x00020000) != 0)) {
        result.availableCollateralize_ = availableCollateralize_;
      }
      if (((from_bitField0_ & 0x00040000) != 0)) {
        result.oracleHistoricPrice_ = oracleHistoricPrice_;
      }
      if (((from_bitField0_ & 0x00080000) != 0)) {
        result.errors_ = errors_;
      }
    }

    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.umee.leverage.v1.QueryMarketSummaryResponse) {
        return mergeFrom((com.umee.leverage.v1.QueryMarketSummaryResponse)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.umee.leverage.v1.QueryMarketSummaryResponse other) {
      if (other == com.umee.leverage.v1.QueryMarketSummaryResponse.getDefaultInstance()) return this;
      if (!other.getSymbolDenom().isEmpty()) {
        symbolDenom_ = other.symbolDenom_;
        bitField0_ |= 0x00000001;
        onChanged();
      }
      if (other.getExponent() != 0) {
        setExponent(other.getExponent());
      }
      if (!other.getOraclePrice().isEmpty()) {
        oraclePrice_ = other.oraclePrice_;
        bitField0_ |= 0x00000004;
        onChanged();
      }
      if (!other.getUTokenExchangeRate().isEmpty()) {
        uTokenExchangeRate_ = other.uTokenExchangeRate_;
        bitField0_ |= 0x00000008;
        onChanged();
      }
      if (!other.getSupplyAPY().isEmpty()) {
        supplyAPY_ = other.supplyAPY_;
        bitField0_ |= 0x00000010;
        onChanged();
      }
      if (!other.getBorrowAPY().isEmpty()) {
        borrowAPY_ = other.borrowAPY_;
        bitField0_ |= 0x00000020;
        onChanged();
      }
      if (!other.getSupplied().isEmpty()) {
        supplied_ = other.supplied_;
        bitField0_ |= 0x00000040;
        onChanged();
      }
      if (!other.getReserved().isEmpty()) {
        reserved_ = other.reserved_;
        bitField0_ |= 0x00000080;
        onChanged();
      }
      if (!other.getCollateral().isEmpty()) {
        collateral_ = other.collateral_;
        bitField0_ |= 0x00000100;
        onChanged();
      }
      if (!other.getBorrowed().isEmpty()) {
        borrowed_ = other.borrowed_;
        bitField0_ |= 0x00000200;
        onChanged();
      }
      if (!other.getLiquidity().isEmpty()) {
        liquidity_ = other.liquidity_;
        bitField0_ |= 0x00000400;
        onChanged();
      }
      if (!other.getMaximumBorrow().isEmpty()) {
        maximumBorrow_ = other.maximumBorrow_;
        bitField0_ |= 0x00000800;
        onChanged();
      }
      if (!other.getMaximumCollateral().isEmpty()) {
        maximumCollateral_ = other.maximumCollateral_;
        bitField0_ |= 0x00001000;
        onChanged();
      }
      if (!other.getMinimumLiquidity().isEmpty()) {
        minimumLiquidity_ = other.minimumLiquidity_;
        bitField0_ |= 0x00002000;
        onChanged();
      }
      if (!other.getUTokenSupply().isEmpty()) {
        uTokenSupply_ = other.uTokenSupply_;
        bitField0_ |= 0x00004000;
        onChanged();
      }
      if (!other.getAvailableBorrow().isEmpty()) {
        availableBorrow_ = other.availableBorrow_;
        bitField0_ |= 0x00008000;
        onChanged();
      }
      if (!other.getAvailableWithdraw().isEmpty()) {
        availableWithdraw_ = other.availableWithdraw_;
        bitField0_ |= 0x00010000;
        onChanged();
      }
      if (!other.getAvailableCollateralize().isEmpty()) {
        availableCollateralize_ = other.availableCollateralize_;
        bitField0_ |= 0x00020000;
        onChanged();
      }
      if (!other.getOracleHistoricPrice().isEmpty()) {
        oracleHistoricPrice_ = other.oracleHistoricPrice_;
        bitField0_ |= 0x00040000;
        onChanged();
      }
      if (!other.getErrors().isEmpty()) {
        errors_ = other.errors_;
        bitField0_ |= 0x00080000;
        onChanged();
      }
      this.mergeUnknownFields(other.getUnknownFields());
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              symbolDenom_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000001;
              break;
            } // case 10
            case 16: {
              exponent_ = input.readUInt32();
              bitField0_ |= 0x00000002;
              break;
            } // case 16
            case 26: {
              oraclePrice_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000004;
              break;
            } // case 26
            case 34: {
              uTokenExchangeRate_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000008;
              break;
            } // case 34
            case 42: {
              supplyAPY_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000010;
              break;
            } // case 42
            case 50: {
              borrowAPY_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000020;
              break;
            } // case 50
            case 58: {
              supplied_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000040;
              break;
            } // case 58
            case 66: {
              reserved_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000080;
              break;
            } // case 66
            case 74: {
              collateral_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000100;
              break;
            } // case 74
            case 82: {
              borrowed_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000200;
              break;
            } // case 82
            case 90: {
              liquidity_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000400;
              break;
            } // case 90
            case 98: {
              maximumBorrow_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000800;
              break;
            } // case 98
            case 106: {
              maximumCollateral_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00001000;
              break;
            } // case 106
            case 114: {
              minimumLiquidity_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00002000;
              break;
            } // case 114
            case 122: {
              uTokenSupply_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00004000;
              break;
            } // case 122
            case 130: {
              availableBorrow_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00008000;
              break;
            } // case 130
            case 138: {
              availableWithdraw_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00010000;
              break;
            } // case 138
            case 146: {
              availableCollateralize_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00020000;
              break;
            } // case 146
            case 154: {
              oracleHistoricPrice_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00040000;
              break;
            } // case 154
            case 162: {
              errors_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00080000;
              break;
            } // case 162
            default: {
              if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                done = true; // was an endgroup tag
              }
              break;
            } // default:
          } // switch (tag)
        } // while (!done)
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.unwrapIOException();
      } finally {
        onChanged();
      } // finally
      return this;
    }
    private int bitField0_;

    private java.lang.Object symbolDenom_ = "";
    /**
     * <pre>
     * Symbol Denom is the human-readable representation of a token denom, for example "UMEE" or "ATOM".
     * </pre>
     *
     * <code>string symbol_denom = 1 [json_name = "symbolDenom"];</code>
     * @return The symbolDenom.
     */
    public java.lang.String getSymbolDenom() {
      java.lang.Object ref = symbolDenom_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        symbolDenom_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Symbol Denom is the human-readable representation of a token denom, for example "UMEE" or "ATOM".
     * </pre>
     *
     * <code>string symbol_denom = 1 [json_name = "symbolDenom"];</code>
     * @return The bytes for symbolDenom.
     */
    public com.google.protobuf.ByteString
        getSymbolDenomBytes() {
      java.lang.Object ref = symbolDenom_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        symbolDenom_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Symbol Denom is the human-readable representation of a token denom, for example "UMEE" or "ATOM".
     * </pre>
     *
     * <code>string symbol_denom = 1 [json_name = "symbolDenom"];</code>
     * @param value The symbolDenom to set.
     * @return This builder for chaining.
     */
    public Builder setSymbolDenom(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      symbolDenom_ = value;
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Symbol Denom is the human-readable representation of a token denom, for example "UMEE" or "ATOM".
     * </pre>
     *
     * <code>string symbol_denom = 1 [json_name = "symbolDenom"];</code>
     * @return This builder for chaining.
     */
    public Builder clearSymbolDenom() {
      symbolDenom_ = getDefaultInstance().getSymbolDenom();
      bitField0_ = (bitField0_ & ~0x00000001);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Symbol Denom is the human-readable representation of a token denom, for example "UMEE" or "ATOM".
     * </pre>
     *
     * <code>string symbol_denom = 1 [json_name = "symbolDenom"];</code>
     * @param value The bytes for symbolDenom to set.
     * @return This builder for chaining.
     */
    public Builder setSymbolDenomBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      symbolDenom_ = value;
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }

    private int exponent_ ;
    /**
     * <pre>
     * Exponent is the power of ten required to get from base denom to symbol denom. For example, an exponent of 6 means 10^6 uumee = 1 UMEE.
     * </pre>
     *
     * <code>uint32 exponent = 2 [json_name = "exponent"];</code>
     * @return The exponent.
     */
    @java.lang.Override
    public int getExponent() {
      return exponent_;
    }
    /**
     * <pre>
     * Exponent is the power of ten required to get from base denom to symbol denom. For example, an exponent of 6 means 10^6 uumee = 1 UMEE.
     * </pre>
     *
     * <code>uint32 exponent = 2 [json_name = "exponent"];</code>
     * @param value The exponent to set.
     * @return This builder for chaining.
     */
    public Builder setExponent(int value) {

      exponent_ = value;
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Exponent is the power of ten required to get from base denom to symbol denom. For example, an exponent of 6 means 10^6 uumee = 1 UMEE.
     * </pre>
     *
     * <code>uint32 exponent = 2 [json_name = "exponent"];</code>
     * @return This builder for chaining.
     */
    public Builder clearExponent() {
      bitField0_ = (bitField0_ & ~0x00000002);
      exponent_ = 0;
      onChanged();
      return this;
    }

    private java.lang.Object oraclePrice_ = "";
    /**
     * <pre>
     * Oracle Price is the current USD value of a token. Oracle price is nil when the oracle is down.
     * </pre>
     *
     * <code>string oracle_price = 3 [json_name = "oraclePrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
     * @return The oraclePrice.
     */
    public java.lang.String getOraclePrice() {
      java.lang.Object ref = oraclePrice_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        oraclePrice_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Oracle Price is the current USD value of a token. Oracle price is nil when the oracle is down.
     * </pre>
     *
     * <code>string oracle_price = 3 [json_name = "oraclePrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
     * @return The bytes for oraclePrice.
     */
    public com.google.protobuf.ByteString
        getOraclePriceBytes() {
      java.lang.Object ref = oraclePrice_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        oraclePrice_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Oracle Price is the current USD value of a token. Oracle price is nil when the oracle is down.
     * </pre>
     *
     * <code>string oracle_price = 3 [json_name = "oraclePrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
     * @param value The oraclePrice to set.
     * @return This builder for chaining.
     */
    public Builder setOraclePrice(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      oraclePrice_ = value;
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Oracle Price is the current USD value of a token. Oracle price is nil when the oracle is down.
     * </pre>
     *
     * <code>string oracle_price = 3 [json_name = "oraclePrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
     * @return This builder for chaining.
     */
    public Builder clearOraclePrice() {
      oraclePrice_ = getDefaultInstance().getOraclePrice();
      bitField0_ = (bitField0_ & ~0x00000004);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Oracle Price is the current USD value of a token. Oracle price is nil when the oracle is down.
     * </pre>
     *
     * <code>string oracle_price = 3 [json_name = "oraclePrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
     * @param value The bytes for oraclePrice to set.
     * @return This builder for chaining.
     */
    public Builder setOraclePriceBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      oraclePrice_ = value;
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }

    private java.lang.Object uTokenExchangeRate_ = "";
    /**
     * <pre>
     * uToken Exchange Rate is the amount of base tokens received when withdrawing 1 uToken. For example, a uToken exchange rate of 1.5 means a supplier receives 3 uumee for every 2 u/uumee they wish to withdraw. The same applies in reverse: supplying 3 uumee would award 2 u/uumee at that time.
     * </pre>
     *
     * <code>string uToken_exchange_rate = 4 [json_name = "uTokenExchangeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "utoken_exchange_rate"];</code>
     * @return The uTokenExchangeRate.
     */
    public java.lang.String getUTokenExchangeRate() {
      java.lang.Object ref = uTokenExchangeRate_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        uTokenExchangeRate_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * uToken Exchange Rate is the amount of base tokens received when withdrawing 1 uToken. For example, a uToken exchange rate of 1.5 means a supplier receives 3 uumee for every 2 u/uumee they wish to withdraw. The same applies in reverse: supplying 3 uumee would award 2 u/uumee at that time.
     * </pre>
     *
     * <code>string uToken_exchange_rate = 4 [json_name = "uTokenExchangeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "utoken_exchange_rate"];</code>
     * @return The bytes for uTokenExchangeRate.
     */
    public com.google.protobuf.ByteString
        getUTokenExchangeRateBytes() {
      java.lang.Object ref = uTokenExchangeRate_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        uTokenExchangeRate_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * uToken Exchange Rate is the amount of base tokens received when withdrawing 1 uToken. For example, a uToken exchange rate of 1.5 means a supplier receives 3 uumee for every 2 u/uumee they wish to withdraw. The same applies in reverse: supplying 3 uumee would award 2 u/uumee at that time.
     * </pre>
     *
     * <code>string uToken_exchange_rate = 4 [json_name = "uTokenExchangeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "utoken_exchange_rate"];</code>
     * @param value The uTokenExchangeRate to set.
     * @return This builder for chaining.
     */
    public Builder setUTokenExchangeRate(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      uTokenExchangeRate_ = value;
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * uToken Exchange Rate is the amount of base tokens received when withdrawing 1 uToken. For example, a uToken exchange rate of 1.5 means a supplier receives 3 uumee for every 2 u/uumee they wish to withdraw. The same applies in reverse: supplying 3 uumee would award 2 u/uumee at that time.
     * </pre>
     *
     * <code>string uToken_exchange_rate = 4 [json_name = "uTokenExchangeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "utoken_exchange_rate"];</code>
     * @return This builder for chaining.
     */
    public Builder clearUTokenExchangeRate() {
      uTokenExchangeRate_ = getDefaultInstance().getUTokenExchangeRate();
      bitField0_ = (bitField0_ & ~0x00000008);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * uToken Exchange Rate is the amount of base tokens received when withdrawing 1 uToken. For example, a uToken exchange rate of 1.5 means a supplier receives 3 uumee for every 2 u/uumee they wish to withdraw. The same applies in reverse: supplying 3 uumee would award 2 u/uumee at that time.
     * </pre>
     *
     * <code>string uToken_exchange_rate = 4 [json_name = "uTokenExchangeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "utoken_exchange_rate"];</code>
     * @param value The bytes for uTokenExchangeRate to set.
     * @return This builder for chaining.
     */
    public Builder setUTokenExchangeRateBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      uTokenExchangeRate_ = value;
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }

    private java.lang.Object supplyAPY_ = "";
    /**
     * <pre>
     * Supply APY is the current interest rate suppliers are receiving for their deposits. For example, 0.11 would mean 11% APY. Supply APY is always less than borrow APY.
     * </pre>
     *
     * <code>string supply_APY = 5 [json_name = "supplyAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "supply_apy"];</code>
     * @return The supplyAPY.
     */
    public java.lang.String getSupplyAPY() {
      java.lang.Object ref = supplyAPY_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        supplyAPY_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Supply APY is the current interest rate suppliers are receiving for their deposits. For example, 0.11 would mean 11% APY. Supply APY is always less than borrow APY.
     * </pre>
     *
     * <code>string supply_APY = 5 [json_name = "supplyAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "supply_apy"];</code>
     * @return The bytes for supplyAPY.
     */
    public com.google.protobuf.ByteString
        getSupplyAPYBytes() {
      java.lang.Object ref = supplyAPY_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        supplyAPY_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Supply APY is the current interest rate suppliers are receiving for their deposits. For example, 0.11 would mean 11% APY. Supply APY is always less than borrow APY.
     * </pre>
     *
     * <code>string supply_APY = 5 [json_name = "supplyAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "supply_apy"];</code>
     * @param value The supplyAPY to set.
     * @return This builder for chaining.
     */
    public Builder setSupplyAPY(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      supplyAPY_ = value;
      bitField0_ |= 0x00000010;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Supply APY is the current interest rate suppliers are receiving for their deposits. For example, 0.11 would mean 11% APY. Supply APY is always less than borrow APY.
     * </pre>
     *
     * <code>string supply_APY = 5 [json_name = "supplyAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "supply_apy"];</code>
     * @return This builder for chaining.
     */
    public Builder clearSupplyAPY() {
      supplyAPY_ = getDefaultInstance().getSupplyAPY();
      bitField0_ = (bitField0_ & ~0x00000010);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Supply APY is the current interest rate suppliers are receiving for their deposits. For example, 0.11 would mean 11% APY. Supply APY is always less than borrow APY.
     * </pre>
     *
     * <code>string supply_APY = 5 [json_name = "supplyAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "supply_apy"];</code>
     * @param value The bytes for supplyAPY to set.
     * @return This builder for chaining.
     */
    public Builder setSupplyAPYBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      supplyAPY_ = value;
      bitField0_ |= 0x00000010;
      onChanged();
      return this;
    }

    private java.lang.Object borrowAPY_ = "";
    /**
     * <pre>
     * Borrow APY is the current interest rate borrowers are being charged on their loans. For example, 0.2 would mean 20% APY.
     * </pre>
     *
     * <code>string borrow_APY = 6 [json_name = "borrowAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "borrow_apy"];</code>
     * @return The borrowAPY.
     */
    public java.lang.String getBorrowAPY() {
      java.lang.Object ref = borrowAPY_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        borrowAPY_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Borrow APY is the current interest rate borrowers are being charged on their loans. For example, 0.2 would mean 20% APY.
     * </pre>
     *
     * <code>string borrow_APY = 6 [json_name = "borrowAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "borrow_apy"];</code>
     * @return The bytes for borrowAPY.
     */
    public com.google.protobuf.ByteString
        getBorrowAPYBytes() {
      java.lang.Object ref = borrowAPY_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        borrowAPY_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Borrow APY is the current interest rate borrowers are being charged on their loans. For example, 0.2 would mean 20% APY.
     * </pre>
     *
     * <code>string borrow_APY = 6 [json_name = "borrowAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "borrow_apy"];</code>
     * @param value The borrowAPY to set.
     * @return This builder for chaining.
     */
    public Builder setBorrowAPY(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      borrowAPY_ = value;
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Borrow APY is the current interest rate borrowers are being charged on their loans. For example, 0.2 would mean 20% APY.
     * </pre>
     *
     * <code>string borrow_APY = 6 [json_name = "borrowAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "borrow_apy"];</code>
     * @return This builder for chaining.
     */
    public Builder clearBorrowAPY() {
      borrowAPY_ = getDefaultInstance().getBorrowAPY();
      bitField0_ = (bitField0_ & ~0x00000020);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Borrow APY is the current interest rate borrowers are being charged on their loans. For example, 0.2 would mean 20% APY.
     * </pre>
     *
     * <code>string borrow_APY = 6 [json_name = "borrowAPY", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.jsontag) = "borrow_apy"];</code>
     * @param value The bytes for borrowAPY to set.
     * @return This builder for chaining.
     */
    public Builder setBorrowAPYBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      borrowAPY_ = value;
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }

    private java.lang.Object supplied_ = "";
    /**
     * <pre>
     * Supplied is the total amount of tokens supplied to the the system by all suppliers, including any interest earned. This includes that tokens which have been borrowed out or enabled as collateral, but excludes reserves. Supplied is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string supplied = 7 [json_name = "supplied", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The supplied.
     */
    public java.lang.String getSupplied() {
      java.lang.Object ref = supplied_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        supplied_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Supplied is the total amount of tokens supplied to the the system by all suppliers, including any interest earned. This includes that tokens which have been borrowed out or enabled as collateral, but excludes reserves. Supplied is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string supplied = 7 [json_name = "supplied", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The bytes for supplied.
     */
    public com.google.protobuf.ByteString
        getSuppliedBytes() {
      java.lang.Object ref = supplied_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        supplied_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Supplied is the total amount of tokens supplied to the the system by all suppliers, including any interest earned. This includes that tokens which have been borrowed out or enabled as collateral, but excludes reserves. Supplied is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string supplied = 7 [json_name = "supplied", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The supplied to set.
     * @return This builder for chaining.
     */
    public Builder setSupplied(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      supplied_ = value;
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Supplied is the total amount of tokens supplied to the the system by all suppliers, including any interest earned. This includes that tokens which have been borrowed out or enabled as collateral, but excludes reserves. Supplied is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string supplied = 7 [json_name = "supplied", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return This builder for chaining.
     */
    public Builder clearSupplied() {
      supplied_ = getDefaultInstance().getSupplied();
      bitField0_ = (bitField0_ & ~0x00000040);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Supplied is the total amount of tokens supplied to the the system by all suppliers, including any interest earned. This includes that tokens which have been borrowed out or enabled as collateral, but excludes reserves. Supplied is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string supplied = 7 [json_name = "supplied", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The bytes for supplied to set.
     * @return This builder for chaining.
     */
    public Builder setSuppliedBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      supplied_ = value;
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }

    private java.lang.Object reserved_ = "";
    /**
     * <pre>
     * Reserved is the total amount of tokens held in reserve by the module for emergencies. Reserves are always excluded from total supply, borrow, collateral, and liqduidity queries. Reserves are denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string reserved = 8 [json_name = "reserved", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The reserved.
     */
    public java.lang.String getReserved() {
      java.lang.Object ref = reserved_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        reserved_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Reserved is the total amount of tokens held in reserve by the module for emergencies. Reserves are always excluded from total supply, borrow, collateral, and liqduidity queries. Reserves are denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string reserved = 8 [json_name = "reserved", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The bytes for reserved.
     */
    public com.google.protobuf.ByteString
        getReservedBytes() {
      java.lang.Object ref = reserved_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        reserved_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Reserved is the total amount of tokens held in reserve by the module for emergencies. Reserves are always excluded from total supply, borrow, collateral, and liqduidity queries. Reserves are denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string reserved = 8 [json_name = "reserved", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The reserved to set.
     * @return This builder for chaining.
     */
    public Builder setReserved(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      reserved_ = value;
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Reserved is the total amount of tokens held in reserve by the module for emergencies. Reserves are always excluded from total supply, borrow, collateral, and liqduidity queries. Reserves are denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string reserved = 8 [json_name = "reserved", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return This builder for chaining.
     */
    public Builder clearReserved() {
      reserved_ = getDefaultInstance().getReserved();
      bitField0_ = (bitField0_ & ~0x00000080);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Reserved is the total amount of tokens held in reserve by the module for emergencies. Reserves are always excluded from total supply, borrow, collateral, and liqduidity queries. Reserves are denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string reserved = 8 [json_name = "reserved", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The bytes for reserved to set.
     * @return This builder for chaining.
     */
    public Builder setReservedBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      reserved_ = value;
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }

    private java.lang.Object collateral_ = "";
    /**
     * <pre>
     * Collateral is the total amount of uTokens collateralized by all borrowers. Collateral is denominated in uTokenso, so both uToken exchange rate and exponent must also be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee and uToken exchange rate is 1.2, then 5 UMEE have been collateralized.
     * </pre>
     *
     * <code>string collateral = 9 [json_name = "collateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The collateral.
     */
    public java.lang.String getCollateral() {
      java.lang.Object ref = collateral_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        collateral_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Collateral is the total amount of uTokens collateralized by all borrowers. Collateral is denominated in uTokenso, so both uToken exchange rate and exponent must also be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee and uToken exchange rate is 1.2, then 5 UMEE have been collateralized.
     * </pre>
     *
     * <code>string collateral = 9 [json_name = "collateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The bytes for collateral.
     */
    public com.google.protobuf.ByteString
        getCollateralBytes() {
      java.lang.Object ref = collateral_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        collateral_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Collateral is the total amount of uTokens collateralized by all borrowers. Collateral is denominated in uTokenso, so both uToken exchange rate and exponent must also be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee and uToken exchange rate is 1.2, then 5 UMEE have been collateralized.
     * </pre>
     *
     * <code>string collateral = 9 [json_name = "collateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The collateral to set.
     * @return This builder for chaining.
     */
    public Builder setCollateral(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      collateral_ = value;
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Collateral is the total amount of uTokens collateralized by all borrowers. Collateral is denominated in uTokenso, so both uToken exchange rate and exponent must also be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee and uToken exchange rate is 1.2, then 5 UMEE have been collateralized.
     * </pre>
     *
     * <code>string collateral = 9 [json_name = "collateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return This builder for chaining.
     */
    public Builder clearCollateral() {
      collateral_ = getDefaultInstance().getCollateral();
      bitField0_ = (bitField0_ & ~0x00000100);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Collateral is the total amount of uTokens collateralized by all borrowers. Collateral is denominated in uTokenso, so both uToken exchange rate and exponent must also be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee and uToken exchange rate is 1.2, then 5 UMEE have been collateralized.
     * </pre>
     *
     * <code>string collateral = 9 [json_name = "collateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The bytes for collateral to set.
     * @return This builder for chaining.
     */
    public Builder setCollateralBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      collateral_ = value;
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }

    private java.lang.Object borrowed_ = "";
    /**
     * <pre>
     * Borrowed is the total amount of debt in this token held across all borrowers. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string borrowed = 10 [json_name = "borrowed", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The borrowed.
     */
    public java.lang.String getBorrowed() {
      java.lang.Object ref = borrowed_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        borrowed_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Borrowed is the total amount of debt in this token held across all borrowers. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string borrowed = 10 [json_name = "borrowed", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The bytes for borrowed.
     */
    public com.google.protobuf.ByteString
        getBorrowedBytes() {
      java.lang.Object ref = borrowed_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        borrowed_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Borrowed is the total amount of debt in this token held across all borrowers. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string borrowed = 10 [json_name = "borrowed", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The borrowed to set.
     * @return This builder for chaining.
     */
    public Builder setBorrowed(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      borrowed_ = value;
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Borrowed is the total amount of debt in this token held across all borrowers. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string borrowed = 10 [json_name = "borrowed", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return This builder for chaining.
     */
    public Builder clearBorrowed() {
      borrowed_ = getDefaultInstance().getBorrowed();
      bitField0_ = (bitField0_ & ~0x00000200);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Borrowed is the total amount of debt in this token held across all borrowers. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string borrowed = 10 [json_name = "borrowed", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The bytes for borrowed to set.
     * @return This builder for chaining.
     */
    public Builder setBorrowedBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      borrowed_ = value;
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }

    private java.lang.Object liquidity_ = "";
    /**
     * <pre>
     * Liquidity is the amount of a token that has been supplied but not yet borrowed or reserved. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string liquidity = 11 [json_name = "liquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The liquidity.
     */
    public java.lang.String getLiquidity() {
      java.lang.Object ref = liquidity_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        liquidity_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Liquidity is the amount of a token that has been supplied but not yet borrowed or reserved. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string liquidity = 11 [json_name = "liquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The bytes for liquidity.
     */
    public com.google.protobuf.ByteString
        getLiquidityBytes() {
      java.lang.Object ref = liquidity_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        liquidity_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Liquidity is the amount of a token that has been supplied but not yet borrowed or reserved. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string liquidity = 11 [json_name = "liquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The liquidity to set.
     * @return This builder for chaining.
     */
    public Builder setLiquidity(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      liquidity_ = value;
      bitField0_ |= 0x00000400;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Liquidity is the amount of a token that has been supplied but not yet borrowed or reserved. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string liquidity = 11 [json_name = "liquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return This builder for chaining.
     */
    public Builder clearLiquidity() {
      liquidity_ = getDefaultInstance().getLiquidity();
      bitField0_ = (bitField0_ & ~0x00000400);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Liquidity is the amount of a token that has been supplied but not yet borrowed or reserved. It is denominated in base tokens, so exponent must be applied to convert to symbol denom.
     * </pre>
     *
     * <code>string liquidity = 11 [json_name = "liquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The bytes for liquidity to set.
     * @return This builder for chaining.
     */
    public Builder setLiquidityBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      liquidity_ = value;
      bitField0_ |= 0x00000400;
      onChanged();
      return this;
    }

    private java.lang.Object maximumBorrow_ = "";
    /**
     * <pre>
     * Maximum Borrow is the amount of a token that is available for borrowing, including that which has already been borrowed out. This amount is less than total supply due to safety limits. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if borrowed is 3000000 uumee and maximum borrow is 4000000 uumee, then 1 UMEE is currently available for borrowing.
     * </pre>
     *
     * <code>string maximum_borrow = 12 [json_name = "maximumBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The maximumBorrow.
     */
    public java.lang.String getMaximumBorrow() {
      java.lang.Object ref = maximumBorrow_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        maximumBorrow_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Maximum Borrow is the amount of a token that is available for borrowing, including that which has already been borrowed out. This amount is less than total supply due to safety limits. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if borrowed is 3000000 uumee and maximum borrow is 4000000 uumee, then 1 UMEE is currently available for borrowing.
     * </pre>
     *
     * <code>string maximum_borrow = 12 [json_name = "maximumBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The bytes for maximumBorrow.
     */
    public com.google.protobuf.ByteString
        getMaximumBorrowBytes() {
      java.lang.Object ref = maximumBorrow_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        maximumBorrow_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Maximum Borrow is the amount of a token that is available for borrowing, including that which has already been borrowed out. This amount is less than total supply due to safety limits. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if borrowed is 3000000 uumee and maximum borrow is 4000000 uumee, then 1 UMEE is currently available for borrowing.
     * </pre>
     *
     * <code>string maximum_borrow = 12 [json_name = "maximumBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The maximumBorrow to set.
     * @return This builder for chaining.
     */
    public Builder setMaximumBorrow(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      maximumBorrow_ = value;
      bitField0_ |= 0x00000800;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Maximum Borrow is the amount of a token that is available for borrowing, including that which has already been borrowed out. This amount is less than total supply due to safety limits. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if borrowed is 3000000 uumee and maximum borrow is 4000000 uumee, then 1 UMEE is currently available for borrowing.
     * </pre>
     *
     * <code>string maximum_borrow = 12 [json_name = "maximumBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return This builder for chaining.
     */
    public Builder clearMaximumBorrow() {
      maximumBorrow_ = getDefaultInstance().getMaximumBorrow();
      bitField0_ = (bitField0_ & ~0x00000800);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Maximum Borrow is the amount of a token that is available for borrowing, including that which has already been borrowed out. This amount is less than total supply due to safety limits. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if borrowed is 3000000 uumee and maximum borrow is 4000000 uumee, then 1 UMEE is currently available for borrowing.
     * </pre>
     *
     * <code>string maximum_borrow = 12 [json_name = "maximumBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The bytes for maximumBorrow to set.
     * @return This builder for chaining.
     */
    public Builder setMaximumBorrowBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      maximumBorrow_ = value;
      bitField0_ |= 0x00000800;
      onChanged();
      return this;
    }

    private java.lang.Object maximumCollateral_ = "";
    /**
     * <pre>
     * Maximum Collateral is the amount of a token that can be collateralized, including that which is already collateral. This amount is less than total supply due to safety limits. It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee, uToken exchange rate is 1.2, and maximum borrow is 7000000 uumee, then a maximum of 2 additional UMEE is permitted to be collateralized.
     * </pre>
     *
     * <code>string maximum_collateral = 13 [json_name = "maximumCollateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The maximumCollateral.
     */
    public java.lang.String getMaximumCollateral() {
      java.lang.Object ref = maximumCollateral_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        maximumCollateral_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Maximum Collateral is the amount of a token that can be collateralized, including that which is already collateral. This amount is less than total supply due to safety limits. It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee, uToken exchange rate is 1.2, and maximum borrow is 7000000 uumee, then a maximum of 2 additional UMEE is permitted to be collateralized.
     * </pre>
     *
     * <code>string maximum_collateral = 13 [json_name = "maximumCollateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The bytes for maximumCollateral.
     */
    public com.google.protobuf.ByteString
        getMaximumCollateralBytes() {
      java.lang.Object ref = maximumCollateral_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        maximumCollateral_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Maximum Collateral is the amount of a token that can be collateralized, including that which is already collateral. This amount is less than total supply due to safety limits. It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee, uToken exchange rate is 1.2, and maximum borrow is 7000000 uumee, then a maximum of 2 additional UMEE is permitted to be collateralized.
     * </pre>
     *
     * <code>string maximum_collateral = 13 [json_name = "maximumCollateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The maximumCollateral to set.
     * @return This builder for chaining.
     */
    public Builder setMaximumCollateral(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      maximumCollateral_ = value;
      bitField0_ |= 0x00001000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Maximum Collateral is the amount of a token that can be collateralized, including that which is already collateral. This amount is less than total supply due to safety limits. It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee, uToken exchange rate is 1.2, and maximum borrow is 7000000 uumee, then a maximum of 2 additional UMEE is permitted to be collateralized.
     * </pre>
     *
     * <code>string maximum_collateral = 13 [json_name = "maximumCollateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return This builder for chaining.
     */
    public Builder clearMaximumCollateral() {
      maximumCollateral_ = getDefaultInstance().getMaximumCollateral();
      bitField0_ = (bitField0_ & ~0x00001000);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Maximum Collateral is the amount of a token that can be collateralized, including that which is already collateral. This amount is less than total supply due to safety limits. It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. For example, if collateral is 4000000 u/uumee, uToken exchange rate is 1.2, and maximum borrow is 7000000 uumee, then a maximum of 2 additional UMEE is permitted to be collateralized.
     * </pre>
     *
     * <code>string maximum_collateral = 13 [json_name = "maximumCollateral", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The bytes for maximumCollateral to set.
     * @return This builder for chaining.
     */
    public Builder setMaximumCollateralBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      maximumCollateral_ = value;
      bitField0_ |= 0x00001000;
      onChanged();
      return this;
    }

    private java.lang.Object minimumLiquidity_ = "";
    /**
     * <pre>
     * Minimum Liquidity is the minimum amount of liquidity in the module required by safety limits, based on the current collateral. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if liquidity is 9000000 uumee and minimum liquidity is 8000000 uumee, then a maximum of 1 additional UMEE is currently available for borrowing or withdrawal.
     * </pre>
     *
     * <code>string minimum_liquidity = 14 [json_name = "minimumLiquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The minimumLiquidity.
     */
    public java.lang.String getMinimumLiquidity() {
      java.lang.Object ref = minimumLiquidity_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        minimumLiquidity_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Minimum Liquidity is the minimum amount of liquidity in the module required by safety limits, based on the current collateral. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if liquidity is 9000000 uumee and minimum liquidity is 8000000 uumee, then a maximum of 1 additional UMEE is currently available for borrowing or withdrawal.
     * </pre>
     *
     * <code>string minimum_liquidity = 14 [json_name = "minimumLiquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The bytes for minimumLiquidity.
     */
    public com.google.protobuf.ByteString
        getMinimumLiquidityBytes() {
      java.lang.Object ref = minimumLiquidity_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        minimumLiquidity_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Minimum Liquidity is the minimum amount of liquidity in the module required by safety limits, based on the current collateral. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if liquidity is 9000000 uumee and minimum liquidity is 8000000 uumee, then a maximum of 1 additional UMEE is currently available for borrowing or withdrawal.
     * </pre>
     *
     * <code>string minimum_liquidity = 14 [json_name = "minimumLiquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The minimumLiquidity to set.
     * @return This builder for chaining.
     */
    public Builder setMinimumLiquidity(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      minimumLiquidity_ = value;
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Minimum Liquidity is the minimum amount of liquidity in the module required by safety limits, based on the current collateral. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if liquidity is 9000000 uumee and minimum liquidity is 8000000 uumee, then a maximum of 1 additional UMEE is currently available for borrowing or withdrawal.
     * </pre>
     *
     * <code>string minimum_liquidity = 14 [json_name = "minimumLiquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return This builder for chaining.
     */
    public Builder clearMinimumLiquidity() {
      minimumLiquidity_ = getDefaultInstance().getMinimumLiquidity();
      bitField0_ = (bitField0_ & ~0x00002000);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Minimum Liquidity is the minimum amount of liquidity in the module required by safety limits, based on the current collateral. It is denominated in base tokens, so exponent must be applied to convert to symbol denom. For example, if liquidity is 9000000 uumee and minimum liquidity is 8000000 uumee, then a maximum of 1 additional UMEE is currently available for borrowing or withdrawal.
     * </pre>
     *
     * <code>string minimum_liquidity = 14 [json_name = "minimumLiquidity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The bytes for minimumLiquidity to set.
     * @return This builder for chaining.
     */
    public Builder setMinimumLiquidityBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      minimumLiquidity_ = value;
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }

    private java.lang.Object uTokenSupply_ = "";
    /**
     * <pre>
     * uToken Supply is the total amount of a base token's associated uToken in circulation.
     * </pre>
     *
     * <code>string uToken_supply = 15 [json_name = "uTokenSupply", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.gogoproto.jsontag) = "utoken_supply"];</code>
     * @return The uTokenSupply.
     */
    public java.lang.String getUTokenSupply() {
      java.lang.Object ref = uTokenSupply_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        uTokenSupply_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * uToken Supply is the total amount of a base token's associated uToken in circulation.
     * </pre>
     *
     * <code>string uToken_supply = 15 [json_name = "uTokenSupply", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.gogoproto.jsontag) = "utoken_supply"];</code>
     * @return The bytes for uTokenSupply.
     */
    public com.google.protobuf.ByteString
        getUTokenSupplyBytes() {
      java.lang.Object ref = uTokenSupply_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        uTokenSupply_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * uToken Supply is the total amount of a base token's associated uToken in circulation.
     * </pre>
     *
     * <code>string uToken_supply = 15 [json_name = "uTokenSupply", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.gogoproto.jsontag) = "utoken_supply"];</code>
     * @param value The uTokenSupply to set.
     * @return This builder for chaining.
     */
    public Builder setUTokenSupply(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      uTokenSupply_ = value;
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * uToken Supply is the total amount of a base token's associated uToken in circulation.
     * </pre>
     *
     * <code>string uToken_supply = 15 [json_name = "uTokenSupply", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.gogoproto.jsontag) = "utoken_supply"];</code>
     * @return This builder for chaining.
     */
    public Builder clearUTokenSupply() {
      uTokenSupply_ = getDefaultInstance().getUTokenSupply();
      bitField0_ = (bitField0_ & ~0x00004000);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * uToken Supply is the total amount of a base token's associated uToken in circulation.
     * </pre>
     *
     * <code>string uToken_supply = 15 [json_name = "uTokenSupply", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.gogoproto.jsontag) = "utoken_supply"];</code>
     * @param value The bytes for uTokenSupply to set.
     * @return This builder for chaining.
     */
    public Builder setUTokenSupplyBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      uTokenSupply_ = value;
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }

    private java.lang.Object availableBorrow_ = "";
    /**
     * <pre>
     * Available Borrow is the maximum additional amount of base tokens than can be borrowed based on current liquidity and system safety limits. It can also be calculated by MIN(maximum_borrow - borrowed, liquidity - minimum_liquidity). It is denominated in base tokens, so exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and borrowing is temporarily unavailable.
     * </pre>
     *
     * <code>string available_borrow = 16 [json_name = "availableBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The availableBorrow.
     */
    public java.lang.String getAvailableBorrow() {
      java.lang.Object ref = availableBorrow_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        availableBorrow_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Available Borrow is the maximum additional amount of base tokens than can be borrowed based on current liquidity and system safety limits. It can also be calculated by MIN(maximum_borrow - borrowed, liquidity - minimum_liquidity). It is denominated in base tokens, so exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and borrowing is temporarily unavailable.
     * </pre>
     *
     * <code>string available_borrow = 16 [json_name = "availableBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The bytes for availableBorrow.
     */
    public com.google.protobuf.ByteString
        getAvailableBorrowBytes() {
      java.lang.Object ref = availableBorrow_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        availableBorrow_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Available Borrow is the maximum additional amount of base tokens than can be borrowed based on current liquidity and system safety limits. It can also be calculated by MIN(maximum_borrow - borrowed, liquidity - minimum_liquidity). It is denominated in base tokens, so exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and borrowing is temporarily unavailable.
     * </pre>
     *
     * <code>string available_borrow = 16 [json_name = "availableBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The availableBorrow to set.
     * @return This builder for chaining.
     */
    public Builder setAvailableBorrow(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      availableBorrow_ = value;
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Available Borrow is the maximum additional amount of base tokens than can be borrowed based on current liquidity and system safety limits. It can also be calculated by MIN(maximum_borrow - borrowed, liquidity - minimum_liquidity). It is denominated in base tokens, so exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and borrowing is temporarily unavailable.
     * </pre>
     *
     * <code>string available_borrow = 16 [json_name = "availableBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return This builder for chaining.
     */
    public Builder clearAvailableBorrow() {
      availableBorrow_ = getDefaultInstance().getAvailableBorrow();
      bitField0_ = (bitField0_ & ~0x00008000);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Available Borrow is the maximum additional amount of base tokens than can be borrowed based on current liquidity and system safety limits. It can also be calculated by MIN(maximum_borrow - borrowed, liquidity - minimum_liquidity). It is denominated in base tokens, so exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and borrowing is temporarily unavailable.
     * </pre>
     *
     * <code>string available_borrow = 16 [json_name = "availableBorrow", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The bytes for availableBorrow to set.
     * @return This builder for chaining.
     */
    public Builder setAvailableBorrowBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      availableBorrow_ = value;
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }

    private java.lang.Object availableWithdraw_ = "";
    /**
     * <pre>
     * Available Withdraw is the maximum amount of uTokens than can currently be withdrawn based on liquidity and system safety limits. It can also be calculated by (liquidity - minimum_liquidity). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and withdrawal is temporarily unavailable.
     * </pre>
     *
     * <code>string available_withdraw = 17 [json_name = "availableWithdraw", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The availableWithdraw.
     */
    public java.lang.String getAvailableWithdraw() {
      java.lang.Object ref = availableWithdraw_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        availableWithdraw_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Available Withdraw is the maximum amount of uTokens than can currently be withdrawn based on liquidity and system safety limits. It can also be calculated by (liquidity - minimum_liquidity). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and withdrawal is temporarily unavailable.
     * </pre>
     *
     * <code>string available_withdraw = 17 [json_name = "availableWithdraw", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The bytes for availableWithdraw.
     */
    public com.google.protobuf.ByteString
        getAvailableWithdrawBytes() {
      java.lang.Object ref = availableWithdraw_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        availableWithdraw_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Available Withdraw is the maximum amount of uTokens than can currently be withdrawn based on liquidity and system safety limits. It can also be calculated by (liquidity - minimum_liquidity). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and withdrawal is temporarily unavailable.
     * </pre>
     *
     * <code>string available_withdraw = 17 [json_name = "availableWithdraw", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The availableWithdraw to set.
     * @return This builder for chaining.
     */
    public Builder setAvailableWithdraw(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      availableWithdraw_ = value;
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Available Withdraw is the maximum amount of uTokens than can currently be withdrawn based on liquidity and system safety limits. It can also be calculated by (liquidity - minimum_liquidity). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and withdrawal is temporarily unavailable.
     * </pre>
     *
     * <code>string available_withdraw = 17 [json_name = "availableWithdraw", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return This builder for chaining.
     */
    public Builder clearAvailableWithdraw() {
      availableWithdraw_ = getDefaultInstance().getAvailableWithdraw();
      bitField0_ = (bitField0_ & ~0x00010000);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Available Withdraw is the maximum amount of uTokens than can currently be withdrawn based on liquidity and system safety limits. It can also be calculated by (liquidity - minimum_liquidity). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and withdrawal is temporarily unavailable.
     * </pre>
     *
     * <code>string available_withdraw = 17 [json_name = "availableWithdraw", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The bytes for availableWithdraw to set.
     * @return This builder for chaining.
     */
    public Builder setAvailableWithdrawBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      availableWithdraw_ = value;
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }

    private java.lang.Object availableCollateralize_ = "";
    /**
     * <pre>
     * Available Collateralize is the maximum additional amount of uTokens than can be collateralized based on current liquidity and system safety limits. It can also be calculated by (maximum_collateral, - collateral). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and additional collateral cannot be created until more liquidity is present.
     * </pre>
     *
     * <code>string available_collateralize = 18 [json_name = "availableCollateralize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The availableCollateralize.
     */
    public java.lang.String getAvailableCollateralize() {
      java.lang.Object ref = availableCollateralize_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        availableCollateralize_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Available Collateralize is the maximum additional amount of uTokens than can be collateralized based on current liquidity and system safety limits. It can also be calculated by (maximum_collateral, - collateral). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and additional collateral cannot be created until more liquidity is present.
     * </pre>
     *
     * <code>string available_collateralize = 18 [json_name = "availableCollateralize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return The bytes for availableCollateralize.
     */
    public com.google.protobuf.ByteString
        getAvailableCollateralizeBytes() {
      java.lang.Object ref = availableCollateralize_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        availableCollateralize_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Available Collateralize is the maximum additional amount of uTokens than can be collateralized based on current liquidity and system safety limits. It can also be calculated by (maximum_collateral, - collateral). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and additional collateral cannot be created until more liquidity is present.
     * </pre>
     *
     * <code>string available_collateralize = 18 [json_name = "availableCollateralize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The availableCollateralize to set.
     * @return This builder for chaining.
     */
    public Builder setAvailableCollateralize(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      availableCollateralize_ = value;
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Available Collateralize is the maximum additional amount of uTokens than can be collateralized based on current liquidity and system safety limits. It can also be calculated by (maximum_collateral, - collateral). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and additional collateral cannot be created until more liquidity is present.
     * </pre>
     *
     * <code>string available_collateralize = 18 [json_name = "availableCollateralize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @return This builder for chaining.
     */
    public Builder clearAvailableCollateralize() {
      availableCollateralize_ = getDefaultInstance().getAvailableCollateralize();
      bitField0_ = (bitField0_ & ~0x00020000);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Available Collateralize is the maximum additional amount of uTokens than can be collateralized based on current liquidity and system safety limits. It can also be calculated by (maximum_collateral, - collateral). It is denominated in uTokens, so both uToken exchange rate and exponent must be applied to convert to symbol denom. A negative availability means safety limits have been exceeded and additional collateral cannot be created until more liquidity is present.
     * </pre>
     *
     * <code>string available_collateralize = 18 [json_name = "availableCollateralize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];</code>
     * @param value The bytes for availableCollateralize to set.
     * @return This builder for chaining.
     */
    public Builder setAvailableCollateralizeBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      availableCollateralize_ = value;
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }

    private java.lang.Object oracleHistoricPrice_ = "";
    /**
     * <pre>
     * Oracle Historic Price is the historic USD value of a token. Historic price is defined as the median of the last N historic median prices from the oracle module, with N being this token's HistoricMedians in the leverage registry. Current price is used if required medians is zero. Price is nil when the oracle is down or insufficient historic medians are available.
     * </pre>
     *
     * <code>string oracle_historic_price = 19 [json_name = "oracleHistoricPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
     * @return The oracleHistoricPrice.
     */
    public java.lang.String getOracleHistoricPrice() {
      java.lang.Object ref = oracleHistoricPrice_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        oracleHistoricPrice_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Oracle Historic Price is the historic USD value of a token. Historic price is defined as the median of the last N historic median prices from the oracle module, with N being this token's HistoricMedians in the leverage registry. Current price is used if required medians is zero. Price is nil when the oracle is down or insufficient historic medians are available.
     * </pre>
     *
     * <code>string oracle_historic_price = 19 [json_name = "oracleHistoricPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
     * @return The bytes for oracleHistoricPrice.
     */
    public com.google.protobuf.ByteString
        getOracleHistoricPriceBytes() {
      java.lang.Object ref = oracleHistoricPrice_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        oracleHistoricPrice_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Oracle Historic Price is the historic USD value of a token. Historic price is defined as the median of the last N historic median prices from the oracle module, with N being this token's HistoricMedians in the leverage registry. Current price is used if required medians is zero. Price is nil when the oracle is down or insufficient historic medians are available.
     * </pre>
     *
     * <code>string oracle_historic_price = 19 [json_name = "oracleHistoricPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
     * @param value The oracleHistoricPrice to set.
     * @return This builder for chaining.
     */
    public Builder setOracleHistoricPrice(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      oracleHistoricPrice_ = value;
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Oracle Historic Price is the historic USD value of a token. Historic price is defined as the median of the last N historic median prices from the oracle module, with N being this token's HistoricMedians in the leverage registry. Current price is used if required medians is zero. Price is nil when the oracle is down or insufficient historic medians are available.
     * </pre>
     *
     * <code>string oracle_historic_price = 19 [json_name = "oracleHistoricPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
     * @return This builder for chaining.
     */
    public Builder clearOracleHistoricPrice() {
      oracleHistoricPrice_ = getDefaultInstance().getOracleHistoricPrice();
      bitField0_ = (bitField0_ & ~0x00040000);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Oracle Historic Price is the historic USD value of a token. Historic price is defined as the median of the last N historic median prices from the oracle module, with N being this token's HistoricMedians in the leverage registry. Current price is used if required medians is zero. Price is nil when the oracle is down or insufficient historic medians are available.
     * </pre>
     *
     * <code>string oracle_historic_price = 19 [json_name = "oracleHistoricPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];</code>
     * @param value The bytes for oracleHistoricPrice to set.
     * @return This builder for chaining.
     */
    public Builder setOracleHistoricPriceBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      oracleHistoricPrice_ = value;
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }

    private java.lang.Object errors_ = "";
    /**
     * <code>string errors = 20 [json_name = "errors"];</code>
     * @return The errors.
     */
    public java.lang.String getErrors() {
      java.lang.Object ref = errors_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        errors_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <code>string errors = 20 [json_name = "errors"];</code>
     * @return The bytes for errors.
     */
    public com.google.protobuf.ByteString
        getErrorsBytes() {
      java.lang.Object ref = errors_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        errors_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <code>string errors = 20 [json_name = "errors"];</code>
     * @param value The errors to set.
     * @return This builder for chaining.
     */
    public Builder setErrors(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      errors_ = value;
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }
    /**
     * <code>string errors = 20 [json_name = "errors"];</code>
     * @return This builder for chaining.
     */
    public Builder clearErrors() {
      errors_ = getDefaultInstance().getErrors();
      bitField0_ = (bitField0_ & ~0x00080000);
      onChanged();
      return this;
    }
    /**
     * <code>string errors = 20 [json_name = "errors"];</code>
     * @param value The bytes for errors to set.
     * @return This builder for chaining.
     */
    public Builder setErrorsBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      errors_ = value;
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:umee.leverage.v1.QueryMarketSummaryResponse)
  }

  // @@protoc_insertion_point(class_scope:umee.leverage.v1.QueryMarketSummaryResponse)
  private static final com.umee.leverage.v1.QueryMarketSummaryResponse DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new com.umee.leverage.v1.QueryMarketSummaryResponse();
  }

  public static com.umee.leverage.v1.QueryMarketSummaryResponse getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<QueryMarketSummaryResponse>
      PARSER = new com.google.protobuf.AbstractParser<QueryMarketSummaryResponse>() {
    @java.lang.Override
    public QueryMarketSummaryResponse parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      Builder builder = newBuilder();
      try {
        builder.mergeFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(builder.buildPartial());
      } catch (com.google.protobuf.UninitializedMessageException e) {
        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e)
            .setUnfinishedMessage(builder.buildPartial());
      }
      return builder.buildPartial();
    }
  };

  public static com.google.protobuf.Parser<QueryMarketSummaryResponse> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<QueryMarketSummaryResponse> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.umee.leverage.v1.QueryMarketSummaryResponse getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

