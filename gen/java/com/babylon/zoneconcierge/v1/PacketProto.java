// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: babylon/zoneconcierge/v1/packet.proto

package com.babylon.zoneconcierge.v1;

public final class PacketProto {
  private PacketProto() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface ZoneconciergePacketDataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.zoneconcierge.v1.ZoneconciergePacketData)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
     * @return Whether the btcTimestamp field is set.
     */
    boolean hasBtcTimestamp();
    /**
     * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
     * @return The btcTimestamp.
     */
    com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp getBtcTimestamp();
    /**
     * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
     */
    com.babylon.zoneconcierge.v1.PacketProto.BTCTimestampOrBuilder getBtcTimestampOrBuilder();

    com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData.PacketCase getPacketCase();
  }
  /**
   * <pre>
   * ZoneconciergePacketData is the message that defines the IBC packets of
   * ZoneConcierge
   * </pre>
   *
   * Protobuf type {@code babylon.zoneconcierge.v1.ZoneconciergePacketData}
   */
  public static final class ZoneconciergePacketData extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.zoneconcierge.v1.ZoneconciergePacketData)
      ZoneconciergePacketDataOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ZoneconciergePacketData.newBuilder() to construct.
    private ZoneconciergePacketData(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ZoneconciergePacketData() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ZoneconciergePacketData();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.zoneconcierge.v1.PacketProto.internal_static_babylon_zoneconcierge_v1_ZoneconciergePacketData_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.zoneconcierge.v1.PacketProto.internal_static_babylon_zoneconcierge_v1_ZoneconciergePacketData_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData.class, com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData.Builder.class);
    }

    private int packetCase_ = 0;
    @SuppressWarnings("serial")
    private java.lang.Object packet_;
    public enum PacketCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      BTC_TIMESTAMP(1),
      PACKET_NOT_SET(0);
      private final int value;
      private PacketCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PacketCase valueOf(int value) {
        return forNumber(value);
      }

      public static PacketCase forNumber(int value) {
        switch (value) {
          case 1: return BTC_TIMESTAMP;
          case 0: return PACKET_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public PacketCase
    getPacketCase() {
      return PacketCase.forNumber(
          packetCase_);
    }

    public static final int BTC_TIMESTAMP_FIELD_NUMBER = 1;
    /**
     * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
     * @return Whether the btcTimestamp field is set.
     */
    @java.lang.Override
    public boolean hasBtcTimestamp() {
      return packetCase_ == 1;
    }
    /**
     * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
     * @return The btcTimestamp.
     */
    @java.lang.Override
    public com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp getBtcTimestamp() {
      if (packetCase_ == 1) {
         return (com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp) packet_;
      }
      return com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.getDefaultInstance();
    }
    /**
     * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
     */
    @java.lang.Override
    public com.babylon.zoneconcierge.v1.PacketProto.BTCTimestampOrBuilder getBtcTimestampOrBuilder() {
      if (packetCase_ == 1) {
         return (com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp) packet_;
      }
      return com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (packetCase_ == 1) {
        output.writeMessage(1, (com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp) packet_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (packetCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp) packet_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData)) {
        return super.equals(obj);
      }
      com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData other = (com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData) obj;

      if (!getPacketCase().equals(other.getPacketCase())) return false;
      switch (packetCase_) {
        case 1:
          if (!getBtcTimestamp()
              .equals(other.getBtcTimestamp())) return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (packetCase_) {
        case 1:
          hash = (37 * hash) + BTC_TIMESTAMP_FIELD_NUMBER;
          hash = (53 * hash) + getBtcTimestamp().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ZoneconciergePacketData is the message that defines the IBC packets of
     * ZoneConcierge
     * </pre>
     *
     * Protobuf type {@code babylon.zoneconcierge.v1.ZoneconciergePacketData}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.zoneconcierge.v1.ZoneconciergePacketData)
        com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketDataOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.zoneconcierge.v1.PacketProto.internal_static_babylon_zoneconcierge_v1_ZoneconciergePacketData_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.zoneconcierge.v1.PacketProto.internal_static_babylon_zoneconcierge_v1_ZoneconciergePacketData_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData.class, com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData.Builder.class);
      }

      // Construct using com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (btcTimestampBuilder_ != null) {
          btcTimestampBuilder_.clear();
        }
        packetCase_ = 0;
        packet_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.zoneconcierge.v1.PacketProto.internal_static_babylon_zoneconcierge_v1_ZoneconciergePacketData_descriptor;
      }

      @java.lang.Override
      public com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData getDefaultInstanceForType() {
        return com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData build() {
        com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData buildPartial() {
        com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData result = new com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartial0(com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData result) {
        int from_bitField0_ = bitField0_;
      }

      private void buildPartialOneofs(com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData result) {
        result.packetCase_ = packetCase_;
        result.packet_ = this.packet_;
        if (packetCase_ == 1 &&
            btcTimestampBuilder_ != null) {
          result.packet_ = btcTimestampBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData) {
          return mergeFrom((com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData other) {
        if (other == com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData.getDefaultInstance()) return this;
        switch (other.getPacketCase()) {
          case BTC_TIMESTAMP: {
            mergeBtcTimestamp(other.getBtcTimestamp());
            break;
          }
          case PACKET_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getBtcTimestampFieldBuilder().getBuilder(),
                    extensionRegistry);
                packetCase_ = 1;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int packetCase_ = 0;
      private java.lang.Object packet_;
      public PacketCase
          getPacketCase() {
        return PacketCase.forNumber(
            packetCase_);
      }

      public Builder clearPacket() {
        packetCase_ = 0;
        packet_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp, com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.Builder, com.babylon.zoneconcierge.v1.PacketProto.BTCTimestampOrBuilder> btcTimestampBuilder_;
      /**
       * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
       * @return Whether the btcTimestamp field is set.
       */
      @java.lang.Override
      public boolean hasBtcTimestamp() {
        return packetCase_ == 1;
      }
      /**
       * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
       * @return The btcTimestamp.
       */
      @java.lang.Override
      public com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp getBtcTimestamp() {
        if (btcTimestampBuilder_ == null) {
          if (packetCase_ == 1) {
            return (com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp) packet_;
          }
          return com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.getDefaultInstance();
        } else {
          if (packetCase_ == 1) {
            return btcTimestampBuilder_.getMessage();
          }
          return com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.getDefaultInstance();
        }
      }
      /**
       * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
       */
      public Builder setBtcTimestamp(com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp value) {
        if (btcTimestampBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          packet_ = value;
          onChanged();
        } else {
          btcTimestampBuilder_.setMessage(value);
        }
        packetCase_ = 1;
        return this;
      }
      /**
       * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
       */
      public Builder setBtcTimestamp(
          com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.Builder builderForValue) {
        if (btcTimestampBuilder_ == null) {
          packet_ = builderForValue.build();
          onChanged();
        } else {
          btcTimestampBuilder_.setMessage(builderForValue.build());
        }
        packetCase_ = 1;
        return this;
      }
      /**
       * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
       */
      public Builder mergeBtcTimestamp(com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp value) {
        if (btcTimestampBuilder_ == null) {
          if (packetCase_ == 1 &&
              packet_ != com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.getDefaultInstance()) {
            packet_ = com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.newBuilder((com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp) packet_)
                .mergeFrom(value).buildPartial();
          } else {
            packet_ = value;
          }
          onChanged();
        } else {
          if (packetCase_ == 1) {
            btcTimestampBuilder_.mergeFrom(value);
          } else {
            btcTimestampBuilder_.setMessage(value);
          }
        }
        packetCase_ = 1;
        return this;
      }
      /**
       * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
       */
      public Builder clearBtcTimestamp() {
        if (btcTimestampBuilder_ == null) {
          if (packetCase_ == 1) {
            packetCase_ = 0;
            packet_ = null;
            onChanged();
          }
        } else {
          if (packetCase_ == 1) {
            packetCase_ = 0;
            packet_ = null;
          }
          btcTimestampBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
       */
      public com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.Builder getBtcTimestampBuilder() {
        return getBtcTimestampFieldBuilder().getBuilder();
      }
      /**
       * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
       */
      @java.lang.Override
      public com.babylon.zoneconcierge.v1.PacketProto.BTCTimestampOrBuilder getBtcTimestampOrBuilder() {
        if ((packetCase_ == 1) && (btcTimestampBuilder_ != null)) {
          return btcTimestampBuilder_.getMessageOrBuilder();
        } else {
          if (packetCase_ == 1) {
            return (com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp) packet_;
          }
          return com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.getDefaultInstance();
        }
      }
      /**
       * <code>.babylon.zoneconcierge.v1.BTCTimestamp btc_timestamp = 1 [json_name = "btcTimestamp"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp, com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.Builder, com.babylon.zoneconcierge.v1.PacketProto.BTCTimestampOrBuilder> 
          getBtcTimestampFieldBuilder() {
        if (btcTimestampBuilder_ == null) {
          if (!(packetCase_ == 1)) {
            packet_ = com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.getDefaultInstance();
          }
          btcTimestampBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp, com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.Builder, com.babylon.zoneconcierge.v1.PacketProto.BTCTimestampOrBuilder>(
                  (com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp) packet_,
                  getParentForChildren(),
                  isClean());
          packet_ = null;
        }
        packetCase_ = 1;
        onChanged();
        return btcTimestampBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.zoneconcierge.v1.ZoneconciergePacketData)
    }

    // @@protoc_insertion_point(class_scope:babylon.zoneconcierge.v1.ZoneconciergePacketData)
    private static final com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData();
    }

    public static com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ZoneconciergePacketData>
        PARSER = new com.google.protobuf.AbstractParser<ZoneconciergePacketData>() {
      @java.lang.Override
      public ZoneconciergePacketData parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ZoneconciergePacketData> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ZoneconciergePacketData> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.zoneconcierge.v1.PacketProto.ZoneconciergePacketData getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface BTCTimestampOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.zoneconcierge.v1.BTCTimestamp)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * header is the last CZ header in the finalized Babylon epoch
     * </pre>
     *
     * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
     * @return Whether the header field is set.
     */
    boolean hasHeader();
    /**
     * <pre>
     * header is the last CZ header in the finalized Babylon epoch
     * </pre>
     *
     * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
     * @return The header.
     */
    com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader getHeader();
    /**
     * <pre>
     * header is the last CZ header in the finalized Babylon epoch
     * </pre>
     *
     * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
     */
    com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeaderOrBuilder getHeaderOrBuilder();

    /**
     * <pre>
     * btc_headers is BTC headers between
     * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
     * - BTC tip at epoch `lastFinalizedEpoch`
     * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
     * </pre>
     *
     * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
     */
    java.util.List<com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo> 
        getBtcHeadersList();
    /**
     * <pre>
     * btc_headers is BTC headers between
     * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
     * - BTC tip at epoch `lastFinalizedEpoch`
     * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
     * </pre>
     *
     * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
     */
    com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo getBtcHeaders(int index);
    /**
     * <pre>
     * btc_headers is BTC headers between
     * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
     * - BTC tip at epoch `lastFinalizedEpoch`
     * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
     * </pre>
     *
     * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
     */
    int getBtcHeadersCount();
    /**
     * <pre>
     * btc_headers is BTC headers between
     * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
     * - BTC tip at epoch `lastFinalizedEpoch`
     * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
     * </pre>
     *
     * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
     */
    java.util.List<? extends com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfoOrBuilder> 
        getBtcHeadersOrBuilderList();
    /**
     * <pre>
     * btc_headers is BTC headers between
     * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
     * - BTC tip at epoch `lastFinalizedEpoch`
     * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
     * </pre>
     *
     * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
     */
    com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfoOrBuilder getBtcHeadersOrBuilder(
        int index);

    /**
     * <pre>
     * epoch_info is the metadata of the sealed epoch
     * </pre>
     *
     * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
     * @return Whether the epochInfo field is set.
     */
    boolean hasEpochInfo();
    /**
     * <pre>
     * epoch_info is the metadata of the sealed epoch
     * </pre>
     *
     * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
     * @return The epochInfo.
     */
    com.babylon.epoching.v1.EpochingProto.Epoch getEpochInfo();
    /**
     * <pre>
     * epoch_info is the metadata of the sealed epoch
     * </pre>
     *
     * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
     */
    com.babylon.epoching.v1.EpochingProto.EpochOrBuilder getEpochInfoOrBuilder();

    /**
     * <pre>
     * raw_checkpoint is the raw checkpoint that seals this epoch
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
     * @return Whether the rawCheckpoint field is set.
     */
    boolean hasRawCheckpoint();
    /**
     * <pre>
     * raw_checkpoint is the raw checkpoint that seals this epoch
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
     * @return The rawCheckpoint.
     */
    com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint getRawCheckpoint();
    /**
     * <pre>
     * raw_checkpoint is the raw checkpoint that seals this epoch
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
     */
    com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointOrBuilder getRawCheckpointOrBuilder();

    /**
     * <pre>
     * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
     * @return Whether the btcSubmissionKey field is set.
     */
    boolean hasBtcSubmissionKey();
    /**
     * <pre>
     * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
     * @return The btcSubmissionKey.
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey getBtcSubmissionKey();
    /**
     * <pre>
     * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder getBtcSubmissionKeyOrBuilder();

    /**
     * <pre>
     * 
     *Proofs that the header is finalized
     * </pre>
     *
     * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
     * @return Whether the proof field is set.
     */
    boolean hasProof();
    /**
     * <pre>
     * 
     *Proofs that the header is finalized
     * </pre>
     *
     * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
     * @return The proof.
     */
    com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo getProof();
    /**
     * <pre>
     * 
     *Proofs that the header is finalized
     * </pre>
     *
     * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
     */
    com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfoOrBuilder getProofOrBuilder();
  }
  /**
   * <pre>
   * BTCTimestamp is a BTC timestamp that carries information of a BTC-finalised epoch
   * It includes a number of BTC headers, a raw checkpoint, an epoch metadata, and 
   * a CZ header if there exists CZ headers checkpointed to this epoch.
   * Upon a newly finalised epoch in Babylon, Babylon will send a BTC timestamp to each
   * Cosmos zone that has phase-2 integration with Babylon via IBC.
   * </pre>
   *
   * Protobuf type {@code babylon.zoneconcierge.v1.BTCTimestamp}
   */
  public static final class BTCTimestamp extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.zoneconcierge.v1.BTCTimestamp)
      BTCTimestampOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use BTCTimestamp.newBuilder() to construct.
    private BTCTimestamp(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private BTCTimestamp() {
      btcHeaders_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new BTCTimestamp();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.zoneconcierge.v1.PacketProto.internal_static_babylon_zoneconcierge_v1_BTCTimestamp_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.zoneconcierge.v1.PacketProto.internal_static_babylon_zoneconcierge_v1_BTCTimestamp_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.class, com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.Builder.class);
    }

    public static final int HEADER_FIELD_NUMBER = 1;
    private com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader header_;
    /**
     * <pre>
     * header is the last CZ header in the finalized Babylon epoch
     * </pre>
     *
     * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
     * @return Whether the header field is set.
     */
    @java.lang.Override
    public boolean hasHeader() {
      return header_ != null;
    }
    /**
     * <pre>
     * header is the last CZ header in the finalized Babylon epoch
     * </pre>
     *
     * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
     * @return The header.
     */
    @java.lang.Override
    public com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader getHeader() {
      return header_ == null ? com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader.getDefaultInstance() : header_;
    }
    /**
     * <pre>
     * header is the last CZ header in the finalized Babylon epoch
     * </pre>
     *
     * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
     */
    @java.lang.Override
    public com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeaderOrBuilder getHeaderOrBuilder() {
      return header_ == null ? com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader.getDefaultInstance() : header_;
    }

    public static final int BTC_HEADERS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo> btcHeaders_;
    /**
     * <pre>
     * btc_headers is BTC headers between
     * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
     * - BTC tip at epoch `lastFinalizedEpoch`
     * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
     * </pre>
     *
     * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
     */
    @java.lang.Override
    public java.util.List<com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo> getBtcHeadersList() {
      return btcHeaders_;
    }
    /**
     * <pre>
     * btc_headers is BTC headers between
     * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
     * - BTC tip at epoch `lastFinalizedEpoch`
     * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
     * </pre>
     *
     * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfoOrBuilder> 
        getBtcHeadersOrBuilderList() {
      return btcHeaders_;
    }
    /**
     * <pre>
     * btc_headers is BTC headers between
     * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
     * - BTC tip at epoch `lastFinalizedEpoch`
     * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
     * </pre>
     *
     * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
     */
    @java.lang.Override
    public int getBtcHeadersCount() {
      return btcHeaders_.size();
    }
    /**
     * <pre>
     * btc_headers is BTC headers between
     * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
     * - BTC tip at epoch `lastFinalizedEpoch`
     * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
     * </pre>
     *
     * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
     */
    @java.lang.Override
    public com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo getBtcHeaders(int index) {
      return btcHeaders_.get(index);
    }
    /**
     * <pre>
     * btc_headers is BTC headers between
     * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
     * - BTC tip at epoch `lastFinalizedEpoch`
     * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
     * </pre>
     *
     * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
     */
    @java.lang.Override
    public com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfoOrBuilder getBtcHeadersOrBuilder(
        int index) {
      return btcHeaders_.get(index);
    }

    public static final int EPOCH_INFO_FIELD_NUMBER = 3;
    private com.babylon.epoching.v1.EpochingProto.Epoch epochInfo_;
    /**
     * <pre>
     * epoch_info is the metadata of the sealed epoch
     * </pre>
     *
     * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
     * @return Whether the epochInfo field is set.
     */
    @java.lang.Override
    public boolean hasEpochInfo() {
      return epochInfo_ != null;
    }
    /**
     * <pre>
     * epoch_info is the metadata of the sealed epoch
     * </pre>
     *
     * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
     * @return The epochInfo.
     */
    @java.lang.Override
    public com.babylon.epoching.v1.EpochingProto.Epoch getEpochInfo() {
      return epochInfo_ == null ? com.babylon.epoching.v1.EpochingProto.Epoch.getDefaultInstance() : epochInfo_;
    }
    /**
     * <pre>
     * epoch_info is the metadata of the sealed epoch
     * </pre>
     *
     * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
     */
    @java.lang.Override
    public com.babylon.epoching.v1.EpochingProto.EpochOrBuilder getEpochInfoOrBuilder() {
      return epochInfo_ == null ? com.babylon.epoching.v1.EpochingProto.Epoch.getDefaultInstance() : epochInfo_;
    }

    public static final int RAW_CHECKPOINT_FIELD_NUMBER = 4;
    private com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint rawCheckpoint_;
    /**
     * <pre>
     * raw_checkpoint is the raw checkpoint that seals this epoch
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
     * @return Whether the rawCheckpoint field is set.
     */
    @java.lang.Override
    public boolean hasRawCheckpoint() {
      return rawCheckpoint_ != null;
    }
    /**
     * <pre>
     * raw_checkpoint is the raw checkpoint that seals this epoch
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
     * @return The rawCheckpoint.
     */
    @java.lang.Override
    public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint getRawCheckpoint() {
      return rawCheckpoint_ == null ? com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.getDefaultInstance() : rawCheckpoint_;
    }
    /**
     * <pre>
     * raw_checkpoint is the raw checkpoint that seals this epoch
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
     */
    @java.lang.Override
    public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointOrBuilder getRawCheckpointOrBuilder() {
      return rawCheckpoint_ == null ? com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.getDefaultInstance() : rawCheckpoint_;
    }

    public static final int BTC_SUBMISSION_KEY_FIELD_NUMBER = 5;
    private com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey btcSubmissionKey_;
    /**
     * <pre>
     * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
     * @return Whether the btcSubmissionKey field is set.
     */
    @java.lang.Override
    public boolean hasBtcSubmissionKey() {
      return btcSubmissionKey_ != null;
    }
    /**
     * <pre>
     * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
     * @return The btcSubmissionKey.
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey getBtcSubmissionKey() {
      return btcSubmissionKey_ == null ? com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.getDefaultInstance() : btcSubmissionKey_;
    }
    /**
     * <pre>
     * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder getBtcSubmissionKeyOrBuilder() {
      return btcSubmissionKey_ == null ? com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.getDefaultInstance() : btcSubmissionKey_;
    }

    public static final int PROOF_FIELD_NUMBER = 6;
    private com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo proof_;
    /**
     * <pre>
     * 
     *Proofs that the header is finalized
     * </pre>
     *
     * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
     * @return Whether the proof field is set.
     */
    @java.lang.Override
    public boolean hasProof() {
      return proof_ != null;
    }
    /**
     * <pre>
     * 
     *Proofs that the header is finalized
     * </pre>
     *
     * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
     * @return The proof.
     */
    @java.lang.Override
    public com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo getProof() {
      return proof_ == null ? com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo.getDefaultInstance() : proof_;
    }
    /**
     * <pre>
     * 
     *Proofs that the header is finalized
     * </pre>
     *
     * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
     */
    @java.lang.Override
    public com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfoOrBuilder getProofOrBuilder() {
      return proof_ == null ? com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo.getDefaultInstance() : proof_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (header_ != null) {
        output.writeMessage(1, getHeader());
      }
      for (int i = 0; i < btcHeaders_.size(); i++) {
        output.writeMessage(2, btcHeaders_.get(i));
      }
      if (epochInfo_ != null) {
        output.writeMessage(3, getEpochInfo());
      }
      if (rawCheckpoint_ != null) {
        output.writeMessage(4, getRawCheckpoint());
      }
      if (btcSubmissionKey_ != null) {
        output.writeMessage(5, getBtcSubmissionKey());
      }
      if (proof_ != null) {
        output.writeMessage(6, getProof());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (header_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getHeader());
      }
      for (int i = 0; i < btcHeaders_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, btcHeaders_.get(i));
      }
      if (epochInfo_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getEpochInfo());
      }
      if (rawCheckpoint_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getRawCheckpoint());
      }
      if (btcSubmissionKey_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getBtcSubmissionKey());
      }
      if (proof_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getProof());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp)) {
        return super.equals(obj);
      }
      com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp other = (com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp) obj;

      if (hasHeader() != other.hasHeader()) return false;
      if (hasHeader()) {
        if (!getHeader()
            .equals(other.getHeader())) return false;
      }
      if (!getBtcHeadersList()
          .equals(other.getBtcHeadersList())) return false;
      if (hasEpochInfo() != other.hasEpochInfo()) return false;
      if (hasEpochInfo()) {
        if (!getEpochInfo()
            .equals(other.getEpochInfo())) return false;
      }
      if (hasRawCheckpoint() != other.hasRawCheckpoint()) return false;
      if (hasRawCheckpoint()) {
        if (!getRawCheckpoint()
            .equals(other.getRawCheckpoint())) return false;
      }
      if (hasBtcSubmissionKey() != other.hasBtcSubmissionKey()) return false;
      if (hasBtcSubmissionKey()) {
        if (!getBtcSubmissionKey()
            .equals(other.getBtcSubmissionKey())) return false;
      }
      if (hasProof() != other.hasProof()) return false;
      if (hasProof()) {
        if (!getProof()
            .equals(other.getProof())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasHeader()) {
        hash = (37 * hash) + HEADER_FIELD_NUMBER;
        hash = (53 * hash) + getHeader().hashCode();
      }
      if (getBtcHeadersCount() > 0) {
        hash = (37 * hash) + BTC_HEADERS_FIELD_NUMBER;
        hash = (53 * hash) + getBtcHeadersList().hashCode();
      }
      if (hasEpochInfo()) {
        hash = (37 * hash) + EPOCH_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getEpochInfo().hashCode();
      }
      if (hasRawCheckpoint()) {
        hash = (37 * hash) + RAW_CHECKPOINT_FIELD_NUMBER;
        hash = (53 * hash) + getRawCheckpoint().hashCode();
      }
      if (hasBtcSubmissionKey()) {
        hash = (37 * hash) + BTC_SUBMISSION_KEY_FIELD_NUMBER;
        hash = (53 * hash) + getBtcSubmissionKey().hashCode();
      }
      if (hasProof()) {
        hash = (37 * hash) + PROOF_FIELD_NUMBER;
        hash = (53 * hash) + getProof().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * BTCTimestamp is a BTC timestamp that carries information of a BTC-finalised epoch
     * It includes a number of BTC headers, a raw checkpoint, an epoch metadata, and 
     * a CZ header if there exists CZ headers checkpointed to this epoch.
     * Upon a newly finalised epoch in Babylon, Babylon will send a BTC timestamp to each
     * Cosmos zone that has phase-2 integration with Babylon via IBC.
     * </pre>
     *
     * Protobuf type {@code babylon.zoneconcierge.v1.BTCTimestamp}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.zoneconcierge.v1.BTCTimestamp)
        com.babylon.zoneconcierge.v1.PacketProto.BTCTimestampOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.zoneconcierge.v1.PacketProto.internal_static_babylon_zoneconcierge_v1_BTCTimestamp_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.zoneconcierge.v1.PacketProto.internal_static_babylon_zoneconcierge_v1_BTCTimestamp_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.class, com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.Builder.class);
      }

      // Construct using com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        header_ = null;
        if (headerBuilder_ != null) {
          headerBuilder_.dispose();
          headerBuilder_ = null;
        }
        if (btcHeadersBuilder_ == null) {
          btcHeaders_ = java.util.Collections.emptyList();
        } else {
          btcHeaders_ = null;
          btcHeadersBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        epochInfo_ = null;
        if (epochInfoBuilder_ != null) {
          epochInfoBuilder_.dispose();
          epochInfoBuilder_ = null;
        }
        rawCheckpoint_ = null;
        if (rawCheckpointBuilder_ != null) {
          rawCheckpointBuilder_.dispose();
          rawCheckpointBuilder_ = null;
        }
        btcSubmissionKey_ = null;
        if (btcSubmissionKeyBuilder_ != null) {
          btcSubmissionKeyBuilder_.dispose();
          btcSubmissionKeyBuilder_ = null;
        }
        proof_ = null;
        if (proofBuilder_ != null) {
          proofBuilder_.dispose();
          proofBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.zoneconcierge.v1.PacketProto.internal_static_babylon_zoneconcierge_v1_BTCTimestamp_descriptor;
      }

      @java.lang.Override
      public com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp getDefaultInstanceForType() {
        return com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp build() {
        com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp buildPartial() {
        com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp result = new com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp result) {
        if (btcHeadersBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            btcHeaders_ = java.util.Collections.unmodifiableList(btcHeaders_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.btcHeaders_ = btcHeaders_;
        } else {
          result.btcHeaders_ = btcHeadersBuilder_.build();
        }
      }

      private void buildPartial0(com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.header_ = headerBuilder_ == null
              ? header_
              : headerBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.epochInfo_ = epochInfoBuilder_ == null
              ? epochInfo_
              : epochInfoBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.rawCheckpoint_ = rawCheckpointBuilder_ == null
              ? rawCheckpoint_
              : rawCheckpointBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.btcSubmissionKey_ = btcSubmissionKeyBuilder_ == null
              ? btcSubmissionKey_
              : btcSubmissionKeyBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.proof_ = proofBuilder_ == null
              ? proof_
              : proofBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp) {
          return mergeFrom((com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp other) {
        if (other == com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp.getDefaultInstance()) return this;
        if (other.hasHeader()) {
          mergeHeader(other.getHeader());
        }
        if (btcHeadersBuilder_ == null) {
          if (!other.btcHeaders_.isEmpty()) {
            if (btcHeaders_.isEmpty()) {
              btcHeaders_ = other.btcHeaders_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureBtcHeadersIsMutable();
              btcHeaders_.addAll(other.btcHeaders_);
            }
            onChanged();
          }
        } else {
          if (!other.btcHeaders_.isEmpty()) {
            if (btcHeadersBuilder_.isEmpty()) {
              btcHeadersBuilder_.dispose();
              btcHeadersBuilder_ = null;
              btcHeaders_ = other.btcHeaders_;
              bitField0_ = (bitField0_ & ~0x00000002);
              btcHeadersBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getBtcHeadersFieldBuilder() : null;
            } else {
              btcHeadersBuilder_.addAllMessages(other.btcHeaders_);
            }
          }
        }
        if (other.hasEpochInfo()) {
          mergeEpochInfo(other.getEpochInfo());
        }
        if (other.hasRawCheckpoint()) {
          mergeRawCheckpoint(other.getRawCheckpoint());
        }
        if (other.hasBtcSubmissionKey()) {
          mergeBtcSubmissionKey(other.getBtcSubmissionKey());
        }
        if (other.hasProof()) {
          mergeProof(other.getProof());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getHeaderFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo m =
                    input.readMessage(
                        com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo.parser(),
                        extensionRegistry);
                if (btcHeadersBuilder_ == null) {
                  ensureBtcHeadersIsMutable();
                  btcHeaders_.add(m);
                } else {
                  btcHeadersBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getEpochInfoFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                input.readMessage(
                    getRawCheckpointFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    getBtcSubmissionKeyFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 50: {
                input.readMessage(
                    getProofFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader header_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader, com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader.Builder, com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeaderOrBuilder> headerBuilder_;
      /**
       * <pre>
       * header is the last CZ header in the finalized Babylon epoch
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
       * @return Whether the header field is set.
       */
      public boolean hasHeader() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * header is the last CZ header in the finalized Babylon epoch
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
       * @return The header.
       */
      public com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader getHeader() {
        if (headerBuilder_ == null) {
          return header_ == null ? com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader.getDefaultInstance() : header_;
        } else {
          return headerBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * header is the last CZ header in the finalized Babylon epoch
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
       */
      public Builder setHeader(com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader value) {
        if (headerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          header_ = value;
        } else {
          headerBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * header is the last CZ header in the finalized Babylon epoch
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
       */
      public Builder setHeader(
          com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader.Builder builderForValue) {
        if (headerBuilder_ == null) {
          header_ = builderForValue.build();
        } else {
          headerBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * header is the last CZ header in the finalized Babylon epoch
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
       */
      public Builder mergeHeader(com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader value) {
        if (headerBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            header_ != null &&
            header_ != com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader.getDefaultInstance()) {
            getHeaderBuilder().mergeFrom(value);
          } else {
            header_ = value;
          }
        } else {
          headerBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * header is the last CZ header in the finalized Babylon epoch
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
       */
      public Builder clearHeader() {
        bitField0_ = (bitField0_ & ~0x00000001);
        header_ = null;
        if (headerBuilder_ != null) {
          headerBuilder_.dispose();
          headerBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * header is the last CZ header in the finalized Babylon epoch
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
       */
      public com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader.Builder getHeaderBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getHeaderFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * header is the last CZ header in the finalized Babylon epoch
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
       */
      public com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeaderOrBuilder getHeaderOrBuilder() {
        if (headerBuilder_ != null) {
          return headerBuilder_.getMessageOrBuilder();
        } else {
          return header_ == null ?
              com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader.getDefaultInstance() : header_;
        }
      }
      /**
       * <pre>
       * header is the last CZ header in the finalized Babylon epoch
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.IndexedHeader header = 1 [json_name = "header"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader, com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader.Builder, com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeaderOrBuilder> 
          getHeaderFieldBuilder() {
        if (headerBuilder_ == null) {
          headerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader, com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeader.Builder, com.babylon.zoneconcierge.v1.ZoneconciergeProto.IndexedHeaderOrBuilder>(
                  getHeader(),
                  getParentForChildren(),
                  isClean());
          header_ = null;
        }
        return headerBuilder_;
      }

      private java.util.List<com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo> btcHeaders_ =
        java.util.Collections.emptyList();
      private void ensureBtcHeadersIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          btcHeaders_ = new java.util.ArrayList<com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo>(btcHeaders_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo, com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo.Builder, com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfoOrBuilder> btcHeadersBuilder_;

      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public java.util.List<com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo> getBtcHeadersList() {
        if (btcHeadersBuilder_ == null) {
          return java.util.Collections.unmodifiableList(btcHeaders_);
        } else {
          return btcHeadersBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public int getBtcHeadersCount() {
        if (btcHeadersBuilder_ == null) {
          return btcHeaders_.size();
        } else {
          return btcHeadersBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo getBtcHeaders(int index) {
        if (btcHeadersBuilder_ == null) {
          return btcHeaders_.get(index);
        } else {
          return btcHeadersBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public Builder setBtcHeaders(
          int index, com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo value) {
        if (btcHeadersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureBtcHeadersIsMutable();
          btcHeaders_.set(index, value);
          onChanged();
        } else {
          btcHeadersBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public Builder setBtcHeaders(
          int index, com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo.Builder builderForValue) {
        if (btcHeadersBuilder_ == null) {
          ensureBtcHeadersIsMutable();
          btcHeaders_.set(index, builderForValue.build());
          onChanged();
        } else {
          btcHeadersBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public Builder addBtcHeaders(com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo value) {
        if (btcHeadersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureBtcHeadersIsMutable();
          btcHeaders_.add(value);
          onChanged();
        } else {
          btcHeadersBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public Builder addBtcHeaders(
          int index, com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo value) {
        if (btcHeadersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureBtcHeadersIsMutable();
          btcHeaders_.add(index, value);
          onChanged();
        } else {
          btcHeadersBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public Builder addBtcHeaders(
          com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo.Builder builderForValue) {
        if (btcHeadersBuilder_ == null) {
          ensureBtcHeadersIsMutable();
          btcHeaders_.add(builderForValue.build());
          onChanged();
        } else {
          btcHeadersBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public Builder addBtcHeaders(
          int index, com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo.Builder builderForValue) {
        if (btcHeadersBuilder_ == null) {
          ensureBtcHeadersIsMutable();
          btcHeaders_.add(index, builderForValue.build());
          onChanged();
        } else {
          btcHeadersBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public Builder addAllBtcHeaders(
          java.lang.Iterable<? extends com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo> values) {
        if (btcHeadersBuilder_ == null) {
          ensureBtcHeadersIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, btcHeaders_);
          onChanged();
        } else {
          btcHeadersBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public Builder clearBtcHeaders() {
        if (btcHeadersBuilder_ == null) {
          btcHeaders_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          btcHeadersBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public Builder removeBtcHeaders(int index) {
        if (btcHeadersBuilder_ == null) {
          ensureBtcHeadersIsMutable();
          btcHeaders_.remove(index);
          onChanged();
        } else {
          btcHeadersBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo.Builder getBtcHeadersBuilder(
          int index) {
        return getBtcHeadersFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfoOrBuilder getBtcHeadersOrBuilder(
          int index) {
        if (btcHeadersBuilder_ == null) {
          return btcHeaders_.get(index);  } else {
          return btcHeadersBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public java.util.List<? extends com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfoOrBuilder> 
           getBtcHeadersOrBuilderList() {
        if (btcHeadersBuilder_ != null) {
          return btcHeadersBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(btcHeaders_);
        }
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo.Builder addBtcHeadersBuilder() {
        return getBtcHeadersFieldBuilder().addBuilder(
            com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo.getDefaultInstance());
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo.Builder addBtcHeadersBuilder(
          int index) {
        return getBtcHeadersFieldBuilder().addBuilder(
            index, com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo.getDefaultInstance());
      }
      /**
       * <pre>
       * btc_headers is BTC headers between
       * - the block AFTER the common ancestor of BTC tip at epoch `lastFinalizedEpoch-1` and BTC tip at epoch `lastFinalizedEpoch`
       * - BTC tip at epoch `lastFinalizedEpoch`
       * where `lastFinalizedEpoch` is the last finalised epoch in Babylon
       * </pre>
       *
       * <code>repeated .babylon.btclightclient.v1.BTCHeaderInfo btc_headers = 2 [json_name = "btcHeaders"];</code>
       */
      public java.util.List<com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo.Builder> 
           getBtcHeadersBuilderList() {
        return getBtcHeadersFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo, com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo.Builder, com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfoOrBuilder> 
          getBtcHeadersFieldBuilder() {
        if (btcHeadersBuilder_ == null) {
          btcHeadersBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo, com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfo.Builder, com.babylon.btclightclient.v1.BtclightclientProto.BTCHeaderInfoOrBuilder>(
                  btcHeaders_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          btcHeaders_ = null;
        }
        return btcHeadersBuilder_;
      }

      private com.babylon.epoching.v1.EpochingProto.Epoch epochInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.epoching.v1.EpochingProto.Epoch, com.babylon.epoching.v1.EpochingProto.Epoch.Builder, com.babylon.epoching.v1.EpochingProto.EpochOrBuilder> epochInfoBuilder_;
      /**
       * <pre>
       * epoch_info is the metadata of the sealed epoch
       * </pre>
       *
       * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
       * @return Whether the epochInfo field is set.
       */
      public boolean hasEpochInfo() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * epoch_info is the metadata of the sealed epoch
       * </pre>
       *
       * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
       * @return The epochInfo.
       */
      public com.babylon.epoching.v1.EpochingProto.Epoch getEpochInfo() {
        if (epochInfoBuilder_ == null) {
          return epochInfo_ == null ? com.babylon.epoching.v1.EpochingProto.Epoch.getDefaultInstance() : epochInfo_;
        } else {
          return epochInfoBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * epoch_info is the metadata of the sealed epoch
       * </pre>
       *
       * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
       */
      public Builder setEpochInfo(com.babylon.epoching.v1.EpochingProto.Epoch value) {
        if (epochInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          epochInfo_ = value;
        } else {
          epochInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * epoch_info is the metadata of the sealed epoch
       * </pre>
       *
       * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
       */
      public Builder setEpochInfo(
          com.babylon.epoching.v1.EpochingProto.Epoch.Builder builderForValue) {
        if (epochInfoBuilder_ == null) {
          epochInfo_ = builderForValue.build();
        } else {
          epochInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * epoch_info is the metadata of the sealed epoch
       * </pre>
       *
       * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
       */
      public Builder mergeEpochInfo(com.babylon.epoching.v1.EpochingProto.Epoch value) {
        if (epochInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            epochInfo_ != null &&
            epochInfo_ != com.babylon.epoching.v1.EpochingProto.Epoch.getDefaultInstance()) {
            getEpochInfoBuilder().mergeFrom(value);
          } else {
            epochInfo_ = value;
          }
        } else {
          epochInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * epoch_info is the metadata of the sealed epoch
       * </pre>
       *
       * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
       */
      public Builder clearEpochInfo() {
        bitField0_ = (bitField0_ & ~0x00000004);
        epochInfo_ = null;
        if (epochInfoBuilder_ != null) {
          epochInfoBuilder_.dispose();
          epochInfoBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * epoch_info is the metadata of the sealed epoch
       * </pre>
       *
       * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
       */
      public com.babylon.epoching.v1.EpochingProto.Epoch.Builder getEpochInfoBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getEpochInfoFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * epoch_info is the metadata of the sealed epoch
       * </pre>
       *
       * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
       */
      public com.babylon.epoching.v1.EpochingProto.EpochOrBuilder getEpochInfoOrBuilder() {
        if (epochInfoBuilder_ != null) {
          return epochInfoBuilder_.getMessageOrBuilder();
        } else {
          return epochInfo_ == null ?
              com.babylon.epoching.v1.EpochingProto.Epoch.getDefaultInstance() : epochInfo_;
        }
      }
      /**
       * <pre>
       * epoch_info is the metadata of the sealed epoch
       * </pre>
       *
       * <code>.babylon.epoching.v1.Epoch epoch_info = 3 [json_name = "epochInfo"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.epoching.v1.EpochingProto.Epoch, com.babylon.epoching.v1.EpochingProto.Epoch.Builder, com.babylon.epoching.v1.EpochingProto.EpochOrBuilder> 
          getEpochInfoFieldBuilder() {
        if (epochInfoBuilder_ == null) {
          epochInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.babylon.epoching.v1.EpochingProto.Epoch, com.babylon.epoching.v1.EpochingProto.Epoch.Builder, com.babylon.epoching.v1.EpochingProto.EpochOrBuilder>(
                  getEpochInfo(),
                  getParentForChildren(),
                  isClean());
          epochInfo_ = null;
        }
        return epochInfoBuilder_;
      }

      private com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint rawCheckpoint_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.Builder, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointOrBuilder> rawCheckpointBuilder_;
      /**
       * <pre>
       * raw_checkpoint is the raw checkpoint that seals this epoch
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
       * @return Whether the rawCheckpoint field is set.
       */
      public boolean hasRawCheckpoint() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * raw_checkpoint is the raw checkpoint that seals this epoch
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
       * @return The rawCheckpoint.
       */
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint getRawCheckpoint() {
        if (rawCheckpointBuilder_ == null) {
          return rawCheckpoint_ == null ? com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.getDefaultInstance() : rawCheckpoint_;
        } else {
          return rawCheckpointBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * raw_checkpoint is the raw checkpoint that seals this epoch
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
       */
      public Builder setRawCheckpoint(com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint value) {
        if (rawCheckpointBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          rawCheckpoint_ = value;
        } else {
          rawCheckpointBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * raw_checkpoint is the raw checkpoint that seals this epoch
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
       */
      public Builder setRawCheckpoint(
          com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.Builder builderForValue) {
        if (rawCheckpointBuilder_ == null) {
          rawCheckpoint_ = builderForValue.build();
        } else {
          rawCheckpointBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * raw_checkpoint is the raw checkpoint that seals this epoch
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
       */
      public Builder mergeRawCheckpoint(com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint value) {
        if (rawCheckpointBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
            rawCheckpoint_ != null &&
            rawCheckpoint_ != com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.getDefaultInstance()) {
            getRawCheckpointBuilder().mergeFrom(value);
          } else {
            rawCheckpoint_ = value;
          }
        } else {
          rawCheckpointBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * raw_checkpoint is the raw checkpoint that seals this epoch
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
       */
      public Builder clearRawCheckpoint() {
        bitField0_ = (bitField0_ & ~0x00000008);
        rawCheckpoint_ = null;
        if (rawCheckpointBuilder_ != null) {
          rawCheckpointBuilder_.dispose();
          rawCheckpointBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * raw_checkpoint is the raw checkpoint that seals this epoch
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
       */
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.Builder getRawCheckpointBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getRawCheckpointFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * raw_checkpoint is the raw checkpoint that seals this epoch
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
       */
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointOrBuilder getRawCheckpointOrBuilder() {
        if (rawCheckpointBuilder_ != null) {
          return rawCheckpointBuilder_.getMessageOrBuilder();
        } else {
          return rawCheckpoint_ == null ?
              com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.getDefaultInstance() : rawCheckpoint_;
        }
      }
      /**
       * <pre>
       * raw_checkpoint is the raw checkpoint that seals this epoch
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.RawCheckpoint raw_checkpoint = 4 [json_name = "rawCheckpoint"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.Builder, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointOrBuilder> 
          getRawCheckpointFieldBuilder() {
        if (rawCheckpointBuilder_ == null) {
          rawCheckpointBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.Builder, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointOrBuilder>(
                  getRawCheckpoint(),
                  getParentForChildren(),
                  isClean());
          rawCheckpoint_ = null;
        }
        return rawCheckpointBuilder_;
      }

      private com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey btcSubmissionKey_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder> btcSubmissionKeyBuilder_;
      /**
       * <pre>
       * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
       * @return Whether the btcSubmissionKey field is set.
       */
      public boolean hasBtcSubmissionKey() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
       * @return The btcSubmissionKey.
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey getBtcSubmissionKey() {
        if (btcSubmissionKeyBuilder_ == null) {
          return btcSubmissionKey_ == null ? com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.getDefaultInstance() : btcSubmissionKey_;
        } else {
          return btcSubmissionKeyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
       */
      public Builder setBtcSubmissionKey(com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey value) {
        if (btcSubmissionKeyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          btcSubmissionKey_ = value;
        } else {
          btcSubmissionKeyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
       */
      public Builder setBtcSubmissionKey(
          com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder builderForValue) {
        if (btcSubmissionKeyBuilder_ == null) {
          btcSubmissionKey_ = builderForValue.build();
        } else {
          btcSubmissionKeyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
       */
      public Builder mergeBtcSubmissionKey(com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey value) {
        if (btcSubmissionKeyBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
            btcSubmissionKey_ != null &&
            btcSubmissionKey_ != com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.getDefaultInstance()) {
            getBtcSubmissionKeyBuilder().mergeFrom(value);
          } else {
            btcSubmissionKey_ = value;
          }
        } else {
          btcSubmissionKeyBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
       */
      public Builder clearBtcSubmissionKey() {
        bitField0_ = (bitField0_ & ~0x00000010);
        btcSubmissionKey_ = null;
        if (btcSubmissionKeyBuilder_ != null) {
          btcSubmissionKeyBuilder_.dispose();
          btcSubmissionKeyBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder getBtcSubmissionKeyBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getBtcSubmissionKeyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder getBtcSubmissionKeyOrBuilder() {
        if (btcSubmissionKeyBuilder_ != null) {
          return btcSubmissionKeyBuilder_.getMessageOrBuilder();
        } else {
          return btcSubmissionKey_ == null ?
              com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.getDefaultInstance() : btcSubmissionKey_;
        }
      }
      /**
       * <pre>
       * btc_submission_key is position of two BTC txs that include the raw checkpoint of this epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.SubmissionKey btc_submission_key = 5 [json_name = "btcSubmissionKey"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder> 
          getBtcSubmissionKeyFieldBuilder() {
        if (btcSubmissionKeyBuilder_ == null) {
          btcSubmissionKeyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder>(
                  getBtcSubmissionKey(),
                  getParentForChildren(),
                  isClean());
          btcSubmissionKey_ = null;
        }
        return btcSubmissionKeyBuilder_;
      }

      private com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo proof_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo, com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo.Builder, com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfoOrBuilder> proofBuilder_;
      /**
       * <pre>
       * 
       *Proofs that the header is finalized
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
       * @return Whether the proof field is set.
       */
      public boolean hasProof() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * 
       *Proofs that the header is finalized
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
       * @return The proof.
       */
      public com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo getProof() {
        if (proofBuilder_ == null) {
          return proof_ == null ? com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo.getDefaultInstance() : proof_;
        } else {
          return proofBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * 
       *Proofs that the header is finalized
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
       */
      public Builder setProof(com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo value) {
        if (proofBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          proof_ = value;
        } else {
          proofBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * 
       *Proofs that the header is finalized
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
       */
      public Builder setProof(
          com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo.Builder builderForValue) {
        if (proofBuilder_ == null) {
          proof_ = builderForValue.build();
        } else {
          proofBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * 
       *Proofs that the header is finalized
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
       */
      public Builder mergeProof(com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo value) {
        if (proofBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
            proof_ != null &&
            proof_ != com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo.getDefaultInstance()) {
            getProofBuilder().mergeFrom(value);
          } else {
            proof_ = value;
          }
        } else {
          proofBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * 
       *Proofs that the header is finalized
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
       */
      public Builder clearProof() {
        bitField0_ = (bitField0_ & ~0x00000020);
        proof_ = null;
        if (proofBuilder_ != null) {
          proofBuilder_.dispose();
          proofBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * 
       *Proofs that the header is finalized
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
       */
      public com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo.Builder getProofBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getProofFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * 
       *Proofs that the header is finalized
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
       */
      public com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfoOrBuilder getProofOrBuilder() {
        if (proofBuilder_ != null) {
          return proofBuilder_.getMessageOrBuilder();
        } else {
          return proof_ == null ?
              com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo.getDefaultInstance() : proof_;
        }
      }
      /**
       * <pre>
       * 
       *Proofs that the header is finalized
       * </pre>
       *
       * <code>.babylon.zoneconcierge.v1.ProofFinalizedChainInfo proof = 6 [json_name = "proof"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo, com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo.Builder, com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfoOrBuilder> 
          getProofFieldBuilder() {
        if (proofBuilder_ == null) {
          proofBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo, com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfo.Builder, com.babylon.zoneconcierge.v1.ZoneconciergeProto.ProofFinalizedChainInfoOrBuilder>(
                  getProof(),
                  getParentForChildren(),
                  isClean());
          proof_ = null;
        }
        return proofBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.zoneconcierge.v1.BTCTimestamp)
    }

    // @@protoc_insertion_point(class_scope:babylon.zoneconcierge.v1.BTCTimestamp)
    private static final com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp();
    }

    public static com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<BTCTimestamp>
        PARSER = new com.google.protobuf.AbstractParser<BTCTimestamp>() {
      @java.lang.Override
      public BTCTimestamp parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<BTCTimestamp> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<BTCTimestamp> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.zoneconcierge.v1.PacketProto.BTCTimestamp getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_zoneconcierge_v1_ZoneconciergePacketData_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_zoneconcierge_v1_ZoneconciergePacketData_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_zoneconcierge_v1_BTCTimestamp_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_zoneconcierge_v1_BTCTimestamp_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n%babylon/zoneconcierge/v1/packet.proto\022" +
      "\030babylon.zoneconcierge.v1\032,babylon/btcch" +
      "eckpoint/v1/btccheckpoint.proto\032)babylon" +
      "/checkpointing/v1/checkpoint.proto\032.baby" +
      "lon/btclightclient/v1/btclightclient.pro" +
      "to\032\"babylon/epoching/v1/epoching.proto\032," +
      "babylon/zoneconcierge/v1/zoneconcierge.p" +
      "roto\"r\n\027ZoneconciergePacketData\022M\n\rbtc_t" +
      "imestamp\030\001 \001(\0132&.babylon.zoneconcierge.v" +
      "1.BTCTimestampH\000R\014btcTimestampB\010\n\006packet" +
      "\"\305\003\n\014BTCTimestamp\022?\n\006header\030\001 \001(\0132\'.baby" +
      "lon.zoneconcierge.v1.IndexedHeaderR\006head" +
      "er\022I\n\013btc_headers\030\002 \003(\0132(.babylon.btclig" +
      "htclient.v1.BTCHeaderInfoR\nbtcHeaders\0229\n" +
      "\nepoch_info\030\003 \001(\0132\032.babylon.epoching.v1." +
      "EpochR\tepochInfo\022N\n\016raw_checkpoint\030\004 \001(\013" +
      "2\'.babylon.checkpointing.v1.RawCheckpoin" +
      "tR\rrawCheckpoint\022U\n\022btc_submission_key\030\005" +
      " \001(\0132\'.babylon.btccheckpoint.v1.Submissi" +
      "onKeyR\020btcSubmissionKey\022G\n\005proof\030\006 \001(\01321" +
      ".babylon.zoneconcierge.v1.ProofFinalized" +
      "ChainInfoR\005proofB\342\001\n\034com.babylon.zonecon" +
      "cierge.v1B\013PacketProtoZ5github.com/babyl" +
      "onchain/babylon/x/zoneconcierge/types\242\002\003" +
      "BZX\252\002\030Babylon.Zoneconcierge.V1\312\002\030Babylon" +
      "\\Zoneconcierge\\V1\342\002$Babylon\\Zoneconcierg" +
      "e\\V1\\GPBMetadata\352\002\032Babylon::Zoneconcierg" +
      "e::V1b\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          com.babylon.btccheckpoint.v1.BtccheckpointProto.getDescriptor(),
          com.babylon.checkpointing.v1.CheckpointProto.getDescriptor(),
          com.babylon.btclightclient.v1.BtclightclientProto.getDescriptor(),
          com.babylon.epoching.v1.EpochingProto.getDescriptor(),
          com.babylon.zoneconcierge.v1.ZoneconciergeProto.getDescriptor(),
        });
    internal_static_babylon_zoneconcierge_v1_ZoneconciergePacketData_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_babylon_zoneconcierge_v1_ZoneconciergePacketData_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_zoneconcierge_v1_ZoneconciergePacketData_descriptor,
        new java.lang.String[] { "BtcTimestamp", "Packet", });
    internal_static_babylon_zoneconcierge_v1_BTCTimestamp_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_babylon_zoneconcierge_v1_BTCTimestamp_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_zoneconcierge_v1_BTCTimestamp_descriptor,
        new java.lang.String[] { "Header", "BtcHeaders", "EpochInfo", "RawCheckpoint", "BtcSubmissionKey", "Proof", });
    com.babylon.btccheckpoint.v1.BtccheckpointProto.getDescriptor();
    com.babylon.checkpointing.v1.CheckpointProto.getDescriptor();
    com.babylon.btclightclient.v1.BtclightclientProto.getDescriptor();
    com.babylon.epoching.v1.EpochingProto.getDescriptor();
    com.babylon.zoneconcierge.v1.ZoneconciergeProto.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
