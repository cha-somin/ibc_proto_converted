// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: babylon/checkpointing/v1/checkpoint.proto

package com.babylon.checkpointing.v1;

public final class CheckpointProto {
  private CheckpointProto() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * CheckpointStatus is the status of a checkpoint.
   * </pre>
   *
   * Protobuf enum {@code babylon.checkpointing.v1.CheckpointStatus}
   */
  public enum CheckpointStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * ACCUMULATING defines a checkpoint that is awaiting for BLS signatures.
     * </pre>
     *
     * <code>CKPT_STATUS_ACCUMULATING = 0 [(.gogoproto.enumvalue_customname) = "Accumulating"];</code>
     */
    CKPT_STATUS_ACCUMULATING(0),
    /**
     * <pre>
     * SEALED defines a checkpoint that has accumulated sufficient BLS signatures.
     * </pre>
     *
     * <code>CKPT_STATUS_SEALED = 1 [(.gogoproto.enumvalue_customname) = "Sealed"];</code>
     */
    CKPT_STATUS_SEALED(1),
    /**
     * <pre>
     * SUBMITTED defines a checkpoint that is included on BTC.
     * </pre>
     *
     * <code>CKPT_STATUS_SUBMITTED = 2 [(.gogoproto.enumvalue_customname) = "Submitted"];</code>
     */
    CKPT_STATUS_SUBMITTED(2),
    /**
     * <pre>
     * CONFIRMED defines a checkpoint that is k-deep on BTC.
     * </pre>
     *
     * <code>CKPT_STATUS_CONFIRMED = 3 [(.gogoproto.enumvalue_customname) = "Confirmed"];</code>
     */
    CKPT_STATUS_CONFIRMED(3),
    /**
     * <pre>
     * FINALIZED defines a checkpoint that is w-deep on BTC.
     * </pre>
     *
     * <code>CKPT_STATUS_FINALIZED = 4 [(.gogoproto.enumvalue_customname) = "Finalized"];</code>
     */
    CKPT_STATUS_FINALIZED(4),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * ACCUMULATING defines a checkpoint that is awaiting for BLS signatures.
     * </pre>
     *
     * <code>CKPT_STATUS_ACCUMULATING = 0 [(.gogoproto.enumvalue_customname) = "Accumulating"];</code>
     */
    public static final int CKPT_STATUS_ACCUMULATING_VALUE = 0;
    /**
     * <pre>
     * SEALED defines a checkpoint that has accumulated sufficient BLS signatures.
     * </pre>
     *
     * <code>CKPT_STATUS_SEALED = 1 [(.gogoproto.enumvalue_customname) = "Sealed"];</code>
     */
    public static final int CKPT_STATUS_SEALED_VALUE = 1;
    /**
     * <pre>
     * SUBMITTED defines a checkpoint that is included on BTC.
     * </pre>
     *
     * <code>CKPT_STATUS_SUBMITTED = 2 [(.gogoproto.enumvalue_customname) = "Submitted"];</code>
     */
    public static final int CKPT_STATUS_SUBMITTED_VALUE = 2;
    /**
     * <pre>
     * CONFIRMED defines a checkpoint that is k-deep on BTC.
     * </pre>
     *
     * <code>CKPT_STATUS_CONFIRMED = 3 [(.gogoproto.enumvalue_customname) = "Confirmed"];</code>
     */
    public static final int CKPT_STATUS_CONFIRMED_VALUE = 3;
    /**
     * <pre>
     * FINALIZED defines a checkpoint that is w-deep on BTC.
     * </pre>
     *
     * <code>CKPT_STATUS_FINALIZED = 4 [(.gogoproto.enumvalue_customname) = "Finalized"];</code>
     */
    public static final int CKPT_STATUS_FINALIZED_VALUE = 4;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static CheckpointStatus valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static CheckpointStatus forNumber(int value) {
      switch (value) {
        case 0: return CKPT_STATUS_ACCUMULATING;
        case 1: return CKPT_STATUS_SEALED;
        case 2: return CKPT_STATUS_SUBMITTED;
        case 3: return CKPT_STATUS_CONFIRMED;
        case 4: return CKPT_STATUS_FINALIZED;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CheckpointStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        CheckpointStatus> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<CheckpointStatus>() {
            public CheckpointStatus findValueByNumber(int number) {
              return CheckpointStatus.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.babylon.checkpointing.v1.CheckpointProto.getDescriptor().getEnumTypes().get(0);
    }

    private static final CheckpointStatus[] VALUES = values();

    public static CheckpointStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private CheckpointStatus(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:babylon.checkpointing.v1.CheckpointStatus)
  }

  public interface RawCheckpointOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.checkpointing.v1.RawCheckpoint)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * epoch_num defines the epoch number the raw checkpoint is for
     * </pre>
     *
     * <code>uint64 epoch_num = 1 [json_name = "epochNum"];</code>
     * @return The epochNum.
     */
    long getEpochNum();

    /**
     * <pre>
     * block_hash defines the 'BlockID.Hash', which is the hash of
     * the block that individual BLS sigs are signed on
     * </pre>
     *
     * <code>bytes block_hash = 2 [json_name = "blockHash", (.gogoproto.customtype) = "BlockHash"];</code>
     * @return The blockHash.
     */
    com.google.protobuf.ByteString getBlockHash();

    /**
     * <pre>
     * bitmap defines the bitmap that indicates the signers of the BLS multi sig
     * </pre>
     *
     * <code>bytes bitmap = 3 [json_name = "bitmap"];</code>
     * @return The bitmap.
     */
    com.google.protobuf.ByteString getBitmap();

    /**
     * <pre>
     * bls_multi_sig defines the multi sig that is aggregated from individual BLS
     * sigs
     * </pre>
     *
     * <code>bytes bls_multi_sig = 4 [json_name = "blsMultiSig", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.Signature"];</code>
     * @return The blsMultiSig.
     */
    com.google.protobuf.ByteString getBlsMultiSig();
  }
  /**
   * <pre>
   * RawCheckpoint wraps the BLS multi sig with metadata
   * </pre>
   *
   * Protobuf type {@code babylon.checkpointing.v1.RawCheckpoint}
   */
  public static final class RawCheckpoint extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.checkpointing.v1.RawCheckpoint)
      RawCheckpointOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RawCheckpoint.newBuilder() to construct.
    private RawCheckpoint(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RawCheckpoint() {
      blockHash_ = com.google.protobuf.ByteString.EMPTY;
      bitmap_ = com.google.protobuf.ByteString.EMPTY;
      blsMultiSig_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new RawCheckpoint();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_RawCheckpoint_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_RawCheckpoint_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.class, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.Builder.class);
    }

    public static final int EPOCH_NUM_FIELD_NUMBER = 1;
    private long epochNum_ = 0L;
    /**
     * <pre>
     * epoch_num defines the epoch number the raw checkpoint is for
     * </pre>
     *
     * <code>uint64 epoch_num = 1 [json_name = "epochNum"];</code>
     * @return The epochNum.
     */
    @java.lang.Override
    public long getEpochNum() {
      return epochNum_;
    }

    public static final int BLOCK_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString blockHash_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * block_hash defines the 'BlockID.Hash', which is the hash of
     * the block that individual BLS sigs are signed on
     * </pre>
     *
     * <code>bytes block_hash = 2 [json_name = "blockHash", (.gogoproto.customtype) = "BlockHash"];</code>
     * @return The blockHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBlockHash() {
      return blockHash_;
    }

    public static final int BITMAP_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString bitmap_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * bitmap defines the bitmap that indicates the signers of the BLS multi sig
     * </pre>
     *
     * <code>bytes bitmap = 3 [json_name = "bitmap"];</code>
     * @return The bitmap.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBitmap() {
      return bitmap_;
    }

    public static final int BLS_MULTI_SIG_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString blsMultiSig_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * bls_multi_sig defines the multi sig that is aggregated from individual BLS
     * sigs
     * </pre>
     *
     * <code>bytes bls_multi_sig = 4 [json_name = "blsMultiSig", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.Signature"];</code>
     * @return The blsMultiSig.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBlsMultiSig() {
      return blsMultiSig_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (epochNum_ != 0L) {
        output.writeUInt64(1, epochNum_);
      }
      if (!blockHash_.isEmpty()) {
        output.writeBytes(2, blockHash_);
      }
      if (!bitmap_.isEmpty()) {
        output.writeBytes(3, bitmap_);
      }
      if (!blsMultiSig_.isEmpty()) {
        output.writeBytes(4, blsMultiSig_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (epochNum_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, epochNum_);
      }
      if (!blockHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, blockHash_);
      }
      if (!bitmap_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, bitmap_);
      }
      if (!blsMultiSig_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, blsMultiSig_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint)) {
        return super.equals(obj);
      }
      com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint other = (com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint) obj;

      if (getEpochNum()
          != other.getEpochNum()) return false;
      if (!getBlockHash()
          .equals(other.getBlockHash())) return false;
      if (!getBitmap()
          .equals(other.getBitmap())) return false;
      if (!getBlsMultiSig()
          .equals(other.getBlsMultiSig())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + EPOCH_NUM_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getEpochNum());
      hash = (37 * hash) + BLOCK_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getBlockHash().hashCode();
      hash = (37 * hash) + BITMAP_FIELD_NUMBER;
      hash = (53 * hash) + getBitmap().hashCode();
      hash = (37 * hash) + BLS_MULTI_SIG_FIELD_NUMBER;
      hash = (53 * hash) + getBlsMultiSig().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * RawCheckpoint wraps the BLS multi sig with metadata
     * </pre>
     *
     * Protobuf type {@code babylon.checkpointing.v1.RawCheckpoint}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.checkpointing.v1.RawCheckpoint)
        com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_RawCheckpoint_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_RawCheckpoint_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.class, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.Builder.class);
      }

      // Construct using com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        epochNum_ = 0L;
        blockHash_ = com.google.protobuf.ByteString.EMPTY;
        bitmap_ = com.google.protobuf.ByteString.EMPTY;
        blsMultiSig_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_RawCheckpoint_descriptor;
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint getDefaultInstanceForType() {
        return com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint build() {
        com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint buildPartial() {
        com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint result = new com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.epochNum_ = epochNum_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.blockHash_ = blockHash_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.bitmap_ = bitmap_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.blsMultiSig_ = blsMultiSig_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint) {
          return mergeFrom((com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint other) {
        if (other == com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.getDefaultInstance()) return this;
        if (other.getEpochNum() != 0L) {
          setEpochNum(other.getEpochNum());
        }
        if (other.getBlockHash() != com.google.protobuf.ByteString.EMPTY) {
          setBlockHash(other.getBlockHash());
        }
        if (other.getBitmap() != com.google.protobuf.ByteString.EMPTY) {
          setBitmap(other.getBitmap());
        }
        if (other.getBlsMultiSig() != com.google.protobuf.ByteString.EMPTY) {
          setBlsMultiSig(other.getBlsMultiSig());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                epochNum_ = input.readUInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                blockHash_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                bitmap_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                blsMultiSig_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long epochNum_ ;
      /**
       * <pre>
       * epoch_num defines the epoch number the raw checkpoint is for
       * </pre>
       *
       * <code>uint64 epoch_num = 1 [json_name = "epochNum"];</code>
       * @return The epochNum.
       */
      @java.lang.Override
      public long getEpochNum() {
        return epochNum_;
      }
      /**
       * <pre>
       * epoch_num defines the epoch number the raw checkpoint is for
       * </pre>
       *
       * <code>uint64 epoch_num = 1 [json_name = "epochNum"];</code>
       * @param value The epochNum to set.
       * @return This builder for chaining.
       */
      public Builder setEpochNum(long value) {

        epochNum_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * epoch_num defines the epoch number the raw checkpoint is for
       * </pre>
       *
       * <code>uint64 epoch_num = 1 [json_name = "epochNum"];</code>
       * @return This builder for chaining.
       */
      public Builder clearEpochNum() {
        bitField0_ = (bitField0_ & ~0x00000001);
        epochNum_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString blockHash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * block_hash defines the 'BlockID.Hash', which is the hash of
       * the block that individual BLS sigs are signed on
       * </pre>
       *
       * <code>bytes block_hash = 2 [json_name = "blockHash", (.gogoproto.customtype) = "BlockHash"];</code>
       * @return The blockHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBlockHash() {
        return blockHash_;
      }
      /**
       * <pre>
       * block_hash defines the 'BlockID.Hash', which is the hash of
       * the block that individual BLS sigs are signed on
       * </pre>
       *
       * <code>bytes block_hash = 2 [json_name = "blockHash", (.gogoproto.customtype) = "BlockHash"];</code>
       * @param value The blockHash to set.
       * @return This builder for chaining.
       */
      public Builder setBlockHash(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        blockHash_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * block_hash defines the 'BlockID.Hash', which is the hash of
       * the block that individual BLS sigs are signed on
       * </pre>
       *
       * <code>bytes block_hash = 2 [json_name = "blockHash", (.gogoproto.customtype) = "BlockHash"];</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockHash() {
        bitField0_ = (bitField0_ & ~0x00000002);
        blockHash_ = getDefaultInstance().getBlockHash();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString bitmap_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * bitmap defines the bitmap that indicates the signers of the BLS multi sig
       * </pre>
       *
       * <code>bytes bitmap = 3 [json_name = "bitmap"];</code>
       * @return The bitmap.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBitmap() {
        return bitmap_;
      }
      /**
       * <pre>
       * bitmap defines the bitmap that indicates the signers of the BLS multi sig
       * </pre>
       *
       * <code>bytes bitmap = 3 [json_name = "bitmap"];</code>
       * @param value The bitmap to set.
       * @return This builder for chaining.
       */
      public Builder setBitmap(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        bitmap_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * bitmap defines the bitmap that indicates the signers of the BLS multi sig
       * </pre>
       *
       * <code>bytes bitmap = 3 [json_name = "bitmap"];</code>
       * @return This builder for chaining.
       */
      public Builder clearBitmap() {
        bitField0_ = (bitField0_ & ~0x00000004);
        bitmap_ = getDefaultInstance().getBitmap();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString blsMultiSig_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * bls_multi_sig defines the multi sig that is aggregated from individual BLS
       * sigs
       * </pre>
       *
       * <code>bytes bls_multi_sig = 4 [json_name = "blsMultiSig", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.Signature"];</code>
       * @return The blsMultiSig.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBlsMultiSig() {
        return blsMultiSig_;
      }
      /**
       * <pre>
       * bls_multi_sig defines the multi sig that is aggregated from individual BLS
       * sigs
       * </pre>
       *
       * <code>bytes bls_multi_sig = 4 [json_name = "blsMultiSig", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.Signature"];</code>
       * @param value The blsMultiSig to set.
       * @return This builder for chaining.
       */
      public Builder setBlsMultiSig(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        blsMultiSig_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * bls_multi_sig defines the multi sig that is aggregated from individual BLS
       * sigs
       * </pre>
       *
       * <code>bytes bls_multi_sig = 4 [json_name = "blsMultiSig", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.Signature"];</code>
       * @return This builder for chaining.
       */
      public Builder clearBlsMultiSig() {
        bitField0_ = (bitField0_ & ~0x00000008);
        blsMultiSig_ = getDefaultInstance().getBlsMultiSig();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.checkpointing.v1.RawCheckpoint)
    }

    // @@protoc_insertion_point(class_scope:babylon.checkpointing.v1.RawCheckpoint)
    private static final com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint();
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RawCheckpoint>
        PARSER = new com.google.protobuf.AbstractParser<RawCheckpoint>() {
      @java.lang.Override
      public RawCheckpoint parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<RawCheckpoint> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RawCheckpoint> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RawCheckpointWithMetaOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.checkpointing.v1.RawCheckpointWithMeta)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
     * @return Whether the ckpt field is set.
     */
    boolean hasCkpt();
    /**
     * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
     * @return The ckpt.
     */
    com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint getCkpt();
    /**
     * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
     */
    com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointOrBuilder getCkptOrBuilder();

    /**
     * <pre>
     * status defines the status of the checkpoint
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.CheckpointStatus status = 2 [json_name = "status"];</code>
     * @return The enum numeric value on the wire for status.
     */
    int getStatusValue();
    /**
     * <pre>
     * status defines the status of the checkpoint
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.CheckpointStatus status = 2 [json_name = "status"];</code>
     * @return The status.
     */
    com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus getStatus();

    /**
     * <pre>
     * bls_aggr_pk defines the aggregated BLS public key
     * </pre>
     *
     * <code>bytes bls_aggr_pk = 3 [json_name = "blsAggrPk", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.PublicKey"];</code>
     * @return The blsAggrPk.
     */
    com.google.protobuf.ByteString getBlsAggrPk();

    /**
     * <pre>
     * power_sum defines the accumulated voting power for the checkpoint
     * </pre>
     *
     * <code>uint64 power_sum = 4 [json_name = "powerSum"];</code>
     * @return The powerSum.
     */
    long getPowerSum();

    /**
     * <pre>
     * lifecycle defines the lifecycle of this checkpoint, i.e., each state
     * transition and the time (in both timestamp and block height) of this
     * transition.
     * </pre>
     *
     * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
     */
    java.util.List<com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate> 
        getLifecycleList();
    /**
     * <pre>
     * lifecycle defines the lifecycle of this checkpoint, i.e., each state
     * transition and the time (in both timestamp and block height) of this
     * transition.
     * </pre>
     *
     * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
     */
    com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate getLifecycle(int index);
    /**
     * <pre>
     * lifecycle defines the lifecycle of this checkpoint, i.e., each state
     * transition and the time (in both timestamp and block height) of this
     * transition.
     * </pre>
     *
     * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
     */
    int getLifecycleCount();
    /**
     * <pre>
     * lifecycle defines the lifecycle of this checkpoint, i.e., each state
     * transition and the time (in both timestamp and block height) of this
     * transition.
     * </pre>
     *
     * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
     */
    java.util.List<? extends com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdateOrBuilder> 
        getLifecycleOrBuilderList();
    /**
     * <pre>
     * lifecycle defines the lifecycle of this checkpoint, i.e., each state
     * transition and the time (in both timestamp and block height) of this
     * transition.
     * </pre>
     *
     * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
     */
    com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdateOrBuilder getLifecycleOrBuilder(
        int index);
  }
  /**
   * <pre>
   * RawCheckpointWithMeta wraps the raw checkpoint with metadata.
   * </pre>
   *
   * Protobuf type {@code babylon.checkpointing.v1.RawCheckpointWithMeta}
   */
  public static final class RawCheckpointWithMeta extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.checkpointing.v1.RawCheckpointWithMeta)
      RawCheckpointWithMetaOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RawCheckpointWithMeta.newBuilder() to construct.
    private RawCheckpointWithMeta(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RawCheckpointWithMeta() {
      status_ = 0;
      blsAggrPk_ = com.google.protobuf.ByteString.EMPTY;
      lifecycle_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new RawCheckpointWithMeta();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_RawCheckpointWithMeta_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_RawCheckpointWithMeta_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.class, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.Builder.class);
    }

    public static final int CKPT_FIELD_NUMBER = 1;
    private com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint ckpt_;
    /**
     * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
     * @return Whether the ckpt field is set.
     */
    @java.lang.Override
    public boolean hasCkpt() {
      return ckpt_ != null;
    }
    /**
     * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
     * @return The ckpt.
     */
    @java.lang.Override
    public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint getCkpt() {
      return ckpt_ == null ? com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.getDefaultInstance() : ckpt_;
    }
    /**
     * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
     */
    @java.lang.Override
    public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointOrBuilder getCkptOrBuilder() {
      return ckpt_ == null ? com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.getDefaultInstance() : ckpt_;
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    private int status_ = 0;
    /**
     * <pre>
     * status defines the status of the checkpoint
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.CheckpointStatus status = 2 [json_name = "status"];</code>
     * @return The enum numeric value on the wire for status.
     */
    @java.lang.Override public int getStatusValue() {
      return status_;
    }
    /**
     * <pre>
     * status defines the status of the checkpoint
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.CheckpointStatus status = 2 [json_name = "status"];</code>
     * @return The status.
     */
    @java.lang.Override public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus getStatus() {
      com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus result = com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus.forNumber(status_);
      return result == null ? com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus.UNRECOGNIZED : result;
    }

    public static final int BLS_AGGR_PK_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString blsAggrPk_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * bls_aggr_pk defines the aggregated BLS public key
     * </pre>
     *
     * <code>bytes bls_aggr_pk = 3 [json_name = "blsAggrPk", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.PublicKey"];</code>
     * @return The blsAggrPk.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBlsAggrPk() {
      return blsAggrPk_;
    }

    public static final int POWER_SUM_FIELD_NUMBER = 4;
    private long powerSum_ = 0L;
    /**
     * <pre>
     * power_sum defines the accumulated voting power for the checkpoint
     * </pre>
     *
     * <code>uint64 power_sum = 4 [json_name = "powerSum"];</code>
     * @return The powerSum.
     */
    @java.lang.Override
    public long getPowerSum() {
      return powerSum_;
    }

    public static final int LIFECYCLE_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private java.util.List<com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate> lifecycle_;
    /**
     * <pre>
     * lifecycle defines the lifecycle of this checkpoint, i.e., each state
     * transition and the time (in both timestamp and block height) of this
     * transition.
     * </pre>
     *
     * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
     */
    @java.lang.Override
    public java.util.List<com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate> getLifecycleList() {
      return lifecycle_;
    }
    /**
     * <pre>
     * lifecycle defines the lifecycle of this checkpoint, i.e., each state
     * transition and the time (in both timestamp and block height) of this
     * transition.
     * </pre>
     *
     * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdateOrBuilder> 
        getLifecycleOrBuilderList() {
      return lifecycle_;
    }
    /**
     * <pre>
     * lifecycle defines the lifecycle of this checkpoint, i.e., each state
     * transition and the time (in both timestamp and block height) of this
     * transition.
     * </pre>
     *
     * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
     */
    @java.lang.Override
    public int getLifecycleCount() {
      return lifecycle_.size();
    }
    /**
     * <pre>
     * lifecycle defines the lifecycle of this checkpoint, i.e., each state
     * transition and the time (in both timestamp and block height) of this
     * transition.
     * </pre>
     *
     * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
     */
    @java.lang.Override
    public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate getLifecycle(int index) {
      return lifecycle_.get(index);
    }
    /**
     * <pre>
     * lifecycle defines the lifecycle of this checkpoint, i.e., each state
     * transition and the time (in both timestamp and block height) of this
     * transition.
     * </pre>
     *
     * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
     */
    @java.lang.Override
    public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdateOrBuilder getLifecycleOrBuilder(
        int index) {
      return lifecycle_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (ckpt_ != null) {
        output.writeMessage(1, getCkpt());
      }
      if (status_ != com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus.CKPT_STATUS_ACCUMULATING.getNumber()) {
        output.writeEnum(2, status_);
      }
      if (!blsAggrPk_.isEmpty()) {
        output.writeBytes(3, blsAggrPk_);
      }
      if (powerSum_ != 0L) {
        output.writeUInt64(4, powerSum_);
      }
      for (int i = 0; i < lifecycle_.size(); i++) {
        output.writeMessage(5, lifecycle_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (ckpt_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getCkpt());
      }
      if (status_ != com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus.CKPT_STATUS_ACCUMULATING.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, status_);
      }
      if (!blsAggrPk_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, blsAggrPk_);
      }
      if (powerSum_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(4, powerSum_);
      }
      for (int i = 0; i < lifecycle_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, lifecycle_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta)) {
        return super.equals(obj);
      }
      com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta other = (com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta) obj;

      if (hasCkpt() != other.hasCkpt()) return false;
      if (hasCkpt()) {
        if (!getCkpt()
            .equals(other.getCkpt())) return false;
      }
      if (status_ != other.status_) return false;
      if (!getBlsAggrPk()
          .equals(other.getBlsAggrPk())) return false;
      if (getPowerSum()
          != other.getPowerSum()) return false;
      if (!getLifecycleList()
          .equals(other.getLifecycleList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCkpt()) {
        hash = (37 * hash) + CKPT_FIELD_NUMBER;
        hash = (53 * hash) + getCkpt().hashCode();
      }
      hash = (37 * hash) + STATUS_FIELD_NUMBER;
      hash = (53 * hash) + status_;
      hash = (37 * hash) + BLS_AGGR_PK_FIELD_NUMBER;
      hash = (53 * hash) + getBlsAggrPk().hashCode();
      hash = (37 * hash) + POWER_SUM_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getPowerSum());
      if (getLifecycleCount() > 0) {
        hash = (37 * hash) + LIFECYCLE_FIELD_NUMBER;
        hash = (53 * hash) + getLifecycleList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * RawCheckpointWithMeta wraps the raw checkpoint with metadata.
     * </pre>
     *
     * Protobuf type {@code babylon.checkpointing.v1.RawCheckpointWithMeta}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.checkpointing.v1.RawCheckpointWithMeta)
        com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMetaOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_RawCheckpointWithMeta_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_RawCheckpointWithMeta_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.class, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.Builder.class);
      }

      // Construct using com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        ckpt_ = null;
        if (ckptBuilder_ != null) {
          ckptBuilder_.dispose();
          ckptBuilder_ = null;
        }
        status_ = 0;
        blsAggrPk_ = com.google.protobuf.ByteString.EMPTY;
        powerSum_ = 0L;
        if (lifecycleBuilder_ == null) {
          lifecycle_ = java.util.Collections.emptyList();
        } else {
          lifecycle_ = null;
          lifecycleBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_RawCheckpointWithMeta_descriptor;
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta getDefaultInstanceForType() {
        return com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta build() {
        com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta buildPartial() {
        com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta result = new com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta result) {
        if (lifecycleBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0)) {
            lifecycle_ = java.util.Collections.unmodifiableList(lifecycle_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.lifecycle_ = lifecycle_;
        } else {
          result.lifecycle_ = lifecycleBuilder_.build();
        }
      }

      private void buildPartial0(com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.ckpt_ = ckptBuilder_ == null
              ? ckpt_
              : ckptBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.status_ = status_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.blsAggrPk_ = blsAggrPk_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.powerSum_ = powerSum_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta) {
          return mergeFrom((com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta other) {
        if (other == com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.getDefaultInstance()) return this;
        if (other.hasCkpt()) {
          mergeCkpt(other.getCkpt());
        }
        if (other.status_ != 0) {
          setStatusValue(other.getStatusValue());
        }
        if (other.getBlsAggrPk() != com.google.protobuf.ByteString.EMPTY) {
          setBlsAggrPk(other.getBlsAggrPk());
        }
        if (other.getPowerSum() != 0L) {
          setPowerSum(other.getPowerSum());
        }
        if (lifecycleBuilder_ == null) {
          if (!other.lifecycle_.isEmpty()) {
            if (lifecycle_.isEmpty()) {
              lifecycle_ = other.lifecycle_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureLifecycleIsMutable();
              lifecycle_.addAll(other.lifecycle_);
            }
            onChanged();
          }
        } else {
          if (!other.lifecycle_.isEmpty()) {
            if (lifecycleBuilder_.isEmpty()) {
              lifecycleBuilder_.dispose();
              lifecycleBuilder_ = null;
              lifecycle_ = other.lifecycle_;
              bitField0_ = (bitField0_ & ~0x00000010);
              lifecycleBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getLifecycleFieldBuilder() : null;
            } else {
              lifecycleBuilder_.addAllMessages(other.lifecycle_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getCkptFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                status_ = input.readEnum();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                blsAggrPk_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 32: {
                powerSum_ = input.readUInt64();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 42: {
                com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate m =
                    input.readMessage(
                        com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.parser(),
                        extensionRegistry);
                if (lifecycleBuilder_ == null) {
                  ensureLifecycleIsMutable();
                  lifecycle_.add(m);
                } else {
                  lifecycleBuilder_.addMessage(m);
                }
                break;
              } // case 42
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint ckpt_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.Builder, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointOrBuilder> ckptBuilder_;
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
       * @return Whether the ckpt field is set.
       */
      public boolean hasCkpt() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
       * @return The ckpt.
       */
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint getCkpt() {
        if (ckptBuilder_ == null) {
          return ckpt_ == null ? com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.getDefaultInstance() : ckpt_;
        } else {
          return ckptBuilder_.getMessage();
        }
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
       */
      public Builder setCkpt(com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint value) {
        if (ckptBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ckpt_ = value;
        } else {
          ckptBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
       */
      public Builder setCkpt(
          com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.Builder builderForValue) {
        if (ckptBuilder_ == null) {
          ckpt_ = builderForValue.build();
        } else {
          ckptBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
       */
      public Builder mergeCkpt(com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint value) {
        if (ckptBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            ckpt_ != null &&
            ckpt_ != com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.getDefaultInstance()) {
            getCkptBuilder().mergeFrom(value);
          } else {
            ckpt_ = value;
          }
        } else {
          ckptBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
       */
      public Builder clearCkpt() {
        bitField0_ = (bitField0_ & ~0x00000001);
        ckpt_ = null;
        if (ckptBuilder_ != null) {
          ckptBuilder_.dispose();
          ckptBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
       */
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.Builder getCkptBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getCkptFieldBuilder().getBuilder();
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
       */
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointOrBuilder getCkptOrBuilder() {
        if (ckptBuilder_ != null) {
          return ckptBuilder_.getMessageOrBuilder();
        } else {
          return ckpt_ == null ?
              com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.getDefaultInstance() : ckpt_;
        }
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpoint ckpt = 1 [json_name = "ckpt"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.Builder, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointOrBuilder> 
          getCkptFieldBuilder() {
        if (ckptBuilder_ == null) {
          ckptBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpoint.Builder, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointOrBuilder>(
                  getCkpt(),
                  getParentForChildren(),
                  isClean());
          ckpt_ = null;
        }
        return ckptBuilder_;
      }

      private int status_ = 0;
      /**
       * <pre>
       * status defines the status of the checkpoint
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.CheckpointStatus status = 2 [json_name = "status"];</code>
       * @return The enum numeric value on the wire for status.
       */
      @java.lang.Override public int getStatusValue() {
        return status_;
      }
      /**
       * <pre>
       * status defines the status of the checkpoint
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.CheckpointStatus status = 2 [json_name = "status"];</code>
       * @param value The enum numeric value on the wire for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusValue(int value) {
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * status defines the status of the checkpoint
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.CheckpointStatus status = 2 [json_name = "status"];</code>
       * @return The status.
       */
      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus getStatus() {
        com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus result = com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus.forNumber(status_);
        return result == null ? com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * status defines the status of the checkpoint
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.CheckpointStatus status = 2 [json_name = "status"];</code>
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        status_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * status defines the status of the checkpoint
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.CheckpointStatus status = 2 [json_name = "status"];</code>
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000002);
        status_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString blsAggrPk_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * bls_aggr_pk defines the aggregated BLS public key
       * </pre>
       *
       * <code>bytes bls_aggr_pk = 3 [json_name = "blsAggrPk", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.PublicKey"];</code>
       * @return The blsAggrPk.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBlsAggrPk() {
        return blsAggrPk_;
      }
      /**
       * <pre>
       * bls_aggr_pk defines the aggregated BLS public key
       * </pre>
       *
       * <code>bytes bls_aggr_pk = 3 [json_name = "blsAggrPk", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.PublicKey"];</code>
       * @param value The blsAggrPk to set.
       * @return This builder for chaining.
       */
      public Builder setBlsAggrPk(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        blsAggrPk_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * bls_aggr_pk defines the aggregated BLS public key
       * </pre>
       *
       * <code>bytes bls_aggr_pk = 3 [json_name = "blsAggrPk", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.PublicKey"];</code>
       * @return This builder for chaining.
       */
      public Builder clearBlsAggrPk() {
        bitField0_ = (bitField0_ & ~0x00000004);
        blsAggrPk_ = getDefaultInstance().getBlsAggrPk();
        onChanged();
        return this;
      }

      private long powerSum_ ;
      /**
       * <pre>
       * power_sum defines the accumulated voting power for the checkpoint
       * </pre>
       *
       * <code>uint64 power_sum = 4 [json_name = "powerSum"];</code>
       * @return The powerSum.
       */
      @java.lang.Override
      public long getPowerSum() {
        return powerSum_;
      }
      /**
       * <pre>
       * power_sum defines the accumulated voting power for the checkpoint
       * </pre>
       *
       * <code>uint64 power_sum = 4 [json_name = "powerSum"];</code>
       * @param value The powerSum to set.
       * @return This builder for chaining.
       */
      public Builder setPowerSum(long value) {

        powerSum_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * power_sum defines the accumulated voting power for the checkpoint
       * </pre>
       *
       * <code>uint64 power_sum = 4 [json_name = "powerSum"];</code>
       * @return This builder for chaining.
       */
      public Builder clearPowerSum() {
        bitField0_ = (bitField0_ & ~0x00000008);
        powerSum_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate> lifecycle_ =
        java.util.Collections.emptyList();
      private void ensureLifecycleIsMutable() {
        if (!((bitField0_ & 0x00000010) != 0)) {
          lifecycle_ = new java.util.ArrayList<com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate>(lifecycle_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate, com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.Builder, com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdateOrBuilder> lifecycleBuilder_;

      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public java.util.List<com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate> getLifecycleList() {
        if (lifecycleBuilder_ == null) {
          return java.util.Collections.unmodifiableList(lifecycle_);
        } else {
          return lifecycleBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public int getLifecycleCount() {
        if (lifecycleBuilder_ == null) {
          return lifecycle_.size();
        } else {
          return lifecycleBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate getLifecycle(int index) {
        if (lifecycleBuilder_ == null) {
          return lifecycle_.get(index);
        } else {
          return lifecycleBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public Builder setLifecycle(
          int index, com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate value) {
        if (lifecycleBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLifecycleIsMutable();
          lifecycle_.set(index, value);
          onChanged();
        } else {
          lifecycleBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public Builder setLifecycle(
          int index, com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.Builder builderForValue) {
        if (lifecycleBuilder_ == null) {
          ensureLifecycleIsMutable();
          lifecycle_.set(index, builderForValue.build());
          onChanged();
        } else {
          lifecycleBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public Builder addLifecycle(com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate value) {
        if (lifecycleBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLifecycleIsMutable();
          lifecycle_.add(value);
          onChanged();
        } else {
          lifecycleBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public Builder addLifecycle(
          int index, com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate value) {
        if (lifecycleBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLifecycleIsMutable();
          lifecycle_.add(index, value);
          onChanged();
        } else {
          lifecycleBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public Builder addLifecycle(
          com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.Builder builderForValue) {
        if (lifecycleBuilder_ == null) {
          ensureLifecycleIsMutable();
          lifecycle_.add(builderForValue.build());
          onChanged();
        } else {
          lifecycleBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public Builder addLifecycle(
          int index, com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.Builder builderForValue) {
        if (lifecycleBuilder_ == null) {
          ensureLifecycleIsMutable();
          lifecycle_.add(index, builderForValue.build());
          onChanged();
        } else {
          lifecycleBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public Builder addAllLifecycle(
          java.lang.Iterable<? extends com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate> values) {
        if (lifecycleBuilder_ == null) {
          ensureLifecycleIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, lifecycle_);
          onChanged();
        } else {
          lifecycleBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public Builder clearLifecycle() {
        if (lifecycleBuilder_ == null) {
          lifecycle_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          lifecycleBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public Builder removeLifecycle(int index) {
        if (lifecycleBuilder_ == null) {
          ensureLifecycleIsMutable();
          lifecycle_.remove(index);
          onChanged();
        } else {
          lifecycleBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.Builder getLifecycleBuilder(
          int index) {
        return getLifecycleFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdateOrBuilder getLifecycleOrBuilder(
          int index) {
        if (lifecycleBuilder_ == null) {
          return lifecycle_.get(index);  } else {
          return lifecycleBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public java.util.List<? extends com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdateOrBuilder> 
           getLifecycleOrBuilderList() {
        if (lifecycleBuilder_ != null) {
          return lifecycleBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(lifecycle_);
        }
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.Builder addLifecycleBuilder() {
        return getLifecycleFieldBuilder().addBuilder(
            com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.getDefaultInstance());
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.Builder addLifecycleBuilder(
          int index) {
        return getLifecycleFieldBuilder().addBuilder(
            index, com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.getDefaultInstance());
      }
      /**
       * <pre>
       * lifecycle defines the lifecycle of this checkpoint, i.e., each state
       * transition and the time (in both timestamp and block height) of this
       * transition.
       * </pre>
       *
       * <code>repeated .babylon.checkpointing.v1.CheckpointStateUpdate lifecycle = 5 [json_name = "lifecycle"];</code>
       */
      public java.util.List<com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.Builder> 
           getLifecycleBuilderList() {
        return getLifecycleFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate, com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.Builder, com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdateOrBuilder> 
          getLifecycleFieldBuilder() {
        if (lifecycleBuilder_ == null) {
          lifecycleBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate, com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.Builder, com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdateOrBuilder>(
                  lifecycle_,
                  ((bitField0_ & 0x00000010) != 0),
                  getParentForChildren(),
                  isClean());
          lifecycle_ = null;
        }
        return lifecycleBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.checkpointing.v1.RawCheckpointWithMeta)
    }

    // @@protoc_insertion_point(class_scope:babylon.checkpointing.v1.RawCheckpointWithMeta)
    private static final com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta();
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RawCheckpointWithMeta>
        PARSER = new com.google.protobuf.AbstractParser<RawCheckpointWithMeta>() {
      @java.lang.Override
      public RawCheckpointWithMeta parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<RawCheckpointWithMeta> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RawCheckpointWithMeta> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MsgInjectedCheckpointOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.checkpointing.v1.MsgInjectedCheckpoint)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
     * @return Whether the ckpt field is set.
     */
    boolean hasCkpt();
    /**
     * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
     * @return The ckpt.
     */
    com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta getCkpt();
    /**
     * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
     */
    com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMetaOrBuilder getCkptOrBuilder();

    /**
     * <pre>
     * extended_commit_info is the commit info including the vote extensions
     * from the previous proposal
     * </pre>
     *
     * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
     * @return Whether the extendedCommitInfo field is set.
     */
    boolean hasExtendedCommitInfo();
    /**
     * <pre>
     * extended_commit_info is the commit info including the vote extensions
     * from the previous proposal
     * </pre>
     *
     * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
     * @return The extendedCommitInfo.
     */
    com.tendermint.abci.TypesProto.ExtendedCommitInfo getExtendedCommitInfo();
    /**
     * <pre>
     * extended_commit_info is the commit info including the vote extensions
     * from the previous proposal
     * </pre>
     *
     * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
     */
    com.tendermint.abci.TypesProto.ExtendedCommitInfoOrBuilder getExtendedCommitInfoOrBuilder();
  }
  /**
   * <pre>
   * MsgInjectedCheckpoint wraps the checkpoint and the extended votes
   * Note: this is a special message type that is only for internal ABCI++ usage
   * for inserting checkpoint into the block
   * </pre>
   *
   * Protobuf type {@code babylon.checkpointing.v1.MsgInjectedCheckpoint}
   */
  public static final class MsgInjectedCheckpoint extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.checkpointing.v1.MsgInjectedCheckpoint)
      MsgInjectedCheckpointOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MsgInjectedCheckpoint.newBuilder() to construct.
    private MsgInjectedCheckpoint(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MsgInjectedCheckpoint() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MsgInjectedCheckpoint();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_MsgInjectedCheckpoint_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_MsgInjectedCheckpoint_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint.class, com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint.Builder.class);
    }

    public static final int CKPT_FIELD_NUMBER = 1;
    private com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta ckpt_;
    /**
     * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
     * @return Whether the ckpt field is set.
     */
    @java.lang.Override
    public boolean hasCkpt() {
      return ckpt_ != null;
    }
    /**
     * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
     * @return The ckpt.
     */
    @java.lang.Override
    public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta getCkpt() {
      return ckpt_ == null ? com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.getDefaultInstance() : ckpt_;
    }
    /**
     * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
     */
    @java.lang.Override
    public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMetaOrBuilder getCkptOrBuilder() {
      return ckpt_ == null ? com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.getDefaultInstance() : ckpt_;
    }

    public static final int EXTENDED_COMMIT_INFO_FIELD_NUMBER = 2;
    private com.tendermint.abci.TypesProto.ExtendedCommitInfo extendedCommitInfo_;
    /**
     * <pre>
     * extended_commit_info is the commit info including the vote extensions
     * from the previous proposal
     * </pre>
     *
     * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
     * @return Whether the extendedCommitInfo field is set.
     */
    @java.lang.Override
    public boolean hasExtendedCommitInfo() {
      return extendedCommitInfo_ != null;
    }
    /**
     * <pre>
     * extended_commit_info is the commit info including the vote extensions
     * from the previous proposal
     * </pre>
     *
     * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
     * @return The extendedCommitInfo.
     */
    @java.lang.Override
    public com.tendermint.abci.TypesProto.ExtendedCommitInfo getExtendedCommitInfo() {
      return extendedCommitInfo_ == null ? com.tendermint.abci.TypesProto.ExtendedCommitInfo.getDefaultInstance() : extendedCommitInfo_;
    }
    /**
     * <pre>
     * extended_commit_info is the commit info including the vote extensions
     * from the previous proposal
     * </pre>
     *
     * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
     */
    @java.lang.Override
    public com.tendermint.abci.TypesProto.ExtendedCommitInfoOrBuilder getExtendedCommitInfoOrBuilder() {
      return extendedCommitInfo_ == null ? com.tendermint.abci.TypesProto.ExtendedCommitInfo.getDefaultInstance() : extendedCommitInfo_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (ckpt_ != null) {
        output.writeMessage(1, getCkpt());
      }
      if (extendedCommitInfo_ != null) {
        output.writeMessage(2, getExtendedCommitInfo());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (ckpt_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getCkpt());
      }
      if (extendedCommitInfo_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getExtendedCommitInfo());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint)) {
        return super.equals(obj);
      }
      com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint other = (com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint) obj;

      if (hasCkpt() != other.hasCkpt()) return false;
      if (hasCkpt()) {
        if (!getCkpt()
            .equals(other.getCkpt())) return false;
      }
      if (hasExtendedCommitInfo() != other.hasExtendedCommitInfo()) return false;
      if (hasExtendedCommitInfo()) {
        if (!getExtendedCommitInfo()
            .equals(other.getExtendedCommitInfo())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCkpt()) {
        hash = (37 * hash) + CKPT_FIELD_NUMBER;
        hash = (53 * hash) + getCkpt().hashCode();
      }
      if (hasExtendedCommitInfo()) {
        hash = (37 * hash) + EXTENDED_COMMIT_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getExtendedCommitInfo().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MsgInjectedCheckpoint wraps the checkpoint and the extended votes
     * Note: this is a special message type that is only for internal ABCI++ usage
     * for inserting checkpoint into the block
     * </pre>
     *
     * Protobuf type {@code babylon.checkpointing.v1.MsgInjectedCheckpoint}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.checkpointing.v1.MsgInjectedCheckpoint)
        com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpointOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_MsgInjectedCheckpoint_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_MsgInjectedCheckpoint_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint.class, com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint.Builder.class);
      }

      // Construct using com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        ckpt_ = null;
        if (ckptBuilder_ != null) {
          ckptBuilder_.dispose();
          ckptBuilder_ = null;
        }
        extendedCommitInfo_ = null;
        if (extendedCommitInfoBuilder_ != null) {
          extendedCommitInfoBuilder_.dispose();
          extendedCommitInfoBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_MsgInjectedCheckpoint_descriptor;
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint getDefaultInstanceForType() {
        return com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint build() {
        com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint buildPartial() {
        com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint result = new com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.ckpt_ = ckptBuilder_ == null
              ? ckpt_
              : ckptBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.extendedCommitInfo_ = extendedCommitInfoBuilder_ == null
              ? extendedCommitInfo_
              : extendedCommitInfoBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint) {
          return mergeFrom((com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint other) {
        if (other == com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint.getDefaultInstance()) return this;
        if (other.hasCkpt()) {
          mergeCkpt(other.getCkpt());
        }
        if (other.hasExtendedCommitInfo()) {
          mergeExtendedCommitInfo(other.getExtendedCommitInfo());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getCkptFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getExtendedCommitInfoFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta ckpt_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.Builder, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMetaOrBuilder> ckptBuilder_;
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
       * @return Whether the ckpt field is set.
       */
      public boolean hasCkpt() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
       * @return The ckpt.
       */
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta getCkpt() {
        if (ckptBuilder_ == null) {
          return ckpt_ == null ? com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.getDefaultInstance() : ckpt_;
        } else {
          return ckptBuilder_.getMessage();
        }
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
       */
      public Builder setCkpt(com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta value) {
        if (ckptBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ckpt_ = value;
        } else {
          ckptBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
       */
      public Builder setCkpt(
          com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.Builder builderForValue) {
        if (ckptBuilder_ == null) {
          ckpt_ = builderForValue.build();
        } else {
          ckptBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
       */
      public Builder mergeCkpt(com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta value) {
        if (ckptBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            ckpt_ != null &&
            ckpt_ != com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.getDefaultInstance()) {
            getCkptBuilder().mergeFrom(value);
          } else {
            ckpt_ = value;
          }
        } else {
          ckptBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
       */
      public Builder clearCkpt() {
        bitField0_ = (bitField0_ & ~0x00000001);
        ckpt_ = null;
        if (ckptBuilder_ != null) {
          ckptBuilder_.dispose();
          ckptBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
       */
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.Builder getCkptBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getCkptFieldBuilder().getBuilder();
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
       */
      public com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMetaOrBuilder getCkptOrBuilder() {
        if (ckptBuilder_ != null) {
          return ckptBuilder_.getMessageOrBuilder();
        } else {
          return ckpt_ == null ?
              com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.getDefaultInstance() : ckpt_;
        }
      }
      /**
       * <code>.babylon.checkpointing.v1.RawCheckpointWithMeta ckpt = 1 [json_name = "ckpt"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.Builder, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMetaOrBuilder> 
          getCkptFieldBuilder() {
        if (ckptBuilder_ == null) {
          ckptBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMeta.Builder, com.babylon.checkpointing.v1.CheckpointProto.RawCheckpointWithMetaOrBuilder>(
                  getCkpt(),
                  getParentForChildren(),
                  isClean());
          ckpt_ = null;
        }
        return ckptBuilder_;
      }

      private com.tendermint.abci.TypesProto.ExtendedCommitInfo extendedCommitInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.tendermint.abci.TypesProto.ExtendedCommitInfo, com.tendermint.abci.TypesProto.ExtendedCommitInfo.Builder, com.tendermint.abci.TypesProto.ExtendedCommitInfoOrBuilder> extendedCommitInfoBuilder_;
      /**
       * <pre>
       * extended_commit_info is the commit info including the vote extensions
       * from the previous proposal
       * </pre>
       *
       * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
       * @return Whether the extendedCommitInfo field is set.
       */
      public boolean hasExtendedCommitInfo() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * extended_commit_info is the commit info including the vote extensions
       * from the previous proposal
       * </pre>
       *
       * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
       * @return The extendedCommitInfo.
       */
      public com.tendermint.abci.TypesProto.ExtendedCommitInfo getExtendedCommitInfo() {
        if (extendedCommitInfoBuilder_ == null) {
          return extendedCommitInfo_ == null ? com.tendermint.abci.TypesProto.ExtendedCommitInfo.getDefaultInstance() : extendedCommitInfo_;
        } else {
          return extendedCommitInfoBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * extended_commit_info is the commit info including the vote extensions
       * from the previous proposal
       * </pre>
       *
       * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
       */
      public Builder setExtendedCommitInfo(com.tendermint.abci.TypesProto.ExtendedCommitInfo value) {
        if (extendedCommitInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          extendedCommitInfo_ = value;
        } else {
          extendedCommitInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * extended_commit_info is the commit info including the vote extensions
       * from the previous proposal
       * </pre>
       *
       * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
       */
      public Builder setExtendedCommitInfo(
          com.tendermint.abci.TypesProto.ExtendedCommitInfo.Builder builderForValue) {
        if (extendedCommitInfoBuilder_ == null) {
          extendedCommitInfo_ = builderForValue.build();
        } else {
          extendedCommitInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * extended_commit_info is the commit info including the vote extensions
       * from the previous proposal
       * </pre>
       *
       * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
       */
      public Builder mergeExtendedCommitInfo(com.tendermint.abci.TypesProto.ExtendedCommitInfo value) {
        if (extendedCommitInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            extendedCommitInfo_ != null &&
            extendedCommitInfo_ != com.tendermint.abci.TypesProto.ExtendedCommitInfo.getDefaultInstance()) {
            getExtendedCommitInfoBuilder().mergeFrom(value);
          } else {
            extendedCommitInfo_ = value;
          }
        } else {
          extendedCommitInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * extended_commit_info is the commit info including the vote extensions
       * from the previous proposal
       * </pre>
       *
       * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
       */
      public Builder clearExtendedCommitInfo() {
        bitField0_ = (bitField0_ & ~0x00000002);
        extendedCommitInfo_ = null;
        if (extendedCommitInfoBuilder_ != null) {
          extendedCommitInfoBuilder_.dispose();
          extendedCommitInfoBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * extended_commit_info is the commit info including the vote extensions
       * from the previous proposal
       * </pre>
       *
       * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
       */
      public com.tendermint.abci.TypesProto.ExtendedCommitInfo.Builder getExtendedCommitInfoBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getExtendedCommitInfoFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * extended_commit_info is the commit info including the vote extensions
       * from the previous proposal
       * </pre>
       *
       * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
       */
      public com.tendermint.abci.TypesProto.ExtendedCommitInfoOrBuilder getExtendedCommitInfoOrBuilder() {
        if (extendedCommitInfoBuilder_ != null) {
          return extendedCommitInfoBuilder_.getMessageOrBuilder();
        } else {
          return extendedCommitInfo_ == null ?
              com.tendermint.abci.TypesProto.ExtendedCommitInfo.getDefaultInstance() : extendedCommitInfo_;
        }
      }
      /**
       * <pre>
       * extended_commit_info is the commit info including the vote extensions
       * from the previous proposal
       * </pre>
       *
       * <code>.tendermint.abci.ExtendedCommitInfo extended_commit_info = 2 [json_name = "extendedCommitInfo"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.tendermint.abci.TypesProto.ExtendedCommitInfo, com.tendermint.abci.TypesProto.ExtendedCommitInfo.Builder, com.tendermint.abci.TypesProto.ExtendedCommitInfoOrBuilder> 
          getExtendedCommitInfoFieldBuilder() {
        if (extendedCommitInfoBuilder_ == null) {
          extendedCommitInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.tendermint.abci.TypesProto.ExtendedCommitInfo, com.tendermint.abci.TypesProto.ExtendedCommitInfo.Builder, com.tendermint.abci.TypesProto.ExtendedCommitInfoOrBuilder>(
                  getExtendedCommitInfo(),
                  getParentForChildren(),
                  isClean());
          extendedCommitInfo_ = null;
        }
        return extendedCommitInfoBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.checkpointing.v1.MsgInjectedCheckpoint)
    }

    // @@protoc_insertion_point(class_scope:babylon.checkpointing.v1.MsgInjectedCheckpoint)
    private static final com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint();
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MsgInjectedCheckpoint>
        PARSER = new com.google.protobuf.AbstractParser<MsgInjectedCheckpoint>() {
      @java.lang.Override
      public MsgInjectedCheckpoint parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MsgInjectedCheckpoint> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MsgInjectedCheckpoint> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.checkpointing.v1.CheckpointProto.MsgInjectedCheckpoint getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CheckpointStateUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.checkpointing.v1.CheckpointStateUpdate)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * state defines the event of a state transition towards this state
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.CheckpointStatus state = 1 [json_name = "state"];</code>
     * @return The enum numeric value on the wire for state.
     */
    int getStateValue();
    /**
     * <pre>
     * state defines the event of a state transition towards this state
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.CheckpointStatus state = 1 [json_name = "state"];</code>
     * @return The state.
     */
    com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus getState();

    /**
     * <pre>
     * block_height is the height of the Babylon block that triggers the state
     * update
     * </pre>
     *
     * <code>uint64 block_height = 2 [json_name = "blockHeight"];</code>
     * @return The blockHeight.
     */
    long getBlockHeight();

    /**
     * <pre>
     * block_time is the timestamp in the Babylon block that triggers the state
     * update
     * </pre>
     *
     * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
     * @return Whether the blockTime field is set.
     */
    boolean hasBlockTime();
    /**
     * <pre>
     * block_time is the timestamp in the Babylon block that triggers the state
     * update
     * </pre>
     *
     * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
     * @return The blockTime.
     */
    com.google.protobuf.Timestamp getBlockTime();
    /**
     * <pre>
     * block_time is the timestamp in the Babylon block that triggers the state
     * update
     * </pre>
     *
     * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
     */
    com.google.protobuf.TimestampOrBuilder getBlockTimeOrBuilder();
  }
  /**
   * <pre>
   * CheckpointStateUpdate defines a state transition on the checkpoint.
   * </pre>
   *
   * Protobuf type {@code babylon.checkpointing.v1.CheckpointStateUpdate}
   */
  public static final class CheckpointStateUpdate extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.checkpointing.v1.CheckpointStateUpdate)
      CheckpointStateUpdateOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CheckpointStateUpdate.newBuilder() to construct.
    private CheckpointStateUpdate(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CheckpointStateUpdate() {
      state_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new CheckpointStateUpdate();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_CheckpointStateUpdate_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_CheckpointStateUpdate_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.class, com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.Builder.class);
    }

    public static final int STATE_FIELD_NUMBER = 1;
    private int state_ = 0;
    /**
     * <pre>
     * state defines the event of a state transition towards this state
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.CheckpointStatus state = 1 [json_name = "state"];</code>
     * @return The enum numeric value on the wire for state.
     */
    @java.lang.Override public int getStateValue() {
      return state_;
    }
    /**
     * <pre>
     * state defines the event of a state transition towards this state
     * </pre>
     *
     * <code>.babylon.checkpointing.v1.CheckpointStatus state = 1 [json_name = "state"];</code>
     * @return The state.
     */
    @java.lang.Override public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus getState() {
      com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus result = com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus.forNumber(state_);
      return result == null ? com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus.UNRECOGNIZED : result;
    }

    public static final int BLOCK_HEIGHT_FIELD_NUMBER = 2;
    private long blockHeight_ = 0L;
    /**
     * <pre>
     * block_height is the height of the Babylon block that triggers the state
     * update
     * </pre>
     *
     * <code>uint64 block_height = 2 [json_name = "blockHeight"];</code>
     * @return The blockHeight.
     */
    @java.lang.Override
    public long getBlockHeight() {
      return blockHeight_;
    }

    public static final int BLOCK_TIME_FIELD_NUMBER = 3;
    private com.google.protobuf.Timestamp blockTime_;
    /**
     * <pre>
     * block_time is the timestamp in the Babylon block that triggers the state
     * update
     * </pre>
     *
     * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
     * @return Whether the blockTime field is set.
     */
    @java.lang.Override
    public boolean hasBlockTime() {
      return blockTime_ != null;
    }
    /**
     * <pre>
     * block_time is the timestamp in the Babylon block that triggers the state
     * update
     * </pre>
     *
     * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
     * @return The blockTime.
     */
    @java.lang.Override
    public com.google.protobuf.Timestamp getBlockTime() {
      return blockTime_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : blockTime_;
    }
    /**
     * <pre>
     * block_time is the timestamp in the Babylon block that triggers the state
     * update
     * </pre>
     *
     * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
     */
    @java.lang.Override
    public com.google.protobuf.TimestampOrBuilder getBlockTimeOrBuilder() {
      return blockTime_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : blockTime_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (state_ != com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus.CKPT_STATUS_ACCUMULATING.getNumber()) {
        output.writeEnum(1, state_);
      }
      if (blockHeight_ != 0L) {
        output.writeUInt64(2, blockHeight_);
      }
      if (blockTime_ != null) {
        output.writeMessage(3, getBlockTime());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (state_ != com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus.CKPT_STATUS_ACCUMULATING.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, state_);
      }
      if (blockHeight_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, blockHeight_);
      }
      if (blockTime_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getBlockTime());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate)) {
        return super.equals(obj);
      }
      com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate other = (com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate) obj;

      if (state_ != other.state_) return false;
      if (getBlockHeight()
          != other.getBlockHeight()) return false;
      if (hasBlockTime() != other.hasBlockTime()) return false;
      if (hasBlockTime()) {
        if (!getBlockTime()
            .equals(other.getBlockTime())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + STATE_FIELD_NUMBER;
      hash = (53 * hash) + state_;
      hash = (37 * hash) + BLOCK_HEIGHT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getBlockHeight());
      if (hasBlockTime()) {
        hash = (37 * hash) + BLOCK_TIME_FIELD_NUMBER;
        hash = (53 * hash) + getBlockTime().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CheckpointStateUpdate defines a state transition on the checkpoint.
     * </pre>
     *
     * Protobuf type {@code babylon.checkpointing.v1.CheckpointStateUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.checkpointing.v1.CheckpointStateUpdate)
        com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdateOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_CheckpointStateUpdate_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_CheckpointStateUpdate_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.class, com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.Builder.class);
      }

      // Construct using com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        state_ = 0;
        blockHeight_ = 0L;
        blockTime_ = null;
        if (blockTimeBuilder_ != null) {
          blockTimeBuilder_.dispose();
          blockTimeBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_CheckpointStateUpdate_descriptor;
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate getDefaultInstanceForType() {
        return com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate build() {
        com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate buildPartial() {
        com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate result = new com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.state_ = state_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.blockHeight_ = blockHeight_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.blockTime_ = blockTimeBuilder_ == null
              ? blockTime_
              : blockTimeBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate) {
          return mergeFrom((com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate other) {
        if (other == com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate.getDefaultInstance()) return this;
        if (other.state_ != 0) {
          setStateValue(other.getStateValue());
        }
        if (other.getBlockHeight() != 0L) {
          setBlockHeight(other.getBlockHeight());
        }
        if (other.hasBlockTime()) {
          mergeBlockTime(other.getBlockTime());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                state_ = input.readEnum();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                blockHeight_ = input.readUInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                input.readMessage(
                    getBlockTimeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int state_ = 0;
      /**
       * <pre>
       * state defines the event of a state transition towards this state
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.CheckpointStatus state = 1 [json_name = "state"];</code>
       * @return The enum numeric value on the wire for state.
       */
      @java.lang.Override public int getStateValue() {
        return state_;
      }
      /**
       * <pre>
       * state defines the event of a state transition towards this state
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.CheckpointStatus state = 1 [json_name = "state"];</code>
       * @param value The enum numeric value on the wire for state to set.
       * @return This builder for chaining.
       */
      public Builder setStateValue(int value) {
        state_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * state defines the event of a state transition towards this state
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.CheckpointStatus state = 1 [json_name = "state"];</code>
       * @return The state.
       */
      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus getState() {
        com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus result = com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus.forNumber(state_);
        return result == null ? com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * state defines the event of a state transition towards this state
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.CheckpointStatus state = 1 [json_name = "state"];</code>
       * @param value The state to set.
       * @return This builder for chaining.
       */
      public Builder setState(com.babylon.checkpointing.v1.CheckpointProto.CheckpointStatus value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        state_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * state defines the event of a state transition towards this state
       * </pre>
       *
       * <code>.babylon.checkpointing.v1.CheckpointStatus state = 1 [json_name = "state"];</code>
       * @return This builder for chaining.
       */
      public Builder clearState() {
        bitField0_ = (bitField0_ & ~0x00000001);
        state_ = 0;
        onChanged();
        return this;
      }

      private long blockHeight_ ;
      /**
       * <pre>
       * block_height is the height of the Babylon block that triggers the state
       * update
       * </pre>
       *
       * <code>uint64 block_height = 2 [json_name = "blockHeight"];</code>
       * @return The blockHeight.
       */
      @java.lang.Override
      public long getBlockHeight() {
        return blockHeight_;
      }
      /**
       * <pre>
       * block_height is the height of the Babylon block that triggers the state
       * update
       * </pre>
       *
       * <code>uint64 block_height = 2 [json_name = "blockHeight"];</code>
       * @param value The blockHeight to set.
       * @return This builder for chaining.
       */
      public Builder setBlockHeight(long value) {

        blockHeight_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * block_height is the height of the Babylon block that triggers the state
       * update
       * </pre>
       *
       * <code>uint64 block_height = 2 [json_name = "blockHeight"];</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockHeight() {
        bitField0_ = (bitField0_ & ~0x00000002);
        blockHeight_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.Timestamp blockTime_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder> blockTimeBuilder_;
      /**
       * <pre>
       * block_time is the timestamp in the Babylon block that triggers the state
       * update
       * </pre>
       *
       * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
       * @return Whether the blockTime field is set.
       */
      public boolean hasBlockTime() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * block_time is the timestamp in the Babylon block that triggers the state
       * update
       * </pre>
       *
       * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
       * @return The blockTime.
       */
      public com.google.protobuf.Timestamp getBlockTime() {
        if (blockTimeBuilder_ == null) {
          return blockTime_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : blockTime_;
        } else {
          return blockTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * block_time is the timestamp in the Babylon block that triggers the state
       * update
       * </pre>
       *
       * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
       */
      public Builder setBlockTime(com.google.protobuf.Timestamp value) {
        if (blockTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          blockTime_ = value;
        } else {
          blockTimeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * block_time is the timestamp in the Babylon block that triggers the state
       * update
       * </pre>
       *
       * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
       */
      public Builder setBlockTime(
          com.google.protobuf.Timestamp.Builder builderForValue) {
        if (blockTimeBuilder_ == null) {
          blockTime_ = builderForValue.build();
        } else {
          blockTimeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * block_time is the timestamp in the Babylon block that triggers the state
       * update
       * </pre>
       *
       * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
       */
      public Builder mergeBlockTime(com.google.protobuf.Timestamp value) {
        if (blockTimeBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            blockTime_ != null &&
            blockTime_ != com.google.protobuf.Timestamp.getDefaultInstance()) {
            getBlockTimeBuilder().mergeFrom(value);
          } else {
            blockTime_ = value;
          }
        } else {
          blockTimeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * block_time is the timestamp in the Babylon block that triggers the state
       * update
       * </pre>
       *
       * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
       */
      public Builder clearBlockTime() {
        bitField0_ = (bitField0_ & ~0x00000004);
        blockTime_ = null;
        if (blockTimeBuilder_ != null) {
          blockTimeBuilder_.dispose();
          blockTimeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * block_time is the timestamp in the Babylon block that triggers the state
       * update
       * </pre>
       *
       * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
       */
      public com.google.protobuf.Timestamp.Builder getBlockTimeBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getBlockTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * block_time is the timestamp in the Babylon block that triggers the state
       * update
       * </pre>
       *
       * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
       */
      public com.google.protobuf.TimestampOrBuilder getBlockTimeOrBuilder() {
        if (blockTimeBuilder_ != null) {
          return blockTimeBuilder_.getMessageOrBuilder();
        } else {
          return blockTime_ == null ?
              com.google.protobuf.Timestamp.getDefaultInstance() : blockTime_;
        }
      }
      /**
       * <pre>
       * block_time is the timestamp in the Babylon block that triggers the state
       * update
       * </pre>
       *
       * <code>.google.protobuf.Timestamp block_time = 3 [json_name = "blockTime", (.gogoproto.stdtime) = true];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder> 
          getBlockTimeFieldBuilder() {
        if (blockTimeBuilder_ == null) {
          blockTimeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder>(
                  getBlockTime(),
                  getParentForChildren(),
                  isClean());
          blockTime_ = null;
        }
        return blockTimeBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.checkpointing.v1.CheckpointStateUpdate)
    }

    // @@protoc_insertion_point(class_scope:babylon.checkpointing.v1.CheckpointStateUpdate)
    private static final com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate();
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CheckpointStateUpdate>
        PARSER = new com.google.protobuf.AbstractParser<CheckpointStateUpdate>() {
      @java.lang.Override
      public CheckpointStateUpdate parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CheckpointStateUpdate> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CheckpointStateUpdate> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.checkpointing.v1.CheckpointProto.CheckpointStateUpdate getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface BlsSigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.checkpointing.v1.BlsSig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * epoch_num defines the epoch number that the BLS sig is signed on
     * </pre>
     *
     * <code>uint64 epoch_num = 1 [json_name = "epochNum"];</code>
     * @return The epochNum.
     */
    long getEpochNum();

    /**
     * <pre>
     * block_hash defines the 'BlockID.Hash', which is the hash of
     * the block that individual BLS sigs are signed on
     * </pre>
     *
     * <code>bytes block_hash = 2 [json_name = "blockHash", (.gogoproto.customtype) = "BlockHash"];</code>
     * @return The blockHash.
     */
    com.google.protobuf.ByteString getBlockHash();

    /**
     * <code>bytes bls_sig = 3 [json_name = "blsSig", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.Signature"];</code>
     * @return The blsSig.
     */
    com.google.protobuf.ByteString getBlsSig();

    /**
     * <pre>
     * can't find cosmos_proto.scalar when compiling due to cosmos v0.45.4 does
     * not support scalar string signer_address = 4 [(cosmos_proto.scalar) =
     * "cosmos.AddressString"]
     * the signer_address defines the address of the
     * signer
     * </pre>
     *
     * <code>string signer_address = 4 [json_name = "signerAddress"];</code>
     * @return The signerAddress.
     */
    java.lang.String getSignerAddress();
    /**
     * <pre>
     * can't find cosmos_proto.scalar when compiling due to cosmos v0.45.4 does
     * not support scalar string signer_address = 4 [(cosmos_proto.scalar) =
     * "cosmos.AddressString"]
     * the signer_address defines the address of the
     * signer
     * </pre>
     *
     * <code>string signer_address = 4 [json_name = "signerAddress"];</code>
     * @return The bytes for signerAddress.
     */
    com.google.protobuf.ByteString
        getSignerAddressBytes();

    /**
     * <pre>
     * validator_address defines the validator's consensus address
     * </pre>
     *
     * <code>string validator_address = 5 [json_name = "validatorAddress"];</code>
     * @return The validatorAddress.
     */
    java.lang.String getValidatorAddress();
    /**
     * <pre>
     * validator_address defines the validator's consensus address
     * </pre>
     *
     * <code>string validator_address = 5 [json_name = "validatorAddress"];</code>
     * @return The bytes for validatorAddress.
     */
    com.google.protobuf.ByteString
        getValidatorAddressBytes();
  }
  /**
   * <pre>
   * BlsSig wraps the BLS sig with metadata.
   * </pre>
   *
   * Protobuf type {@code babylon.checkpointing.v1.BlsSig}
   */
  public static final class BlsSig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.checkpointing.v1.BlsSig)
      BlsSigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use BlsSig.newBuilder() to construct.
    private BlsSig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private BlsSig() {
      blockHash_ = com.google.protobuf.ByteString.EMPTY;
      blsSig_ = com.google.protobuf.ByteString.EMPTY;
      signerAddress_ = "";
      validatorAddress_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new BlsSig();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_BlsSig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_BlsSig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.checkpointing.v1.CheckpointProto.BlsSig.class, com.babylon.checkpointing.v1.CheckpointProto.BlsSig.Builder.class);
    }

    public static final int EPOCH_NUM_FIELD_NUMBER = 1;
    private long epochNum_ = 0L;
    /**
     * <pre>
     * epoch_num defines the epoch number that the BLS sig is signed on
     * </pre>
     *
     * <code>uint64 epoch_num = 1 [json_name = "epochNum"];</code>
     * @return The epochNum.
     */
    @java.lang.Override
    public long getEpochNum() {
      return epochNum_;
    }

    public static final int BLOCK_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString blockHash_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * block_hash defines the 'BlockID.Hash', which is the hash of
     * the block that individual BLS sigs are signed on
     * </pre>
     *
     * <code>bytes block_hash = 2 [json_name = "blockHash", (.gogoproto.customtype) = "BlockHash"];</code>
     * @return The blockHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBlockHash() {
      return blockHash_;
    }

    public static final int BLS_SIG_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString blsSig_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <code>bytes bls_sig = 3 [json_name = "blsSig", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.Signature"];</code>
     * @return The blsSig.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBlsSig() {
      return blsSig_;
    }

    public static final int SIGNER_ADDRESS_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object signerAddress_ = "";
    /**
     * <pre>
     * can't find cosmos_proto.scalar when compiling due to cosmos v0.45.4 does
     * not support scalar string signer_address = 4 [(cosmos_proto.scalar) =
     * "cosmos.AddressString"]
     * the signer_address defines the address of the
     * signer
     * </pre>
     *
     * <code>string signer_address = 4 [json_name = "signerAddress"];</code>
     * @return The signerAddress.
     */
    @java.lang.Override
    public java.lang.String getSignerAddress() {
      java.lang.Object ref = signerAddress_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        signerAddress_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * can't find cosmos_proto.scalar when compiling due to cosmos v0.45.4 does
     * not support scalar string signer_address = 4 [(cosmos_proto.scalar) =
     * "cosmos.AddressString"]
     * the signer_address defines the address of the
     * signer
     * </pre>
     *
     * <code>string signer_address = 4 [json_name = "signerAddress"];</code>
     * @return The bytes for signerAddress.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSignerAddressBytes() {
      java.lang.Object ref = signerAddress_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        signerAddress_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VALIDATOR_ADDRESS_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object validatorAddress_ = "";
    /**
     * <pre>
     * validator_address defines the validator's consensus address
     * </pre>
     *
     * <code>string validator_address = 5 [json_name = "validatorAddress"];</code>
     * @return The validatorAddress.
     */
    @java.lang.Override
    public java.lang.String getValidatorAddress() {
      java.lang.Object ref = validatorAddress_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        validatorAddress_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * validator_address defines the validator's consensus address
     * </pre>
     *
     * <code>string validator_address = 5 [json_name = "validatorAddress"];</code>
     * @return The bytes for validatorAddress.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getValidatorAddressBytes() {
      java.lang.Object ref = validatorAddress_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        validatorAddress_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (epochNum_ != 0L) {
        output.writeUInt64(1, epochNum_);
      }
      if (!blockHash_.isEmpty()) {
        output.writeBytes(2, blockHash_);
      }
      if (!blsSig_.isEmpty()) {
        output.writeBytes(3, blsSig_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(signerAddress_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, signerAddress_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(validatorAddress_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, validatorAddress_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (epochNum_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, epochNum_);
      }
      if (!blockHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, blockHash_);
      }
      if (!blsSig_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, blsSig_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(signerAddress_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, signerAddress_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(validatorAddress_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, validatorAddress_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.checkpointing.v1.CheckpointProto.BlsSig)) {
        return super.equals(obj);
      }
      com.babylon.checkpointing.v1.CheckpointProto.BlsSig other = (com.babylon.checkpointing.v1.CheckpointProto.BlsSig) obj;

      if (getEpochNum()
          != other.getEpochNum()) return false;
      if (!getBlockHash()
          .equals(other.getBlockHash())) return false;
      if (!getBlsSig()
          .equals(other.getBlsSig())) return false;
      if (!getSignerAddress()
          .equals(other.getSignerAddress())) return false;
      if (!getValidatorAddress()
          .equals(other.getValidatorAddress())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + EPOCH_NUM_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getEpochNum());
      hash = (37 * hash) + BLOCK_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getBlockHash().hashCode();
      hash = (37 * hash) + BLS_SIG_FIELD_NUMBER;
      hash = (53 * hash) + getBlsSig().hashCode();
      hash = (37 * hash) + SIGNER_ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getSignerAddress().hashCode();
      hash = (37 * hash) + VALIDATOR_ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getValidatorAddress().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.BlsSig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.BlsSig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.BlsSig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.BlsSig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.BlsSig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.BlsSig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.BlsSig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.BlsSig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.BlsSig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.BlsSig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.BlsSig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.checkpointing.v1.CheckpointProto.BlsSig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.checkpointing.v1.CheckpointProto.BlsSig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * BlsSig wraps the BLS sig with metadata.
     * </pre>
     *
     * Protobuf type {@code babylon.checkpointing.v1.BlsSig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.checkpointing.v1.BlsSig)
        com.babylon.checkpointing.v1.CheckpointProto.BlsSigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_BlsSig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_BlsSig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.checkpointing.v1.CheckpointProto.BlsSig.class, com.babylon.checkpointing.v1.CheckpointProto.BlsSig.Builder.class);
      }

      // Construct using com.babylon.checkpointing.v1.CheckpointProto.BlsSig.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        epochNum_ = 0L;
        blockHash_ = com.google.protobuf.ByteString.EMPTY;
        blsSig_ = com.google.protobuf.ByteString.EMPTY;
        signerAddress_ = "";
        validatorAddress_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.checkpointing.v1.CheckpointProto.internal_static_babylon_checkpointing_v1_BlsSig_descriptor;
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.BlsSig getDefaultInstanceForType() {
        return com.babylon.checkpointing.v1.CheckpointProto.BlsSig.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.BlsSig build() {
        com.babylon.checkpointing.v1.CheckpointProto.BlsSig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.checkpointing.v1.CheckpointProto.BlsSig buildPartial() {
        com.babylon.checkpointing.v1.CheckpointProto.BlsSig result = new com.babylon.checkpointing.v1.CheckpointProto.BlsSig(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.babylon.checkpointing.v1.CheckpointProto.BlsSig result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.epochNum_ = epochNum_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.blockHash_ = blockHash_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.blsSig_ = blsSig_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.signerAddress_ = signerAddress_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.validatorAddress_ = validatorAddress_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.checkpointing.v1.CheckpointProto.BlsSig) {
          return mergeFrom((com.babylon.checkpointing.v1.CheckpointProto.BlsSig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.checkpointing.v1.CheckpointProto.BlsSig other) {
        if (other == com.babylon.checkpointing.v1.CheckpointProto.BlsSig.getDefaultInstance()) return this;
        if (other.getEpochNum() != 0L) {
          setEpochNum(other.getEpochNum());
        }
        if (other.getBlockHash() != com.google.protobuf.ByteString.EMPTY) {
          setBlockHash(other.getBlockHash());
        }
        if (other.getBlsSig() != com.google.protobuf.ByteString.EMPTY) {
          setBlsSig(other.getBlsSig());
        }
        if (!other.getSignerAddress().isEmpty()) {
          signerAddress_ = other.signerAddress_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (!other.getValidatorAddress().isEmpty()) {
          validatorAddress_ = other.validatorAddress_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                epochNum_ = input.readUInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                blockHash_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                blsSig_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                signerAddress_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                validatorAddress_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long epochNum_ ;
      /**
       * <pre>
       * epoch_num defines the epoch number that the BLS sig is signed on
       * </pre>
       *
       * <code>uint64 epoch_num = 1 [json_name = "epochNum"];</code>
       * @return The epochNum.
       */
      @java.lang.Override
      public long getEpochNum() {
        return epochNum_;
      }
      /**
       * <pre>
       * epoch_num defines the epoch number that the BLS sig is signed on
       * </pre>
       *
       * <code>uint64 epoch_num = 1 [json_name = "epochNum"];</code>
       * @param value The epochNum to set.
       * @return This builder for chaining.
       */
      public Builder setEpochNum(long value) {

        epochNum_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * epoch_num defines the epoch number that the BLS sig is signed on
       * </pre>
       *
       * <code>uint64 epoch_num = 1 [json_name = "epochNum"];</code>
       * @return This builder for chaining.
       */
      public Builder clearEpochNum() {
        bitField0_ = (bitField0_ & ~0x00000001);
        epochNum_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString blockHash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * block_hash defines the 'BlockID.Hash', which is the hash of
       * the block that individual BLS sigs are signed on
       * </pre>
       *
       * <code>bytes block_hash = 2 [json_name = "blockHash", (.gogoproto.customtype) = "BlockHash"];</code>
       * @return The blockHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBlockHash() {
        return blockHash_;
      }
      /**
       * <pre>
       * block_hash defines the 'BlockID.Hash', which is the hash of
       * the block that individual BLS sigs are signed on
       * </pre>
       *
       * <code>bytes block_hash = 2 [json_name = "blockHash", (.gogoproto.customtype) = "BlockHash"];</code>
       * @param value The blockHash to set.
       * @return This builder for chaining.
       */
      public Builder setBlockHash(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        blockHash_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * block_hash defines the 'BlockID.Hash', which is the hash of
       * the block that individual BLS sigs are signed on
       * </pre>
       *
       * <code>bytes block_hash = 2 [json_name = "blockHash", (.gogoproto.customtype) = "BlockHash"];</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockHash() {
        bitField0_ = (bitField0_ & ~0x00000002);
        blockHash_ = getDefaultInstance().getBlockHash();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString blsSig_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>bytes bls_sig = 3 [json_name = "blsSig", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.Signature"];</code>
       * @return The blsSig.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBlsSig() {
        return blsSig_;
      }
      /**
       * <code>bytes bls_sig = 3 [json_name = "blsSig", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.Signature"];</code>
       * @param value The blsSig to set.
       * @return This builder for chaining.
       */
      public Builder setBlsSig(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        blsSig_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>bytes bls_sig = 3 [json_name = "blsSig", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/crypto/bls12381.Signature"];</code>
       * @return This builder for chaining.
       */
      public Builder clearBlsSig() {
        bitField0_ = (bitField0_ & ~0x00000004);
        blsSig_ = getDefaultInstance().getBlsSig();
        onChanged();
        return this;
      }

      private java.lang.Object signerAddress_ = "";
      /**
       * <pre>
       * can't find cosmos_proto.scalar when compiling due to cosmos v0.45.4 does
       * not support scalar string signer_address = 4 [(cosmos_proto.scalar) =
       * "cosmos.AddressString"]
       * the signer_address defines the address of the
       * signer
       * </pre>
       *
       * <code>string signer_address = 4 [json_name = "signerAddress"];</code>
       * @return The signerAddress.
       */
      public java.lang.String getSignerAddress() {
        java.lang.Object ref = signerAddress_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          signerAddress_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * can't find cosmos_proto.scalar when compiling due to cosmos v0.45.4 does
       * not support scalar string signer_address = 4 [(cosmos_proto.scalar) =
       * "cosmos.AddressString"]
       * the signer_address defines the address of the
       * signer
       * </pre>
       *
       * <code>string signer_address = 4 [json_name = "signerAddress"];</code>
       * @return The bytes for signerAddress.
       */
      public com.google.protobuf.ByteString
          getSignerAddressBytes() {
        java.lang.Object ref = signerAddress_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          signerAddress_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * can't find cosmos_proto.scalar when compiling due to cosmos v0.45.4 does
       * not support scalar string signer_address = 4 [(cosmos_proto.scalar) =
       * "cosmos.AddressString"]
       * the signer_address defines the address of the
       * signer
       * </pre>
       *
       * <code>string signer_address = 4 [json_name = "signerAddress"];</code>
       * @param value The signerAddress to set.
       * @return This builder for chaining.
       */
      public Builder setSignerAddress(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        signerAddress_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * can't find cosmos_proto.scalar when compiling due to cosmos v0.45.4 does
       * not support scalar string signer_address = 4 [(cosmos_proto.scalar) =
       * "cosmos.AddressString"]
       * the signer_address defines the address of the
       * signer
       * </pre>
       *
       * <code>string signer_address = 4 [json_name = "signerAddress"];</code>
       * @return This builder for chaining.
       */
      public Builder clearSignerAddress() {
        signerAddress_ = getDefaultInstance().getSignerAddress();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * can't find cosmos_proto.scalar when compiling due to cosmos v0.45.4 does
       * not support scalar string signer_address = 4 [(cosmos_proto.scalar) =
       * "cosmos.AddressString"]
       * the signer_address defines the address of the
       * signer
       * </pre>
       *
       * <code>string signer_address = 4 [json_name = "signerAddress"];</code>
       * @param value The bytes for signerAddress to set.
       * @return This builder for chaining.
       */
      public Builder setSignerAddressBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        signerAddress_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object validatorAddress_ = "";
      /**
       * <pre>
       * validator_address defines the validator's consensus address
       * </pre>
       *
       * <code>string validator_address = 5 [json_name = "validatorAddress"];</code>
       * @return The validatorAddress.
       */
      public java.lang.String getValidatorAddress() {
        java.lang.Object ref = validatorAddress_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          validatorAddress_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * validator_address defines the validator's consensus address
       * </pre>
       *
       * <code>string validator_address = 5 [json_name = "validatorAddress"];</code>
       * @return The bytes for validatorAddress.
       */
      public com.google.protobuf.ByteString
          getValidatorAddressBytes() {
        java.lang.Object ref = validatorAddress_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          validatorAddress_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * validator_address defines the validator's consensus address
       * </pre>
       *
       * <code>string validator_address = 5 [json_name = "validatorAddress"];</code>
       * @param value The validatorAddress to set.
       * @return This builder for chaining.
       */
      public Builder setValidatorAddress(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        validatorAddress_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validator_address defines the validator's consensus address
       * </pre>
       *
       * <code>string validator_address = 5 [json_name = "validatorAddress"];</code>
       * @return This builder for chaining.
       */
      public Builder clearValidatorAddress() {
        validatorAddress_ = getDefaultInstance().getValidatorAddress();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * validator_address defines the validator's consensus address
       * </pre>
       *
       * <code>string validator_address = 5 [json_name = "validatorAddress"];</code>
       * @param value The bytes for validatorAddress to set.
       * @return This builder for chaining.
       */
      public Builder setValidatorAddressBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        validatorAddress_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.checkpointing.v1.BlsSig)
    }

    // @@protoc_insertion_point(class_scope:babylon.checkpointing.v1.BlsSig)
    private static final com.babylon.checkpointing.v1.CheckpointProto.BlsSig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.checkpointing.v1.CheckpointProto.BlsSig();
    }

    public static com.babylon.checkpointing.v1.CheckpointProto.BlsSig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<BlsSig>
        PARSER = new com.google.protobuf.AbstractParser<BlsSig>() {
      @java.lang.Override
      public BlsSig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<BlsSig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<BlsSig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.checkpointing.v1.CheckpointProto.BlsSig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_checkpointing_v1_RawCheckpoint_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_checkpointing_v1_RawCheckpoint_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_checkpointing_v1_RawCheckpointWithMeta_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_checkpointing_v1_RawCheckpointWithMeta_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_checkpointing_v1_MsgInjectedCheckpoint_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_checkpointing_v1_MsgInjectedCheckpoint_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_checkpointing_v1_CheckpointStateUpdate_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_checkpointing_v1_CheckpointStateUpdate_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_checkpointing_v1_BlsSig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_checkpointing_v1_BlsSig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n)babylon/checkpointing/v1/checkpoint.pr" +
      "oto\022\030babylon.checkpointing.v1\032\037google/pr" +
      "otobuf/timestamp.proto\032\024gogoproto/gogo.p" +
      "roto\032\033tendermint/abci/types.proto\"\335\001\n\rRa" +
      "wCheckpoint\022\033\n\tepoch_num\030\001 \001(\004R\010epochNum" +
      "\022,\n\nblock_hash\030\002 \001(\014B\r\332\336\037\tBlockHashR\tblo" +
      "ckHash\022\026\n\006bitmap\030\003 \001(\014R\006bitmap\022c\n\rbls_mu" +
      "lti_sig\030\004 \001(\014B?\332\336\037;github.com/babylonlab" +
      "s-io/babylon/crypto/bls12381.SignatureR\013" +
      "blsMultiSig:\004\350\240\037\001\"\353\002\n\025RawCheckpointWithM" +
      "eta\022;\n\004ckpt\030\001 \001(\0132\'.babylon.checkpointin" +
      "g.v1.RawCheckpointR\004ckpt\022B\n\006status\030\002 \001(\016" +
      "2*.babylon.checkpointing.v1.CheckpointSt" +
      "atusR\006status\022_\n\013bls_aggr_pk\030\003 \001(\014B?\332\336\037;g" +
      "ithub.com/babylonlabs-io/babylon/crypto/" +
      "bls12381.PublicKeyR\tblsAggrPk\022\033\n\tpower_s" +
      "um\030\004 \001(\004R\010powerSum\022M\n\tlifecycle\030\005 \003(\0132/." +
      "babylon.checkpointing.v1.CheckpointState" +
      "UpdateR\tlifecycle:\004\350\240\037\001\"\263\001\n\025MsgInjectedC" +
      "heckpoint\022C\n\004ckpt\030\001 \001(\0132/.babylon.checkp" +
      "ointing.v1.RawCheckpointWithMetaR\004ckpt\022U" +
      "\n\024extended_commit_info\030\002 \001(\0132#.tendermin" +
      "t.abci.ExtendedCommitInfoR\022extendedCommi" +
      "tInfo\"\303\001\n\025CheckpointStateUpdate\022@\n\005state" +
      "\030\001 \001(\0162*.babylon.checkpointing.v1.Checkp" +
      "ointStatusR\005state\022!\n\014block_height\030\002 \001(\004R" +
      "\013blockHeight\022?\n\nblock_time\030\003 \001(\0132\032.googl" +
      "e.protobuf.TimestampB\004\220\337\037\001R\tblockTime:\004\350" +
      "\240\037\001\"\207\002\n\006BlsSig\022\033\n\tepoch_num\030\001 \001(\004R\010epoch" +
      "Num\022,\n\nblock_hash\030\002 \001(\014B\r\332\336\037\tBlockHashR\t" +
      "blockHash\022X\n\007bls_sig\030\003 \001(\014B?\332\336\037;github.c" +
      "om/babylonlabs-io/babylon/crypto/bls1238" +
      "1.SignatureR\006blsSig\022%\n\016signer_address\030\004 " +
      "\001(\tR\rsignerAddress\022+\n\021validator_address\030" +
      "\005 \001(\tR\020validatorAddress:\004\350\240\037\000*\352\001\n\020Checkp" +
      "ointStatus\022.\n\030CKPT_STATUS_ACCUMULATING\020\000" +
      "\032\020\212\235 \014Accumulating\022\"\n\022CKPT_STATUS_SEALED" +
      "\020\001\032\n\212\235 \006Sealed\022(\n\025CKPT_STATUS_SUBMITTED\020" +
      "\002\032\r\212\235 \tSubmitted\022(\n\025CKPT_STATUS_CONFIRME" +
      "D\020\003\032\r\212\235 \tConfirmed\022(\n\025CKPT_STATUS_FINALI" +
      "ZED\020\004\032\r\212\235 \tFinalized\032\004\210\243\036\000B\350\001\n\034com.babyl" +
      "on.checkpointing.v1B\017CheckpointProtoZ7gi" +
      "thub.com/babylonlabs-io/babylon/x/checkp" +
      "ointing/types\242\002\003BCX\252\002\030Babylon.Checkpoint" +
      "ing.V1\312\002\030Babylon\\Checkpointing\\V1\342\002$Baby" +
      "lon\\Checkpointing\\V1\\GPBMetadata\352\002\032Babyl" +
      "on::Checkpointing::V1b\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          com.google.protobuf.TimestampProto.getDescriptor(),
          com.gogoproto.GogoProto.getDescriptor(),
          com.tendermint.abci.TypesProto.getDescriptor(),
        });
    internal_static_babylon_checkpointing_v1_RawCheckpoint_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_babylon_checkpointing_v1_RawCheckpoint_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_checkpointing_v1_RawCheckpoint_descriptor,
        new java.lang.String[] { "EpochNum", "BlockHash", "Bitmap", "BlsMultiSig", });
    internal_static_babylon_checkpointing_v1_RawCheckpointWithMeta_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_babylon_checkpointing_v1_RawCheckpointWithMeta_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_checkpointing_v1_RawCheckpointWithMeta_descriptor,
        new java.lang.String[] { "Ckpt", "Status", "BlsAggrPk", "PowerSum", "Lifecycle", });
    internal_static_babylon_checkpointing_v1_MsgInjectedCheckpoint_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_babylon_checkpointing_v1_MsgInjectedCheckpoint_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_checkpointing_v1_MsgInjectedCheckpoint_descriptor,
        new java.lang.String[] { "Ckpt", "ExtendedCommitInfo", });
    internal_static_babylon_checkpointing_v1_CheckpointStateUpdate_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_babylon_checkpointing_v1_CheckpointStateUpdate_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_checkpointing_v1_CheckpointStateUpdate_descriptor,
        new java.lang.String[] { "State", "BlockHeight", "BlockTime", });
    internal_static_babylon_checkpointing_v1_BlsSig_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_babylon_checkpointing_v1_BlsSig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_checkpointing_v1_BlsSig_descriptor,
        new java.lang.String[] { "EpochNum", "BlockHash", "BlsSig", "SignerAddress", "ValidatorAddress", });
    com.google.protobuf.ExtensionRegistry registry =
        com.google.protobuf.ExtensionRegistry.newInstance();
    registry.add(com.gogoproto.GogoProto.customtype);
    registry.add(com.gogoproto.GogoProto.enumvalueCustomname);
    registry.add(com.gogoproto.GogoProto.equal);
    registry.add(com.gogoproto.GogoProto.goprotoEnumPrefix);
    registry.add(com.gogoproto.GogoProto.stdtime);
    com.google.protobuf.Descriptors.FileDescriptor
        .internalUpdateFileDescriptor(descriptor, registry);
    com.google.protobuf.TimestampProto.getDescriptor();
    com.gogoproto.GogoProto.getDescriptor();
    com.tendermint.abci.TypesProto.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
