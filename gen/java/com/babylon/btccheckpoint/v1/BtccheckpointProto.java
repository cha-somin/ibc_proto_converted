// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: babylon/btccheckpoint/v1/btccheckpoint.proto

package com.babylon.btccheckpoint.v1;

public final class BtccheckpointProto {
  private BtccheckpointProto() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * BtcStatus is an enum describing the current btc status of the checkpoint
   * </pre>
   *
   * Protobuf enum {@code babylon.btccheckpoint.v1.BtcStatus}
   */
  public enum BtcStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * SUBMITTED Epoch has Submitted btc status if there ever was at least one
     * known submission on btc main chain
     * </pre>
     *
     * <code>EPOCH_STATUS_SUBMITTED = 0 [(.gogoproto.enumvalue_customname) = "Submitted"];</code>
     */
    EPOCH_STATUS_SUBMITTED(0),
    /**
     * <pre>
     * CONFIRMED Epoch has Confirmed btc status if there ever was at least one
     * known submission on btc main chain which was k-deep
     * </pre>
     *
     * <code>EPOCH_STATUS_CONFIRMED = 1 [(.gogoproto.enumvalue_customname) = "Confirmed"];</code>
     */
    EPOCH_STATUS_CONFIRMED(1),
    /**
     * <pre>
     * CONFIRMED Epoch has Finalized btc status if there is was at exactly one
     * knon submission on btc main chain which is w-deep
     * </pre>
     *
     * <code>EPOCH_STATUS_FINALIZED = 2 [(.gogoproto.enumvalue_customname) = "Finalized"];</code>
     */
    EPOCH_STATUS_FINALIZED(2),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * SUBMITTED Epoch has Submitted btc status if there ever was at least one
     * known submission on btc main chain
     * </pre>
     *
     * <code>EPOCH_STATUS_SUBMITTED = 0 [(.gogoproto.enumvalue_customname) = "Submitted"];</code>
     */
    public static final int EPOCH_STATUS_SUBMITTED_VALUE = 0;
    /**
     * <pre>
     * CONFIRMED Epoch has Confirmed btc status if there ever was at least one
     * known submission on btc main chain which was k-deep
     * </pre>
     *
     * <code>EPOCH_STATUS_CONFIRMED = 1 [(.gogoproto.enumvalue_customname) = "Confirmed"];</code>
     */
    public static final int EPOCH_STATUS_CONFIRMED_VALUE = 1;
    /**
     * <pre>
     * CONFIRMED Epoch has Finalized btc status if there is was at exactly one
     * knon submission on btc main chain which is w-deep
     * </pre>
     *
     * <code>EPOCH_STATUS_FINALIZED = 2 [(.gogoproto.enumvalue_customname) = "Finalized"];</code>
     */
    public static final int EPOCH_STATUS_FINALIZED_VALUE = 2;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static BtcStatus valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static BtcStatus forNumber(int value) {
      switch (value) {
        case 0: return EPOCH_STATUS_SUBMITTED;
        case 1: return EPOCH_STATUS_CONFIRMED;
        case 2: return EPOCH_STATUS_FINALIZED;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<BtcStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        BtcStatus> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<BtcStatus>() {
            public BtcStatus findValueByNumber(int number) {
              return BtcStatus.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.getDescriptor().getEnumTypes().get(0);
    }

    private static final BtcStatus[] VALUES = values();

    public static BtcStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private BtcStatus(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:babylon.btccheckpoint.v1.BtcStatus)
  }

  public interface BTCSpvProofOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.btccheckpoint.v1.BTCSpvProof)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Valid bitcoin transaction containing OP_RETURN opcode.
     * </pre>
     *
     * <code>bytes btc_transaction = 1 [json_name = "btcTransaction"];</code>
     * @return The btcTransaction.
     */
    com.google.protobuf.ByteString getBtcTransaction();

    /**
     * <pre>
     * Index of transaction within the block. Index is needed to determine if
     * currently hashed node is left or right.
     * </pre>
     *
     * <code>uint32 btc_transaction_index = 2 [json_name = "btcTransactionIndex"];</code>
     * @return The btcTransactionIndex.
     */
    int getBtcTransactionIndex();

    /**
     * <pre>
     * List of concatenated intermediate merkle tree nodes, without root node and
     * leaf node against which we calculate the proof. Each node has 32 byte
     * length. Example proof can look like: 32_bytes_of_node1 || 32_bytes_of_node2
     * ||  32_bytes_of_node3 so the length of the proof will always be divisible
     * by 32.
     * </pre>
     *
     * <code>bytes merkle_nodes = 3 [json_name = "merkleNodes"];</code>
     * @return The merkleNodes.
     */
    com.google.protobuf.ByteString getMerkleNodes();

    /**
     * <pre>
     * Valid btc header which confirms btc_transaction.
     * Should have exactly 80 bytes
     * </pre>
     *
     * <code>bytes confirming_btc_header = 4 [json_name = "confirmingBtcHeader", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderBytes"];</code>
     * @return The confirmingBtcHeader.
     */
    com.google.protobuf.ByteString getConfirmingBtcHeader();
  }
  /**
   * <pre>
   * Consider we have a Merkle tree with following structure:
   *            ROOT
   *           /    &#92;
   *      H1234      H5555
   *     /     &#92;       &#92;
   *   H12     H34      H55
   *  /  &#92;    /  &#92;     /
   * H1  H2  H3  H4  H5
   * L1  L2  L3  L4  L5
   * To prove L3 was part of ROOT we need:
   * - btc_transaction_index = 2 which in binary is 010
   * (where 0 means going left, 1 means going right in the tree)
   * - merkle_nodes we'd have H4 || H12 || H5555
   * By looking at 010 we would know that H4 is a right sibling,
   * H12 is left, H5555 is right again.
   * </pre>
   *
   * Protobuf type {@code babylon.btccheckpoint.v1.BTCSpvProof}
   */
  public static final class BTCSpvProof extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.btccheckpoint.v1.BTCSpvProof)
      BTCSpvProofOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use BTCSpvProof.newBuilder() to construct.
    private BTCSpvProof(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private BTCSpvProof() {
      btcTransaction_ = com.google.protobuf.ByteString.EMPTY;
      merkleNodes_ = com.google.protobuf.ByteString.EMPTY;
      confirmingBtcHeader_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new BTCSpvProof();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_BTCSpvProof_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_BTCSpvProof_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof.Builder.class);
    }

    public static final int BTC_TRANSACTION_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString btcTransaction_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Valid bitcoin transaction containing OP_RETURN opcode.
     * </pre>
     *
     * <code>bytes btc_transaction = 1 [json_name = "btcTransaction"];</code>
     * @return The btcTransaction.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBtcTransaction() {
      return btcTransaction_;
    }

    public static final int BTC_TRANSACTION_INDEX_FIELD_NUMBER = 2;
    private int btcTransactionIndex_ = 0;
    /**
     * <pre>
     * Index of transaction within the block. Index is needed to determine if
     * currently hashed node is left or right.
     * </pre>
     *
     * <code>uint32 btc_transaction_index = 2 [json_name = "btcTransactionIndex"];</code>
     * @return The btcTransactionIndex.
     */
    @java.lang.Override
    public int getBtcTransactionIndex() {
      return btcTransactionIndex_;
    }

    public static final int MERKLE_NODES_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString merkleNodes_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * List of concatenated intermediate merkle tree nodes, without root node and
     * leaf node against which we calculate the proof. Each node has 32 byte
     * length. Example proof can look like: 32_bytes_of_node1 || 32_bytes_of_node2
     * ||  32_bytes_of_node3 so the length of the proof will always be divisible
     * by 32.
     * </pre>
     *
     * <code>bytes merkle_nodes = 3 [json_name = "merkleNodes"];</code>
     * @return The merkleNodes.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getMerkleNodes() {
      return merkleNodes_;
    }

    public static final int CONFIRMING_BTC_HEADER_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString confirmingBtcHeader_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Valid btc header which confirms btc_transaction.
     * Should have exactly 80 bytes
     * </pre>
     *
     * <code>bytes confirming_btc_header = 4 [json_name = "confirmingBtcHeader", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderBytes"];</code>
     * @return The confirmingBtcHeader.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getConfirmingBtcHeader() {
      return confirmingBtcHeader_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!btcTransaction_.isEmpty()) {
        output.writeBytes(1, btcTransaction_);
      }
      if (btcTransactionIndex_ != 0) {
        output.writeUInt32(2, btcTransactionIndex_);
      }
      if (!merkleNodes_.isEmpty()) {
        output.writeBytes(3, merkleNodes_);
      }
      if (!confirmingBtcHeader_.isEmpty()) {
        output.writeBytes(4, confirmingBtcHeader_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!btcTransaction_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, btcTransaction_);
      }
      if (btcTransactionIndex_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, btcTransactionIndex_);
      }
      if (!merkleNodes_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, merkleNodes_);
      }
      if (!confirmingBtcHeader_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, confirmingBtcHeader_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof)) {
        return super.equals(obj);
      }
      com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof other = (com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof) obj;

      if (!getBtcTransaction()
          .equals(other.getBtcTransaction())) return false;
      if (getBtcTransactionIndex()
          != other.getBtcTransactionIndex()) return false;
      if (!getMerkleNodes()
          .equals(other.getMerkleNodes())) return false;
      if (!getConfirmingBtcHeader()
          .equals(other.getConfirmingBtcHeader())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + BTC_TRANSACTION_FIELD_NUMBER;
      hash = (53 * hash) + getBtcTransaction().hashCode();
      hash = (37 * hash) + BTC_TRANSACTION_INDEX_FIELD_NUMBER;
      hash = (53 * hash) + getBtcTransactionIndex();
      hash = (37 * hash) + MERKLE_NODES_FIELD_NUMBER;
      hash = (53 * hash) + getMerkleNodes().hashCode();
      hash = (37 * hash) + CONFIRMING_BTC_HEADER_FIELD_NUMBER;
      hash = (53 * hash) + getConfirmingBtcHeader().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Consider we have a Merkle tree with following structure:
     *            ROOT
     *           /    &#92;
     *      H1234      H5555
     *     /     &#92;       &#92;
     *   H12     H34      H55
     *  /  &#92;    /  &#92;     /
     * H1  H2  H3  H4  H5
     * L1  L2  L3  L4  L5
     * To prove L3 was part of ROOT we need:
     * - btc_transaction_index = 2 which in binary is 010
     * (where 0 means going left, 1 means going right in the tree)
     * - merkle_nodes we'd have H4 || H12 || H5555
     * By looking at 010 we would know that H4 is a right sibling,
     * H12 is left, H5555 is right again.
     * </pre>
     *
     * Protobuf type {@code babylon.btccheckpoint.v1.BTCSpvProof}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.btccheckpoint.v1.BTCSpvProof)
        com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProofOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_BTCSpvProof_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_BTCSpvProof_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof.Builder.class);
      }

      // Construct using com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        btcTransaction_ = com.google.protobuf.ByteString.EMPTY;
        btcTransactionIndex_ = 0;
        merkleNodes_ = com.google.protobuf.ByteString.EMPTY;
        confirmingBtcHeader_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_BTCSpvProof_descriptor;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof getDefaultInstanceForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof build() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof buildPartial() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof result = new com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.btcTransaction_ = btcTransaction_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.btcTransactionIndex_ = btcTransactionIndex_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.merkleNodes_ = merkleNodes_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.confirmingBtcHeader_ = confirmingBtcHeader_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof) {
          return mergeFrom((com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof other) {
        if (other == com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof.getDefaultInstance()) return this;
        if (other.getBtcTransaction() != com.google.protobuf.ByteString.EMPTY) {
          setBtcTransaction(other.getBtcTransaction());
        }
        if (other.getBtcTransactionIndex() != 0) {
          setBtcTransactionIndex(other.getBtcTransactionIndex());
        }
        if (other.getMerkleNodes() != com.google.protobuf.ByteString.EMPTY) {
          setMerkleNodes(other.getMerkleNodes());
        }
        if (other.getConfirmingBtcHeader() != com.google.protobuf.ByteString.EMPTY) {
          setConfirmingBtcHeader(other.getConfirmingBtcHeader());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                btcTransaction_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                btcTransactionIndex_ = input.readUInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                merkleNodes_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                confirmingBtcHeader_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString btcTransaction_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Valid bitcoin transaction containing OP_RETURN opcode.
       * </pre>
       *
       * <code>bytes btc_transaction = 1 [json_name = "btcTransaction"];</code>
       * @return The btcTransaction.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBtcTransaction() {
        return btcTransaction_;
      }
      /**
       * <pre>
       * Valid bitcoin transaction containing OP_RETURN opcode.
       * </pre>
       *
       * <code>bytes btc_transaction = 1 [json_name = "btcTransaction"];</code>
       * @param value The btcTransaction to set.
       * @return This builder for chaining.
       */
      public Builder setBtcTransaction(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        btcTransaction_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Valid bitcoin transaction containing OP_RETURN opcode.
       * </pre>
       *
       * <code>bytes btc_transaction = 1 [json_name = "btcTransaction"];</code>
       * @return This builder for chaining.
       */
      public Builder clearBtcTransaction() {
        bitField0_ = (bitField0_ & ~0x00000001);
        btcTransaction_ = getDefaultInstance().getBtcTransaction();
        onChanged();
        return this;
      }

      private int btcTransactionIndex_ ;
      /**
       * <pre>
       * Index of transaction within the block. Index is needed to determine if
       * currently hashed node is left or right.
       * </pre>
       *
       * <code>uint32 btc_transaction_index = 2 [json_name = "btcTransactionIndex"];</code>
       * @return The btcTransactionIndex.
       */
      @java.lang.Override
      public int getBtcTransactionIndex() {
        return btcTransactionIndex_;
      }
      /**
       * <pre>
       * Index of transaction within the block. Index is needed to determine if
       * currently hashed node is left or right.
       * </pre>
       *
       * <code>uint32 btc_transaction_index = 2 [json_name = "btcTransactionIndex"];</code>
       * @param value The btcTransactionIndex to set.
       * @return This builder for chaining.
       */
      public Builder setBtcTransactionIndex(int value) {

        btcTransactionIndex_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Index of transaction within the block. Index is needed to determine if
       * currently hashed node is left or right.
       * </pre>
       *
       * <code>uint32 btc_transaction_index = 2 [json_name = "btcTransactionIndex"];</code>
       * @return This builder for chaining.
       */
      public Builder clearBtcTransactionIndex() {
        bitField0_ = (bitField0_ & ~0x00000002);
        btcTransactionIndex_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString merkleNodes_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * List of concatenated intermediate merkle tree nodes, without root node and
       * leaf node against which we calculate the proof. Each node has 32 byte
       * length. Example proof can look like: 32_bytes_of_node1 || 32_bytes_of_node2
       * ||  32_bytes_of_node3 so the length of the proof will always be divisible
       * by 32.
       * </pre>
       *
       * <code>bytes merkle_nodes = 3 [json_name = "merkleNodes"];</code>
       * @return The merkleNodes.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getMerkleNodes() {
        return merkleNodes_;
      }
      /**
       * <pre>
       * List of concatenated intermediate merkle tree nodes, without root node and
       * leaf node against which we calculate the proof. Each node has 32 byte
       * length. Example proof can look like: 32_bytes_of_node1 || 32_bytes_of_node2
       * ||  32_bytes_of_node3 so the length of the proof will always be divisible
       * by 32.
       * </pre>
       *
       * <code>bytes merkle_nodes = 3 [json_name = "merkleNodes"];</code>
       * @param value The merkleNodes to set.
       * @return This builder for chaining.
       */
      public Builder setMerkleNodes(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        merkleNodes_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * List of concatenated intermediate merkle tree nodes, without root node and
       * leaf node against which we calculate the proof. Each node has 32 byte
       * length. Example proof can look like: 32_bytes_of_node1 || 32_bytes_of_node2
       * ||  32_bytes_of_node3 so the length of the proof will always be divisible
       * by 32.
       * </pre>
       *
       * <code>bytes merkle_nodes = 3 [json_name = "merkleNodes"];</code>
       * @return This builder for chaining.
       */
      public Builder clearMerkleNodes() {
        bitField0_ = (bitField0_ & ~0x00000004);
        merkleNodes_ = getDefaultInstance().getMerkleNodes();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString confirmingBtcHeader_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Valid btc header which confirms btc_transaction.
       * Should have exactly 80 bytes
       * </pre>
       *
       * <code>bytes confirming_btc_header = 4 [json_name = "confirmingBtcHeader", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderBytes"];</code>
       * @return The confirmingBtcHeader.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getConfirmingBtcHeader() {
        return confirmingBtcHeader_;
      }
      /**
       * <pre>
       * Valid btc header which confirms btc_transaction.
       * Should have exactly 80 bytes
       * </pre>
       *
       * <code>bytes confirming_btc_header = 4 [json_name = "confirmingBtcHeader", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderBytes"];</code>
       * @param value The confirmingBtcHeader to set.
       * @return This builder for chaining.
       */
      public Builder setConfirmingBtcHeader(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        confirmingBtcHeader_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Valid btc header which confirms btc_transaction.
       * Should have exactly 80 bytes
       * </pre>
       *
       * <code>bytes confirming_btc_header = 4 [json_name = "confirmingBtcHeader", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderBytes"];</code>
       * @return This builder for chaining.
       */
      public Builder clearConfirmingBtcHeader() {
        bitField0_ = (bitField0_ & ~0x00000008);
        confirmingBtcHeader_ = getDefaultInstance().getConfirmingBtcHeader();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.btccheckpoint.v1.BTCSpvProof)
    }

    // @@protoc_insertion_point(class_scope:babylon.btccheckpoint.v1.BTCSpvProof)
    private static final com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof();
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<BTCSpvProof>
        PARSER = new com.google.protobuf.AbstractParser<BTCSpvProof>() {
      @java.lang.Override
      public BTCSpvProof parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<BTCSpvProof> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<BTCSpvProof> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCSpvProof getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TransactionKeyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.btccheckpoint.v1.TransactionKey)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>uint32 index = 1 [json_name = "index"];</code>
     * @return The index.
     */
    int getIndex();

    /**
     * <code>bytes hash = 2 [json_name = "hash", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderHashBytes"];</code>
     * @return The hash.
     */
    com.google.protobuf.ByteString getHash();
  }
  /**
   * <pre>
   * Each provided OP_RETURN transaction can be identified by hash of block in
   * which transaction was included and transaction index in the block
   * </pre>
   *
   * Protobuf type {@code babylon.btccheckpoint.v1.TransactionKey}
   */
  public static final class TransactionKey extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.btccheckpoint.v1.TransactionKey)
      TransactionKeyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TransactionKey.newBuilder() to construct.
    private TransactionKey(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TransactionKey() {
      hash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TransactionKey();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_TransactionKey_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_TransactionKey_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder.class);
    }

    public static final int INDEX_FIELD_NUMBER = 1;
    private int index_ = 0;
    /**
     * <code>uint32 index = 1 [json_name = "index"];</code>
     * @return The index.
     */
    @java.lang.Override
    public int getIndex() {
      return index_;
    }

    public static final int HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <code>bytes hash = 2 [json_name = "hash", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderHashBytes"];</code>
     * @return The hash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getHash() {
      return hash_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (index_ != 0) {
        output.writeUInt32(1, index_);
      }
      if (!hash_.isEmpty()) {
        output.writeBytes(2, hash_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (index_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, index_);
      }
      if (!hash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, hash_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey)) {
        return super.equals(obj);
      }
      com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey other = (com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey) obj;

      if (getIndex()
          != other.getIndex()) return false;
      if (!getHash()
          .equals(other.getHash())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + INDEX_FIELD_NUMBER;
      hash = (53 * hash) + getIndex();
      hash = (37 * hash) + HASH_FIELD_NUMBER;
      hash = (53 * hash) + getHash().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Each provided OP_RETURN transaction can be identified by hash of block in
     * which transaction was included and transaction index in the block
     * </pre>
     *
     * Protobuf type {@code babylon.btccheckpoint.v1.TransactionKey}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.btccheckpoint.v1.TransactionKey)
        com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_TransactionKey_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_TransactionKey_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder.class);
      }

      // Construct using com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        index_ = 0;
        hash_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_TransactionKey_descriptor;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey getDefaultInstanceForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey build() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey buildPartial() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey result = new com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.index_ = index_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.hash_ = hash_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey) {
          return mergeFrom((com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey other) {
        if (other == com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.getDefaultInstance()) return this;
        if (other.getIndex() != 0) {
          setIndex(other.getIndex());
        }
        if (other.getHash() != com.google.protobuf.ByteString.EMPTY) {
          setHash(other.getHash());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                index_ = input.readUInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                hash_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int index_ ;
      /**
       * <code>uint32 index = 1 [json_name = "index"];</code>
       * @return The index.
       */
      @java.lang.Override
      public int getIndex() {
        return index_;
      }
      /**
       * <code>uint32 index = 1 [json_name = "index"];</code>
       * @param value The index to set.
       * @return This builder for chaining.
       */
      public Builder setIndex(int value) {

        index_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>uint32 index = 1 [json_name = "index"];</code>
       * @return This builder for chaining.
       */
      public Builder clearIndex() {
        bitField0_ = (bitField0_ & ~0x00000001);
        index_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>bytes hash = 2 [json_name = "hash", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderHashBytes"];</code>
       * @return The hash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getHash() {
        return hash_;
      }
      /**
       * <code>bytes hash = 2 [json_name = "hash", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderHashBytes"];</code>
       * @param value The hash to set.
       * @return This builder for chaining.
       */
      public Builder setHash(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        hash_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>bytes hash = 2 [json_name = "hash", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderHashBytes"];</code>
       * @return This builder for chaining.
       */
      public Builder clearHash() {
        bitField0_ = (bitField0_ & ~0x00000002);
        hash_ = getDefaultInstance().getHash();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.btccheckpoint.v1.TransactionKey)
    }

    // @@protoc_insertion_point(class_scope:babylon.btccheckpoint.v1.TransactionKey)
    private static final com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey();
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TransactionKey>
        PARSER = new com.google.protobuf.AbstractParser<TransactionKey>() {
      @java.lang.Override
      public TransactionKey parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TransactionKey> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TransactionKey> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SubmissionKeyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.btccheckpoint.v1.SubmissionKey)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     */
    java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey> 
        getKeyList();
    /**
     * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey getKey(int index);
    /**
     * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     */
    int getKeyCount();
    /**
     * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     */
    java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder> 
        getKeyOrBuilderList();
    /**
     * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder getKeyOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Checkpoint can be composed from multiple transactions, so to identify whole
   * submission we need list of transaction keys.
   * Each submission can generally be identified by this list of (txIdx,
   * blockHash) tuples. Note: this could possibly be optimized as if transactions
   * were in one block they would have the same block hash and different indexes,
   * but each blockhash is only 33 (1  byte for prefix encoding and 32 byte hash),
   * so there should be other strong arguments for this optimization
   * </pre>
   *
   * Protobuf type {@code babylon.btccheckpoint.v1.SubmissionKey}
   */
  public static final class SubmissionKey extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.btccheckpoint.v1.SubmissionKey)
      SubmissionKeyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SubmissionKey.newBuilder() to construct.
    private SubmissionKey(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SubmissionKey() {
      key_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SubmissionKey();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_SubmissionKey_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_SubmissionKey_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder.class);
    }

    public static final int KEY_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey> key_;
    /**
     * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     */
    @java.lang.Override
    public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey> getKeyList() {
      return key_;
    }
    /**
     * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder> 
        getKeyOrBuilderList() {
      return key_;
    }
    /**
     * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     */
    @java.lang.Override
    public int getKeyCount() {
      return key_.size();
    }
    /**
     * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey getKey(int index) {
      return key_.get(index);
    }
    /**
     * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder getKeyOrBuilder(
        int index) {
      return key_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < key_.size(); i++) {
        output.writeMessage(1, key_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < key_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, key_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey)) {
        return super.equals(obj);
      }
      com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey other = (com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey) obj;

      if (!getKeyList()
          .equals(other.getKeyList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getKeyCount() > 0) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKeyList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Checkpoint can be composed from multiple transactions, so to identify whole
     * submission we need list of transaction keys.
     * Each submission can generally be identified by this list of (txIdx,
     * blockHash) tuples. Note: this could possibly be optimized as if transactions
     * were in one block they would have the same block hash and different indexes,
     * but each blockhash is only 33 (1  byte for prefix encoding and 32 byte hash),
     * so there should be other strong arguments for this optimization
     * </pre>
     *
     * Protobuf type {@code babylon.btccheckpoint.v1.SubmissionKey}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.btccheckpoint.v1.SubmissionKey)
        com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_SubmissionKey_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_SubmissionKey_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder.class);
      }

      // Construct using com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (keyBuilder_ == null) {
          key_ = java.util.Collections.emptyList();
        } else {
          key_ = null;
          keyBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_SubmissionKey_descriptor;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey getDefaultInstanceForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey build() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey buildPartial() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey result = new com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey result) {
        if (keyBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            key_ = java.util.Collections.unmodifiableList(key_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.key_ = key_;
        } else {
          result.key_ = keyBuilder_.build();
        }
      }

      private void buildPartial0(com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey) {
          return mergeFrom((com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey other) {
        if (other == com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.getDefaultInstance()) return this;
        if (keyBuilder_ == null) {
          if (!other.key_.isEmpty()) {
            if (key_.isEmpty()) {
              key_ = other.key_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureKeyIsMutable();
              key_.addAll(other.key_);
            }
            onChanged();
          }
        } else {
          if (!other.key_.isEmpty()) {
            if (keyBuilder_.isEmpty()) {
              keyBuilder_.dispose();
              keyBuilder_ = null;
              key_ = other.key_;
              bitField0_ = (bitField0_ & ~0x00000001);
              keyBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getKeyFieldBuilder() : null;
            } else {
              keyBuilder_.addAllMessages(other.key_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey m =
                    input.readMessage(
                        com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.parser(),
                        extensionRegistry);
                if (keyBuilder_ == null) {
                  ensureKeyIsMutable();
                  key_.add(m);
                } else {
                  keyBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey> key_ =
        java.util.Collections.emptyList();
      private void ensureKeyIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          key_ = new java.util.ArrayList<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey>(key_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder> keyBuilder_;

      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey> getKeyList() {
        if (keyBuilder_ == null) {
          return java.util.Collections.unmodifiableList(key_);
        } else {
          return keyBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public int getKeyCount() {
        if (keyBuilder_ == null) {
          return key_.size();
        } else {
          return keyBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey getKey(int index) {
        if (keyBuilder_ == null) {
          return key_.get(index);
        } else {
          return keyBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public Builder setKey(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey value) {
        if (keyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeyIsMutable();
          key_.set(index, value);
          onChanged();
        } else {
          keyBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public Builder setKey(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder builderForValue) {
        if (keyBuilder_ == null) {
          ensureKeyIsMutable();
          key_.set(index, builderForValue.build());
          onChanged();
        } else {
          keyBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public Builder addKey(com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey value) {
        if (keyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeyIsMutable();
          key_.add(value);
          onChanged();
        } else {
          keyBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public Builder addKey(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey value) {
        if (keyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeyIsMutable();
          key_.add(index, value);
          onChanged();
        } else {
          keyBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public Builder addKey(
          com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder builderForValue) {
        if (keyBuilder_ == null) {
          ensureKeyIsMutable();
          key_.add(builderForValue.build());
          onChanged();
        } else {
          keyBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public Builder addKey(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder builderForValue) {
        if (keyBuilder_ == null) {
          ensureKeyIsMutable();
          key_.add(index, builderForValue.build());
          onChanged();
        } else {
          keyBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public Builder addAllKey(
          java.lang.Iterable<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey> values) {
        if (keyBuilder_ == null) {
          ensureKeyIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, key_);
          onChanged();
        } else {
          keyBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public Builder clearKey() {
        if (keyBuilder_ == null) {
          key_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          keyBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public Builder removeKey(int index) {
        if (keyBuilder_ == null) {
          ensureKeyIsMutable();
          key_.remove(index);
          onChanged();
        } else {
          keyBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder getKeyBuilder(
          int index) {
        return getKeyFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder getKeyOrBuilder(
          int index) {
        if (keyBuilder_ == null) {
          return key_.get(index);  } else {
          return keyBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder> 
           getKeyOrBuilderList() {
        if (keyBuilder_ != null) {
          return keyBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(key_);
        }
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder addKeyBuilder() {
        return getKeyFieldBuilder().addBuilder(
            com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.getDefaultInstance());
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder addKeyBuilder(
          int index) {
        return getKeyFieldBuilder().addBuilder(
            index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.getDefaultInstance());
      }
      /**
       * <code>repeated .babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder> 
           getKeyBuilderList() {
        return getKeyFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder> 
          getKeyFieldBuilder() {
        if (keyBuilder_ == null) {
          keyBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder>(
                  key_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          key_ = null;
        }
        return keyBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.btccheckpoint.v1.SubmissionKey)
    }

    // @@protoc_insertion_point(class_scope:babylon.btccheckpoint.v1.SubmissionKey)
    private static final com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey();
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SubmissionKey>
        PARSER = new com.google.protobuf.AbstractParser<SubmissionKey>() {
      @java.lang.Override
      public SubmissionKey parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SubmissionKey> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SubmissionKey> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TransactionInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.btccheckpoint.v1.TransactionInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * key is the position (txIdx, blockHash) of this tx on BTC blockchain
     * Although it is already a part of SubmissionKey, we store it here again
     * to make TransactionInfo self-contained.
     * For example, storing the key allows TransactionInfo to not relay on
     * the fact that TransactionInfo will be ordered in the same order as
     * TransactionKeys in SubmissionKey.
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <pre>
     * key is the position (txIdx, blockHash) of this tx on BTC blockchain
     * Although it is already a part of SubmissionKey, we store it here again
     * to make TransactionInfo self-contained.
     * For example, storing the key allows TransactionInfo to not relay on
     * the fact that TransactionInfo will be ordered in the same order as
     * TransactionKeys in SubmissionKey.
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     * @return The key.
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey getKey();
    /**
     * <pre>
     * key is the position (txIdx, blockHash) of this tx on BTC blockchain
     * Although it is already a part of SubmissionKey, we store it here again
     * to make TransactionInfo self-contained.
     * For example, storing the key allows TransactionInfo to not relay on
     * the fact that TransactionInfo will be ordered in the same order as
     * TransactionKeys in SubmissionKey.
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder getKeyOrBuilder();

    /**
     * <pre>
     * transaction is the full transaction in bytes
     * </pre>
     *
     * <code>bytes transaction = 2 [json_name = "transaction"];</code>
     * @return The transaction.
     */
    com.google.protobuf.ByteString getTransaction();

    /**
     * <pre>
     * proof is the Merkle proof that this tx is included in the position in `key`
     * TODO: maybe it could use here better format as we already processed and
     * validated the proof?
     * </pre>
     *
     * <code>bytes proof = 3 [json_name = "proof"];</code>
     * @return The proof.
     */
    com.google.protobuf.ByteString getProof();
  }
  /**
   * <pre>
   * TransactionInfo is the info of a tx on Bitcoin,
   * including
   * - the position of the tx on BTC blockchain
   * - the full tx content
   * - the Merkle proof that this tx is on the above position
   * </pre>
   *
   * Protobuf type {@code babylon.btccheckpoint.v1.TransactionInfo}
   */
  public static final class TransactionInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.btccheckpoint.v1.TransactionInfo)
      TransactionInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TransactionInfo.newBuilder() to construct.
    private TransactionInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TransactionInfo() {
      transaction_ = com.google.protobuf.ByteString.EMPTY;
      proof_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TransactionInfo();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_TransactionInfo_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_TransactionInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder.class);
    }

    public static final int KEY_FIELD_NUMBER = 1;
    private com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey key_;
    /**
     * <pre>
     * key is the position (txIdx, blockHash) of this tx on BTC blockchain
     * Although it is already a part of SubmissionKey, we store it here again
     * to make TransactionInfo self-contained.
     * For example, storing the key allows TransactionInfo to not relay on
     * the fact that TransactionInfo will be ordered in the same order as
     * TransactionKeys in SubmissionKey.
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     * @return Whether the key field is set.
     */
    @java.lang.Override
    public boolean hasKey() {
      return key_ != null;
    }
    /**
     * <pre>
     * key is the position (txIdx, blockHash) of this tx on BTC blockchain
     * Although it is already a part of SubmissionKey, we store it here again
     * to make TransactionInfo self-contained.
     * For example, storing the key allows TransactionInfo to not relay on
     * the fact that TransactionInfo will be ordered in the same order as
     * TransactionKeys in SubmissionKey.
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     * @return The key.
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey getKey() {
      return key_ == null ? com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.getDefaultInstance() : key_;
    }
    /**
     * <pre>
     * key is the position (txIdx, blockHash) of this tx on BTC blockchain
     * Although it is already a part of SubmissionKey, we store it here again
     * to make TransactionInfo self-contained.
     * For example, storing the key allows TransactionInfo to not relay on
     * the fact that TransactionInfo will be ordered in the same order as
     * TransactionKeys in SubmissionKey.
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder getKeyOrBuilder() {
      return key_ == null ? com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.getDefaultInstance() : key_;
    }

    public static final int TRANSACTION_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString transaction_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * transaction is the full transaction in bytes
     * </pre>
     *
     * <code>bytes transaction = 2 [json_name = "transaction"];</code>
     * @return The transaction.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTransaction() {
      return transaction_;
    }

    public static final int PROOF_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString proof_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * proof is the Merkle proof that this tx is included in the position in `key`
     * TODO: maybe it could use here better format as we already processed and
     * validated the proof?
     * </pre>
     *
     * <code>bytes proof = 3 [json_name = "proof"];</code>
     * @return The proof.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getProof() {
      return proof_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (key_ != null) {
        output.writeMessage(1, getKey());
      }
      if (!transaction_.isEmpty()) {
        output.writeBytes(2, transaction_);
      }
      if (!proof_.isEmpty()) {
        output.writeBytes(3, proof_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (key_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getKey());
      }
      if (!transaction_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, transaction_);
      }
      if (!proof_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, proof_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo)) {
        return super.equals(obj);
      }
      com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo other = (com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo) obj;

      if (hasKey() != other.hasKey()) return false;
      if (hasKey()) {
        if (!getKey()
            .equals(other.getKey())) return false;
      }
      if (!getTransaction()
          .equals(other.getTransaction())) return false;
      if (!getProof()
          .equals(other.getProof())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasKey()) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKey().hashCode();
      }
      hash = (37 * hash) + TRANSACTION_FIELD_NUMBER;
      hash = (53 * hash) + getTransaction().hashCode();
      hash = (37 * hash) + PROOF_FIELD_NUMBER;
      hash = (53 * hash) + getProof().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * TransactionInfo is the info of a tx on Bitcoin,
     * including
     * - the position of the tx on BTC blockchain
     * - the full tx content
     * - the Merkle proof that this tx is on the above position
     * </pre>
     *
     * Protobuf type {@code babylon.btccheckpoint.v1.TransactionInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.btccheckpoint.v1.TransactionInfo)
        com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_TransactionInfo_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_TransactionInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder.class);
      }

      // Construct using com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        key_ = null;
        if (keyBuilder_ != null) {
          keyBuilder_.dispose();
          keyBuilder_ = null;
        }
        transaction_ = com.google.protobuf.ByteString.EMPTY;
        proof_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_TransactionInfo_descriptor;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo getDefaultInstanceForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo build() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo buildPartial() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo result = new com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.key_ = keyBuilder_ == null
              ? key_
              : keyBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.transaction_ = transaction_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.proof_ = proof_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo) {
          return mergeFrom((com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo other) {
        if (other == com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.getDefaultInstance()) return this;
        if (other.hasKey()) {
          mergeKey(other.getKey());
        }
        if (other.getTransaction() != com.google.protobuf.ByteString.EMPTY) {
          setTransaction(other.getTransaction());
        }
        if (other.getProof() != com.google.protobuf.ByteString.EMPTY) {
          setProof(other.getProof());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getKeyFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                transaction_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                proof_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey key_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder> keyBuilder_;
      /**
       * <pre>
       * key is the position (txIdx, blockHash) of this tx on BTC blockchain
       * Although it is already a part of SubmissionKey, we store it here again
       * to make TransactionInfo self-contained.
       * For example, storing the key allows TransactionInfo to not relay on
       * the fact that TransactionInfo will be ordered in the same order as
       * TransactionKeys in SubmissionKey.
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       * @return Whether the key field is set.
       */
      public boolean hasKey() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * key is the position (txIdx, blockHash) of this tx on BTC blockchain
       * Although it is already a part of SubmissionKey, we store it here again
       * to make TransactionInfo self-contained.
       * For example, storing the key allows TransactionInfo to not relay on
       * the fact that TransactionInfo will be ordered in the same order as
       * TransactionKeys in SubmissionKey.
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       * @return The key.
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey getKey() {
        if (keyBuilder_ == null) {
          return key_ == null ? com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.getDefaultInstance() : key_;
        } else {
          return keyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * key is the position (txIdx, blockHash) of this tx on BTC blockchain
       * Although it is already a part of SubmissionKey, we store it here again
       * to make TransactionInfo self-contained.
       * For example, storing the key allows TransactionInfo to not relay on
       * the fact that TransactionInfo will be ordered in the same order as
       * TransactionKeys in SubmissionKey.
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public Builder setKey(com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey value) {
        if (keyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          key_ = value;
        } else {
          keyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * key is the position (txIdx, blockHash) of this tx on BTC blockchain
       * Although it is already a part of SubmissionKey, we store it here again
       * to make TransactionInfo self-contained.
       * For example, storing the key allows TransactionInfo to not relay on
       * the fact that TransactionInfo will be ordered in the same order as
       * TransactionKeys in SubmissionKey.
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public Builder setKey(
          com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder builderForValue) {
        if (keyBuilder_ == null) {
          key_ = builderForValue.build();
        } else {
          keyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * key is the position (txIdx, blockHash) of this tx on BTC blockchain
       * Although it is already a part of SubmissionKey, we store it here again
       * to make TransactionInfo self-contained.
       * For example, storing the key allows TransactionInfo to not relay on
       * the fact that TransactionInfo will be ordered in the same order as
       * TransactionKeys in SubmissionKey.
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public Builder mergeKey(com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey value) {
        if (keyBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            key_ != null &&
            key_ != com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.getDefaultInstance()) {
            getKeyBuilder().mergeFrom(value);
          } else {
            key_ = value;
          }
        } else {
          keyBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * key is the position (txIdx, blockHash) of this tx on BTC blockchain
       * Although it is already a part of SubmissionKey, we store it here again
       * to make TransactionInfo self-contained.
       * For example, storing the key allows TransactionInfo to not relay on
       * the fact that TransactionInfo will be ordered in the same order as
       * TransactionKeys in SubmissionKey.
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public Builder clearKey() {
        bitField0_ = (bitField0_ & ~0x00000001);
        key_ = null;
        if (keyBuilder_ != null) {
          keyBuilder_.dispose();
          keyBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * key is the position (txIdx, blockHash) of this tx on BTC blockchain
       * Although it is already a part of SubmissionKey, we store it here again
       * to make TransactionInfo self-contained.
       * For example, storing the key allows TransactionInfo to not relay on
       * the fact that TransactionInfo will be ordered in the same order as
       * TransactionKeys in SubmissionKey.
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder getKeyBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getKeyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * key is the position (txIdx, blockHash) of this tx on BTC blockchain
       * Although it is already a part of SubmissionKey, we store it here again
       * to make TransactionInfo self-contained.
       * For example, storing the key allows TransactionInfo to not relay on
       * the fact that TransactionInfo will be ordered in the same order as
       * TransactionKeys in SubmissionKey.
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder getKeyOrBuilder() {
        if (keyBuilder_ != null) {
          return keyBuilder_.getMessageOrBuilder();
        } else {
          return key_ == null ?
              com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.getDefaultInstance() : key_;
        }
      }
      /**
       * <pre>
       * key is the position (txIdx, blockHash) of this tx on BTC blockchain
       * Although it is already a part of SubmissionKey, we store it here again
       * to make TransactionInfo self-contained.
       * For example, storing the key allows TransactionInfo to not relay on
       * the fact that TransactionInfo will be ordered in the same order as
       * TransactionKeys in SubmissionKey.
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.TransactionKey key = 1 [json_name = "key"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder> 
          getKeyFieldBuilder() {
        if (keyBuilder_ == null) {
          keyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKey.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionKeyOrBuilder>(
                  getKey(),
                  getParentForChildren(),
                  isClean());
          key_ = null;
        }
        return keyBuilder_;
      }

      private com.google.protobuf.ByteString transaction_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * transaction is the full transaction in bytes
       * </pre>
       *
       * <code>bytes transaction = 2 [json_name = "transaction"];</code>
       * @return The transaction.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTransaction() {
        return transaction_;
      }
      /**
       * <pre>
       * transaction is the full transaction in bytes
       * </pre>
       *
       * <code>bytes transaction = 2 [json_name = "transaction"];</code>
       * @param value The transaction to set.
       * @return This builder for chaining.
       */
      public Builder setTransaction(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        transaction_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * transaction is the full transaction in bytes
       * </pre>
       *
       * <code>bytes transaction = 2 [json_name = "transaction"];</code>
       * @return This builder for chaining.
       */
      public Builder clearTransaction() {
        bitField0_ = (bitField0_ & ~0x00000002);
        transaction_ = getDefaultInstance().getTransaction();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString proof_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * proof is the Merkle proof that this tx is included in the position in `key`
       * TODO: maybe it could use here better format as we already processed and
       * validated the proof?
       * </pre>
       *
       * <code>bytes proof = 3 [json_name = "proof"];</code>
       * @return The proof.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getProof() {
        return proof_;
      }
      /**
       * <pre>
       * proof is the Merkle proof that this tx is included in the position in `key`
       * TODO: maybe it could use here better format as we already processed and
       * validated the proof?
       * </pre>
       *
       * <code>bytes proof = 3 [json_name = "proof"];</code>
       * @param value The proof to set.
       * @return This builder for chaining.
       */
      public Builder setProof(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        proof_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * proof is the Merkle proof that this tx is included in the position in `key`
       * TODO: maybe it could use here better format as we already processed and
       * validated the proof?
       * </pre>
       *
       * <code>bytes proof = 3 [json_name = "proof"];</code>
       * @return This builder for chaining.
       */
      public Builder clearProof() {
        bitField0_ = (bitField0_ & ~0x00000004);
        proof_ = getDefaultInstance().getProof();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.btccheckpoint.v1.TransactionInfo)
    }

    // @@protoc_insertion_point(class_scope:babylon.btccheckpoint.v1.TransactionInfo)
    private static final com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo();
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TransactionInfo>
        PARSER = new com.google.protobuf.AbstractParser<TransactionInfo>() {
      @java.lang.Override
      public TransactionInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TransactionInfo> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TransactionInfo> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SubmissionDataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.btccheckpoint.v1.SubmissionData)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * address of the submitter and reporter
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
     * @return Whether the vigilanteAddresses field is set.
     */
    boolean hasVigilanteAddresses();
    /**
     * <pre>
     * address of the submitter and reporter
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
     * @return The vigilanteAddresses.
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses getVigilanteAddresses();
    /**
     * <pre>
     * address of the submitter and reporter
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder getVigilanteAddressesOrBuilder();

    /**
     * <pre>
     * txs_info is the two `TransactionInfo`s corresponding to the submission
     * It is used for
     * - recovering address of sender of btc transaction to payup the reward.
     * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
     * BTC
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
     */
    java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo> 
        getTxsInfoList();
    /**
     * <pre>
     * txs_info is the two `TransactionInfo`s corresponding to the submission
     * It is used for
     * - recovering address of sender of btc transaction to payup the reward.
     * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
     * BTC
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo getTxsInfo(int index);
    /**
     * <pre>
     * txs_info is the two `TransactionInfo`s corresponding to the submission
     * It is used for
     * - recovering address of sender of btc transaction to payup the reward.
     * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
     * BTC
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
     */
    int getTxsInfoCount();
    /**
     * <pre>
     * txs_info is the two `TransactionInfo`s corresponding to the submission
     * It is used for
     * - recovering address of sender of btc transaction to payup the reward.
     * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
     * BTC
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
     */
    java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder> 
        getTxsInfoOrBuilderList();
    /**
     * <pre>
     * txs_info is the two `TransactionInfo`s corresponding to the submission
     * It is used for
     * - recovering address of sender of btc transaction to payup the reward.
     * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
     * BTC
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder getTxsInfoOrBuilder(
        int index);

    /**
     * <code>uint64 epoch = 3 [json_name = "epoch"];</code>
     * @return The epoch.
     */
    long getEpoch();
  }
  /**
   * <pre>
   * TODO: Determine if we should keep any block number or depth info.
   * On one hand it may be useful to determine if block is stable or not, on
   * other depth/block number info, without context (i.e info about chain) is
   * pretty useless and blockhash in enough to retrieve is from lightclient
   * </pre>
   *
   * Protobuf type {@code babylon.btccheckpoint.v1.SubmissionData}
   */
  public static final class SubmissionData extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.btccheckpoint.v1.SubmissionData)
      SubmissionDataOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SubmissionData.newBuilder() to construct.
    private SubmissionData(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SubmissionData() {
      txsInfo_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SubmissionData();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_SubmissionData_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_SubmissionData_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData.Builder.class);
    }

    public static final int VIGILANTE_ADDRESSES_FIELD_NUMBER = 1;
    private com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses vigilanteAddresses_;
    /**
     * <pre>
     * address of the submitter and reporter
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
     * @return Whether the vigilanteAddresses field is set.
     */
    @java.lang.Override
    public boolean hasVigilanteAddresses() {
      return vigilanteAddresses_ != null;
    }
    /**
     * <pre>
     * address of the submitter and reporter
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
     * @return The vigilanteAddresses.
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses getVigilanteAddresses() {
      return vigilanteAddresses_ == null ? com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.getDefaultInstance() : vigilanteAddresses_;
    }
    /**
     * <pre>
     * address of the submitter and reporter
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder getVigilanteAddressesOrBuilder() {
      return vigilanteAddresses_ == null ? com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.getDefaultInstance() : vigilanteAddresses_;
    }

    public static final int TXS_INFO_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo> txsInfo_;
    /**
     * <pre>
     * txs_info is the two `TransactionInfo`s corresponding to the submission
     * It is used for
     * - recovering address of sender of btc transaction to payup the reward.
     * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
     * BTC
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
     */
    @java.lang.Override
    public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo> getTxsInfoList() {
      return txsInfo_;
    }
    /**
     * <pre>
     * txs_info is the two `TransactionInfo`s corresponding to the submission
     * It is used for
     * - recovering address of sender of btc transaction to payup the reward.
     * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
     * BTC
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder> 
        getTxsInfoOrBuilderList() {
      return txsInfo_;
    }
    /**
     * <pre>
     * txs_info is the two `TransactionInfo`s corresponding to the submission
     * It is used for
     * - recovering address of sender of btc transaction to payup the reward.
     * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
     * BTC
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
     */
    @java.lang.Override
    public int getTxsInfoCount() {
      return txsInfo_.size();
    }
    /**
     * <pre>
     * txs_info is the two `TransactionInfo`s corresponding to the submission
     * It is used for
     * - recovering address of sender of btc transaction to payup the reward.
     * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
     * BTC
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo getTxsInfo(int index) {
      return txsInfo_.get(index);
    }
    /**
     * <pre>
     * txs_info is the two `TransactionInfo`s corresponding to the submission
     * It is used for
     * - recovering address of sender of btc transaction to payup the reward.
     * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
     * BTC
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder getTxsInfoOrBuilder(
        int index) {
      return txsInfo_.get(index);
    }

    public static final int EPOCH_FIELD_NUMBER = 3;
    private long epoch_ = 0L;
    /**
     * <code>uint64 epoch = 3 [json_name = "epoch"];</code>
     * @return The epoch.
     */
    @java.lang.Override
    public long getEpoch() {
      return epoch_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (vigilanteAddresses_ != null) {
        output.writeMessage(1, getVigilanteAddresses());
      }
      for (int i = 0; i < txsInfo_.size(); i++) {
        output.writeMessage(2, txsInfo_.get(i));
      }
      if (epoch_ != 0L) {
        output.writeUInt64(3, epoch_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (vigilanteAddresses_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getVigilanteAddresses());
      }
      for (int i = 0; i < txsInfo_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, txsInfo_.get(i));
      }
      if (epoch_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, epoch_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData)) {
        return super.equals(obj);
      }
      com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData other = (com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData) obj;

      if (hasVigilanteAddresses() != other.hasVigilanteAddresses()) return false;
      if (hasVigilanteAddresses()) {
        if (!getVigilanteAddresses()
            .equals(other.getVigilanteAddresses())) return false;
      }
      if (!getTxsInfoList()
          .equals(other.getTxsInfoList())) return false;
      if (getEpoch()
          != other.getEpoch()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasVigilanteAddresses()) {
        hash = (37 * hash) + VIGILANTE_ADDRESSES_FIELD_NUMBER;
        hash = (53 * hash) + getVigilanteAddresses().hashCode();
      }
      if (getTxsInfoCount() > 0) {
        hash = (37 * hash) + TXS_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getTxsInfoList().hashCode();
      }
      hash = (37 * hash) + EPOCH_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getEpoch());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * TODO: Determine if we should keep any block number or depth info.
     * On one hand it may be useful to determine if block is stable or not, on
     * other depth/block number info, without context (i.e info about chain) is
     * pretty useless and blockhash in enough to retrieve is from lightclient
     * </pre>
     *
     * Protobuf type {@code babylon.btccheckpoint.v1.SubmissionData}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.btccheckpoint.v1.SubmissionData)
        com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionDataOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_SubmissionData_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_SubmissionData_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData.Builder.class);
      }

      // Construct using com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        vigilanteAddresses_ = null;
        if (vigilanteAddressesBuilder_ != null) {
          vigilanteAddressesBuilder_.dispose();
          vigilanteAddressesBuilder_ = null;
        }
        if (txsInfoBuilder_ == null) {
          txsInfo_ = java.util.Collections.emptyList();
        } else {
          txsInfo_ = null;
          txsInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        epoch_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_SubmissionData_descriptor;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData getDefaultInstanceForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData build() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData buildPartial() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData result = new com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData result) {
        if (txsInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            txsInfo_ = java.util.Collections.unmodifiableList(txsInfo_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.txsInfo_ = txsInfo_;
        } else {
          result.txsInfo_ = txsInfoBuilder_.build();
        }
      }

      private void buildPartial0(com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.vigilanteAddresses_ = vigilanteAddressesBuilder_ == null
              ? vigilanteAddresses_
              : vigilanteAddressesBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.epoch_ = epoch_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData) {
          return mergeFrom((com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData other) {
        if (other == com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData.getDefaultInstance()) return this;
        if (other.hasVigilanteAddresses()) {
          mergeVigilanteAddresses(other.getVigilanteAddresses());
        }
        if (txsInfoBuilder_ == null) {
          if (!other.txsInfo_.isEmpty()) {
            if (txsInfo_.isEmpty()) {
              txsInfo_ = other.txsInfo_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureTxsInfoIsMutable();
              txsInfo_.addAll(other.txsInfo_);
            }
            onChanged();
          }
        } else {
          if (!other.txsInfo_.isEmpty()) {
            if (txsInfoBuilder_.isEmpty()) {
              txsInfoBuilder_.dispose();
              txsInfoBuilder_ = null;
              txsInfo_ = other.txsInfo_;
              bitField0_ = (bitField0_ & ~0x00000002);
              txsInfoBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getTxsInfoFieldBuilder() : null;
            } else {
              txsInfoBuilder_.addAllMessages(other.txsInfo_);
            }
          }
        }
        if (other.getEpoch() != 0L) {
          setEpoch(other.getEpoch());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getVigilanteAddressesFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo m =
                    input.readMessage(
                        com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.parser(),
                        extensionRegistry);
                if (txsInfoBuilder_ == null) {
                  ensureTxsInfoIsMutable();
                  txsInfo_.add(m);
                } else {
                  txsInfoBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 24: {
                epoch_ = input.readUInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses vigilanteAddresses_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder> vigilanteAddressesBuilder_;
      /**
       * <pre>
       * address of the submitter and reporter
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
       * @return Whether the vigilanteAddresses field is set.
       */
      public boolean hasVigilanteAddresses() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * address of the submitter and reporter
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
       * @return The vigilanteAddresses.
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses getVigilanteAddresses() {
        if (vigilanteAddressesBuilder_ == null) {
          return vigilanteAddresses_ == null ? com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.getDefaultInstance() : vigilanteAddresses_;
        } else {
          return vigilanteAddressesBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * address of the submitter and reporter
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
       */
      public Builder setVigilanteAddresses(com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses value) {
        if (vigilanteAddressesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          vigilanteAddresses_ = value;
        } else {
          vigilanteAddressesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * address of the submitter and reporter
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
       */
      public Builder setVigilanteAddresses(
          com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder builderForValue) {
        if (vigilanteAddressesBuilder_ == null) {
          vigilanteAddresses_ = builderForValue.build();
        } else {
          vigilanteAddressesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * address of the submitter and reporter
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
       */
      public Builder mergeVigilanteAddresses(com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses value) {
        if (vigilanteAddressesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            vigilanteAddresses_ != null &&
            vigilanteAddresses_ != com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.getDefaultInstance()) {
            getVigilanteAddressesBuilder().mergeFrom(value);
          } else {
            vigilanteAddresses_ = value;
          }
        } else {
          vigilanteAddressesBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * address of the submitter and reporter
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
       */
      public Builder clearVigilanteAddresses() {
        bitField0_ = (bitField0_ & ~0x00000001);
        vigilanteAddresses_ = null;
        if (vigilanteAddressesBuilder_ != null) {
          vigilanteAddressesBuilder_.dispose();
          vigilanteAddressesBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * address of the submitter and reporter
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder getVigilanteAddressesBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getVigilanteAddressesFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * address of the submitter and reporter
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder getVigilanteAddressesOrBuilder() {
        if (vigilanteAddressesBuilder_ != null) {
          return vigilanteAddressesBuilder_.getMessageOrBuilder();
        } else {
          return vigilanteAddresses_ == null ?
              com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.getDefaultInstance() : vigilanteAddresses_;
        }
      }
      /**
       * <pre>
       * address of the submitter and reporter
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.CheckpointAddresses vigilante_addresses = 1 [json_name = "vigilanteAddresses"];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder> 
          getVigilanteAddressesFieldBuilder() {
        if (vigilanteAddressesBuilder_ == null) {
          vigilanteAddressesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder>(
                  getVigilanteAddresses(),
                  getParentForChildren(),
                  isClean());
          vigilanteAddresses_ = null;
        }
        return vigilanteAddressesBuilder_;
      }

      private java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo> txsInfo_ =
        java.util.Collections.emptyList();
      private void ensureTxsInfoIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          txsInfo_ = new java.util.ArrayList<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo>(txsInfo_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder> txsInfoBuilder_;

      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo> getTxsInfoList() {
        if (txsInfoBuilder_ == null) {
          return java.util.Collections.unmodifiableList(txsInfo_);
        } else {
          return txsInfoBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public int getTxsInfoCount() {
        if (txsInfoBuilder_ == null) {
          return txsInfo_.size();
        } else {
          return txsInfoBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo getTxsInfo(int index) {
        if (txsInfoBuilder_ == null) {
          return txsInfo_.get(index);
        } else {
          return txsInfoBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public Builder setTxsInfo(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo value) {
        if (txsInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTxsInfoIsMutable();
          txsInfo_.set(index, value);
          onChanged();
        } else {
          txsInfoBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public Builder setTxsInfo(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder builderForValue) {
        if (txsInfoBuilder_ == null) {
          ensureTxsInfoIsMutable();
          txsInfo_.set(index, builderForValue.build());
          onChanged();
        } else {
          txsInfoBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public Builder addTxsInfo(com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo value) {
        if (txsInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTxsInfoIsMutable();
          txsInfo_.add(value);
          onChanged();
        } else {
          txsInfoBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public Builder addTxsInfo(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo value) {
        if (txsInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTxsInfoIsMutable();
          txsInfo_.add(index, value);
          onChanged();
        } else {
          txsInfoBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public Builder addTxsInfo(
          com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder builderForValue) {
        if (txsInfoBuilder_ == null) {
          ensureTxsInfoIsMutable();
          txsInfo_.add(builderForValue.build());
          onChanged();
        } else {
          txsInfoBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public Builder addTxsInfo(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder builderForValue) {
        if (txsInfoBuilder_ == null) {
          ensureTxsInfoIsMutable();
          txsInfo_.add(index, builderForValue.build());
          onChanged();
        } else {
          txsInfoBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public Builder addAllTxsInfo(
          java.lang.Iterable<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo> values) {
        if (txsInfoBuilder_ == null) {
          ensureTxsInfoIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, txsInfo_);
          onChanged();
        } else {
          txsInfoBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public Builder clearTxsInfo() {
        if (txsInfoBuilder_ == null) {
          txsInfo_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          txsInfoBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public Builder removeTxsInfo(int index) {
        if (txsInfoBuilder_ == null) {
          ensureTxsInfoIsMutable();
          txsInfo_.remove(index);
          onChanged();
        } else {
          txsInfoBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder getTxsInfoBuilder(
          int index) {
        return getTxsInfoFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder getTxsInfoOrBuilder(
          int index) {
        if (txsInfoBuilder_ == null) {
          return txsInfo_.get(index);  } else {
          return txsInfoBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder> 
           getTxsInfoOrBuilderList() {
        if (txsInfoBuilder_ != null) {
          return txsInfoBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(txsInfo_);
        }
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder addTxsInfoBuilder() {
        return getTxsInfoFieldBuilder().addBuilder(
            com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.getDefaultInstance());
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder addTxsInfoBuilder(
          int index) {
        return getTxsInfoFieldBuilder().addBuilder(
            index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.getDefaultInstance());
      }
      /**
       * <pre>
       * txs_info is the two `TransactionInfo`s corresponding to the submission
       * It is used for
       * - recovering address of sender of btc transaction to payup the reward.
       * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
       * BTC
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo txs_info = 2 [json_name = "txsInfo"];</code>
       */
      public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder> 
           getTxsInfoBuilderList() {
        return getTxsInfoFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder> 
          getTxsInfoFieldBuilder() {
        if (txsInfoBuilder_ == null) {
          txsInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder>(
                  txsInfo_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          txsInfo_ = null;
        }
        return txsInfoBuilder_;
      }

      private long epoch_ ;
      /**
       * <code>uint64 epoch = 3 [json_name = "epoch"];</code>
       * @return The epoch.
       */
      @java.lang.Override
      public long getEpoch() {
        return epoch_;
      }
      /**
       * <code>uint64 epoch = 3 [json_name = "epoch"];</code>
       * @param value The epoch to set.
       * @return This builder for chaining.
       */
      public Builder setEpoch(long value) {

        epoch_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>uint64 epoch = 3 [json_name = "epoch"];</code>
       * @return This builder for chaining.
       */
      public Builder clearEpoch() {
        bitField0_ = (bitField0_ & ~0x00000004);
        epoch_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.btccheckpoint.v1.SubmissionData)
    }

    // @@protoc_insertion_point(class_scope:babylon.btccheckpoint.v1.SubmissionData)
    private static final com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData();
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SubmissionData>
        PARSER = new com.google.protobuf.AbstractParser<SubmissionData>() {
      @java.lang.Override
      public SubmissionData parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SubmissionData> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SubmissionData> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionData getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface EpochDataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.btccheckpoint.v1.EpochData)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * keys is the list of all received checkpoints during this epoch, sorted by
     * order of submission.
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
     */
    java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey> 
        getKeysList();
    /**
     * <pre>
     * keys is the list of all received checkpoints during this epoch, sorted by
     * order of submission.
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey getKeys(int index);
    /**
     * <pre>
     * keys is the list of all received checkpoints during this epoch, sorted by
     * order of submission.
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
     */
    int getKeysCount();
    /**
     * <pre>
     * keys is the list of all received checkpoints during this epoch, sorted by
     * order of submission.
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
     */
    java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder> 
        getKeysOrBuilderList();
    /**
     * <pre>
     * keys is the list of all received checkpoints during this epoch, sorted by
     * order of submission.
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder getKeysOrBuilder(
        int index);

    /**
     * <pre>
     * status is the current btc status of the epoch
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.BtcStatus status = 2 [json_name = "status"];</code>
     * @return The enum numeric value on the wire for status.
     */
    int getStatusValue();
    /**
     * <pre>
     * status is the current btc status of the epoch
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.BtcStatus status = 2 [json_name = "status"];</code>
     * @return The status.
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.BtcStatus getStatus();
  }
  /**
   * <pre>
   * Data stored in db and indexed by epoch number
   * TODO: Add btc blockheight at epoch end, when adding handling of epoching
   * callbacks
   * </pre>
   *
   * Protobuf type {@code babylon.btccheckpoint.v1.EpochData}
   */
  public static final class EpochData extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.btccheckpoint.v1.EpochData)
      EpochDataOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use EpochData.newBuilder() to construct.
    private EpochData(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private EpochData() {
      keys_ = java.util.Collections.emptyList();
      status_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new EpochData();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_EpochData_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_EpochData_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData.Builder.class);
    }

    public static final int KEYS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey> keys_;
    /**
     * <pre>
     * keys is the list of all received checkpoints during this epoch, sorted by
     * order of submission.
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
     */
    @java.lang.Override
    public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey> getKeysList() {
      return keys_;
    }
    /**
     * <pre>
     * keys is the list of all received checkpoints during this epoch, sorted by
     * order of submission.
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder> 
        getKeysOrBuilderList() {
      return keys_;
    }
    /**
     * <pre>
     * keys is the list of all received checkpoints during this epoch, sorted by
     * order of submission.
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
     */
    @java.lang.Override
    public int getKeysCount() {
      return keys_.size();
    }
    /**
     * <pre>
     * keys is the list of all received checkpoints during this epoch, sorted by
     * order of submission.
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey getKeys(int index) {
      return keys_.get(index);
    }
    /**
     * <pre>
     * keys is the list of all received checkpoints during this epoch, sorted by
     * order of submission.
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder getKeysOrBuilder(
        int index) {
      return keys_.get(index);
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    private int status_ = 0;
    /**
     * <pre>
     * status is the current btc status of the epoch
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.BtcStatus status = 2 [json_name = "status"];</code>
     * @return The enum numeric value on the wire for status.
     */
    @java.lang.Override public int getStatusValue() {
      return status_;
    }
    /**
     * <pre>
     * status is the current btc status of the epoch
     * </pre>
     *
     * <code>.babylon.btccheckpoint.v1.BtcStatus status = 2 [json_name = "status"];</code>
     * @return The status.
     */
    @java.lang.Override public com.babylon.btccheckpoint.v1.BtccheckpointProto.BtcStatus getStatus() {
      com.babylon.btccheckpoint.v1.BtccheckpointProto.BtcStatus result = com.babylon.btccheckpoint.v1.BtccheckpointProto.BtcStatus.forNumber(status_);
      return result == null ? com.babylon.btccheckpoint.v1.BtccheckpointProto.BtcStatus.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < keys_.size(); i++) {
        output.writeMessage(1, keys_.get(i));
      }
      if (status_ != com.babylon.btccheckpoint.v1.BtccheckpointProto.BtcStatus.EPOCH_STATUS_SUBMITTED.getNumber()) {
        output.writeEnum(2, status_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < keys_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, keys_.get(i));
      }
      if (status_ != com.babylon.btccheckpoint.v1.BtccheckpointProto.BtcStatus.EPOCH_STATUS_SUBMITTED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, status_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData)) {
        return super.equals(obj);
      }
      com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData other = (com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData) obj;

      if (!getKeysList()
          .equals(other.getKeysList())) return false;
      if (status_ != other.status_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getKeysCount() > 0) {
        hash = (37 * hash) + KEYS_FIELD_NUMBER;
        hash = (53 * hash) + getKeysList().hashCode();
      }
      hash = (37 * hash) + STATUS_FIELD_NUMBER;
      hash = (53 * hash) + status_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Data stored in db and indexed by epoch number
     * TODO: Add btc blockheight at epoch end, when adding handling of epoching
     * callbacks
     * </pre>
     *
     * Protobuf type {@code babylon.btccheckpoint.v1.EpochData}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.btccheckpoint.v1.EpochData)
        com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochDataOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_EpochData_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_EpochData_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData.Builder.class);
      }

      // Construct using com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (keysBuilder_ == null) {
          keys_ = java.util.Collections.emptyList();
        } else {
          keys_ = null;
          keysBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        status_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_EpochData_descriptor;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData getDefaultInstanceForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData build() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData buildPartial() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData result = new com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData result) {
        if (keysBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            keys_ = java.util.Collections.unmodifiableList(keys_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.keys_ = keys_;
        } else {
          result.keys_ = keysBuilder_.build();
        }
      }

      private void buildPartial0(com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.status_ = status_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData) {
          return mergeFrom((com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData other) {
        if (other == com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData.getDefaultInstance()) return this;
        if (keysBuilder_ == null) {
          if (!other.keys_.isEmpty()) {
            if (keys_.isEmpty()) {
              keys_ = other.keys_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureKeysIsMutable();
              keys_.addAll(other.keys_);
            }
            onChanged();
          }
        } else {
          if (!other.keys_.isEmpty()) {
            if (keysBuilder_.isEmpty()) {
              keysBuilder_.dispose();
              keysBuilder_ = null;
              keys_ = other.keys_;
              bitField0_ = (bitField0_ & ~0x00000001);
              keysBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getKeysFieldBuilder() : null;
            } else {
              keysBuilder_.addAllMessages(other.keys_);
            }
          }
        }
        if (other.status_ != 0) {
          setStatusValue(other.getStatusValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey m =
                    input.readMessage(
                        com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.parser(),
                        extensionRegistry);
                if (keysBuilder_ == null) {
                  ensureKeysIsMutable();
                  keys_.add(m);
                } else {
                  keysBuilder_.addMessage(m);
                }
                break;
              } // case 10
              case 16: {
                status_ = input.readEnum();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey> keys_ =
        java.util.Collections.emptyList();
      private void ensureKeysIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          keys_ = new java.util.ArrayList<com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey>(keys_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder> keysBuilder_;

      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey> getKeysList() {
        if (keysBuilder_ == null) {
          return java.util.Collections.unmodifiableList(keys_);
        } else {
          return keysBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public int getKeysCount() {
        if (keysBuilder_ == null) {
          return keys_.size();
        } else {
          return keysBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey getKeys(int index) {
        if (keysBuilder_ == null) {
          return keys_.get(index);
        } else {
          return keysBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public Builder setKeys(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey value) {
        if (keysBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeysIsMutable();
          keys_.set(index, value);
          onChanged();
        } else {
          keysBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public Builder setKeys(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder builderForValue) {
        if (keysBuilder_ == null) {
          ensureKeysIsMutable();
          keys_.set(index, builderForValue.build());
          onChanged();
        } else {
          keysBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public Builder addKeys(com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey value) {
        if (keysBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeysIsMutable();
          keys_.add(value);
          onChanged();
        } else {
          keysBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public Builder addKeys(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey value) {
        if (keysBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeysIsMutable();
          keys_.add(index, value);
          onChanged();
        } else {
          keysBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public Builder addKeys(
          com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder builderForValue) {
        if (keysBuilder_ == null) {
          ensureKeysIsMutable();
          keys_.add(builderForValue.build());
          onChanged();
        } else {
          keysBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public Builder addKeys(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder builderForValue) {
        if (keysBuilder_ == null) {
          ensureKeysIsMutable();
          keys_.add(index, builderForValue.build());
          onChanged();
        } else {
          keysBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public Builder addAllKeys(
          java.lang.Iterable<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey> values) {
        if (keysBuilder_ == null) {
          ensureKeysIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, keys_);
          onChanged();
        } else {
          keysBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public Builder clearKeys() {
        if (keysBuilder_ == null) {
          keys_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          keysBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public Builder removeKeys(int index) {
        if (keysBuilder_ == null) {
          ensureKeysIsMutable();
          keys_.remove(index);
          onChanged();
        } else {
          keysBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder getKeysBuilder(
          int index) {
        return getKeysFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder getKeysOrBuilder(
          int index) {
        if (keysBuilder_ == null) {
          return keys_.get(index);  } else {
          return keysBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder> 
           getKeysOrBuilderList() {
        if (keysBuilder_ != null) {
          return keysBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(keys_);
        }
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder addKeysBuilder() {
        return getKeysFieldBuilder().addBuilder(
            com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.getDefaultInstance());
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder addKeysBuilder(
          int index) {
        return getKeysFieldBuilder().addBuilder(
            index, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.getDefaultInstance());
      }
      /**
       * <pre>
       * keys is the list of all received checkpoints during this epoch, sorted by
       * order of submission.
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.SubmissionKey keys = 1 [json_name = "keys"];</code>
       */
      public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder> 
           getKeysBuilderList() {
        return getKeysFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder> 
          getKeysFieldBuilder() {
        if (keysBuilder_ == null) {
          keysBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKey.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.SubmissionKeyOrBuilder>(
                  keys_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          keys_ = null;
        }
        return keysBuilder_;
      }

      private int status_ = 0;
      /**
       * <pre>
       * status is the current btc status of the epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.BtcStatus status = 2 [json_name = "status"];</code>
       * @return The enum numeric value on the wire for status.
       */
      @java.lang.Override public int getStatusValue() {
        return status_;
      }
      /**
       * <pre>
       * status is the current btc status of the epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.BtcStatus status = 2 [json_name = "status"];</code>
       * @param value The enum numeric value on the wire for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusValue(int value) {
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * status is the current btc status of the epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.BtcStatus status = 2 [json_name = "status"];</code>
       * @return The status.
       */
      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.BtcStatus getStatus() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.BtcStatus result = com.babylon.btccheckpoint.v1.BtccheckpointProto.BtcStatus.forNumber(status_);
        return result == null ? com.babylon.btccheckpoint.v1.BtccheckpointProto.BtcStatus.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * status is the current btc status of the epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.BtcStatus status = 2 [json_name = "status"];</code>
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(com.babylon.btccheckpoint.v1.BtccheckpointProto.BtcStatus value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        status_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * status is the current btc status of the epoch
       * </pre>
       *
       * <code>.babylon.btccheckpoint.v1.BtcStatus status = 2 [json_name = "status"];</code>
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000002);
        status_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.btccheckpoint.v1.EpochData)
    }

    // @@protoc_insertion_point(class_scope:babylon.btccheckpoint.v1.EpochData)
    private static final com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData();
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<EpochData>
        PARSER = new com.google.protobuf.AbstractParser<EpochData>() {
      @java.lang.Override
      public EpochData parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<EpochData> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<EpochData> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.EpochData getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CheckpointAddressesOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.btccheckpoint.v1.CheckpointAddresses)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * TODO: this could probably be better typed
     * submitter is the address of the checkpoint submitter to BTC, extracted from
     * the checkpoint itself.
     * </pre>
     *
     * <code>bytes submitter = 1 [json_name = "submitter"];</code>
     * @return The submitter.
     */
    com.google.protobuf.ByteString getSubmitter();

    /**
     * <pre>
     * reporter is the address of the reporter who reported the submissions,
     * calculated from submission message MsgInsertBTCSpvProof itself
     * </pre>
     *
     * <code>bytes reporter = 2 [json_name = "reporter"];</code>
     * @return The reporter.
     */
    com.google.protobuf.ByteString getReporter();
  }
  /**
   * <pre>
   * CheckpointAddresses contains the addresses of the submitter and reporter of a
   * given checkpoint
   * </pre>
   *
   * Protobuf type {@code babylon.btccheckpoint.v1.CheckpointAddresses}
   */
  public static final class CheckpointAddresses extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.btccheckpoint.v1.CheckpointAddresses)
      CheckpointAddressesOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CheckpointAddresses.newBuilder() to construct.
    private CheckpointAddresses(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CheckpointAddresses() {
      submitter_ = com.google.protobuf.ByteString.EMPTY;
      reporter_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new CheckpointAddresses();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_CheckpointAddresses_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_CheckpointAddresses_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder.class);
    }

    public static final int SUBMITTER_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString submitter_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * TODO: this could probably be better typed
     * submitter is the address of the checkpoint submitter to BTC, extracted from
     * the checkpoint itself.
     * </pre>
     *
     * <code>bytes submitter = 1 [json_name = "submitter"];</code>
     * @return The submitter.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSubmitter() {
      return submitter_;
    }

    public static final int REPORTER_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString reporter_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * reporter is the address of the reporter who reported the submissions,
     * calculated from submission message MsgInsertBTCSpvProof itself
     * </pre>
     *
     * <code>bytes reporter = 2 [json_name = "reporter"];</code>
     * @return The reporter.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getReporter() {
      return reporter_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!submitter_.isEmpty()) {
        output.writeBytes(1, submitter_);
      }
      if (!reporter_.isEmpty()) {
        output.writeBytes(2, reporter_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!submitter_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, submitter_);
      }
      if (!reporter_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, reporter_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses)) {
        return super.equals(obj);
      }
      com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses other = (com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses) obj;

      if (!getSubmitter()
          .equals(other.getSubmitter())) return false;
      if (!getReporter()
          .equals(other.getReporter())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SUBMITTER_FIELD_NUMBER;
      hash = (53 * hash) + getSubmitter().hashCode();
      hash = (37 * hash) + REPORTER_FIELD_NUMBER;
      hash = (53 * hash) + getReporter().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * CheckpointAddresses contains the addresses of the submitter and reporter of a
     * given checkpoint
     * </pre>
     *
     * Protobuf type {@code babylon.btccheckpoint.v1.CheckpointAddresses}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.btccheckpoint.v1.CheckpointAddresses)
        com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_CheckpointAddresses_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_CheckpointAddresses_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder.class);
      }

      // Construct using com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        submitter_ = com.google.protobuf.ByteString.EMPTY;
        reporter_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_CheckpointAddresses_descriptor;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses getDefaultInstanceForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses build() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses buildPartial() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses result = new com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.submitter_ = submitter_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.reporter_ = reporter_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses) {
          return mergeFrom((com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses other) {
        if (other == com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.getDefaultInstance()) return this;
        if (other.getSubmitter() != com.google.protobuf.ByteString.EMPTY) {
          setSubmitter(other.getSubmitter());
        }
        if (other.getReporter() != com.google.protobuf.ByteString.EMPTY) {
          setReporter(other.getReporter());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                submitter_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                reporter_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString submitter_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * TODO: this could probably be better typed
       * submitter is the address of the checkpoint submitter to BTC, extracted from
       * the checkpoint itself.
       * </pre>
       *
       * <code>bytes submitter = 1 [json_name = "submitter"];</code>
       * @return The submitter.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSubmitter() {
        return submitter_;
      }
      /**
       * <pre>
       * TODO: this could probably be better typed
       * submitter is the address of the checkpoint submitter to BTC, extracted from
       * the checkpoint itself.
       * </pre>
       *
       * <code>bytes submitter = 1 [json_name = "submitter"];</code>
       * @param value The submitter to set.
       * @return This builder for chaining.
       */
      public Builder setSubmitter(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        submitter_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TODO: this could probably be better typed
       * submitter is the address of the checkpoint submitter to BTC, extracted from
       * the checkpoint itself.
       * </pre>
       *
       * <code>bytes submitter = 1 [json_name = "submitter"];</code>
       * @return This builder for chaining.
       */
      public Builder clearSubmitter() {
        bitField0_ = (bitField0_ & ~0x00000001);
        submitter_ = getDefaultInstance().getSubmitter();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString reporter_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * reporter is the address of the reporter who reported the submissions,
       * calculated from submission message MsgInsertBTCSpvProof itself
       * </pre>
       *
       * <code>bytes reporter = 2 [json_name = "reporter"];</code>
       * @return The reporter.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getReporter() {
        return reporter_;
      }
      /**
       * <pre>
       * reporter is the address of the reporter who reported the submissions,
       * calculated from submission message MsgInsertBTCSpvProof itself
       * </pre>
       *
       * <code>bytes reporter = 2 [json_name = "reporter"];</code>
       * @param value The reporter to set.
       * @return This builder for chaining.
       */
      public Builder setReporter(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        reporter_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * reporter is the address of the reporter who reported the submissions,
       * calculated from submission message MsgInsertBTCSpvProof itself
       * </pre>
       *
       * <code>bytes reporter = 2 [json_name = "reporter"];</code>
       * @return This builder for chaining.
       */
      public Builder clearReporter() {
        bitField0_ = (bitField0_ & ~0x00000002);
        reporter_ = getDefaultInstance().getReporter();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.btccheckpoint.v1.CheckpointAddresses)
    }

    // @@protoc_insertion_point(class_scope:babylon.btccheckpoint.v1.CheckpointAddresses)
    private static final com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses();
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CheckpointAddresses>
        PARSER = new com.google.protobuf.AbstractParser<CheckpointAddresses>() {
      @java.lang.Override
      public CheckpointAddresses parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CheckpointAddresses> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CheckpointAddresses> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface BTCCheckpointInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:babylon.btccheckpoint.v1.BTCCheckpointInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * epoch number of this checkpoint
     * </pre>
     *
     * <code>uint64 epoch_number = 1 [json_name = "epochNumber"];</code>
     * @return The epochNumber.
     */
    long getEpochNumber();

    /**
     * <pre>
     * btc height of the best submission of the epoch
     * </pre>
     *
     * <code>uint32 best_submission_btc_block_height = 2 [json_name = "bestSubmissionBtcBlockHeight"];</code>
     * @return The bestSubmissionBtcBlockHeight.
     */
    int getBestSubmissionBtcBlockHeight();

    /**
     * <pre>
     * hash of the btc block which determines checkpoint btc block height i.e.
     * youngest block of best submission
     * </pre>
     *
     * <code>bytes best_submission_btc_block_hash = 3 [json_name = "bestSubmissionBtcBlockHash", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderHashBytes"];</code>
     * @return The bestSubmissionBtcBlockHash.
     */
    com.google.protobuf.ByteString getBestSubmissionBtcBlockHash();

    /**
     * <pre>
     * the BTC checkpoint transactions of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
     */
    java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo> 
        getBestSubmissionTransactionsList();
    /**
     * <pre>
     * the BTC checkpoint transactions of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo getBestSubmissionTransactions(int index);
    /**
     * <pre>
     * the BTC checkpoint transactions of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
     */
    int getBestSubmissionTransactionsCount();
    /**
     * <pre>
     * the BTC checkpoint transactions of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
     */
    java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder> 
        getBestSubmissionTransactionsOrBuilderList();
    /**
     * <pre>
     * the BTC checkpoint transactions of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder getBestSubmissionTransactionsOrBuilder(
        int index);

    /**
     * <pre>
     * list of vigilantes' addresses of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
     */
    java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses> 
        getBestSubmissionVigilanteAddressListList();
    /**
     * <pre>
     * list of vigilantes' addresses of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses getBestSubmissionVigilanteAddressList(int index);
    /**
     * <pre>
     * list of vigilantes' addresses of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
     */
    int getBestSubmissionVigilanteAddressListCount();
    /**
     * <pre>
     * list of vigilantes' addresses of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
     */
    java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder> 
        getBestSubmissionVigilanteAddressListOrBuilderList();
    /**
     * <pre>
     * list of vigilantes' addresses of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
     */
    com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder getBestSubmissionVigilanteAddressListOrBuilder(
        int index);
  }
  /**
   * <pre>
   * BTCCheckpointInfo contains all data about best submission of checkpoint for
   * given epoch. Best submission is the submission which is deeper in btc ledger
   * </pre>
   *
   * Protobuf type {@code babylon.btccheckpoint.v1.BTCCheckpointInfo}
   */
  public static final class BTCCheckpointInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:babylon.btccheckpoint.v1.BTCCheckpointInfo)
      BTCCheckpointInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use BTCCheckpointInfo.newBuilder() to construct.
    private BTCCheckpointInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private BTCCheckpointInfo() {
      bestSubmissionBtcBlockHash_ = com.google.protobuf.ByteString.EMPTY;
      bestSubmissionTransactions_ = java.util.Collections.emptyList();
      bestSubmissionVigilanteAddressList_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new BTCCheckpointInfo();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_BTCCheckpointInfo_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_BTCCheckpointInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo.Builder.class);
    }

    public static final int EPOCH_NUMBER_FIELD_NUMBER = 1;
    private long epochNumber_ = 0L;
    /**
     * <pre>
     * epoch number of this checkpoint
     * </pre>
     *
     * <code>uint64 epoch_number = 1 [json_name = "epochNumber"];</code>
     * @return The epochNumber.
     */
    @java.lang.Override
    public long getEpochNumber() {
      return epochNumber_;
    }

    public static final int BEST_SUBMISSION_BTC_BLOCK_HEIGHT_FIELD_NUMBER = 2;
    private int bestSubmissionBtcBlockHeight_ = 0;
    /**
     * <pre>
     * btc height of the best submission of the epoch
     * </pre>
     *
     * <code>uint32 best_submission_btc_block_height = 2 [json_name = "bestSubmissionBtcBlockHeight"];</code>
     * @return The bestSubmissionBtcBlockHeight.
     */
    @java.lang.Override
    public int getBestSubmissionBtcBlockHeight() {
      return bestSubmissionBtcBlockHeight_;
    }

    public static final int BEST_SUBMISSION_BTC_BLOCK_HASH_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString bestSubmissionBtcBlockHash_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * hash of the btc block which determines checkpoint btc block height i.e.
     * youngest block of best submission
     * </pre>
     *
     * <code>bytes best_submission_btc_block_hash = 3 [json_name = "bestSubmissionBtcBlockHash", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderHashBytes"];</code>
     * @return The bestSubmissionBtcBlockHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBestSubmissionBtcBlockHash() {
      return bestSubmissionBtcBlockHash_;
    }

    public static final int BEST_SUBMISSION_TRANSACTIONS_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo> bestSubmissionTransactions_;
    /**
     * <pre>
     * the BTC checkpoint transactions of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
     */
    @java.lang.Override
    public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo> getBestSubmissionTransactionsList() {
      return bestSubmissionTransactions_;
    }
    /**
     * <pre>
     * the BTC checkpoint transactions of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder> 
        getBestSubmissionTransactionsOrBuilderList() {
      return bestSubmissionTransactions_;
    }
    /**
     * <pre>
     * the BTC checkpoint transactions of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
     */
    @java.lang.Override
    public int getBestSubmissionTransactionsCount() {
      return bestSubmissionTransactions_.size();
    }
    /**
     * <pre>
     * the BTC checkpoint transactions of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo getBestSubmissionTransactions(int index) {
      return bestSubmissionTransactions_.get(index);
    }
    /**
     * <pre>
     * the BTC checkpoint transactions of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder getBestSubmissionTransactionsOrBuilder(
        int index) {
      return bestSubmissionTransactions_.get(index);
    }

    public static final int BEST_SUBMISSION_VIGILANTE_ADDRESS_LIST_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses> bestSubmissionVigilanteAddressList_;
    /**
     * <pre>
     * list of vigilantes' addresses of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
     */
    @java.lang.Override
    public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses> getBestSubmissionVigilanteAddressListList() {
      return bestSubmissionVigilanteAddressList_;
    }
    /**
     * <pre>
     * list of vigilantes' addresses of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
     */
    @java.lang.Override
    public java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder> 
        getBestSubmissionVigilanteAddressListOrBuilderList() {
      return bestSubmissionVigilanteAddressList_;
    }
    /**
     * <pre>
     * list of vigilantes' addresses of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
     */
    @java.lang.Override
    public int getBestSubmissionVigilanteAddressListCount() {
      return bestSubmissionVigilanteAddressList_.size();
    }
    /**
     * <pre>
     * list of vigilantes' addresses of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses getBestSubmissionVigilanteAddressList(int index) {
      return bestSubmissionVigilanteAddressList_.get(index);
    }
    /**
     * <pre>
     * list of vigilantes' addresses of the best submission
     * </pre>
     *
     * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
     */
    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder getBestSubmissionVigilanteAddressListOrBuilder(
        int index) {
      return bestSubmissionVigilanteAddressList_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (epochNumber_ != 0L) {
        output.writeUInt64(1, epochNumber_);
      }
      if (bestSubmissionBtcBlockHeight_ != 0) {
        output.writeUInt32(2, bestSubmissionBtcBlockHeight_);
      }
      if (!bestSubmissionBtcBlockHash_.isEmpty()) {
        output.writeBytes(3, bestSubmissionBtcBlockHash_);
      }
      for (int i = 0; i < bestSubmissionTransactions_.size(); i++) {
        output.writeMessage(4, bestSubmissionTransactions_.get(i));
      }
      for (int i = 0; i < bestSubmissionVigilanteAddressList_.size(); i++) {
        output.writeMessage(5, bestSubmissionVigilanteAddressList_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (epochNumber_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, epochNumber_);
      }
      if (bestSubmissionBtcBlockHeight_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, bestSubmissionBtcBlockHeight_);
      }
      if (!bestSubmissionBtcBlockHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, bestSubmissionBtcBlockHash_);
      }
      for (int i = 0; i < bestSubmissionTransactions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, bestSubmissionTransactions_.get(i));
      }
      for (int i = 0; i < bestSubmissionVigilanteAddressList_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, bestSubmissionVigilanteAddressList_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo)) {
        return super.equals(obj);
      }
      com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo other = (com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo) obj;

      if (getEpochNumber()
          != other.getEpochNumber()) return false;
      if (getBestSubmissionBtcBlockHeight()
          != other.getBestSubmissionBtcBlockHeight()) return false;
      if (!getBestSubmissionBtcBlockHash()
          .equals(other.getBestSubmissionBtcBlockHash())) return false;
      if (!getBestSubmissionTransactionsList()
          .equals(other.getBestSubmissionTransactionsList())) return false;
      if (!getBestSubmissionVigilanteAddressListList()
          .equals(other.getBestSubmissionVigilanteAddressListList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + EPOCH_NUMBER_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getEpochNumber());
      hash = (37 * hash) + BEST_SUBMISSION_BTC_BLOCK_HEIGHT_FIELD_NUMBER;
      hash = (53 * hash) + getBestSubmissionBtcBlockHeight();
      hash = (37 * hash) + BEST_SUBMISSION_BTC_BLOCK_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getBestSubmissionBtcBlockHash().hashCode();
      if (getBestSubmissionTransactionsCount() > 0) {
        hash = (37 * hash) + BEST_SUBMISSION_TRANSACTIONS_FIELD_NUMBER;
        hash = (53 * hash) + getBestSubmissionTransactionsList().hashCode();
      }
      if (getBestSubmissionVigilanteAddressListCount() > 0) {
        hash = (37 * hash) + BEST_SUBMISSION_VIGILANTE_ADDRESS_LIST_FIELD_NUMBER;
        hash = (53 * hash) + getBestSubmissionVigilanteAddressListList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * BTCCheckpointInfo contains all data about best submission of checkpoint for
     * given epoch. Best submission is the submission which is deeper in btc ledger
     * </pre>
     *
     * Protobuf type {@code babylon.btccheckpoint.v1.BTCCheckpointInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:babylon.btccheckpoint.v1.BTCCheckpointInfo)
        com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_BTCCheckpointInfo_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_BTCCheckpointInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo.class, com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo.Builder.class);
      }

      // Construct using com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        epochNumber_ = 0L;
        bestSubmissionBtcBlockHeight_ = 0;
        bestSubmissionBtcBlockHash_ = com.google.protobuf.ByteString.EMPTY;
        if (bestSubmissionTransactionsBuilder_ == null) {
          bestSubmissionTransactions_ = java.util.Collections.emptyList();
        } else {
          bestSubmissionTransactions_ = null;
          bestSubmissionTransactionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          bestSubmissionVigilanteAddressList_ = java.util.Collections.emptyList();
        } else {
          bestSubmissionVigilanteAddressList_ = null;
          bestSubmissionVigilanteAddressListBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.internal_static_babylon_btccheckpoint_v1_BTCCheckpointInfo_descriptor;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo getDefaultInstanceForType() {
        return com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo.getDefaultInstance();
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo build() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo buildPartial() {
        com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo result = new com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo result) {
        if (bestSubmissionTransactionsBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            bestSubmissionTransactions_ = java.util.Collections.unmodifiableList(bestSubmissionTransactions_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.bestSubmissionTransactions_ = bestSubmissionTransactions_;
        } else {
          result.bestSubmissionTransactions_ = bestSubmissionTransactionsBuilder_.build();
        }
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0)) {
            bestSubmissionVigilanteAddressList_ = java.util.Collections.unmodifiableList(bestSubmissionVigilanteAddressList_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.bestSubmissionVigilanteAddressList_ = bestSubmissionVigilanteAddressList_;
        } else {
          result.bestSubmissionVigilanteAddressList_ = bestSubmissionVigilanteAddressListBuilder_.build();
        }
      }

      private void buildPartial0(com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.epochNumber_ = epochNumber_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.bestSubmissionBtcBlockHeight_ = bestSubmissionBtcBlockHeight_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.bestSubmissionBtcBlockHash_ = bestSubmissionBtcBlockHash_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo) {
          return mergeFrom((com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo other) {
        if (other == com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo.getDefaultInstance()) return this;
        if (other.getEpochNumber() != 0L) {
          setEpochNumber(other.getEpochNumber());
        }
        if (other.getBestSubmissionBtcBlockHeight() != 0) {
          setBestSubmissionBtcBlockHeight(other.getBestSubmissionBtcBlockHeight());
        }
        if (other.getBestSubmissionBtcBlockHash() != com.google.protobuf.ByteString.EMPTY) {
          setBestSubmissionBtcBlockHash(other.getBestSubmissionBtcBlockHash());
        }
        if (bestSubmissionTransactionsBuilder_ == null) {
          if (!other.bestSubmissionTransactions_.isEmpty()) {
            if (bestSubmissionTransactions_.isEmpty()) {
              bestSubmissionTransactions_ = other.bestSubmissionTransactions_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureBestSubmissionTransactionsIsMutable();
              bestSubmissionTransactions_.addAll(other.bestSubmissionTransactions_);
            }
            onChanged();
          }
        } else {
          if (!other.bestSubmissionTransactions_.isEmpty()) {
            if (bestSubmissionTransactionsBuilder_.isEmpty()) {
              bestSubmissionTransactionsBuilder_.dispose();
              bestSubmissionTransactionsBuilder_ = null;
              bestSubmissionTransactions_ = other.bestSubmissionTransactions_;
              bitField0_ = (bitField0_ & ~0x00000008);
              bestSubmissionTransactionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getBestSubmissionTransactionsFieldBuilder() : null;
            } else {
              bestSubmissionTransactionsBuilder_.addAllMessages(other.bestSubmissionTransactions_);
            }
          }
        }
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          if (!other.bestSubmissionVigilanteAddressList_.isEmpty()) {
            if (bestSubmissionVigilanteAddressList_.isEmpty()) {
              bestSubmissionVigilanteAddressList_ = other.bestSubmissionVigilanteAddressList_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureBestSubmissionVigilanteAddressListIsMutable();
              bestSubmissionVigilanteAddressList_.addAll(other.bestSubmissionVigilanteAddressList_);
            }
            onChanged();
          }
        } else {
          if (!other.bestSubmissionVigilanteAddressList_.isEmpty()) {
            if (bestSubmissionVigilanteAddressListBuilder_.isEmpty()) {
              bestSubmissionVigilanteAddressListBuilder_.dispose();
              bestSubmissionVigilanteAddressListBuilder_ = null;
              bestSubmissionVigilanteAddressList_ = other.bestSubmissionVigilanteAddressList_;
              bitField0_ = (bitField0_ & ~0x00000010);
              bestSubmissionVigilanteAddressListBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getBestSubmissionVigilanteAddressListFieldBuilder() : null;
            } else {
              bestSubmissionVigilanteAddressListBuilder_.addAllMessages(other.bestSubmissionVigilanteAddressList_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                epochNumber_ = input.readUInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                bestSubmissionBtcBlockHeight_ = input.readUInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                bestSubmissionBtcBlockHash_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo m =
                    input.readMessage(
                        com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.parser(),
                        extensionRegistry);
                if (bestSubmissionTransactionsBuilder_ == null) {
                  ensureBestSubmissionTransactionsIsMutable();
                  bestSubmissionTransactions_.add(m);
                } else {
                  bestSubmissionTransactionsBuilder_.addMessage(m);
                }
                break;
              } // case 34
              case 42: {
                com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses m =
                    input.readMessage(
                        com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.parser(),
                        extensionRegistry);
                if (bestSubmissionVigilanteAddressListBuilder_ == null) {
                  ensureBestSubmissionVigilanteAddressListIsMutable();
                  bestSubmissionVigilanteAddressList_.add(m);
                } else {
                  bestSubmissionVigilanteAddressListBuilder_.addMessage(m);
                }
                break;
              } // case 42
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long epochNumber_ ;
      /**
       * <pre>
       * epoch number of this checkpoint
       * </pre>
       *
       * <code>uint64 epoch_number = 1 [json_name = "epochNumber"];</code>
       * @return The epochNumber.
       */
      @java.lang.Override
      public long getEpochNumber() {
        return epochNumber_;
      }
      /**
       * <pre>
       * epoch number of this checkpoint
       * </pre>
       *
       * <code>uint64 epoch_number = 1 [json_name = "epochNumber"];</code>
       * @param value The epochNumber to set.
       * @return This builder for chaining.
       */
      public Builder setEpochNumber(long value) {

        epochNumber_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * epoch number of this checkpoint
       * </pre>
       *
       * <code>uint64 epoch_number = 1 [json_name = "epochNumber"];</code>
       * @return This builder for chaining.
       */
      public Builder clearEpochNumber() {
        bitField0_ = (bitField0_ & ~0x00000001);
        epochNumber_ = 0L;
        onChanged();
        return this;
      }

      private int bestSubmissionBtcBlockHeight_ ;
      /**
       * <pre>
       * btc height of the best submission of the epoch
       * </pre>
       *
       * <code>uint32 best_submission_btc_block_height = 2 [json_name = "bestSubmissionBtcBlockHeight"];</code>
       * @return The bestSubmissionBtcBlockHeight.
       */
      @java.lang.Override
      public int getBestSubmissionBtcBlockHeight() {
        return bestSubmissionBtcBlockHeight_;
      }
      /**
       * <pre>
       * btc height of the best submission of the epoch
       * </pre>
       *
       * <code>uint32 best_submission_btc_block_height = 2 [json_name = "bestSubmissionBtcBlockHeight"];</code>
       * @param value The bestSubmissionBtcBlockHeight to set.
       * @return This builder for chaining.
       */
      public Builder setBestSubmissionBtcBlockHeight(int value) {

        bestSubmissionBtcBlockHeight_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * btc height of the best submission of the epoch
       * </pre>
       *
       * <code>uint32 best_submission_btc_block_height = 2 [json_name = "bestSubmissionBtcBlockHeight"];</code>
       * @return This builder for chaining.
       */
      public Builder clearBestSubmissionBtcBlockHeight() {
        bitField0_ = (bitField0_ & ~0x00000002);
        bestSubmissionBtcBlockHeight_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString bestSubmissionBtcBlockHash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * hash of the btc block which determines checkpoint btc block height i.e.
       * youngest block of best submission
       * </pre>
       *
       * <code>bytes best_submission_btc_block_hash = 3 [json_name = "bestSubmissionBtcBlockHash", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderHashBytes"];</code>
       * @return The bestSubmissionBtcBlockHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBestSubmissionBtcBlockHash() {
        return bestSubmissionBtcBlockHash_;
      }
      /**
       * <pre>
       * hash of the btc block which determines checkpoint btc block height i.e.
       * youngest block of best submission
       * </pre>
       *
       * <code>bytes best_submission_btc_block_hash = 3 [json_name = "bestSubmissionBtcBlockHash", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderHashBytes"];</code>
       * @param value The bestSubmissionBtcBlockHash to set.
       * @return This builder for chaining.
       */
      public Builder setBestSubmissionBtcBlockHash(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        bestSubmissionBtcBlockHash_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * hash of the btc block which determines checkpoint btc block height i.e.
       * youngest block of best submission
       * </pre>
       *
       * <code>bytes best_submission_btc_block_hash = 3 [json_name = "bestSubmissionBtcBlockHash", (.gogoproto.customtype) = "github.com/babylonlabs-io/babylon/types.BTCHeaderHashBytes"];</code>
       * @return This builder for chaining.
       */
      public Builder clearBestSubmissionBtcBlockHash() {
        bitField0_ = (bitField0_ & ~0x00000004);
        bestSubmissionBtcBlockHash_ = getDefaultInstance().getBestSubmissionBtcBlockHash();
        onChanged();
        return this;
      }

      private java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo> bestSubmissionTransactions_ =
        java.util.Collections.emptyList();
      private void ensureBestSubmissionTransactionsIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          bestSubmissionTransactions_ = new java.util.ArrayList<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo>(bestSubmissionTransactions_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder> bestSubmissionTransactionsBuilder_;

      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo> getBestSubmissionTransactionsList() {
        if (bestSubmissionTransactionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(bestSubmissionTransactions_);
        } else {
          return bestSubmissionTransactionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public int getBestSubmissionTransactionsCount() {
        if (bestSubmissionTransactionsBuilder_ == null) {
          return bestSubmissionTransactions_.size();
        } else {
          return bestSubmissionTransactionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo getBestSubmissionTransactions(int index) {
        if (bestSubmissionTransactionsBuilder_ == null) {
          return bestSubmissionTransactions_.get(index);
        } else {
          return bestSubmissionTransactionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public Builder setBestSubmissionTransactions(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo value) {
        if (bestSubmissionTransactionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureBestSubmissionTransactionsIsMutable();
          bestSubmissionTransactions_.set(index, value);
          onChanged();
        } else {
          bestSubmissionTransactionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public Builder setBestSubmissionTransactions(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder builderForValue) {
        if (bestSubmissionTransactionsBuilder_ == null) {
          ensureBestSubmissionTransactionsIsMutable();
          bestSubmissionTransactions_.set(index, builderForValue.build());
          onChanged();
        } else {
          bestSubmissionTransactionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public Builder addBestSubmissionTransactions(com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo value) {
        if (bestSubmissionTransactionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureBestSubmissionTransactionsIsMutable();
          bestSubmissionTransactions_.add(value);
          onChanged();
        } else {
          bestSubmissionTransactionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public Builder addBestSubmissionTransactions(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo value) {
        if (bestSubmissionTransactionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureBestSubmissionTransactionsIsMutable();
          bestSubmissionTransactions_.add(index, value);
          onChanged();
        } else {
          bestSubmissionTransactionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public Builder addBestSubmissionTransactions(
          com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder builderForValue) {
        if (bestSubmissionTransactionsBuilder_ == null) {
          ensureBestSubmissionTransactionsIsMutable();
          bestSubmissionTransactions_.add(builderForValue.build());
          onChanged();
        } else {
          bestSubmissionTransactionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public Builder addBestSubmissionTransactions(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder builderForValue) {
        if (bestSubmissionTransactionsBuilder_ == null) {
          ensureBestSubmissionTransactionsIsMutable();
          bestSubmissionTransactions_.add(index, builderForValue.build());
          onChanged();
        } else {
          bestSubmissionTransactionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public Builder addAllBestSubmissionTransactions(
          java.lang.Iterable<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo> values) {
        if (bestSubmissionTransactionsBuilder_ == null) {
          ensureBestSubmissionTransactionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, bestSubmissionTransactions_);
          onChanged();
        } else {
          bestSubmissionTransactionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public Builder clearBestSubmissionTransactions() {
        if (bestSubmissionTransactionsBuilder_ == null) {
          bestSubmissionTransactions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          bestSubmissionTransactionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public Builder removeBestSubmissionTransactions(int index) {
        if (bestSubmissionTransactionsBuilder_ == null) {
          ensureBestSubmissionTransactionsIsMutable();
          bestSubmissionTransactions_.remove(index);
          onChanged();
        } else {
          bestSubmissionTransactionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder getBestSubmissionTransactionsBuilder(
          int index) {
        return getBestSubmissionTransactionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder getBestSubmissionTransactionsOrBuilder(
          int index) {
        if (bestSubmissionTransactionsBuilder_ == null) {
          return bestSubmissionTransactions_.get(index);  } else {
          return bestSubmissionTransactionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder> 
           getBestSubmissionTransactionsOrBuilderList() {
        if (bestSubmissionTransactionsBuilder_ != null) {
          return bestSubmissionTransactionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(bestSubmissionTransactions_);
        }
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder addBestSubmissionTransactionsBuilder() {
        return getBestSubmissionTransactionsFieldBuilder().addBuilder(
            com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.getDefaultInstance());
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder addBestSubmissionTransactionsBuilder(
          int index) {
        return getBestSubmissionTransactionsFieldBuilder().addBuilder(
            index, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.getDefaultInstance());
      }
      /**
       * <pre>
       * the BTC checkpoint transactions of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.TransactionInfo best_submission_transactions = 4 [json_name = "bestSubmissionTransactions"];</code>
       */
      public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder> 
           getBestSubmissionTransactionsBuilderList() {
        return getBestSubmissionTransactionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder> 
          getBestSubmissionTransactionsFieldBuilder() {
        if (bestSubmissionTransactionsBuilder_ == null) {
          bestSubmissionTransactionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfo.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.TransactionInfoOrBuilder>(
                  bestSubmissionTransactions_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          bestSubmissionTransactions_ = null;
        }
        return bestSubmissionTransactionsBuilder_;
      }

      private java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses> bestSubmissionVigilanteAddressList_ =
        java.util.Collections.emptyList();
      private void ensureBestSubmissionVigilanteAddressListIsMutable() {
        if (!((bitField0_ & 0x00000010) != 0)) {
          bestSubmissionVigilanteAddressList_ = new java.util.ArrayList<com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses>(bestSubmissionVigilanteAddressList_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder> bestSubmissionVigilanteAddressListBuilder_;

      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses> getBestSubmissionVigilanteAddressListList() {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          return java.util.Collections.unmodifiableList(bestSubmissionVigilanteAddressList_);
        } else {
          return bestSubmissionVigilanteAddressListBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public int getBestSubmissionVigilanteAddressListCount() {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          return bestSubmissionVigilanteAddressList_.size();
        } else {
          return bestSubmissionVigilanteAddressListBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses getBestSubmissionVigilanteAddressList(int index) {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          return bestSubmissionVigilanteAddressList_.get(index);
        } else {
          return bestSubmissionVigilanteAddressListBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public Builder setBestSubmissionVigilanteAddressList(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses value) {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureBestSubmissionVigilanteAddressListIsMutable();
          bestSubmissionVigilanteAddressList_.set(index, value);
          onChanged();
        } else {
          bestSubmissionVigilanteAddressListBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public Builder setBestSubmissionVigilanteAddressList(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder builderForValue) {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          ensureBestSubmissionVigilanteAddressListIsMutable();
          bestSubmissionVigilanteAddressList_.set(index, builderForValue.build());
          onChanged();
        } else {
          bestSubmissionVigilanteAddressListBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public Builder addBestSubmissionVigilanteAddressList(com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses value) {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureBestSubmissionVigilanteAddressListIsMutable();
          bestSubmissionVigilanteAddressList_.add(value);
          onChanged();
        } else {
          bestSubmissionVigilanteAddressListBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public Builder addBestSubmissionVigilanteAddressList(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses value) {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureBestSubmissionVigilanteAddressListIsMutable();
          bestSubmissionVigilanteAddressList_.add(index, value);
          onChanged();
        } else {
          bestSubmissionVigilanteAddressListBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public Builder addBestSubmissionVigilanteAddressList(
          com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder builderForValue) {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          ensureBestSubmissionVigilanteAddressListIsMutable();
          bestSubmissionVigilanteAddressList_.add(builderForValue.build());
          onChanged();
        } else {
          bestSubmissionVigilanteAddressListBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public Builder addBestSubmissionVigilanteAddressList(
          int index, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder builderForValue) {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          ensureBestSubmissionVigilanteAddressListIsMutable();
          bestSubmissionVigilanteAddressList_.add(index, builderForValue.build());
          onChanged();
        } else {
          bestSubmissionVigilanteAddressListBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public Builder addAllBestSubmissionVigilanteAddressList(
          java.lang.Iterable<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses> values) {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          ensureBestSubmissionVigilanteAddressListIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, bestSubmissionVigilanteAddressList_);
          onChanged();
        } else {
          bestSubmissionVigilanteAddressListBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public Builder clearBestSubmissionVigilanteAddressList() {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          bestSubmissionVigilanteAddressList_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          bestSubmissionVigilanteAddressListBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public Builder removeBestSubmissionVigilanteAddressList(int index) {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          ensureBestSubmissionVigilanteAddressListIsMutable();
          bestSubmissionVigilanteAddressList_.remove(index);
          onChanged();
        } else {
          bestSubmissionVigilanteAddressListBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder getBestSubmissionVigilanteAddressListBuilder(
          int index) {
        return getBestSubmissionVigilanteAddressListFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder getBestSubmissionVigilanteAddressListOrBuilder(
          int index) {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          return bestSubmissionVigilanteAddressList_.get(index);  } else {
          return bestSubmissionVigilanteAddressListBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public java.util.List<? extends com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder> 
           getBestSubmissionVigilanteAddressListOrBuilderList() {
        if (bestSubmissionVigilanteAddressListBuilder_ != null) {
          return bestSubmissionVigilanteAddressListBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(bestSubmissionVigilanteAddressList_);
        }
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder addBestSubmissionVigilanteAddressListBuilder() {
        return getBestSubmissionVigilanteAddressListFieldBuilder().addBuilder(
            com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.getDefaultInstance());
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder addBestSubmissionVigilanteAddressListBuilder(
          int index) {
        return getBestSubmissionVigilanteAddressListFieldBuilder().addBuilder(
            index, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.getDefaultInstance());
      }
      /**
       * <pre>
       * list of vigilantes' addresses of the best submission
       * </pre>
       *
       * <code>repeated .babylon.btccheckpoint.v1.CheckpointAddresses best_submission_vigilante_address_list = 5 [json_name = "bestSubmissionVigilanteAddressList"];</code>
       */
      public java.util.List<com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder> 
           getBestSubmissionVigilanteAddressListBuilderList() {
        return getBestSubmissionVigilanteAddressListFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder> 
          getBestSubmissionVigilanteAddressListFieldBuilder() {
        if (bestSubmissionVigilanteAddressListBuilder_ == null) {
          bestSubmissionVigilanteAddressListBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddresses.Builder, com.babylon.btccheckpoint.v1.BtccheckpointProto.CheckpointAddressesOrBuilder>(
                  bestSubmissionVigilanteAddressList_,
                  ((bitField0_ & 0x00000010) != 0),
                  getParentForChildren(),
                  isClean());
          bestSubmissionVigilanteAddressList_ = null;
        }
        return bestSubmissionVigilanteAddressListBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:babylon.btccheckpoint.v1.BTCCheckpointInfo)
    }

    // @@protoc_insertion_point(class_scope:babylon.btccheckpoint.v1.BTCCheckpointInfo)
    private static final com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo();
    }

    public static com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<BTCCheckpointInfo>
        PARSER = new com.google.protobuf.AbstractParser<BTCCheckpointInfo>() {
      @java.lang.Override
      public BTCCheckpointInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<BTCCheckpointInfo> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<BTCCheckpointInfo> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.babylon.btccheckpoint.v1.BtccheckpointProto.BTCCheckpointInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_btccheckpoint_v1_BTCSpvProof_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_btccheckpoint_v1_BTCSpvProof_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_btccheckpoint_v1_TransactionKey_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_btccheckpoint_v1_TransactionKey_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_btccheckpoint_v1_SubmissionKey_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_btccheckpoint_v1_SubmissionKey_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_btccheckpoint_v1_TransactionInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_btccheckpoint_v1_TransactionInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_btccheckpoint_v1_SubmissionData_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_btccheckpoint_v1_SubmissionData_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_btccheckpoint_v1_EpochData_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_btccheckpoint_v1_EpochData_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_btccheckpoint_v1_CheckpointAddresses_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_btccheckpoint_v1_CheckpointAddresses_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_babylon_btccheckpoint_v1_BTCCheckpointInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_babylon_btccheckpoint_v1_BTCCheckpointInfo_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n,babylon/btccheckpoint/v1/btccheckpoint" +
      ".proto\022\030babylon.btccheckpoint.v1\032\024gogopr" +
      "oto/gogo.proto\"\375\001\n\013BTCSpvProof\022\'\n\017btc_tr" +
      "ansaction\030\001 \001(\014R\016btcTransaction\0222\n\025btc_t" +
      "ransaction_index\030\002 \001(\rR\023btcTransactionIn" +
      "dex\022!\n\014merkle_nodes\030\003 \001(\014R\013merkleNodes\022n" +
      "\n\025confirming_btc_header\030\004 \001(\014B:\332\336\0376githu" +
      "b.com/babylonlabs-io/babylon/types.BTCHe" +
      "aderBytesR\023confirmingBtcHeader\"z\n\016Transa" +
      "ctionKey\022\024\n\005index\030\001 \001(\rR\005index\022R\n\004hash\030\002" +
      " \001(\014B>\332\336\037:github.com/babylonlabs-io/baby" +
      "lon/types.BTCHeaderHashBytesR\004hash\"K\n\rSu" +
      "bmissionKey\022:\n\003key\030\001 \003(\0132(.babylon.btcch" +
      "eckpoint.v1.TransactionKeyR\003key\"\205\001\n\017Tran" +
      "sactionInfo\022:\n\003key\030\001 \001(\0132(.babylon.btcch" +
      "eckpoint.v1.TransactionKeyR\003key\022 \n\013trans" +
      "action\030\002 \001(\014R\013transaction\022\024\n\005proof\030\003 \001(\014" +
      "R\005proof\"\314\001\n\016SubmissionData\022^\n\023vigilante_" +
      "addresses\030\001 \001(\0132-.babylon.btccheckpoint." +
      "v1.CheckpointAddressesR\022vigilanteAddress" +
      "es\022D\n\010txs_info\030\002 \003(\0132).babylon.btccheckp" +
      "oint.v1.TransactionInfoR\007txsInfo\022\024\n\005epoc" +
      "h\030\003 \001(\004R\005epoch\"\205\001\n\tEpochData\022;\n\004keys\030\001 \003" +
      "(\0132\'.babylon.btccheckpoint.v1.Submission" +
      "KeyR\004keys\022;\n\006status\030\002 \001(\0162#.babylon.btcc" +
      "heckpoint.v1.BtcStatusR\006status\"O\n\023Checkp" +
      "ointAddresses\022\034\n\tsubmitter\030\001 \001(\014R\tsubmit" +
      "ter\022\032\n\010reporter\030\002 \001(\014R\010reporter\"\364\003\n\021BTCC" +
      "heckpointInfo\022!\n\014epoch_number\030\001 \001(\004R\013epo" +
      "chNumber\022F\n best_submission_btc_block_he" +
      "ight\030\002 \001(\rR\034bestSubmissionBtcBlockHeight" +
      "\022\202\001\n\036best_submission_btc_block_hash\030\003 \001(" +
      "\014B>\332\336\037:github.com/babylonlabs-io/babylon" +
      "/types.BTCHeaderHashBytesR\032bestSubmissio" +
      "nBtcBlockHash\022k\n\034best_submission_transac" +
      "tions\030\004 \003(\0132).babylon.btccheckpoint.v1.T" +
      "ransactionInfoR\032bestSubmissionTransactio" +
      "ns\022\201\001\n&best_submission_vigilante_address" +
      "_list\030\005 \003(\0132-.babylon.btccheckpoint.v1.C" +
      "heckpointAddressesR\"bestSubmissionVigila" +
      "nteAddressList*\222\001\n\tBtcStatus\022)\n\026EPOCH_ST" +
      "ATUS_SUBMITTED\020\000\032\r\212\235 \tSubmitted\022)\n\026EPOCH" +
      "_STATUS_CONFIRMED\020\001\032\r\212\235 \tConfirmed\022)\n\026EP" +
      "OCH_STATUS_FINALIZED\020\002\032\r\212\235 \tFinalized\032\004\210" +
      "\243\036\000B\353\001\n\034com.babylon.btccheckpoint.v1B\022Bt" +
      "ccheckpointProtoZ7github.com/babylonlabs" +
      "-io/babylon/x/btccheckpoint/types\242\002\003BBX\252" +
      "\002\030Babylon.Btccheckpoint.V1\312\002\030Babylon\\Btc" +
      "checkpoint\\V1\342\002$Babylon\\Btccheckpoint\\V1" +
      "\\GPBMetadata\352\002\032Babylon::Btccheckpoint::V" +
      "1b\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          com.gogoproto.GogoProto.getDescriptor(),
        });
    internal_static_babylon_btccheckpoint_v1_BTCSpvProof_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_babylon_btccheckpoint_v1_BTCSpvProof_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_btccheckpoint_v1_BTCSpvProof_descriptor,
        new java.lang.String[] { "BtcTransaction", "BtcTransactionIndex", "MerkleNodes", "ConfirmingBtcHeader", });
    internal_static_babylon_btccheckpoint_v1_TransactionKey_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_babylon_btccheckpoint_v1_TransactionKey_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_btccheckpoint_v1_TransactionKey_descriptor,
        new java.lang.String[] { "Index", "Hash", });
    internal_static_babylon_btccheckpoint_v1_SubmissionKey_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_babylon_btccheckpoint_v1_SubmissionKey_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_btccheckpoint_v1_SubmissionKey_descriptor,
        new java.lang.String[] { "Key", });
    internal_static_babylon_btccheckpoint_v1_TransactionInfo_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_babylon_btccheckpoint_v1_TransactionInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_btccheckpoint_v1_TransactionInfo_descriptor,
        new java.lang.String[] { "Key", "Transaction", "Proof", });
    internal_static_babylon_btccheckpoint_v1_SubmissionData_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_babylon_btccheckpoint_v1_SubmissionData_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_btccheckpoint_v1_SubmissionData_descriptor,
        new java.lang.String[] { "VigilanteAddresses", "TxsInfo", "Epoch", });
    internal_static_babylon_btccheckpoint_v1_EpochData_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_babylon_btccheckpoint_v1_EpochData_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_btccheckpoint_v1_EpochData_descriptor,
        new java.lang.String[] { "Keys", "Status", });
    internal_static_babylon_btccheckpoint_v1_CheckpointAddresses_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_babylon_btccheckpoint_v1_CheckpointAddresses_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_btccheckpoint_v1_CheckpointAddresses_descriptor,
        new java.lang.String[] { "Submitter", "Reporter", });
    internal_static_babylon_btccheckpoint_v1_BTCCheckpointInfo_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_babylon_btccheckpoint_v1_BTCCheckpointInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_babylon_btccheckpoint_v1_BTCCheckpointInfo_descriptor,
        new java.lang.String[] { "EpochNumber", "BestSubmissionBtcBlockHeight", "BestSubmissionBtcBlockHash", "BestSubmissionTransactions", "BestSubmissionVigilanteAddressList", });
    com.google.protobuf.ExtensionRegistry registry =
        com.google.protobuf.ExtensionRegistry.newInstance();
    registry.add(com.gogoproto.GogoProto.customtype);
    registry.add(com.gogoproto.GogoProto.enumvalueCustomname);
    registry.add(com.gogoproto.GogoProto.goprotoEnumPrefix);
    com.google.protobuf.Descriptors.FileDescriptor
        .internalUpdateFileDescriptor(descriptor, registry);
    com.gogoproto.GogoProto.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
